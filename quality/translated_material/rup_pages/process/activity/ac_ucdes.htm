
<html>

<head>
<link rel="StyleSheet" href="../../rop.css" type="text/css">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Activity: Use-Case Design</title>
<meta http-equiv="Content-Type" content="text/html">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Microsoft Border" content="rb">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">
<a href="_ac_ucdes.htm">Оригинал этой страницы (RUP-2001) смотрите здесь!</a>
<h2 class="banner"><a name="Top"></a><a name="XE_use_case__design"></a>Активность: Спроектировать прецедент</h2>
<h2 class="banner"><a name="Top"></a><a name="XE_use_case__design"></a>Activity: Use-Case Design</h2>

<div align="center"><center>

<table border="1" width="85%" cellspacing="0" cellpadding="2">
  <tr>
    <td colspan="2" valign="top" bordercolor="#808080" width="645"><font face="Arial"><small><strong>Цель<br>Purpose</strong></small></font>
    <ul>
      <li>Уточнить прецедент в терминах взаимодействий.</li>
      <li>Уточнить требования у операциям проектных классов.</li>
      <li>Уточнить требования к операциям подсистем и/или их интерфейсам.</li>
      <li class="reactive">Уточнить требования к операциям капсул</li>
      <p>
      <li>To refine use-case realizations in terms of interactions.</li>
      <li>To refine requirements on the operations of design classes.</li>
      <li>To refine requirements on the operations of subsystems and/or their
        interfaces.</li>
      <li class="reactive">To refine requirements on the operations of capsules</li>
    </ul>
    </td>
  </tr>
  <tr>
    <td colspan="2" valign="top" bordercolor="#808080" width="645"><small><strong><font face="Arial">Шаги<br>Steps</font></strong></small>
    <ul>
      <li><a href="#Describe Interactions Between Design Objects">Описать взаимодействия между проектными объектами</a></li>
      <li><a href="#Describe Interactions Between Subsystems and/or their Interfaces (optional)">Упростить
        диаграммы последовательностей, используя подсистемы (опционально)</a></li>
      <li><a href="#Describe Persistence-Related Behaviors">Описать сохраняемо-связанное поведение</a>
        <ul>
          <li><a href="#Writing Persistent Objects">Написание сохраняемых объектов</a></li>
          <li><a href="#Reading Persistent Objects">Прочтение сохраняемых объектов</a></li>
          <li><a href="#Deleting Persistent Objects">Удаление сохраняемых объектов</a></li>
          <li><a href="#Modeling Transactions">моделирование транзакций</a></li>
          <li><a href="#Handling Error Conditions">Обработка ошиочных условий</a></li>
          <li><a href="#Handling Concurrency Control">Обработка параллельного контроля</a></li>
        </ul>
      </li>
      <li><a href="#Refine the Flow of Events Description">Уточнить описание потока событий</a></li>
      <li><a href="#Unify Classes and Subsystems">Соединить классы и подсистемы</a></li>
      <li><a href="#Evaluate Your Results">Оценить результаты</a></li>
      <p>
      <li><a href="#Describe Interactions Between Design Objects">Describe
        Interactions Between Design Objects</a></li>
      <li><a href="#Describe Interactions Between Subsystems and/or their Interfaces (optional)">Simplify
        Sequence Diagrams using Subsystems (optional)</a></li>
      <li><a href="#Describe Persistence-Related Behaviors">Describe
        Persistence-related Behavior</a>
        <ul>
          <li><a href="#Writing Persistent Objects">Writing Persistent Objects</a></li>
          <li><a href="#Reading Persistent Objects">Reading Persistent Objects</a></li>
          <li><a href="#Deleting Persistent Objects">Deleting Persistent Objects</a></li>
          <li><a href="#Modeling Transactions">Modeling Transactions</a></li>
          <li><a href="#Handling Error Conditions">Handling Error Conditions</a></li>
          <li><a href="#Handling Concurrency Control">Handling Concurrency
            Control</a></li>
        </ul>
      </li>
      <li><a href="#Refine the Flow of Events Description">Refine the Flow of
        Events Description</a></li>
      <li><a href="#Unify Classes and Subsystems">Unify Classes and Subsystems</a></li>
      <li><a href="#Evaluate Your Results">Evaluate Your Results</a></li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top" bordercolor="#808080" width="317"><small><font face="Arial"><strong>Входящие артефакты:<br>Input
    Artifacts:</strong></font></small>
    <ul>
      <li><a href="../artifact/ar_sspec.htm">Дополнительные спецификации</a></li>
      <li><a href="../artifact/ar_uc.htm">Прецедент</a></li>
      <li><a href="../artifact/ar_ucrea.htm">Реализация прецедента</a></li>
      <li><a href="../artifact/ar_class.htm">Проектный класс</a></li>
      <li><a href="../artifact/ar_dsub.htm">Проектная подсистема</a></li>
      <li><a href="../artifact/ar_if.htm">Интерфейс</a></li>
      <li class="reactive"><a href="../artifact/ar_cpsl.htm">Капсула</a></li>
      <p>
      <li><a href="../artifact/ar_sspec.htm">Supplementary Specifications</a></li>
      <li><a href="../artifact/ar_uc.htm">Use Case</a></li>
      <li><a href="../artifact/ar_ucrea.htm">Use-Case Realization</a></li>
      <li><a href="../artifact/ar_class.htm">Design Class</a></li>
      <li><a href="../artifact/ar_dsub.htm">Design Subsystem</a></li>
      <li><a href="../artifact/ar_if.htm">Interface</a></li>
      <li class="reactive"><a href="../artifact/ar_cpsl.htm">Capsule</a></li>
    </ul>
    </td>
    <td style="text-indent: 0px" valign="top" bordercolor="#808080" width="322"><small><font face="Arial"><strong>Результирующие артефакты<br>Resulting
    Artifacts:</strong></font></small>
    <ul>
      <li>
        <p align="left"><a href="../artifact/ar_ucrea.htm">Реализация прецедента</a>,
        описанная с диаграммами последовательности и уточненным потоком потоком событий</p>
      </li>
      <p>
      <li>
        <p align="left"><a href="../artifact/ar_ucrea.htm">Use-Case Realization</a>,
        described with sequence diagrams, and flow of events refined</p>
      </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td valign="top" colspan="2" style="text-indent: 4px" bordercolor="#808080" width="645"><strong><font face="Arial"><small>Роль:</small>
    </font></strong><a href="../workers/wk_dsgnr.htm">Проектировщик</a></td>
  </tr>
</table>
  </center>
</div>
<!-- Linked to Workflow Begin -->
<p><table border="1" width="85%" cellspacing="0" cellpadding="2" style="border: 1px solid rgb(128,128,128)">
<tr>
<td valign="top" colspan="2" bordercolor="#808080"><small><font face="Arial"><strong>Детали потока работ<br>Workflow Details:</strong></font></small><ul>
<li><b><a href="../workflow/ovu_and.htm">Поток работ: Анализ и проектирование</a></b></li><ul>
<li><a href="../workflow/ana_desi/wfs_and4.htm">Проектирование компонент</a></li>
<li><a href="../workflow/ana_desi/wfs_and6.htm">Проектирование компонент реального времени</a></li>
<p>
<li><b><a href="../workflow/ovu_and.htm">Core Workflow: Analysis & Design</a></b></li><ul>
<li><a href="../workflow/ana_desi/wfs_and4.htm">Design Components</a></li>
<li><a href="../workflow/ana_desi/wfs_and6.htm">Design Real-Time Components</a></li>
</ul>
</ul>
</td>
</tr>
</table>
<!-- Linked to Workflow End -->
</center></div>

<p><a name="XE_interaction__describing_interactions_between_design_objects"></a>
Поведение системы может описываться с использованием техники взаимодействий и коопераций.
Эта активность описывает использование взаимодействий, в частности,
диаграмм последовательности, чтобы описать поведение системы.
Диаграммы последовательности лучше всего использовать там, где поведение системы или подсистемы может быть описано 
механизмом синхронных сообщений. Асинхронные сообщения, особенно в системе, управляемой событиями,
часто более легко описываются в терминах машин состояний и коопераций, позволяя компактно описать
возможные взаимодействия между объектами.</p>
<p><a name="XE_interaction__describing_interactions_between_design_objects"></a>The
behavior of a system can be described using a number of techniques -
collaborations or interactions. This activity describes the use of interactions,
specifically sequence diagrams, to describe the behavior of the system. Sequence
diagrams are most useful where the behavior of the system or subsystem can be
primarily described by synchronous messaging. Asynchronous messaging, especially
in event-driven systems, is often more easily described in terms of state
machines and collaborations, allowing a compact way of defining possible
interactions between objects.</p>
<br>
<p class="reactive"> Асинхронные сообщения играют важную роль в системах реального времени или реактивных системах, и
используются для взаимодействия между экземплярами <a href="../artifact/ar_cpsl.htm">Артефакта: Капсула</a>.</p>
<p class="reactive"> Asynchronous messages play an important role in real-time or
reactive systems, and are used for communication between instances of <a href="../artifact/ar_cpsl.htm">Artifact:
Capsule</a>s.</p>

<h3><a name="Describe Interactions Between Design Objects">Описать взаимодействия между проектными объектами </a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<h3><a name="Describe Interactions Between Design Objects">Describe Interactions
Between Design Objects</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<div align="center"><center>

<table border="1" width="85%" cellspacing="0" cellpadding="2" style="border: 1px solid rgb(128,128,128)">
  <tr>
    <td valign="top" style="text-indent: 4px" bordercolor="#808080"><small><font face="Arial"><strong>Помощь по инструментарию:<br>Tool Mentor: </strong></font></small>
    <a href="../../toolment/rose/tm_ucds1.htm">Управление Диаграммами последовательности при использовании Rational Rose<br>Managing Sequence Diagrams Using Rational Rose</a></td>
  </tr>
</table>
</center></div>

<p>Взаимодействие в каждой реализации прецедента нужно иллюстрировать взаимодействиями между
участвующими проектными объектами путем созданием одной или более диаграмм последовательности.
Они начинают создаваться в <a href="ac_ucana.htm">Активности: Провести анализ прецедента</a>. 
Если они включены в <a href="../artifact/ar_amdl.htm">Артефакт: Модель Анализа</a>, то нужно их перевести
в <a href="../artifact/ar_desmd.htm">Артефакт: Проектная Модель</a>, где продолжится их развитие.</p>
<p>For each use-case realization, you should illustrate the interactions between
its participating design objects by creating one or more sequence diagrams.
Early versions of these may have been created during <a href="ac_ucana.htm">Activity:
Use-Case Analysis</a>. If they were created in the <a href="../artifact/ar_amdl.htm">Artifact:
Analysis Model</a>, they will need to be transposed into the <a href="../artifact/ar_desmd.htm">Artifact:
Design Model</a> so that their evolution can continue.</p>
<br>
<p>Совершенствование диаграмм последовательности заключается в следующих шагах:
<p>Updating the sequence diagrams involves the following steps:
<ul>
  <li>Определите участвующие в потоке прецедента объекты. Это можно сделать путем обработки
    проектных классов и подсистем, определенных в <a href="ac_iddes.htm">Активности: Определить проектные элементы</a>.
    <br class="reactive"> В системах реального времени также будут определяться экземпляры капсул, которые участвуют в потоке
    прецедента.</li>
  <li>Identify each object that participates in the flow of the use case. This
    is done by instantiating the design classes and subsystems identified in the <a href="ac_iddes.htm">Activity:
    Identify Design Elements</a>.<br class="reactive"> In real-time systems, you
    will also be identifying the capsule instances that participate in the flow
    of the use case. </li>
  <li>Представьте каждый участвующий объект на диаграмме последовательности. Покажите 
    линию жизни каждого участвующего объекта диаграммы активности. 
    for each participating object in the sequence diagram. В случае представления подсистем, вы имеете два варианта выбора:
  <li>Represent each participating object in a sequence diagram. Make a lifeline
    for each participating object in the sequence diagram. In order to represent
    the subsystems, you have two choices:
    <ul>
      <li>Вы можете использовать интерфейсы, предоставляемые подсистемой. Это предпочтительней в случаях, когда вы хотите 
        показать, что любой элемент модели, который реализует тот же интерфейс, может использоваться вместо интерфейса.
        Если вы показываете интерфейсы на диаграмме последовательности, знайте, что придется гарантировать, что нет 
        сообщений, посылаемых от интерфейса другим объектам. Причина этого в том, что интерфейсы полностью
        определяются внутренними реализациями их операций. Мы не можем быть уверены, что все элементы модели,
        реализующие интерфейс, будут спроектированы так же. Итак, на диаграммах последовательности не должно быть
        сообщений от интерфейсов.</li>
      <li>You may use the interfaces realized by the subsystem. This is
        preferred in cases where you wish to show that any model element which
        realizes the same interface may be used in place of the interface. If
        you choose to show interfaces on the sequence diagram, be aware that you
        will want to ensure that no messages are sent from the interface to
        other objects. The reason for this is that interfaces completely
        encapsulate the internal realization of their operations. Therefore, we
        cannot be certain that all model elements which realize the interface
        will in fact actually be designed the same way. So on sequence diagrams
        no messages should be shown being sent from interfaces.</li>
      <p>
      <li>Вы можете использовать прокси-класс (посредника) чтобы показать подсистему на диаграммах последовательности.
        Он содержится в подсистеме и применяется для представления подсистемы в диаграммах, которые не поддерживают
        прямого использования пакетов и подсистем как элементов, задающих поведение. Прокси-класс должен использоваться
        в случаях, когда вы хотите показать, что данная подсистема отвечает на соообщение. В этом случае, вы можете
        показать события, посылаемые от прокси подсистемы другим объектам.</li>
      <li>You may use a proxy class to represent the subsystem on sequence
        diagrams. This proxy class is contained within the subsystem and is used
        to represent the subsystem in diagrams which do not support the direct
        use of packages and subsystems as behavioral elements. The proxy class
        should be used in cases where you wish to show that a specific subsystem
        responds to a message. In this case, you may show messages being sent
        from the subsystem proxy to other objects.</li>
    </ul>
    <p>Заметьте, что активные взаимодействия объектов обычно описываются при использовании подробных описаний коопераций и
    машин состояний. Они используются для отображения, как сообщения могут посылаться активным объектам от других элементов
    системы в больших реализациях прецедентов. Обычно цель активности, активные объекты размещают в подсистемах, таких как
    реализации прецедентов, состоящие из набора взаимодействующих  подсистем. В подсистемах активные объекты представляют
    параллельныу нити процесса выполнения. Подсистемы могут разделяться между командами разработчиков, с интерфейсами, 
    служащими в качестве формального соглашения между командами.</p>
    <p class="reactive">Для систем реального времени используйте <a href="../artifact/ar_cpsl.htm">Артефакт:
    Капсула</a>, представляющий активные объекты.</p>
    <p>Note that active object interactions are typically described using
    specification collaborations and state machines. They would be used here to
    show how messages may be sent to active objects by other elements in the system in
    a larger use-case realization. In typical usage, active objects are encapsulated
    within subsystems for the purpose of this activity, such that the use-case
    realization consists of a set of interacting subsystems. The interactions
    define the responsibilities and interfaces of the subsystems. Within the
    subsystems, active objects represent concurrent threads of execution. The
    subsystems allow work to be divided between development teams, with the
    interfaces serving as the formal contracts between the teams.</p>
    <p class="reactive">For real-time systems, you will use <a href="../artifact/ar_cpsl.htm">Artifact:
    Capsule</a>s to represent the active objects.</p>
    <br>
    <p>Замечания по отображению сообщений, выходящие из подсистем (или их прокси-классов): ограничивая сообщения
    только к интерфейсам, вы уменьшаете связанность между элементами модели и увеличивает гибкость проектирования.
    Где возможно, попытайтесь сделать это, в случае, где сообщения от подсистем идут к неинтерфейсным элементам модели,
    вы должны найти возможности изменить их на сообщения к интерфейсу, чтобы уменьшить связанность модели.</p>
    <p>A minor note on showing messages emanating from subsystems (or their
    proxy classes): restricting messages only to interfaces reduces coupling
    between model elements and improves the resiliency of the design. Where
    possible, you should try to achieve this, and in cases where there are
    messages emanating from subsystems to non-interface model elements, you
    should look for opportunities to change these to messages to interfaces to
    improve decoupling in the model.</p>
  </li>
  <li>Отобразите взаимодействие с актерами. Отобразите каждого актера и внешний объект, которые взаимодействуют друг с другом,
    и покажите линии жизни на диаграммах последовательности.</li>
  <li>Represent the interaction that takes place with actors. Represent each
    actor instance and external object that the participating objects interacts
    with by a lifeline in the sequence diagram.</li>
  <li>Отобразите сообщения посылаемые между участвующими объектами. Поток событий начинается в верхней части диаграммы и 
    продолжается ниже, показывая хронологию вертикальными осями. Покажите стрелками сообщения между объектами, создавая их между 
    линиями жизни. Название сообщения должно быть именем операции, вызываемой сообщением.
    На ранних этапах проектирования не так много операций, назначенных объектам, и вы можете не отображать эту информацию, дать
    сообщению временное имя; такие сообщения называются &quot;неназначенными&quot;. Позже, когда вы
    найдете больше операций взаимодействующих объектов, Вам нужно будет обновить диаграмму последовательности и назначить
    сообщения этим операциям.</li>
  <li>Illustrate the message sending between participating objects. The flow of
    events begins at the top of the diagram and continues downward, indicating a
    vertical chronological axis. Illustrate the message sending between objects
    by creating messages (arrows) between the lifelines. The name of a message
    should be the name of the operation invoked by the message. In the early
    stages of design, not many operations will be assigned to the objects, so
    you may have to leave this information out and give the message a temporary
    name; such messages are said to be &quot;unassigned.&quot; Later, when you
    have found more of the participating objects' operations, you should update
    the sequence diagram by &quot;assigning&quot; the messages with these
    operations.</li>
  <li>Опишите, что делает объект, когда получае сообщение. Это делается путем прикрепления письменного описания к сообщению.
    Поместите эти описания на полях диаграммы. Используйте структурированный текст или псевдокод. Если будете использовать
    псевдокод, для упрощения дальнейшей реализации используйте конструкции языка реализации. Тому, кто отвечает
    за назначение класса объекта и задание его операций, будет обеспечена основа для его работы.</li>
  <li>Describe what an object does when it receives a message. This is done by
    attaching a script to the corresponding message. Place these scripts in the
    margin of the diagram. Use either structured text or pseudocode. If you use
    pseudocode, be sure to use constructs in the implementation language so that
    the implementation of the corresponding operations will be easier. When the
    person responsible for an object's class assigns and defines its operations,
    the object's scripts will provide a basis for that work.</li>
</ul>
<p align="center"><img src="images/seqdiag1.gif" border="0" width="672" height="417"></p>
<p class="picturetext">Вы документируете поведение прецедента, которое производится объектами на диаграмме последовательности.</p>
<p class="picturetext">You document the use-case behavior performed by the
objects in a sequence diagram.</p>
<p>Когда вы распределяете поведение между объектами, вы должны рассмотреть, как будет контролироваться поток. 
Вы найдете объекты,
зная, что они будут взаимодействовать каким-то путем в реализации прецедента и играть какую-то роль. После распределения поведения,
вы можете начать проверку таких допущений. В некоторых частях потока вы захотите децентрализовать структуру; в некоторых - 
вы предпочтете централизованную. Дополнительную информацию по этим вариантам и рекомендации по их использованию, см. в
<a href="../modguide/md_seqdm.htm#Distributing Control">Руководстве: Диаграммы последовательности</a>.</p>
<p>When you have distributed behavior among the objects, you should consider how
the flow will be controlled. You found the objects by assuming they would
interact a certain way in the use-case realization, and have a certain role. As
you distribute behavior, you can begin to test those assumptions. In some parts
of the flow, you may want to use a decentralized structure; in others, you may
prefer a centralized structure. For definitions of these variants and
recommendations on when to use the two types of structure, see <a href="../modguide/md_seqdm.htm#Distributing Control">Guidelines:
Sequence Diagrams</a>.</p>
<br>
<p>Возможно, Вам будут нужны новые объекты, например, если Вы используете централизованную структуру и нуждаетесь в объекте,
контролирующем поток. Помните, что любой объект, который Вы добавляете в Проектную модель, должен удовлетворять требованиям
объектной модели.</p>
<p>You may need new objects at this point, for example if you are using a
centralized structure and need a new object to control the flow. Remember that
any object you add to the design model must fulfill the requirements made on the
object model.</p>

<h4>Отработать все варианты потока событий</h4>
<h4>Handle All Variants of the Flow of Events</h4>
<p>Вы должны описать каждый вариант потока в отдельной диаграмме последовательности. Диаграммы последовательности,
вообще говоря, предпочтительней: их легче читать, когда диаграмма должна содержать тот уровень детализации, который 
обычно используется при проектировании системы.</p>
<p>You should describe each flow variant in a separate sequence diagram.
Sequence diagrams are generally preferable to collaboration diagram as they tend
to be easier to read when the diagram must contain the level of detail we
typically want in when designing the system.</p>
<br>
<p>Начните с описания основного потока, который или наиболее общий, или наиболее важный. Затем опишите варианты, 
такие как исключительные ситуации. Вы не сможете описать все потоки до тех пор, пока вы не назначите и не 
проиллюстрируете все операции участвующих объектов. Следуя этому, очень тривиальные потоки, например, включающие только 
один объект, могут быть опущены.</p>
<p>Start with describing the basic flow, which is the most common or most
important flow of events. Then describe variants such as exceptional flows. You
do not have to describe all the flows of events, as long as you employ and
exemplify all operations of the participating objects. Given this, very trivial
flows can be omitted, such as those that concern only one object.</p>
<br>
<p>Изучите прецедент, чтобы увидеть, имеются ли варианты потока, не описанные в требованиях и анализах, например,
зависящие о  реализации. после определения новых потоков, опишите каждый из них в диаграмме последовательности. Примеры 
исключительных потоков подразумевают следующее.
<p>Study the use case to see if there are flow variants other than those already
described in requirements capture and analysis, for example, those that depend
on implementation. As you identify new flows, describe each one in a sequence
diagram. Examples of exceptional flows include the following.
<ul>
  <li><strong>Обработку ошибок</strong>. Если интерфейс сообщает, что ошибка случилась во взаимодействии с внешней системой,
    например, когда прецедент должен работать в ней, возможным решением является открытие нового канала связи.</li>
  <li><strong>Обработка истечения времени ожидания</strong>. Если пользователь не отвечает в течение определенного времени,
    прецедент должен предпринять специальные меры.</li>
  <li><strong>Обработка ошибочного ввода в объект, участвующий в прецеденте</strong>. Ошибки, подобные этой, можно отловить
    защитой от некорректного пользовательского ввода.</li>
  <p>
  <li><strong>Error handling</strong>. If an interface reports that an error has
    occurred in its communication with some external system, for example, the
    use case should deal with this. A possible solution is to open a new
    communication route.</li>
  <li><strong>Time-out handling</strong>. If the user does not reply within a
    certain period, the use case should take some special measures.</li>
  <li><strong>Handling of erroneous input to the objects that participate in the
    use case</strong>. Errors like this might stem from incorrect user input.</li>
</ul>

<h4>Обработка опциональных частей прецедента</h4>
<h4>Handle Optional Parts of the Use Case</h4>
<p>Вы можете описать альтернативные пути потока как опциональный поток вместо вариантного. Ниже перечислены 2 пример опциональных потоков.
<p>You can describe an alternative path of a flow as an optional flow instead of
as a variant. The following list includes two examples of optional flows.
<ul>
  <li>Посылая сигнал, актер отталкивается от числа следующих действий прецедента. Прецедент просит актера ответить на вопрос да или нет,
    или обеспечить актера рядом функций, производимыми системой в текущем состоянии прецедента.</li>
  <li>Поток выбирается в зависимости от значения атрибутов или связей. Следующий поток событий зависит от типа данных, которые 
    нужно обработать.</li>
  <p>
  <li>By sending a signal, the actor decides-from a number of options-what the
    use case is to do next. The use case has asked the actor to answer yes or no
    to a question, for example, or provided the actor with a variety of
    functions the system can perform in the use case's current state.</li>
  <li>The flow path varies depending on the value of stored attributes or
    relationships. The subsequent flow of events depends on the type of data to
    be processed.</li>
</ul>
<p>Если вы хотите, чтобы опциональные потоки или любые комплексные подпотоки были более заметны, используйте отдельные диаграммы
последовательностей. К каждой из них должна иметься ссылка из диаграммы последовательности основного потока событий. Это
делается с помощью пояснения на основной диаграмме, на которой показывается, где начинается подпоток или опциональное 
поведение.</p>
<p>If you want an optional flow, or any complex sub-flow, to be especially
noticeable, use a separate sequence diagram. Each separate sequence diagram
should be referred to from the sequence diagram for the main flow of events
using scripts, margin text or notes to indicate where the optional or sub-flow
behavior occurs.</p>
<p>Если опциональный или исключительный поток может случаться где угодно,
например, что-то должно произойти, когда случается событие, диаграмма последовательности основного потока событий
должна пояснять, что когда это событие случается, будет произведено поведение, описанное в опциональной/исключительной диаграмме последовательности.
Как альтернатива, если есть значительное поведение, основанное на событийной лолгике, рассмотрите использование диаграмм
состояний. См. <a href="../modguide/md_stadm.htm">Инструкция: Диаграмма состояний</a>.</p>
<p>In cases where the optional or exceptional flow behavior could occur
anywhere, for example behavior which executes when a particular event occurs,
the sequence diagram for the main flow of events should be annotated to indicate
that when the event occurs, the behavior described in the optional/exceptional
sequence diagram will be executed. Alternately, if there is significant
event-driven behavior, consider using statechart diagrams to describe the
behavior of the system. For more information, see <a href="../modguide/md_stadm.htm">Guidelines:
Statechart Diagram</a>.</p>

<h3><a name="Describe Interactions Between Subsystems and/or their Interfaces (optional)"></a>
Упростить диаграммы последовательностей, используя подсистемы (опционально) <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<h3><a name="Describe Interactions Between Subsystems and/or their Interfaces (optional)"></a>Simplify
Sequence Diagrams using Subsystems (optional) <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>Когда прецедент реализован, поток событий описывается в терминах объектов выполнения, т.е. как взаимодействие между
проектными объектами. Чтобы упростить диаграммы и выделить поведение, которое можно использовать вторично, может понадобиться
выделить подпотоки событий в  подсистеме. Когда это будет проведено, большие части диаграмм последовательности будут замещены
простым сообщением к системе. Внутри подсистемы отдельные диаграммы последовательности могут иллюстрировать внутренние 
взаимодействия подсистемы, задающие необходимое поведение. См. <a href="ac_subds.htm">Активность: Спроектировать подсистему</a>).
Подпоследовательность сообщений диаграммы последовательности должны быть включены в подсистему когда:
<p>When a use case is realized, the flow of events is usually described in terms
of the executing objects, i.e. as interaction between design objects. To
simplify diagrams and to identify re-usable behavior, there may be a need to
encapsulate a sub-flow of events within a subsystem. When this is done, large
subsections of the sequence diagram are replaced with a single message to the
subsystem. Within the subsystem, a separate sequence diagram may illustrate the
internal interactions within the subsystem that provide the required behavior
(for more information, see <a href="ac_subds.htm">Activity: Subsystem Design</a>).
Sub-sequences of messages within sequence diagrams should be encapsulated
within a subsystem when:
<ul>
  <li>Подпоследовательность повторяется в различных реализациях прецедента; то есть похожие сообщения посылаются схожим
    объектам, получается тот же результат.</li>
  <li>Подпоследовательность случается только в одной реализации прецедента, но ожидается ее периодическое использование
    в будущих итерациях или будущих системах. Можно создать хороший для вторичного использования компонент.</li>
  <li>Подпоследовательность случается только в одной реализации прецедента, но она сложна, легко выделяема, ее результат 
    хорошо проработан, ответственность за нее возложена на одного человека или команду. В этих ситуациях сложное поведение 
    обычно требует специальных тех. знаний или знаний предметной области и, как результат, хорошо его выделить в подсистеме.</li>
  <li>Подпоследовательность задается в колмпоненте модели реализации. В этом случае, подсистема соответствующим образом
    представляет компонент в проектной модели.</li>
  <p>
  <li>The sub-sequence occurs repeatedly in different use-case realizations;
    that is, the same (or similar) messages are sent to the same (or similar)
    objects, providing the same end result. The phrase 'similar' is used because
    some design work may be needed to make the behavior reusable.</li>
  <li>The sub-sequence occurs in only one use-case realization, but it is
    expected to be performed repeatedly in future iterations, or in similar
    systems in the future. The behavior may make a good reusable component.</li>
  <li>The sub-sequence occurs in only one use-case realization, but is complex
    but easily encapsulated, needs to be the responsibility of one person or a
    team, and provides a well-defined result. In these kinds of situations, the
    complex behavior usually requires special technical knowledge, or special
    domain knowledge, and as a result is well-suited to encapsulating it within
    a subsystem.</li>
  <li>The sub-sequence is determined to be encapsulated within a component in
    the implementation model. In this case, a subsystem is the appropriate
    representation for the component within the design model.</li>
</ul>
<p align="center"><img src="images/seqdiag6.gif" border="0" width="409" height="121"></p>
<p class="picturetext">Реализация прецедента может описываться, если необходимо, на нескольких уровнях иерархии подсистем.
Линии жизни в центральной диаграмме представляет подсистемы; взаимодействия в кружках представляют внутреннее взаимодействие
членов подсистемы при поступлении сообщения.<br>
A use-case realization can be described, if necessary, at
several levels in the subsystem hierarchy. The lifelines in the middle diagram
represent subsystems; the interactions in the circles represent the internal
interaction of subsystem members in response to the message.</p>
<p>Преимущества такого подхода:
<p>The advantages of this approach are:
<ul>
  <li>Реализации прецедентов менее связаны, особенно если внутренний дизайн подсистем сложен.</li>
  <li>Реализации прецедентов могут создаваться перед внутренним проектированием создаваемых подсистем; это полезно, например,
    в параллельной разработке окружения. См. &quot;<a href="#How to Work in Parallel">Как работать в параллели</a>&quot;).</li>
  <li>Реализации прецедентов становятся более общими и легко изменяются, особенно, если подсистема должна замещаться другой
    подсистемой.</li>
  <p>
  <li>Use-case realizations become less cluttered, especially if the internal
    design of some subsystems is complex.</li>
  <li>Use-case realizations can be created before the internal designs of
    subsystems are created; this is useful for example in parallel development
    environments (see &quot;<a href="#How to Work in Parallel">How to Work in
    Parallel</a>&quot;).</li>
  <li>Use-case realizations become more generic and easy to change, especially
    if a subsystem needs to be substituted with another subsystem.</li>
</ul>
<p class="exampleheading">Пример:</p>
<p class="exampleheading">Example:</p>
<p class="example">Рассмотрите следующую диаграмму последовательности, которая является частью реализации
<strong>Локального Вызова</strong> прецедента:</p>
<p class="example">Consider the following sequence diagram, which is part of a
realization of the <strong>Local Call</strong> use case:</p>

<p align="center"><img src="images/seqdiag7.gif" width="729" height="396"></p>
<p class="example">На диаграмме серые классы принадлежат подсистеме сетевой обработки; остальные - подсистеме обработки
абонентов. Это подразумевает, что существует диаграмма последовательностей множества подсистем, т.е. диаграмма, где включены все
объекты, участвующие во взаимодействии, независимо от того, лежат ли их классы вразных подсистемах.</p>
<p class="example">In this diagram, the gray classes belong to a Network
Handling subsystem; the other classes belong to a Subscriber Handling subsystem.
This implies that this is a multi-subsystem sequence diagram, i.e. a diagram
where all the objects that participate in the flow of events are included,
regardless of whether their classes lie in different subsystems or not.</p>
<br>
<p class="example">Как альтернатива, мы можем показать вызов поведения на диаграмме подсистемы сетевой обработки и
использование участвующих интерфейсов в такой подсистеме. Давайте предположим, что подсистема Сетевой обработки обеспечивает
интерфейс ICoordinator, который используется подсистемой обработки абонентов</p>
<p class="example">As an alternative, we can show invocation of behavior on the
Network Handling subsystem, and the exercise of a particular interface on that
subsystem. Let's assume that the Network Handling subsystem provides an
ICoordinator interface, which is used by the Subscriber Handling subsystem:</p>
<br>
<p align="center"><img src="images/subs_if.gif" width="425" height="100"></p>
<p class="example">ICoordinator реализуется классом Coordinator в сетевой обработке. 
Следуя этому, мы можем использовать подсистему сетевой обработки и интерфейс
ICoordinator, содержащийся в ней, на диаграмме последовательности, вместо экземпляров классов в
Сетевой Обработке:</p>
<p class="example">The ICoordinator interface is realized by the Coordinator
class within Network Handling. Given this, we can use the Network Handling
subsystem itself and its ICoordinator interface in the sequence diagram, instead
of instances of classes within Network Handling:</p>
<p align="center"><img src="images/seqdiag1.gif" width="672" height="417"></p>
<p class="example">Заметьте, что экземпляры классов Coordinator, Digit Information, и Network
замещены подсистемами, в которые они входят. Все обращения к подсистеме
делаются вместо этого через интерфейс ICoordinator.</p>
<p class="example">Note that the Coordinator, Digit Information, and Network
class instances are substituted by their containing subsystem. All calls to the
subsystem are instead done via the ICoordinator interface.</p>

<h4>Отображените интерфейсов на линиях жизни</h4>
<h4>Showing Interfaces on Lifelines</h4>
<p>Для достижения настоящей заменяемости подсистем, реализующих одинаковые интерфейсы, 
при взаимодействиях (и вообще на диаграммах) должны показываться только их интерфейсы; 
в противном случае взаимодействия (или диаграммы) должны изменяться, когда подсистемы заменяются одна другой.</p>
<p>In order to achieve true substitutability of subsystems realizing the same
interface, only their interface should be visible in interactions (and in
diagrams in general); otherwise the interactions (or diagrams) need to be
changed when subsystems are substituted with each other.</p>
<p class="exampleheading">Пример:</p>
<p class="exampleheading">Example:</p>
<p align="left" class="example">Мы можем включить только интерфейс ICoordinator, но не подсистему, его обеспечивающую,
на диаграмме последовательности:</p>
<p align="left" class="example">We can include only the ICoordinator interface,
but not its providing subsystem, in a sequence diagram:</p>
<p align="center"><img src="images/seqdiag2.gif" width="519" height="309"></p>
<p class="example">Посылка сообщения к линии жизни интерфейса означает, что любая подсистема, которая реализует
интерфейс, может быть заменена на интерфейс на диаграмме. Заметьте, что линия жизни интерфейса ICoordinator 
не имеет сообщений, идущих от нее, потому что различные подсистемы могут реализовать интерфейсы, посылающие 
разные сообщения. Однако, если вы хотите описать, какие сообщения должны посылаться (или позволено посылать) любой подсистеме,
реализующей интерфейс, такие сообщения могут идти от линий жизни интерфейса.</p>
<p class="example">Sending a message to an interface lifeline means that any
subsystem which realizes the interface can be substituted for the interface in
the diagram. Note that the ICoordinator interface lifeline does not have
messages going out from it, since different subsystems realizing the interface
may send different messages. However, if you want to describe what messages
should be sent (or are allowed to be sent) from any subsystem realizing the
interface, such messages can go out from the interface lifeline.</p>

<h4><a name="How to Work in Parallel">Как работать в параллели</a></h4>
<h4><a name="How to Work in Parallel">How to Work in Parallel</a></h4>
<p>В некоторых случаях, необходимо разработать подсистему более или менее независимо и в параллели с 
разработкой других подсистем. Для этого мы должны сначала выделить зависимости подсистем, определяя интерфейсы между ними.</p>
<p>In some cases it can be appropriate to develop a subsystem more or less
independently and in parallel with the development of other subsystems. To
achieve this, we must first find subsystem dependencies by identifying the
interfaces between them.</p>
<ol>
  <li>Сконцентрируйте внимание на требованиях, которые затрагивают интерфейсы между подсистемами.</li>
  <li>Выберите основные принципы требуемых интерфейсов, показывая сообщения, идущие через границы подсистемы.</li>
  <li>Сформируйте диаграммы последовательностей в терминах подсистем для каждого прецедента.</li>
  <li>Уточните интерфейсы, необходимые для сообщений.</li>
  <li>Разработайте каждую систему в параллели и используйте интерфейсвы как инструмент синхронизации 
    между командами разработчиков.</li>
  <p>
  <li>Concentrate on the requirements that affect the interfaces between the
    subsystems.</li>
  <li>Make outlines of the required interfaces, showing the messages that are
    going to pass over the subsystem borders.</li>
  <li>Draw sequence diagrams in terms of subsystems for each use case.</li>
  <li>Refine the interfaces needed to provide messages.</li>
  <li>Develop each subsystem in parallel, and use the interfaces as
    synchronization instruments between development teams.</li>
</ol>
<p>Вы также можете выбрать, систематизировать ли диаграммы последовательностей в терминах подсистем или только в терминах их
интерфейсов. В некоторых проектах может быть даже необходимым реализовать классы, обеспечивающие интерфейсы, перед тем, как 
продолжить моделирование.</p>
<p>You can also choose whether to arrange the sequence diagrams in term of
subsystems or in terms of their interfaces only. In some projects, it might even
be necessary to implement the classes providing the interfaces before you
continue with the rest of the modeling.</p>

<h3><a name="XE_persistent_object__describing"></a><a name="XE_persistence__describing_persistence-related_behavior"></a><a name="Describe Persistence-Related Behaviors">
Описать сохраняемо-связанное поведение</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<h3><a name="XE_persistent_object__describing"></a><a name="XE_persistence__describing_persistence-related_behavior"></a><a name="Describe Persistence-Related Behaviors">Describe
Persistence-Related Behaviors</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>

<p>The whole goal of the object-oriented paradigm is to <strong>encapsulate </strong>implementation
details. Therefore, with respect to persistence, we would like to have a
persistent object look <strong>just like</strong> a transient object. We should
not have to be aware that the object is persistent, or treat it any differently
than we would any other object. At least that’s the goal.</p>
<p>The whole goal of the object-oriented paradigm is to <strong>encapsulate </strong>implementation
details. Therefore, with respect to persistence, we would like to have a
persistent object look <strong>just like</strong> a transient object. We should
not have to be aware that the object is persistent, or treat it any differently
than we would any other object. At least that's the goal.</p>

<p>In practice, there may be times when the application needs to control various
aspects of persistence:
<ul>
  <li>when persistent objects are read and written</li>
  <li>when persistent objects are deleted</li>
  <li>how transactions are managed</li>
  <li>how locking and concurrency control is achieved</li>
</ul>
<p>In practice, there may be times when the application needs to control various
aspects of persistence:
<ul>
  <li>when persistent objects are read and written</li>
  <li>when persistent objects are deleted</li>
  <li>how transactions are managed</li>
  <li>how locking and concurrency control is achieved</li>
</ul>

<h4><a name="Writing Persistent Objects">Writing Persistent Objects</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>There are two cases to be concerned with here: the initial time the object is
written to the persistent object store, and subsequent times when the
application wants to update the persistent object store with a change to the
object.</p>
<p>In either case, the specific mechanism depends on the operations supported by
the persistence framework. Generally, the mechanism used is to send a message to
the persistence framework to create the persistent object. Once an object is
persistent, the persistence framework is smart enough to detect subsequent
changes to the persistent object and write them to the persistent object store
when necessary (usually when a transaction is committed).</p>
<p>An example of a persistent object being created is shown below:</p>
<p align="center"><img src="images/vbos1.gif" width="325" height="230"></p>
<p align="center" class="picturetext">The object PersistenceMgr is an instance
of VBOS, a persistence framework. The OrderCoordinator creates a persistent
Order by sending it as the argument to a 'createPersistentObject' message to the
PersistenceMgr.</p>
<p>It is <strong>generally</strong> not necessary to explicitly model this
unless it is important to know that the object is being explicitly stored at a
specific point in some sequence of events. If subsequent operations need to
query the object, the object must exist in the database, and therefore it is
important to know that the object will exist there.</p>
<h4><a name="Reading Persistent Objects">Reading Persistent Objects</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Retrieval of objects from the persistent object store is necessary before the
application can send messages to that object. Recall that work in an
object-oriented system is performed by sending messages to objects. But if the
object that you want to send a message to is in the database but not yet in
memory, you have a problem: you cannot send a message to something which does
not yet exist!</p>
<p>In short, you need to send a message to an object that knows how to query the
database, retrieve the correct object, and instantiate it. Then, and only then,
can you send the original message you originally intended. The object that
instantiates a persistent object is sometimes called a <em>factory</em> object.
A <strong>factory</strong> object is responsible for creating instances of
objects, including persistent objects. Given a query, the <strong>factory</strong>
could be designed to return a set of one or more objects which match the query.</p>
<p>Generally objects are richly connected to one another through their
associations, so it is usually only necessary to retrieve the <strong>root</strong>
object in an object graph; the rest are essentially transparently ‘pulled’
out of the database by their associations with the root object. (A good
persistence mechanism is smart about this: it only retrieves objects when they
are needed; otherwise, we might end up trying to instantiate a large number of
objects needlessly. Retrieving objects before they are needed is one of the main
performance problems caused by simplistic persistence mechanisms.)</p>
<p>The following example shows how object retrieval from the persistent object
store can be modeled. In an actual sequence diagram, the DBMS would not be
shown, as this should be encapsulated in the <strong>factory</strong> object.</p>
<p align="center"><img src="images/retriev.gif" width="489" height="297"></p>
<h4><a name="Deleting Persistent Objects">Deleting Persistent Objects</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>The problem with persistent objects is, well, they persist! Unlike transient
objects which simply disappear when the process that created them dies,
persistent objects exist until they are explicitly deleted. So it’s important
to delete the object when it’s no longer being used.</p>
<p>Trouble is, this is hard to determine. Just because one application is done
with an object does not mean that all applications, present and future, are
done. And because objects can and do have associations that even they don’t
know about, it is not always easy to figure out if it is okay to delete an
object.</p>
<p>In design, this can be represented semantically using <strong>state charts</strong>:
when the object reaches the <strong>end</strong> state, it can be said to be <strong>released</strong>.
Developers responsible for implementing persistent classes can then use the
state chart information to invoke the appropriate persistence mechanism behavior
to release the object. The responsibility of the Designer of the use-case
realization is to invoke the appropriate operations to cause the object to reach
its <strong>end</strong> state when it is appropriate for the object to be
deleted.</p>
<p>If an object is richly connected to other objects, it may be difficult to
determine whether the object can be deleted. Since a <strong>factory</strong>
object knows about the structure of the object as well as the objects to which
it is connected, it is often useful to charge the factory object for a class
with the responsibility of determining whether a particular instance can be
deleted. The persistence framework may also provide support for this capability.</p>
<h4><a name="Modeling Transactions">Modeling Transactions</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Transactions define a set of operation invocations which are <strong>atomic</strong>;
they are either all performed, or none of them are performed. In the context of
persistence, a transaction defines a set of changes to a set of objects which
are either all performed or none are performed. Transactions provide
consistency, ensuring that sets of objects move from one consistent state to
another.</p>
<p>There are several options for showing transactions in Use Case Realizations:
<ul>
  <li><strong>Textually</strong>. Using scripts in the margin of the sequence
    diagram, transaction boundaries can be documented as shown below. This
    method is simple, and allows any number of mechanisms to be used to
    implement the transaction.</li>
</ul>
<p align="center"><img src="images/txn1.gif" width="496" height="466"></p>
<p class="picturetext">Representing transaction boundaries using textual
annotations.
<ul>
  <li><strong>Using Explicit Messages</strong>. If the transaction management
    mechanism being used uses explicit messages to begin and end transactions,
    these messages can be shown explicitly in the sequence diagram, as shown
    below:</li>
</ul>
<p align="center"><img src="images/txn2.gif" width="558" height="575"></p>
<p class="picturetext">A sequence diagram showing explicit messages to start and
stop transactions.</p>
<h4><a name="Handling Error Conditions"></a>Handling Error Conditions <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>If all operations specified in a transaction cannot be performed (usually
because an error occurred), the transaction is <strong>aborted</strong>, and all
changes made during the transaction are reversed. Anticipated error conditions
often represent exceptional flows of events in use cases. In other cases, error
conditions occur because of some failure in the system. Error conditions should
be documented in interactions was well. Simple errors and exceptions can be
shown in the interaction where they occur; complex errors and exception may
require their own interactions.</p>
<p>Failure modes of specific objects can be shown on state charts. Conditional
flow of control handling of these failure modes can be shown in the interaction
in which the error or exception occurs.</p>
<h4><a name="Handling Concurrency Control">Handling Concurrency Control</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h4>
<p>Concurrency describes the control of access to critical system resources in
the course of a transaction. In order to keep the system in a consistent state,
a transaction may require that it have exclusive access to certain key resources
in the system. The exclusivity may include the ability to read a set of objects,
write a set of objects, or both read and write a set of objects.</p>
<p>Let’s look at a simple example of why we might need to restrict access to a
set of objects. Let’s say we a running a simple order entry system. People
call-in to place orders, and in turn we process the orders and ship the orders.
We can view the order as a kind of transaction.</p>
<p>To illustrate the need for concurrency control, let’s say I call in to
order a new pair of hiking boots. When the order is entered into the system, it
checks to see if the hiking boots I want, in the correct size, are in inventory.
If they are, we want to <strong>reserve</strong> that pair, so that no one else
can purchase them before the order can be shipped out. Once the order is
shipped, the boots are removed from inventory.</p>
<p>During the period between when the order is placed and when it ships, the
boots are in a special state – they are in inventory, but they are
&quot;committed&quot; to my order. If my order gets canceled for some reason (I
change my mind, or my credit card has expired), the boots get returned to
inventory. Once the order is shipped, we will assume that our little company
does not want to keep a record that it once had the boots.</p>
<p>The goal of concurrency, like transactions, is to ensure that the system
moves from one consistent state to another. In addition, concurrency strives to
ensure that a transaction has all the resources it needs to complete its work.
Concurrency control may be implemented in a number of different ways, including
resource locking, semaphores, shared memory latches, and private workspaces.</p>
<p>In an object-oriented system, it is difficult to tell from just the message
patterns whether a particular message might cause a state change on an object.
Also, different implementations may obviate the need to restrict access to
certain types of resources; for example, some implementations provide each
transaction with its own view of the state of the system at the beginning of the
transaction. In this case, other processes may change the state of and object
without affecting the ‘view’ of any other executing transactions.</p>
<p>To avoid constraining the implementation, in design we simply want to
indicate the resources to which the transaction must have exclusive access.
Using our earlier example, we want to indicate that we need exclusive access to
the boots that were ordered. A simple alternative is to annotate the description
of the message being sent, indicating that the application needs exclusive
access to the object. The Implementer then can use this information to determine
how best to implement the concurrency requirement. An example sequence diagram
showing annotation of which messages require exclusive access is shown below.
The assumption is that all locks are released when the transaction is completed.</p>
<p align="center"><img src="images/locking.gif" width="630" height="569"></p>
<p class="picturetext">An example showing annotated access control in a sequence
diagram.</p>
<p>The reason for not restricting access to all objects needed in a transaction
is that often only a few objects should have access restrictions; restricting
access to all objects participating in a transaction wastes valuable resources
and could create, rather than prevent, performance bottlenecks.</p>
<h3><a name="Refine the Flow of Events Description"></a>Refine the Flow of
Events Description <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>In the flow of events of the use-case realization you may need to add
additional description to the sequence diagrams, in cases where the flow of
events is not fully clear from just examining the messages sent between
participating objects. Some examples of these cases include cases where timing
annotations, notes on conditional behavior, or clarification of operation
behavior is needed to make it easier for external observers to read the
diagrams.</p>
<p>The flow of events is initially outlined in the <a href="ac_ucana.htm">Activity:
Use-Case Analysis</a>. In this step you refine the flow of events as needed to
clarify the sequence diagrams.</p>
<p>Often, the name of the operation is not sufficient to understand why the
operation is being performed. Textual notes or scripts in the margin of the
diagram may be needed to clarify the sequence diagram. Textual notes and scripts
may also be needed to represent control flow such as decision steps, looping,
and branching. In addition, textual tags may be needed to correlate extension
points in the use case with specific locations in sequence diagrams.</p>
<p>Previous examples within this activity have illustrated a number of different
ways of annotating sequence diagrams.</p>
<h3><a name="XE_design_subsystem__unifying"></a><a name="XE_class__unifying_design_classes"></a><a name="Unify Classes and Subsystems">Unify
Classes and Subsystems</a> <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>As use cases are realized, you need to unify the identified classes and
subsystems to ensure homogeneity and consistency in the model.</p>
<p>Points to consider:
<ul>
  <li>Names of model elements should describe their function.</li>
  <li>Avoid similar names and synonyms because they make it difficult to
    distinguish between model elements.</li>
  <li>Merge model elements that define similar behavior, or that represent the
    same phenomenon.</li>
  <li>Merge entity classes that represent the same concept or have the same
    attributes, even if their defined behavior is different.</li>
  <li>Use inheritance to abstract model elements, which tends to make the model
    more robust.</li>
  <li>When updating a model element, also update the corresponding flow of
    events description of the use-case realizations.</li>
</ul>
<h3><a name="Evaluate Your Results"></a>Evaluate Your Results <a href="#Top"><img src="../../images/top.gif" alt="To top of page" border="0" width="26" height="20"></a></h3>
<p>You should check the design model at this stage to verify that your work is
headed in the right direction. There is no need to review the model in detail,
but you should consider the <a href="chklists/ck_dmdl.htm">Checkpoints for the
Design Model</a> while you are working on it.</p>
<p>See especially <a href="chklists/ck_ucrlz.htm">checkpoints for use-case
realization</a> in the <font color="#800080"><a href="ac_rvdes.htm">Activity:
Review the Design</a>.</font><br>
<br>
<p><font face="Arial"><a href="../../copyrite/copyrite.htm"><small><small>Copyright&nbsp;
© 1987 - 2000 Rational Software Corporation</small></small></a></font>
<!--msnavigation--></td><td valign="top" width="24"></td><td valign="top" width="1%">
<p><a href="../../index.htm"></a></p>
<script language="JavaScript">
<!--
function loadTop()
{
  if(parent.frames.length!=0 && parent.frames[1].name=="ory_toc")
  {
     alert("The Rational Unified Process is already displayed using frames");
  }
  else
  {
    if(window.name=="ory_doc")
    {
      window.name = "xyz1234";
    }
    var expires = new Date();
    expires.setTime (expires.getTime() + (1000 * 20));
    document.cookie = "rup_ory_doc=" + escape (document.URL) +
    "; expires=" + expires.toUTCString() +  "; path=/";

    var new_ory_doc_loc = null;

    for(i=document.links.length-1;i>=0;i--)
    {
       if(document.links[i].href.indexOf("index.htm")!=-1)
       {
         new_ory_doc_loc = document.links[i].href;
         break;
       }
    }

    if(new_ory_doc_loc!=null)
    {
       top.location = new_ory_doc_loc;
    }
   }
}
// -->
</script>
<script language="JavaScript">
<!--
  function getImageUrl(image)
  {
    var new_ory_doc_loc=null;
    for(i=document.links.length-1;i>=0;i--)
    {
       if(document.links[i].href.indexOf("index.htm")!=-1)
       {
         new_ory_doc_loc = document.links[i].href.substring(0,document.links[i].href.lastIndexOf("/"));
         new_ory_doc_loc = new_ory_doc_loc + "" + image;
         return new_ory_doc_loc;
       }
    }
    return null;
  }
// -->
</script>
<script
language="JavaScript">
<!--
MSFPhover =
(((navigator.appName == "Netscape") &&
  (parseInt(navigator.appVersion) >= 3 )) ||
  ((navigator.appName == "Microsoft Internet Explorer") &&
  (parseInt(navigator.appVersion) >= 4 )));

  function MSFPpreload(img)
  {
     var a=new Image();
     a.src=img;
     return a;
  }
// -->
</script>
<script language="JavaScript">
<!--
    if(MSFPhover)
    {
        RupGray=MSFPpreload(getImageUrl('/images/rup1.gif'));
        RupBlue=MSFPpreload(getImageUrl('/images/rup1_a.gif'));
    }
// -->
</script>
<a href="JavaScript:loadTop();" onmouseover="if(MSFPhover) document['Home'].src=RupBlue.src; self.status='Display Rational Unified Process using frames'; return true" onmouseout="if(MSFPhover) document['Home'].src=RupGray.src; self.status= ' ';return true">
<p><img src="../../images/rup1.gif" border="0" alt="Display Rational Unified Process using frames" name="Home" border="0" width="20" height="110"></a></p>
</td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>
<p align="right"><font face="Arial"><small><small>Rational Unified
Process&nbsp;&nbsp; <img border="0" src="../../_borders/rupversion.gif" width="63" height="7"></small></small></font>
</td></tr><!--msnavigation--></table></body>

</html>
