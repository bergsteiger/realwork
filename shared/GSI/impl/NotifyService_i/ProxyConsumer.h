////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/shared/GSI/impl/NotifyService_i/ProxyConsumer.h"
// генератор заголовочных файлов C++ (.h)
// Generated from UML model, root element: <<SimpleClass::Class>> shared::GSI::NotifyService_i::ProxyConsumer
//
// Дополнительный получатель сообщений, имеющий связь с основным получателем. Решает следующее
// проблемы:
// 1. потому-что внутри фаер эвент основной получатель может быть уничтожен (типа: поймали
// сообщение - убей себя, такое бывает при апдейте)
// 2.  если объект стал дестроится из другого потока, то ТАО переходит в такое хитрое состояние -
// запрещение апколлов. А так как до конца умереть он не может, т.к. мешает захваченый здесь
// m_mutex, то состояние сохраняется и любой удаленный вызов внутри этого фаер эвент приводит к
// зависанию.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __SHARED_GSI_NOTIFYSERVICE_I_PROXYCONSUMER_H__
#define __SHARED_GSI_NOTIFYSERVICE_I_PROXYCONSUMER_H__

#include "shared/CoreSrv/sys/std_inc.h"

namespace GSI {
namespace NotifyService_i {

class Consumer_i;
// Дополнительный получатель сообщений, имеющий связь с основным получателем. Решает следующее
// проблемы:
// 1. потому-что внутри фаер эвент основной получатель может быть уничтожен (типа: поймали
// сообщение - убей себя, такое бывает при апдейте)
// 2.  если объект стал дестроится из другого потока, то ТАО переходит в такое хитрое состояние -
// запрещение апколлов. А так как до конца умереть он не может, т.к. мешает захваченый здесь
// m_mutex, то состояние сохраняется и любой удаленный вызов внутри этого фаер эвент приводит к
// зависанию.
class ProxyConsumer;
typedef Core::Var<ProxyConsumer> ProxyConsumer_var;
typedef Core::Var<const ProxyConsumer> ProxyConsumer_cvar;

class ProxyConsumer :
	virtual public Core::RefCountObjectBase
{
	SET_OBJECT_COUNTER (ProxyConsumer)
//////////////////////////////////////////////////////////////////////////////////////////
// constructors and destructor
public:
	// конструктор, в котором сразу связываемся с основным получателем
	explicit ProxyConsumer (Consumer_i* consumer);

public:
	virtual ~ProxyConsumer ();

//////////////////////////////////////////////////////////////////////////////////////////
// self methods
public:
	// зовется корбовским листенером для обработки пришедшего сообщения
	virtual void push_event (const CORBA::Any& event);

	// прикращаем принимать сообщения из корбовского листенера
	virtual void stop_listen ();

//////////////////////////////////////////////////////////////////////////////////////////
// self data
private:
	Core::Mutex m_mutex;

	Consumer_i* m_real_consumer;
}; // class ProxyConsumer

} // namespace NotifyService_i
} // namespace GSI


#endif //__SHARED_GSI_NOTIFYSERVICE_I_PROXYCONSUMER_H__
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

