UNIT ElemMemberPrim.ms.dict

USES
 axiom_push.ms.dict
;

USES
 core.ms.dict
;

USES
 arrays.ms.dict
;

USES
 ModelElementsDefinition.ms.dict
;

USES
 DoCacheElemMember.ms.dict
;

USES
 TransformElementMember.ms.dict
;

USES
 IsNil.ms.dict
;

USES
 RoseModel.ms.dict
;

ANY elem_func ElemMemberPrim
  STRING IN aMemberName
  IN aDefaultValue
  
 TtfwWord VAR l_FieldVar
 
 Self %% aMemberName >>> l_FieldVar
 
 if ( l_FieldVar NotValid ) then
 begin
  Self %% 'Original' >>> l_FieldVar
  if ( l_FieldVar NotValid ) then
  begin
   Self aMemberName aDefaultValue DoCacheElemMember
   (
    aDefaultValue 
   ) 
   >>> Result
  end // l_FieldVar NotValid
  else
  begin
   TtfwWord VAR l_Original
   l_FieldVar DO >>> l_Original
   if ( l_Original IsNil ) then
   begin
    Self aMemberName aDefaultValue DoCacheElemMember
    (
     aDefaultValue 
    ) 
    >>> Result
   end // l_Original IsNil
   else
   begin
    l_Original aMemberName aDefaultValue call.me >>> Result
   end // l_Original IsNil
  end // l_FieldVar NotValid
 end // l_FieldVar NotValid
 else
 begin
  Self aMemberName aDefaultValue DoCacheElemMember
  (
   l_FieldVar TransformElementMember 
  ) 
  >>> Result
 end // l_FieldVar NotValid
; // ElemMemberPrim

ANY elem_func xElemMemberPrim
  STRING IN aMemberName
  IN aDefaultValue
  
 TtfwWord VAR l_FieldVar
 
 Self %% aMemberName >>> l_FieldVar
 
 if ( l_FieldVar NotValid ) then
 begin
  //Self aMemberName aDefaultValue DoCacheElemMember
  (
   aDefaultValue 
  ) 
  >>> Result
 end // l_FieldVar NotValid
 else
 begin
  Self aMemberName aDefaultValue DoCacheElemMember
  (
   l_FieldVar TransformElementMember 
  ) 
  >>> Result
 end // l_FieldVar NotValid
; // xElemMemberPrim

elem_iterator xElemList
  STRING IN aMemberName
 Self aMemberName [empty] .xElemMemberPrim
 >>> Result 
; // xElemList

ModelElement elem_func xElemWord
  STRING IN aMemberName
 Self aMemberName nil .xElemMemberPrim
 >>> Result 
; // xElemWord

STRING elem_func xElemString
  STRING IN aMemberName
 Self aMemberName '' .xElemMemberPrim 
 >>> Result 
; // xElemString

INTEGER elem_func xMDAClass
 Self 'Class' class_Unknown .xElemMemberPrim >>> Result
; // xMDAClass

STRING elem_func xName
 if ( Self IsString ) then
 begin
  Self >>> Result
 end // Self IsString
 else
 begin
  Self 'Name' .xElemString >>> Result
 end // Self IsString
; // xName

STRING elem_func xOriginalName
 if ( Self IsString ) then
 begin
  Self >>> Result
 end // Self IsString
 else
 begin
  Self 'OriginalName' .xElemString >>> Result
 end // Self IsString
; // xOriginalName

STRING elem_func xNameInModel
 Self .xOriginalName >>> Result
 if ( Result .IsNil ) then
 begin
  Self .xName >>> Result
 end // ( Result .IsNil )
; // xNameInModel

elem_iterator xChildren
 Self 'Children' .xElemList >>> Result
; // xChildren

elem_iterator xViews
 Self 'Views' .xElemList >>> Result
; // xViews

ModelElement STRING elem_func xStereotype
 Self 'Stereotype' .xElemWord >>> Result
; // xStereotype

ModelElement elem_func xParent
 Self 'Parent' .xElemWord >>> Result
; // xParent

elem_iterator xParameters
 Self 'Parameters' .xElemList >>> Result
; // xParameters

USES
 ref.ms.dict
;

BOOLEAN elem_func IsView
 RULES
  ( Self .IsNil )
   false
  DEFAULT
   begin
    RULES
     ( Self IsIntf )
      ( Self pop:WordBox:Boxed )
     DEFAULT
      Self
    ; // RULES  
    pop:Word:Producer @ MEVIEW ?==
   end // DEFAULT
 ; // RULES
 >>> Result
; // IsView

BOOLEAN elem_func IsViewLink
 RULES
  ( Self .IsNil )
   false
  DEFAULT
   begin
    RULES
     ( Self IsIntf )
      ( Self pop:WordBox:Boxed )
     DEFAULT
      Self
    ; // RULES  
    pop:Word:Producer @ MEVIEWLINK ?==
   end // DEFAULT
 ; // RULES
 >>> Result
; // IsViewLink

BOOLEAN elem_func IsDiagram
 RULES
  ( Self .IsNil )
   false
  DEFAULT
   begin
    RULES
     ( Self IsIntf )
      ( Self pop:WordBox:Boxed )
     DEFAULT
      Self
    ; // RULES  
    pop:Word:Producer @ MEDIAGRAM ?==
   end // DEFAULT
 ; // RULES
 >>> Result
; // IsDiagram

BOOLEAN elem_func IsDiagrams
 RULES
  ( Self .IsNil )
   false
  DEFAULT
   begin
    RULES
     ( Self IsIntf )
      ( Self pop:WordBox:Boxed )
     DEFAULT
      Self
    ; // RULES  
    pop:Word:Producer @ MEDIAGRAMS ?==
   end // DEFAULT
 ; // RULES
 >>> Result
; // IsDiagrams

BOOLEAN elem_func IsMeStub
 RULES
  ( Self .IsNil )
   false
  DEFAULT
   begin
    RULES
     ( Self IsIntf )
      ( Self pop:WordBox:Boxed )
     DEFAULT
      Self
    ; // RULES  
    pop:Word:Producer @ MESTUB ?==
   end // DEFAULT
 ; // RULES
 >>> Result
; // IsMeStub

BOOLEAN elem_func IsSomeView
 RULES
  ( Self .IsNil )
   false
  ( Self .IsDiagram )
   true 
  ( Self .IsView )
   true 
  ( Self .IsViewLink )
   true 
  DEFAULT
   false 
 ; // RULES
 >>> Result  
; // IsSomeView

ANY elem_func ElemMember
  STRING IN aMemberName
  IN aDefaultValue
  
 //Self aMemberName aDefaultValue DoCacheElemMember
 ( 
  RULES 
   ( Self IsNil )
    aDefaultValue
   ( Self IsString )
    aDefaultValue
   ( Self IsIntf ) 
    ( Self pop:WordBox:Boxed aMemberName aDefaultValue .ElemMemberPrim )
   DEFAULT
    ( Self aMemberName aDefaultValue .ElemMemberPrim )
  ; // RULES
 )
 >>> Result
; // ElemMember

elem_iterator ElemList
  STRING IN aMemberName
 //Self aMemberName [empty] DoCache
 (
  Self aMemberName [empty] .ElemMember 
 )
 >>> Result 
; // ElemList

STRING elem_func ElemString
  STRING IN aMemberName
 //Self aMemberName '' DoCache
 (
  Self aMemberName '' .ElemMember 
 ) 
 >>> Result 
; // ElemString

ModelElement elem_func ElemWord
  STRING IN aMemberName
 //Self aMemberName nil DoCache
 (
  Self aMemberName nil .ElemMember 
 ) 
 >>> Result 
; // ElemWord

STRING elem_func Name
 if ( Self IsString ) then
 begin
  Self >>> Result
 end // Self IsString
 else
 begin
  Self 'Name' .ElemString >>> Result
 end // Self IsString
; // Name

STRING elem_func OriginalName
 if ( Self IsString ) then
 begin
  Self >>> Result
 end // Self IsString
 else
 begin
  Self 'OriginalName' .ElemString >>> Result
 end // Self IsString
; // OriginalName

STRING elem_func NameInModel
 RULES
  ( Self .IsDiagram )
   ( Self .Name >>> Result )
  DEFAULT 
   begin
    Self .OriginalName >>> Result
    if ( Result .IsNil ) then
    begin
     Self .Name >>> Result
    end // ( Result .IsNil )
   end // DEFAULT
 ; // RULES
; // NameInModel

USES
 DoCache.ms.dict
;

: CacheWord
  ModelElement IN aCacheWhere
  TtfwWord IN aWord
  ^ IN aLambda
 aCacheWhere aWord .WordName nil DoCache ( aLambda DO )
; // CacheWord

MACRO Cache
 axiom:PushSymbol @SELF
 axiom:PushSymbol CacheWord
; // Cache

MACRO CacheMethod
 'Self' Ctx:Parser:PushSymbol
 axiom:PushSymbol @SELF
 axiom:PushSymbol CacheWord
; // CacheMethod

WordAlias Cached: CacheMethod

ModelElement STRING elem_func Stereotype
 Self 'Stereotype' .ElemWord >>> Result
; // Stereotype

USES
 WordsRTTI.ms.dict
;

BOOLEAN FUNCTION IsStereoKindOf
  ModelElement IN anOurStereo
  ModelElement IN anOtherStereo
 anOurStereo 
 'isA:' anOtherStereo .WordName Cat 
 false
 DoCache 
 (
  BOOLEAN VAR l_Is
  anOurStereo anOtherStereo ?== >>> l_Is
  if ( l_Is ! ) then
  begin
   anOurStereo .Name anOtherStereo .Name ?== >>> l_Is
  end // l_Is !
  if ( l_Is ! ) then
  begin
   RULES
    ( anOurStereo IsString )
     ()
    DEFAULT 
     begin
      anOurStereo .Inherited.Words 
      .trunc> ( DROP l_Is ! ) 
      .for> (
       ModelElement IN anAncestor
       if ( anAncestor anOtherStereo call.me ) then
       begin
        true >>> l_Is
       end
      )
     end // DEFAULT
   ; // RULES 
  end // l_Is !
  l_Is
 ) 
 >>> Result
; // IsStereoKindOf

elem_iterator Inherits
 Self 'Inherits' .ElemList >>> Result
; // Inherits

elem_iterator Implements
 Self 'Implements' .ElemList >>> Result
; // Implements

elem_iterator StereotypeAncestors
 Cached:
 (
  Self .Implements
  .filter> ( .NameInModel Self .NameInModel SameStr )
  // - вытаскиваем вперёд переопределения, они типа главные
  .join> (
   Self .Inherits
   .join> ( Self .Implements ) 
  )
  array:CopyWithoutDuplicates
 ) 
 >>> Result
; // StereotypeAncestors

ModelElement STRING elem_func StereotypeInModel
 RULES
  //( Self .IsStereotype st_MDACategory )
  // Self
  //( Self .IsStereotype st_MDAClass )
  // Self
  ( Self .IsMeStub )
   ( Self 'StereotypeInModel' .ElemWord )
  //( Self 'StereotypeInModel' .ElemWord .IsNil )
  // Self
  DEFAULT
   Self
   //( Self 'StereotypeInModel' .ElemWord )
 ; // RULES  
 >>> Result
; // StereotypeInModel

BOOLEAN FUNCTION .IsStereotypeInModelKindOf
  ModelElement IN anOurStereo
  ModelElement IN anOtherStereo
 anOtherStereo .StereotypeInModel >>> anOtherStereo
 anOurStereo 
 'IsStereotypeInModelKindOf:' anOtherStereo .WordName Cat 
 false
 DoCache 
 (
  BOOLEAN VAR l_Is
  anOurStereo anOtherStereo ?== >>> l_Is
  if ( l_Is ! ) then
  begin
   anOurStereo .Name anOtherStereo .Name ?== >>> l_Is
  end // l_Is !
  if ( l_Is ! ) then
  begin
   RULES
    ( anOurStereo IsString )
     ()
    DEFAULT 
     begin
      anOurStereo .StereotypeAncestors
      .trunc> ( DROP l_Is ! ) 
      .for> (
       ModelElement IN anAncestor
       if ( anAncestor anOtherStereo call.me ) then
       begin
        true >>> l_Is
       end
      )
     end // DEFAULT
   ; // RULES 
  end // l_Is !
  l_Is
 ) 
 >>> Result
; // .IsStereotypeInModelKindOf

BOOLEAN elem_func IsStereotypeInModelKindOf:
  ^ IN anOtherStereo
 Self anOtherStereo .IsStereotypeInModelKindOf
 >>> Result
; // IsStereotypeInModelKindOf:

BOOLEAN elem_func IsStereotype
  ^ IN aStereo
  
 ModelElement VAR l_OurStereo
 Self .Stereotype >>> l_OurStereo
 
 RULES 
  ( l_OurStereo .IsNil )
    false
  (  
   ( l_OurStereo .IsMeStub )
   OR ( l_OurStereo .StereotypeInModel l_OurStereo ?== )
  ) 
   begin
    ModelElement VAR l_Stereo
    aStereo DO >>> l_Stereo
    l_OurStereo l_Stereo IsStereoKindOf
   end // // l_OurStereo IsNil
  DEFAULT 
   begin
    ModelElement VAR l_Stereo
    aStereo DO >>> l_Stereo
    l_OurStereo l_Stereo .IsStereotypeInModelKindOf
   end // // l_OurStereo IsNil
 ; // RULES
 >>> Result
 
; // IsStereotype

WordAlias .IsStereotype: .IsStereotype

VOID IMMEDIATE operator %%Inner
 ^L IN aName
; // %%Inner

VOID IMMEDIATE operator %%InjectedBy
 ^L IN aTo
 ^L IN aFrom
; // %%InjectedBy

VOID IMMEDIATE operator %%ImplementedBy
 ^L IN aTo
 ^L IN aFrom
; // %%ImplementedBy

VOID IMMEDIATE operator %%InheritedBy
 ^L IN aTo
 ^L IN aFrom
; // %%InheritedBy

elem_iterator Attributes
 Self 'Attributes' .ElemList >>> Result
; // Attributes

