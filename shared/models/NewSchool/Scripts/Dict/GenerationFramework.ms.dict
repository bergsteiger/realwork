UNIT GenerationFramework.ms.dict

USES
 axiom_push.ms.dict
;

USES
 core.ms.dict
;

USES
 IsNil.ms.dict
;

USES
 CompileTimeVAR.ms.dict
;

USES
 SaveVarAndDo.ms.dict
;

USES
 arrays.ms.dict
;

USES
 WordsRTTI.ms.dict
;

USES
 ModelElementsDefinition.ms.dict
;

TtfwWord CompileTime-VAR g_CurrentGenerator nil
%REMARK 'Текущий генератор'

: WithGen:
  ^ IN aGen
  ^ IN aLambda
 TF g_CurrentGenerator (
  aGen |^@Deepest >>> g_CurrentGenerator
  //aGen >>> g_CurrentGenerator
  aLambda DO
 ) // TF g_CurrentGenerator
; // WithGen:

USES
 filterNil.ms.dict
;

TtfwWord FUNCTION .FindMemberRecur
  STRING IN aName
  TtfwWord IN aGen

 TtfwKeyWord VAR l_Member
 aName aGen pop:Word:FindMember >>> l_Member

 if ( l_Member .IsNil ) then
  ( nil >>> Result )
 else
  ( l_Member pop:KeyWord:Word >>> Result )

 if ( Result .IsNil ) then
  ( 
   aGen .Inherited.Words
   .filterNil>
   .for> (
    IN anItem 
    VAR l_Found 
    aName anItem call.me >>> l_Found
    ( Result .IsNil ) 
    OR ( l_Found .IsNil ) 
    OR ( Result = l_Found ) 
     ?ASSURE [ 'Multiply inheritance. Word: ' aName ' generator ' aGen .WordName ' parent generator ' anItem .WordName ]
    l_Found >>> Result
   ) 
  )

; // .FindMemberRecur

: .?
  ^ IN aWord

 VAR l_Word
 nil >>> l_Word

 g_CurrentGenerator .NotIsNil ?ASSURE 'Нет текущего генератора'
 if ( g_CurrentGenerator .NotIsNil ) then
  ( aWord |N g_CurrentGenerator .FindMemberRecur >>> l_Word )

 if ( l_Word .IsNil ) then
  ( aWord DO )
 else
  ( l_Word DO )
; // .?

elem_proc CurrentGenerator
 Self g_CurrentGenerator DO
; // CurrentGenerator

CONST cRoot 'w:'

USES
 Out.ms.dict
;

USES
 CutPrefix.ms.dict
;

STRING FUNCTION .CheckDrive
  STRING IN Self
 Self >>> Result
 if ( cRoot Result StartsText ! ) then
 begin
  Result cPathSep .CutPrefix >>> Result
  [ cRoot
  // - это потому, что в пути нету диска, а для ExtractFileName он нужен
  Result ] cPathSep strings:CatSep >>> Result
 end // ( cRoot Result StartsText ! )
; // .CheckDrive

BOOLEAN elem_func NeedOwnFilePrim
 false >>> Result
; // NeedOwnFilePrim

BOOLEAN elem_func NeedOwnFile
 Self .? .NeedOwnFilePrim >>> Result
; // NeedOwnFile

STRING elem_func FinalFileNamePrim
 '' >>> Result
; // FinalFileNamePrim

USES
 ElementsRTTI.ms.dict
;

USES
 cGenScriptsFolder.ms.dict
;

STRING FUNCTION Ext
 '.dump' >>> Result
; // Ext

CONST cUCFileExt '.uc.txt'

STRING elem_func UCFileName
 //g_RealFileName cUCFileExt Cat
 [
  cGenScriptsFolder
  [ Self .WordName .? Ext cUCFileExt ] strings:Cat
 ] cPathSep strings:CatSep
 >>> Result
; // UCFileName

BOOLEAN elem_func NewSchoolGenerator
 false >>> Result
; // NewSchoolGenerator

BOOLEAN elem_func IsNewSchoolGenerator
 Self .? .NewSchoolGenerator >>> Result
; // IsNewSchoolGenerator

BOOLEAN elem_func IsNewSchoolElement
 RULES
  ( Self .IsNewSchoolGenerator )
   true
  ( Self .IsNewSchoolRec )
   true 
  DEFAULT
   false 
 ; // RULES  
 >>> Result
; // IsNewSchoolElement

elem_proc SavePrimPrim
 RULES
  ( Self .NeedOwnFile )
   begin
    VAR l_FileName
    Self .? .FinalFileNamePrim .CheckDrive >>> l_FileName
    if ( l_FileName .NotIsNil ) then
    begin
     l_FileName .ProcessTmpOut: (
      Self .CurrentGenerator
     ) // l_FileName .ProcessTmpOut:
    end // ( l_FileName .NotIsNil )
   end // ( Self .NeedOwnFile )
  DEFAULT
   () 
 ; // RULES
; // SavePrimPrim

elem_proc SavePrim
 Self .SavePrimPrim
/*{ if ( Self .IsNewSchoolGenerator ) then
 // - сохраняем элементы, сохранённые СТАРЫМ генератором
 begin
  Self .Children
  .join> ( Self .Constants )
  .filter> ( .IsNewSchool ! )
  .for> call.me
 end // ( Self .IsNewSchoolGenerator )}*/
; // SavePrim

elem_proc Save
  IN aGenerator
 WithGen: aGenerator (
  RULES
   ( Self .IsNil )
    ()
   ( Self .NeedOwnFile )
    ( Self .SavePrim )
   DEFAULT
    begin
     Self .Parent aGenerator call.me
    end // DEFAULT
  ; // RULES
 ) // WithGen:
; // Save
