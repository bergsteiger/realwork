UNIT LoadOnDemand.ms.dict

USES
 core.ms.dict
;

USES
 Log.ms.dict
;

USES
 WordsCache.ms.dict
;

USES
 Chars.ms.dict
;

USES
 ModelRoot.ms.dict
;

USES
 ProcessModelFiles.ms.dict
;

USES
 DiagramExt.ms.dict
;

USES
 CutPrefix.ms.dict
;

USES
 MEPrefix.ms.dict
;

USES
 DiagramsSuffix.ms.dict
;

TtfwWord FUNCTION LoadWord
  STRING IN aWordName
  STRING IN aDictName
 Ctx:EnterCS
 TRY
  if ( aWordName WordFromCache ) then
  begin
   >>> Result
  end // ( aWordName WordFromCache )
  else
  begin
   STRING VAR l_Code 
   BOOLEAN VAR l_WasException
   false >>> l_WasException
   
   aDictName Ctx:ResolveIncludedFilePath >>> aDictName
   if ( aDictName sysutils:FileExists ) then
   begin
    [ 'INCLUDE ' cQuote aDictName cQuote ' @ ' aWordName ] strings:Cat >>> l_Code
    VAR l_N
    [ 'C:\Temp\Scripts\WL\' aDictName sysutils:ExtractFilePath ':' '' string:Replace ] '\' strings:CatSep >>> l_N
    l_N sysutils:ForceDirectories DROP
    [ l_N aWordName '.wl.script' ] strings:Cat >>> l_N
    VAR l_N1
    [ l_N '.tmp' ] strings:Cat >>> l_N1
    FILE VAR l_Out
    l_N1 File:OpenWrite >>> l_Out
    TRY
     l_Code l_Out File:WriteStr
    FINALLY
     nil >>> l_Out
    END // TRY..FINALLY
    if (
        ( l_N sysutils:FileExists ! )
        OR ( cEmptyStr l_N l_N1 CompareFiles ! )
       ) then
    begin
     VAR l_TryCount
     30 >>> l_TryCount
     while ( l_TryCount > 0 )
     begin
      TRY
       $20 l_N l_N1 CopyFile
       0 >>> l_TryCount
      EXCEPT
       Dec l_TryCount
       if ( l_TryCount <= 0 ) then
        RAISE
       100 SLEEP 
      END // TRY..EXCEPT 
     end // while ( l_TryCount > 0 )
    end // ( l_N sysutils:FileExists ! )
    TRY
     l_N script:CompileAndProcess DO
     //l_Code script:CompileStringAndProcess DO
    EXCEPT
     current:exception:Message Say
     [ 'Возможно элемент ' aWordName ' : ' aDictName ' удалён' ] strings:Cat Say
     true >>> l_WasException
     nil >>> Result
    END
    if ( l_WasException ! ) then
    begin
     TRY
      >>> Result
      Result pop:Word:Name aWordName == ?ASSURE [ 'Вернулось неверное слово ' Result pop:Word:Name ' вместо ' aWordName ]
     EXCEPT
      current:exception:Message Say
      [ 'Возможно элемент ' aWordName ' : ' aDictName ' удалён' ] strings:Cat Say
      nil >>> Result
     END 
    end // l_WasException !
   end // ( aDictName sysutils:FileExists )
   else
   begin
    nil >>> Result
   end // ( aDictName sysutils:FileExists )
   
   if ( Result IsNil ) then
   // - пытаемся тут загрузить слово поиском по всем файлам модели
   begin
    if ( DiagramExt aDictName EndsText ! ) then
    begin
     if ( DiagramsSuffix aWordName EndsText ! ) then
     begin
      Log: [ 'Пытаемся тут загрузить слово ' aWordName ' поиском по всем файлам модели' ' вместо: ' aDictName ]
     end // ( DiagramsSuffix aWordName EndsText ! )
     ModelRootIn .ProcessModelFiles: ( 
       STRING IN aFileName
      if ( aDictName sysutils:ExtractFileName aFileName sysutils:ExtractFileName SameText ! ) then
      begin
       if ( [ 'ME ' aWordName ] strings:Cat aFileName FindInFile ) then
       begin 
        if ( [ 'MEPROP UID ' cQuote aWordName MEPrefix .CutPrefix cQuote ] strings:Cat aFileName FindInFile ) then
        begin
         aWordName aFileName call.me >>> Result
        end
       end // ( [ 'ME ' aWordName ] strings:Cat aFileName FindInFile )
      end // ( aDictName aFileName SameText ! )
     ) // ModelRootIn .ProcessModelFiles:
    end // ( DiagramExt aDictName EndsText ! )
   end // ( Result IsNil )
   
   aWordName Result WordToCache
  end // ( aWordName WordFromCache )
 FINALLY
  Ctx:LeaveCS
 END // TRY..FINALLY 
; // LoadWord 

WordAlias LW LoadWord

USES
 CompileTimeVar.ms.dict
;

CompileTime-VAR g_TransformWord nil

PROCEDURE TransformWord
  TtfwWord IN aWord
 if ( g_TransformWord IsNil ! ) then
 begin
  aWord g_TransformWord DO
 end // ( g_TransformWord IsNil ! )
; // TransformWord

TtfwWord FUNCTION WordLink
  ^ IN aWordName
  ^ IN aDictName
 aWordName DO aDictName DO LoadWord 
 >>> Result
 Result TransformWord
; // WordLink

USES
 ref.ms.dict
;

TtfwWord FUNCTION HardWordLink
  ^ IN aWord
 //aWord DO
 //aWord |^@
 aWord |^
 >>> Result
 Result TransformWord
; // HardWordLink

WordAlias WL WordLink

USES
 CutPrefix.ms.dict
;

USES
 ModelScriptExt.ms.dict
;

TtfwWord FUNCTION WL?
  ^ IN aWordName
 VAR l_WordName  
 aWordName |N >>> l_WordName
 l_WordName l_WordName MEPrefix .CutPrefix ModelScriptExt Cat /*{DUP Msg}*/ LoadWord
 >>> Result 
; // WL?

//WordAlias HWL HardWordLink

MACRO HWL
  ^L IN aWord
 VAR l_N
 aWord |N >>> l_N
 //l_N Msg
 RULES
  ( l_N IsWordDeclared ! )
   begin
    Log: [ l_N ' не определён. Будем пытаться найти' ]
    axiom:PushSymbol WL?
    l_N Ctx:Parser:PushString
   end // ( l_N IsWordDeclared ! )
  DEFAULT
   begin 
    axiom:PushSymbol HardWordLink 
    l_N Ctx:Parser:PushSymbol 
   end // DEFAULT
 ; // RULES  
; // HWL

