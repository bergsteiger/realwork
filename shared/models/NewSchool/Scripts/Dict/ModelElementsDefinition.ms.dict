UNIT ModelElementsDefinition.ms.dict

USES 
 types.ms.dict
 axiom_push.ms.dict
 core.ms.dict
 NoStrangeSymbols.ms.dict
 WordsRTTI.ms.dict
;

USES
 CompileTimeVar.ms.dict
;

USES
 arrays.ms.dict
;

BOOLEAN FUNCTION .IsWord
 IN aValue
 ( aValue IsObj ) AND ( aValue IS class::TtfwWord ) >>> Result
; // .IsWord

USES
 ModelElement.ms.dict
;

BOOLEAN FUNCTION .IsSequence
 IN aValue
 ( aValue .IsWord ) AND ( aValue IS class::TkwBeginLikeCompiledCode ) >>> Result
; // .IsSequence

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N this.method.addr nil 'ModelElement' do_word_func
; // elem_func

WordAlias elem_func_with_side_effects elem_func

BOOLEAN elem_func True
 %SUMMARY 'Функтор определяющий, что все значения подходят.' ;
 true >>> Result
; // True

PROCEDURE do_elem_proc_prim
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 STRING IN aType
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 if ( aType IsNil ! ) then
 begin
  aType Ctx:Parser:PushSymbol
 end // ( aType IsNil ! )
 aName aSelf aModifier 'ModelElement' do_word_func
; // do_elem_proc_prim

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 aName aSelf aModifier 'VOID' do_elem_proc_prim
; // do_elem_proc

MACRO elem:
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N this.method.addr nil '' do_elem_proc_prim
; // elem:

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_iterator
 [ 'ARRAY elem_func' ] Ctx:Parser:PushArray
 @SELF Ctx:SetWordProducerForCompiledClass
; // elem_iterator

ARRAY FUNCTION .SequenceCode.It
  TkwBeginLikeCompiledCode IN aCode
 %SUMMARY 'Преобразует список компилированных слов в итератор вызывающий каждое из этих слов' ;
 aCode CodeIterator .map> DO >>> Result
; // .SequenceCode.It

ARRAY FUNCTION Seq:
  ^ IN aCode
 %SUMMARY 'Преобразует список компилированных слов в итератор вызывающий каждое из этих слов' ;
 aCode CodeIterator .map> DO >>> Result
; // Seq:

USES
 axiom:WordBox
;

ModelElement elem_func WeakRef
 %SUMMARY
  'Возвращает СЛАБУЮ ссылку на элемент.'
 ;
 RULES
  ( Self IsIntf )
   ( Self pop:WordBox:Boxed )
  DEFAULT
   Self
 ; // RULES
 >>> Result
; // WeakRef

USES
 MEPrefix.ms.dict
;

STRING elem_func WordName
 RULES
  ( Self IsIntf )
   ( Self pop:WordBox:Boxed pop:Word:Name )
  DEFAULT
   ( Self pop:Word:Name ) 
 ; // RULES
 >>> Result  
 if (
     ( Result IsNil ) 
     OR ( Result 'KeyValues:Create' == )
    ) then
 begin
  if ( Self IsIntf ) then
  begin
   Self pop:WordBox:Boxed >>> Self
  end // ( Self IsIntf )
  
  VAR l_Field
  Self %% 'UID' >>> l_Field
  if ( l_Field IsNil ) then
  begin
   Self %% 'Name' >>> l_Field
  end // ( l_Field IsNil )
  l_Field IsNil ?FAIL 'Не удалось получить UID'
  MEPrefix l_Field DO Cat >>> Result
 end // ( Result IsNil )
; // WordName

EXPORTS
 ModelElement.ms.dict
