UNIT ModelGeneration.ms.dict

USES
 axiom_push.ms.dict
;

USES
 core.ms.dict
;

USES
 arrays.ms.dict
;

USES
 ModelElementsDefinition.ms.dict
;

USES
 ElementsRTTI.ms.dict
;

USES
 Chars.ms.dict
;

USES
 DictName.ms.dict
;

USES
 IsAutoElement.ms.dict
;

USES
 msmMetaModel.ms.dict
;

USES
 smallMetaModel.ms.dict
;

USES
 LUID.ms.dict
;

USES
 IsNil.ms.dict
;

USES
 Out.ms.dict
;

USES
 Predicates.ms.dict
;

USES
 g_ForwardedTypes.ms.dict
;

USES
 CountIt.ms.dict
;

USES
 FirstElement.ms.dict
;

USES
 SaveVarAndDo.ms.dict
;

USES
 InheritsAndImplementsNew.ms.dict
;

USES
 MakeElements.ms.dict
;

USES
 CutPrefix.ms.dict
;

STRING elem_func KindString
 RULES
  ( Self .Kind kind_NormalClass == )
   'NormalClass'
  ( Self .Kind kind_ParameterizedClass == )
   'ParameterizedClass'
  DEFAULT
   ( Self .Kind ToPrintable )
 ; // RULES
 >>> Result
; // KindString

STRING elem_func VisibilityString
 RULES
  ( Self .Visibility PublicAccess == )
   'PublicAccess'
  ( Self .Visibility PrivateAccess == )
   'PrivateAccess'
  ( Self .Visibility ProtectedAccess == )
   'ProtectedAccess'
  DEFAULT
   ( Self .Visibility ToPrintable ) 
 ; // RULES
 >>> Result
; // VisibilityString
 
STRING elem_func AbstractionString
 RULES
  ( Self .Abstraction at_final == )
   'final'
  ( Self .Abstraction at_regular == )
   'regular'
  ( Self .Abstraction at_abstract == )
   'abstract'
  ( Self .Abstraction at_optional == )
   'optional'
  DEFAULT
   ( Self .Abstraction ToPrintable )
 ; // RULES
 >>> Result
; // AbstractionString

STRING elem_func LinkTypeString
 RULES
  ( Self .LinkType lt_lnk == )
   'lnk'
  ( Self .LinkType lt_ref == )
   'ref'
  ( Self .LinkType lt_agr == )
   'agr'
  DEFAULT
   ( Self .LinkType ToPrintable )
 ; // RULES
 >>> Result
; // LinkTypeString

STRING elem_func OpKindString
 RULES
  ( Self .OpKind opkind_Normal == )
   'Normal'
  ( Self .OpKind opkind_Implemented == )
   'Implemented'
  ( Self .OpKind opkind_Overridden == )
   'Overridden'
  ( Self .OpKind opkind_DecoratedType == )
   'DecoratedType'
  ( Self .OpKind opkind_ReferencedType == )
   'ReferencedType'
  DEFAULT
   ( Self .OpKind ToPrintable )
 ; // RULES
 >>> Result
; // OpKindString

STRING FUNCTION .FineString
  STRING IN Self
 Self
 cQuote '''''' string:Replace
 #13#10 '''#13#10''' string:Replace
 #13 '''#13''' string:Replace
 #10 '''#10''' string:Replace
 >>> Result
; // .FineString

USES
 MEPrefix.ms.dict
;

USES
 ModelScriptExt.ms.dict
;

USES
 IsDeletedElement.ms.dict
;

STRING elem_func ScriptWordLink
 [
  RULES
   ( Self .IsNil )
    'nil'
   ( Self .IsDeletedElement )
     'nil'
   ( 
    Self .WordName MEPrefix .CutPrefix
    Self .DictName 
    SameText
   )
    begin
     'WL? '
     cQuote Self .WordName cQuote
    end
   DEFAULT
    begin
     'WL '
     cQuote Self .WordName cQuote ' '
     cQuote Self .DictName cModelScript cQuote
    end // DEFAULT
  ; // RULES
 ] strings:Cat
 >>> Result
; // ScriptWordLink

USES
 GenerationFramework.ms.dict
;

USES
 ModelRoot.ms.dict
;

USES
 filterNil.ms.dict
;

elem_proc ModelGeneration
 [
  '// '
  Self .NameInModel ' '
  Self .LUID ' '
  Self .Stereotype .Name ' '
  Self .MDAClassString
 ] .Out
 OutLn
 [ 'INCLUDE ' cQuote 'ElementsRTTI.ms.dict' cQuote ] .Out
 OutLn
 
 begin
  VAR l_NeedLn
  false >>> l_NeedLn
  Self .Children
  .filterNil>
  .map> .WordName
  .filterNil>
  .for> (
    IN aChildName
   [ '%%Inner ' aChildName ] .Out 
   true >>> l_NeedLn
  ) // .for>
  if l_NeedLn then
   OutLn
 end

 VAR l_LinkFrom
 Self >>> l_LinkFrom
 VAR l_DictName
 Self .DictName >>> l_DictName

 STRING elem_func pas_script_ReferencePrim
   STRING IN aComment
  [
   RULES
    ( Self .IsNil )
     'nil'
    ( Self .IsDeletedElement )
     'nil'
    DEFAULT
     begin
      RULES
       ( Self .IsReferencedType )
        ( [ 'HWL ' Self .WordName ] strings:Cat )
       (
        ( Self .IsSubRoot )
        AND ( Self l_LinkFrom ?!= )
       ) 
        ( Self .ScriptWordLink )
       ( l_DictName Self .DictName != )
        ( Self .ScriptWordLink )
       ( Self .MDAClass class_Parameter == )
        ( Self .WordName )
       ( Self .MDAClass class_Dependency == )
        ( Self .WordName )
       ( Self .Original .NotIsNil )
        ( Self .WordName )
       DEFAULT
        ( [ 'HWL ' Self .WordName ] strings:Cat )
      ; // RULES
      ' // '
      RULES
       ( aComment .NotIsNil )
        aComment
       ( Self .MDAClass class_Dependency == )
        (
         if ( Self .NameInModel .NotIsNil ) then
         begin
          Self .NameInModel
          ':'
         end // ( Self .NameInModel .NotIsNil )
         Self .Target .NameInModel
        )
       DEFAULT
        ( Self .NameInModel )
      ; // RULES
      \n
     end // DEFAULT
   ; // RULES
  ] strings:Cat
  >>> Result
 ; // pas_script_ReferencePrim

 STRING elem_func pas_script_Reference
  Self '' .pas_script_ReferencePrim
  >>> Result
 ; // pas_script_Reference

 STRING FUNCTION .ValueToString
   IN Self
  RULES
   ( Self IsString )
    ( [ cQuote Self .FineString cQuote ] strings:Cat )
   ( Self IsObj )
    ( Self .pas_script_Reference )
   DEFAULT
    ( Self ToPrintable )
  ; // RULES
  >>> Result
 ; // .ValueToString

 elem_proc pas_script_GenerateDescription
 
  elem_proc OutForward
   RULES
    ( Self .IsValueValid ! )
     ()
    ( Self .IsNil )
     ()
    ( Self .IsDeletedElement )
     ()
    ( l_DictName Self .DictName != )
     ()
    DEFAULT
    begin
     if ( Self .AddToArray?: g_ForwardedTypes ) then
      ( [ 'FORWARD ' Self .WordName \n ] .Out )
    end  
   ; // RULES
  ; // OutForward

  Self .Forwarded .filterNil> .for> .OutForward
  Self .Injected .filterNil> .for> .OutForward
  
  Self .Inherits 
  .filterNil> 
  .filter> .Not: .IsReferencedType
  .for> .OutForward
  
  Self .Implements 
  .filter> .Not: .IsReferencedType
  .filterNil> 
  .for> .OutForward
  
  Self .Implementors .filterNil> .for> .OutForward
  Self .Zones .filterNil> .for> .OutForward
  Self .CanRaise .filterNil> .for> .OutForward
  Self .CanRaiseInSet .filterNil> .for> .OutForward
  Self .Target .OutForward
  Self .ValueType .OutForward
  Self .Original .OutForward
  Self .SpelledFor .OutForward
  Self .Speller .OutForward
  Self .GetUP 'extprop:CASTER' .OutForward

  Self .Children
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> ( Self .OutForward call.me )

  Self .Constants
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> ( Self .OutForward call.me )
  
  Self .Attributes
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> ( Self .OutForward call.me )

  Self .Operations
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> ( Self .OutForward call.me )

  Self .Parameters
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> ( Self .OutForward call.me )

  Self .Dependencies
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> ( Self .OutForward call.me )

  elem_proc OutUPs
   Self .UpList .NotEmpty ?
   (
    Self .UpList
    .filter> ( .WordName 'IsSummoned' != )
    .for> (
      IN aUP
     [
      VAR l_Value
      [ aUP DO ]
      .FirstElement >>> l_Value
      RULES
       ( l_Value .IsValueValid ! )
        ()
       ( l_Value .IsAutoElement )
        ()
       ( l_Value IsObj )
        ( 'UPLINK ' aUP .WordName ' ' l_Value .ValueToString ' ;' )
       DEFAULT
        ( 'UP ' aUP .WordName ' ' l_Value .ValueToString )
      ; // RULES
     ] .Out
    ) // Self .UpList .for>
   )
  ; // OutUPs

  elem_proc OutImplemented
   Self .Original .OutForward
   [ 'MEREF ' Self .WordName ] .Out
   Indented: (
    Self .Original .NotIsNil ?
     ( [ 'MELINK Original ' Self .Original .pas_script_Reference ' ;' ] .Out )
    Self .OpKind opkind_Normal != ?
     ( [ 'MEPROP OpKind opkind_' Self .OpKindString ] .Out )
    Self .IsAutoElement ?
     ( [ 'UP IsAuto ' 'true' ] .Out )
    Self .OutUPs 
   ) // Indented:
   [ 'ENDMEREF ' '// ' Self .WordName ' ' Self .NameInModel ] .Out
   OutLn
  ; // OutImplemented
  
  Self .Implemented
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> .OutImplemented

  Self .Overridden
  .filterNil>
  .filter> .Not: .NeedOwnFile
  .for> .OutImplemented

  Self .Inherits
  .filterNil>
  .filter> .IsReferencedType
  .for> .OutImplemented

  Self .Implements
  .filterNil>
  .filter> .IsReferencedType
  .for> .OutImplemented
  
  Self .AddToArray?: g_ForwardedTypes DROP
  
  begin
   VAR l_NeedLn
   false >>> l_NeedLn
   Self .Dependencies
   .filterNil>
   .filter> .IsInjects
   .for> (
     IN aDep
    [ '%%InjectedBy ' aDep .Target .WordName ' ' Self .WordName ] .Out 
    true >>> l_NeedLn
   ) // .for>
   if l_NeedLn then
    OutLn
  end
  
  begin
   VAR l_NeedLn
   false >>> l_NeedLn
   Self .Implements
   .filterNil>
   .for> (
     IN aDep
    [ '%%ImplementedBy ' aDep .ReferencedTypeOriginal .WordName ' ' Self .WordName ] .Out 
    true >>> l_NeedLn
   ) // .for>
   if l_NeedLn then
    OutLn
  end
  
  begin
   VAR l_NeedLn
   false >>> l_NeedLn
   Self .Inherits
   .filterNil>
   .for> (
     IN aDep
    [ '%%InheritedBy ' aDep .ReferencedTypeOriginal .WordName ' ' Self .WordName ] .Out 
    true >>> l_NeedLn
   ) // .for>
   if l_NeedLn then
    OutLn
  end
  
  [ 'ME ' Self .WordName ] .Out
  Indented: (
   Self .IsNewSchoolElement ?
    ( [ 'MEPROP IsNewSchool ' 'true' ] .Out )
   Self .UID .NotIsNil ?
    ( [ 'MEPROP UID ' cQuote Self .UID cQuote ] .Out )
   Self .GUID .NotIsNil ?
    ( [ 'MEPROP GUID ' cQuote Self .GUID cQuote ] .Out )
   Self .Name .NotIsNil ?
    ( [ 'MEPROP Name ' cQuote Self .Name .FineString cQuote ] .Out )
   Self .FullName .NotIsNil ?
    ( [ 'MEPROP FullName ' cQuote Self .FullName .FineString cQuote ] .Out )
   Self .OriginalName .NotIsNil ?
    ( [ 'MEPROP OriginalName ' cQuote Self .OriginalName .FineString cQuote ] .Out )
   Self .IsSummoned ?
    ( [ 'UP IsSummoned ' 'true' ] .Out )
   Self .IsAutoElement ?
    ( [ 'UP IsAuto ' 'true' ] .Out )
   Self .IsSubRoot ?
    ( [ 'MEPROP IsSubRoot ' 'true' ] .Out )
   Self .MDAClass class_Unknown != ?
    ( [ 
       'MEPROP Class class_' 
       if ( Self .IsMethod ) then
       begin
        'Operation'
       end // ( Self .IsMethod )
       else
       begin
        Self .MDAClassString 
       end // ( Self .IsMethod )
      ] .Out )
   VAR l_Stereo   
   Self .Stereotype >>> l_Stereo
   l_Stereo .NotIsNil 
   AND ( l_Stereo .UPisTrue "unstereotyped" ! )
   ?
    ( [ 
       'MELINK Stereotype st_' 
       l_Stereo .Name ' ' '_' string:Replace
       RULES
        (
         ( l_Stereo .IsMeStub ! )
         AND ( l_Stereo .Stereotype .NotIsNil )
         AND ( l_Stereo .Stereotype .StereotypeInModel .IsStereotypeInModelKindOf: st_MDASubStereotype )
         AND ( Self .MDAClassString 'Class' ?!= )
         AND ( Self .MDAClassString 'Category' ?!= )
        ) 
         ( '::' Self .MDAClassString )
       ; // RULES
       ' ;' 
      ] .Out )
   Self .Kind kind_Unknown != ?
    ( [ 'MEPROP Kind kind_' Self .KindString ] .Out )
   Self .Documentation .NotIsNil ?
    ( [ '%SUMMARY ' cQuote Self .Documentation .FineString cQuote ' ;' ] .Out )
   Self .Visibility UnknownAccess != ?
    ( [ 'MEPROP Visibility ' Self .VisibilityString ] .Out )
   ( Self .MDAClass class_Parameter != ) AND
   ( Self .MDAClass class_Dependency != ) ?
    ( [ 'MEPROP Abstraction at_' Self .AbstractionString ] .Out )
   Self .LinkType lt_unknown != ?
    ( [ 'MEPROP LinkType lt_' Self .LinkTypeString ] .Out )
   Self .OpKind opkind_Normal != ?
    ( [ 'MEPROP OpKind opkind_' Self .OpKindString ] .Out )
   Self .Parent .NotIsNil 
   AND ( Self .MDAClass class_Parameter != )
   AND ( Self .Parent .IsProjectGroup ! )
   ?
    ( [ 'MELINK Parent ' Self .Parent .pas_script_Reference ' ;' ] .Out )
   Self .Target .NotIsNil ?
    ( [ 'MELINK Target ' Self .Target .pas_script_Reference ' ;' ] .Out )
   Self .TargetStereotype .NotIsNil ?
    ( [ 'MEPROP TargetStereotype ' cQuote Self .TargetStereotype cQuote ] .Out )
   Self .GetUP 'Value' .IsValueValid ?
    ( [ 'MEPROP Value ' Self .GetUP 'Value' .ValueToString ] .Out )
   Self .ValueType .NotIsNil ?
    ( [ 'MELINK ValueType ' Self .ValueType .pas_script_Reference ' ;' ] .Out )

   Self .Inherits .NotEmpty ?
   (
    [ 'MELIST Inherits' ] .Out
    [ '  Seq: ( ' Self .Inherits .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Inherits' ] .Out
   )

   Self .Implements .NotEmpty ?
   (
    [ 'MELIST Implements' ] .Out
    [ '  Seq: ( ' Self .Implements .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Implements' ] .Out
   )

   Self .CanRaise .NotEmpty ?
   (
    [ 'MELIST CanRaise' ] .Out
    [ '  Seq: ( ' Self .CanRaise .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // CanRaise' ] .Out
   )

   Self .CanRaiseInSet .NotEmpty ?
   (
    [ 'MELIST CanRaiseInSet' ] .Out
    [ '  Seq: ( ' Self .CanRaiseInSet .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // CanRaiseInSet' ] .Out
   )

   Self .Attributes .NotEmpty ?
   (
    [ 'MELIST Attributes' ] .Out
    [ '  Seq: ( ' Self .Attributes .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Attributes' ] .Out
   )

   Self .Operations .NotEmpty ?
   (
    [ 'MELIST Operations' ] .Out
    [ '  Seq: ( ' Self .Operations .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Operations' ] .Out
   )

   Self .Implemented .NotEmpty ?
   (
    [ 'MELIST Implemented' ] .Out
    [ '  Seq: ( ' Self .Implemented .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Implemented' ] .Out
   )

   Self .Overridden .NotEmpty ?
   (
    [ 'MELIST Overridden' ] .Out
    [ '  Seq: ( ' Self .Overridden .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Overridden' ] .Out
   )

   Self .Children .NotEmpty ?
   (
    [ 'MELIST Children' ] .Out
    [ '  Seq: ( ' Self .Children .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Children' ] .Out
   )
   
   Self .Constants .NotEmpty ?
   (
    [ 'MELIST Constants' ] .Out
    [ '  Seq: ( ' Self .Constants .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Constants' ] .Out
   )
   
   Self .Parameters .NotEmpty ?
   (
    [ 'MELIST Parameters' ] .Out
    [ '  Seq: ( ' Self .Parameters .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Parameters' ] .Out
   )

   Self .Dependencies .NotEmpty ?
   (
    [ 'MELIST Dependencies' ] .Out
    [ '  Seq: ( ' Self .Dependencies .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Dependencies' ] .Out
   )
   
   Self .Injected .NotEmpty ?
   (
    [ 'MELIST Injected' ] .Out
    [ '  Seq: ( ' Self .Injected .filterNil> .for> ( DUP .Parent .NameInModel .pas_script_ReferencePrim ' ' ) ')' ] .Out
    [ '; // Injected' ] .Out
   )
   
   Self .Zones .NotEmpty ?
   (
    [ 'MELIST Zones' ] .Out
    [ '  Seq: ( ' Self .Zones .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Zones' ] .Out
   )
   
   Self .Implementors .NotEmpty ?
   (
    [ 'MELIST Implementors' ] .Out
    [ '  Seq: ( ' Self .Implementors .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Implementors' ] .Out
   )
   
   Self .Depends .NotEmpty ?
   (
    [ 'MELIST Depends' ] .Out
    [ '  Seq: ( ' Self .Depends .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Depends' ] .Out
   )
   
   Self .Forwarded .NotEmpty ?
   (
    [ 'MELIST Forwarded' ] .Out
    [ '  Seq: ( ' Self .Forwarded .filterNil> .for> ( .pas_script_Reference ' ' ) ')' ] .Out
    [ '; // Forwarded' ] .Out
   )

   Self .DiagramsNames .NotEmpty ?
   (
    [ 'MESTRINGLIST DiagramsNames' ] .Out
    [ '  Seq: ( ' Self .DiagramsNames .filterNil> .for> ( .Name cQuote SWAP cQuote ' ' ) ')' ] .Out
    [ '; // DiagramsNames' ] .Out
   )
   
   Self .OutUPs
   
  ) // Indented:
  OutLn
  [ 'ENDME ' '// ' Self .WordName ' ' Self .NameInModel ] .Out
  OutLn
 ; // pas_script_GenerateDescription

 TF g_ForwardedTypes (
  [] >>> g_ForwardedTypes
  Self .pas_script_GenerateDescription
 ) // TF g_ForwardedTypes

; // ModelGeneration

elem_generator model.script

 CONST Ext '.model.script'

 BOOLEAN elem_func NeedOwnFilePrim
  RULES
   ( Self .IsAutoElement )
   // - это "автоматически выдуманый элемент"
    false
   ( Self .IsSubRoot )
    true
   DEFAULT
    false
  ; // RULES
  >>> Result
 ; // NeedOwnFilePrim

 BOOLEAN elem_func CanCopyToFinalFile
  true >>> Result
 ; // CanCopyToFinalFile

 BOOLEAN elem_func CanDeleteFinalFile
  RULES
   ( Self .MDAClass class_Category == )
    true
   ( Self .IsSimpleClass )
    true
   DEFAULT
    false 
  ; // RULES
  >>> Result
 ; // CanDeleteFinalFile

 BOOLEAN elem_func UseNewGenExcluded
  false >>> Result
 ; // UseNewGenExcluded
 
 STRING elem_func FinalFileNamePrim
  [
   ModelRoot
   if ( Self .LUID .IsNil ) then
    ( Self .Name )
   else
    ( Self .LUID )
   cModelScript
  ] strings:Cat >>> Result
 ; // FinalFileNamePrim
 
 BOOLEAN elem_func NewSchoolGenerator
  false >>> Result
 ; // NewSchoolGenerator
 
 Self .ModelGeneration

; // model.script
