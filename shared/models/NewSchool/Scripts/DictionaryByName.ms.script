PROGRAM DictionaryByName.ms.script

USES
 axiom_push.ms.dict
; 

USES
 DictionaryByName.ms.dict
;

USES
 ElementsRTTI.ms.dict
;

USES
 axiom:KeyValues
 axiom:WordBox
;

USES
 arrays.ms.dict
;

USES
 IsNil.ms.dict
;

USES
 CountIt.ms.dict
;

USES
 FirstElement.ms.dict
;

USES
 KeyValuesCreateAndDo.ms.dict
;

ARRAY FUNCTION ProcessDict
  IN aDictName

 [
  //aDictName sysutils:ExtractFileName >>> aDictName
  VAR l_Dict
  aDictName DictionaryByName >>> l_Dict
  
  VAR l_DictFileName
  l_Dict pop:DictionaryEx:FileName sysutils:ExtractFileName >>> l_DictFileName
  
  l_Dict pop:Dictionary:WordsIterator 
  .for> (
    IN aWord
   aWord .Dependencies
   .filter> ( .IsStereotype st_injects::Dependency )
   .for> (
     IN aDep
    KeyValuesCreate: (
      IN aMade
     aMade -> SourceFile := l_DictFileName
     aMade -> Source := ( aWord .UID )
     aMade -> Target := ( aDep .Target .UID )
    ) // KeyValuesCreate:
   ) // .for>
  ) // .for>
 ]
 >>> Result
; // ProcessDict

ARRAY VAR A
[ 
 @ ProcessDict 
 '*.pas.ms.script' 
 VAR l_Dir
 thisDictionary pop:DictionaryEx:FileName sysutils:ExtractFilePath >>> l_Dir
 if ( l_Dir IsNil ) then
 begin
  sysutils:GetCurrentDir >>> l_Dir
 end // ( l_Dir IsNil )
 //l_Dir .
 l_Dir
 ProcessFilesWithMask
] >>> A

ARRAY VAR B
[] >>> B

A .for> (
 .map> pop:WordBox:Boxed
 .for> (
   IN aRec
  VAR l_Rec
  B
  .map> pop:WordBox:Boxed
  .filter> (
    IN anItem
   anItem -> Target aRec -> Target ==
  )
  .FirstElement >>> l_Rec
  
  : MakePair
   KeyValuesCreate: (
     IN aPair
    aPair -> SourceFile := ( aRec -> SourceFile )
    aPair -> Source := ( aRec -> Source )
   ) // KeyValuesCreate:
  ; // MakePair
  
  if ( l_Rec .NotIsNil ) then
  begin
   MakePair .AddToArray: ( l_Rec -> Sources )
  end // ( l_Rec .NotIsNil )
  else
  begin
   KeyValuesCreate: (
     IN aMade
    aMade -> Target := ( aRec -> Target )
    aMade -> Sources := [ MakePair ]
   ) .AddToArray: B
  end // ( l_Rec .NotIsNil )
 ) // .for>
) // .for>

B 
.map> pop:WordBox:Boxed
.for> (
   IN aRec
 FILE VAR l_Out
 aRec -> Target '.pas.ms.script.inj' Cat File:OpenWrite >>> l_Out
 TRY
  'Seq: (' l_Out File:WriteWStrLn
  aRec -> Sources
  .map> pop:WordBox:Boxed
  .map> (
    IN aRec
   [ 
    'WL' ' '
    '''' aRec -> Source ''''
    ' '
    '''' aRec -> SourceFile '.pas.ms.script' '''' 
   ] strings:Cat
  ) // .map>
  .for> (
   l_Out File:WriteWStrLn
  ) // .for>
  ')' l_Out File:WriteWStrLn
 FINALLY
  nil >>> l_Out
 END
) // .for>

B 
.map> pop:WordBox:Boxed
.for> (
   IN aRec
 [ 'Target:' aRec -> Target ] .
 aRec -> Sources
 .map> pop:WordBox:Boxed
 .map> (
   IN aRec
  [ 
   'SourceFile: ' aRec -> SourceFile 
   'Source:' aRec -> Source
  ] 
 ) // .map>
 .
) // .for>