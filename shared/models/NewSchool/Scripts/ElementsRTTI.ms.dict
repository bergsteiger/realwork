UNIT ElementsRTTI.ms.dict

USES 
 types.ms.dict
 axiom_push.ms.dict
 core.ms.dict
 NoStrangeSymbols.ms.dict
 WordsRTTI.ms.dict
;

USES
 CompileTimeVar.ms.dict
;

CONST [nil] nil
%REMARK 'Пустой итератор.'
CONST [empty] nil
//ARRAY CompileTime-VAR [empty] []
%REMARK 'Пустой итератор'

STRING ENGINE_WORD INTERFACE TYPE ModelElement
 %REMARK 'Элемент модели'
 
BOOLEAN FUNCTION .IsWord
 IN aValue
 ( aValue IsObj ) AND ( aValue IS class::TtfwWord ) >>> Result
; // .IsWord

BOOLEAN FUNCTION .IsSequence
 IN aValue
 ( aValue .IsWord ) AND ( aValue IS class::TkwBeginLikeCompiledCode ) >>> Result
; // .IsSequence

USES
 ref.ms.dict
;

EXPORTS
 ref.ms.dict

MACRO elem_func
 Literal IN aName
 %SUMMARY 'Функция на элементе модели' ;
 aName |N this.method.addr nil 'ModelElement' do_word_func
; // elem_func

WordAlias elem_func_with_side_effects elem_func

BOOLEAN elem_func True
 %SUMMARY 'Функтор определяющий, что все значения подходят.' ;
 true >>> Result
; // True

PROCEDURE do_elem_proc_prim
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 STRING IN aType
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 Ctx:ClearTypeInfo
 if ( aType IsNil ! ) then
 begin
  aType Ctx:Parser:PushSymbol
 end // ( aType IsNil ! )
 aName aSelf aModifier 'ModelElement' do_word_func
; // do_elem_proc_prim

PROCEDURE do_elem_proc
 STRING IN aName
 ENGINE_WORD IN aSelf
 ENGINE_WORD IN aModifier
 %SUMMARY 'Реализация elem_proc и elem_generator' ;
 aName aSelf aModifier 'VOID' do_elem_proc_prim
; // do_elem_proc

MACRO elem:
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N this.method.addr nil '' do_elem_proc_prim
; // elem:

MACRO elem_proc
 Literal IN aName
 %SUMMARY 'Процедура на элементе модели' ;
 aName |N this.method.addr nil do_elem_proc
; // elem_proc

MACRO elem_generator
 Literal IN aName
 %SUMMARY 'Генератор содержимого элемента' ;
 aName |N this.method.addr nil do_elem_proc
; // elem_generator

MACRO elem_iterator
 [ 'ARRAY elem_func' ] Ctx:Parser:PushArray
 @SELF Ctx:SetWordProducerForCompiledClass
; // elem_iterator

ARRAY FUNCTION .SequenceCode.It
  TkwBeginLikeCompiledCode IN aCode
 %SUMMARY 'Преобразует список компилированных слов в итератор вызывающий каждое из этих слов' ;
 aCode CodeIterator .map> DO >>> Result
; // .SequenceCode.It

ARRAY FUNCTION Seq:
  ^ IN aCode
 %SUMMARY 'Преобразует список компилированных слов в итератор вызывающий каждое из этих слов' ;
 aCode CodeIterator .map> DO >>> Result
; // Seq:

USES
 axiom:WordBox
;

STRING elem_func WordName
 RULES
  ( Self IsIntf )
   ( Self pop:WordBox:Boxed pop:Word:Name )
  DEFAULT
   ( Self pop:Word:Name ) 
 ; // RULES
 >>> Result  
 if (
     ( Result IsNil ) 
     OR ( Result 'KeyValues:Create' == )
    ) then
 begin
  if ( Self IsIntf ) then
  begin
   Self pop:WordBox:Boxed >>> Self
  end // ( Self IsIntf )
  
  VAR l_Field
  Self %% 'UID' >>> l_Field
  if ( l_Field IsNil ) then
  begin
   Self %% 'Name' >>> l_Field
  end // ( l_Field IsNil )
  l_Field IsNil ?FAIL 'Не удалось получить UID'
  'ME_' l_Field DO Cat >>> Result
 end // ( Result IsNil )
; // WordName

: DoCache
  ModelElement IN aCacheWhere
  STRING IN aKey
  IN aDefault
  ^ IN aLambda
  
 if ( aCacheWhere IsNil ) then
 begin
  aLambda DO
 end // aCacheWhere IsNil
 else
 if ( aCacheWhere IsString ) then
 begin
  //ERROR [ aCacheWhere ':' aKey ]
  //[ aCacheWhere ':' aKey ] strings:Cat Msg
  aLambda DO
 end // aCacheWhere IsString
 else
/*(* 
 if ( aCacheWhere IsIntf ) then
 begin
  aLambda DO
 end // aCacheWhere IsIntf
 else
*)*/ 
 begin 
  ModelElement VAR l_CacheWhere
  VAR l_IsIntf
  false >>> l_IsIntf
  if ( aCacheWhere IsIntf ) then
  begin
   aCacheWhere pop:WordBox:Boxed >>> l_CacheWhere
   true >>> l_IsIntf
  end // ( aCacheWhere IsIntf )
  else
  begin
   aCacheWhere >>> l_CacheWhere
  end // ( aCacheWhere IsIntf )
  
  'cache:' aKey Cat >>> aKey
  VAR l_FieldVar
  l_CacheWhere %% aKey >>> l_FieldVar
 
  if ( l_FieldVar NotValid ) then    
  begin
   TRY
    aLambda DO
   EXCEPT
    [ 'Ошибка вызова: ' current:exception:Message ' : ' aKey ' на ' l_CacheWhere .WordName ] strings:Cat .
    aDefault
   END
   
   if l_IsIntf then
   begin
    if ( DUP IsIntf ! ) then
    begin
     false >>> l_IsIntf
    end // ( DUP IsIntf ! )
   end // l_IsIntf
   
   if ( l_IsIntf ! ) then
   begin
    VAR l_NewVar
    aKey false l_CacheWhere pop:NewWordDefinitor:CheckVar >>> l_NewVar
    @SELF l_NewVar pop:Word:SetProducer
    l_NewVar pop:Word:SetValue
    l_NewVar DO
   end // ( l_IsIntf ! )
  end // ( l_FieldVar NotValid )
  else 
  begin
   l_FieldVar DO
  end // ( l_FieldVar NotValid )
 end // aCacheWhere IsNil
; // DoCache

: CacheWord
  ModelElement IN aCacheWhere
  TtfwWord IN aWord
  ^ IN aLambda
 aCacheWhere aWord .WordName nil DoCache ( aLambda DO )
; // CacheWord

MACRO Cache
 axiom:PushSymbol @SELF
 axiom:PushSymbol CacheWord
; // Cache

MACRO CacheMethod
 'Self' Ctx:Parser:PushSymbol
 axiom:PushSymbol @SELF
 axiom:PushSymbol CacheWord
; // CacheMethod

WordAlias Cached: CacheMethod

ANY elem_func ElemMemberPrim
  STRING IN aMemberName
  IN aDefaultValue
  
 TtfwWord VAR l_FieldVar
 
 Self %% aMemberName >>> l_FieldVar
 
 if ( l_FieldVar NotValid ) then
 begin
  Self %% 'Original' >>> l_FieldVar
  if ( l_FieldVar NotValid ) then
  begin
   aDefaultValue >>> Result
  end // l_FieldVar NotValid
  else
  begin
   TtfwWord VAR l_Original
   l_FieldVar DO >>> l_Original
   if ( l_Original IsNil ) then
   begin
    aDefaultValue >>> Result
   end // l_Original IsNil
   else
   begin
    l_Original aMemberName aDefaultValue call.me >>> Result
   end // l_Original IsNil
  end // l_FieldVar NotValid
 end // l_FieldVar NotValid
 else
 begin
  l_FieldVar DO >>> Result
 end // l_FieldVar NotValid
; // ElemMemberPrim

ANY elem_func ElemMember
  STRING IN aMemberName
  IN aDefaultValue
  
 RULES 
  ( Self IsNil )
   aDefaultValue
  ( Self IsString )
   aDefaultValue
  ( Self IsIntf ) 
   ( Self pop:WordBox:Boxed aMemberName aDefaultValue .ElemMemberPrim )
  DEFAULT
   ( Self aMemberName aDefaultValue .ElemMemberPrim )
 ; // RULES
 >>> Result
; // ElemMember

elem_iterator ElemList
  STRING IN aMemberName
 Self aMemberName [nil] /*[empty]*/ DoCache
 (
  Self aMemberName [nil] /*[empty]*/ .ElemMember 
 )
 >>> Result 
; // ElemList

STRING elem_func ElemString
  STRING IN aMemberName
 Self aMemberName '' DoCache
 (
  Self aMemberName '' .ElemMember 
 ) 
 >>> Result 
; // ElemString

ModelElement elem_func ElemWord
  STRING IN aMemberName
 //Self aMemberName nil DoCache
 (
  Self aMemberName nil .ElemMember 
 ) 
 >>> Result 
; // ElemWord

elem_iterator Children
 Self 'Children' .ElemList >>> Result
; // Children

elem_iterator Constants
 Self 'Constants' .ElemList >>> Result
; // Constants

elem_iterator Dependencies
 Self 'Dependencies' .ElemList >>> Result
; // Dependencies

elem_iterator Depends
 Self 'Depends' .ElemList >>> Result
; // Depends

elem_iterator Injected
 Self 'Injected' .ElemList >>> Result
; // Injected

elem_iterator Zones
 Self 'Zones' .ElemList >>> Result
; // Zones

elem_iterator Implementors
 Self 'Implementors' .ElemList >>> Result
; // Implementors

elem_iterator Forwarded
 Self 'Forwarded' .ElemList >>> Result
; // Forwarded

elem_iterator Attributes
 Self 'Attributes' .ElemList >>> Result
; // Attributes

elem_iterator Parameters
 Self 'Parameters' .ElemList >>> Result
; // Parameters

elem_iterator Operations
 Self 'Operations' .ElemList >>> Result
; // Operations

elem_iterator Overridden
 Self 'Overridden' .ElemList >>> Result
; // Overridden

elem_iterator Implemented
 Self 'Implemented' .ElemList >>> Result
; // Implemented

elem_iterator Inherits
 Self 'Inherits' .ElemList >>> Result
; // Inherits

elem_iterator Implements
 Self 'Implements' .ElemList >>> Result
; // Implements

elem_iterator CanRaise
 Self 'CanRaise' .ElemList >>> Result
; // CanRaise

elem_iterator CanRaiseInSet
 Self 'CanRaiseInSet' .ElemList >>> Result
; // CanRaiseInSet

STRING elem_func Name
 if ( Self IsString ) then
 begin
  Self >>> Result
 end // Self IsString
 else
 begin
  Self 'Name' .ElemString >>> Result
 end // Self IsString
; // Name

STRING elem_func Documentation
 Self '%SUM' .ElemString >>> Result
; // Documentation

ModelElement elem_func Target
 Self 'Target' .ElemWord >>> Result
; // Target

ModelElement elem_func ValueType
 Self 'ValueType' .ElemWord >>> Result
; // ValueType

ANY elem_func GetUP
  Literal IN aName
  
 Self aName |N '' .ElemMember >>> Result 
; // GetUP

BOOLEAN elem_func UPisTrue
  Literal IN aName
  
 Self aName |N false .ElemMember true ?== >>> Result  
; // UPisTrue

ModelElement STRING elem_func Stereotype
 Self 'Stereotype' .ElemWord >>> Result
; // Stereotype

BOOLEAN elem_func IsStereotype
  ^ IN aStereo
  
 BOOLEAN FUNCTION IsStereoKindOf
   ModelElement IN anOurStereo
   ModelElement IN anOtherStereo
  anOurStereo 
  'isA:' anOtherStereo .WordName Cat 
  false
  DoCache (
   BOOLEAN VAR l_Is
   anOurStereo anOtherStereo ?== >>> l_Is
   if ( l_Is ! ) then
   begin
    anOurStereo .Name anOtherStereo .Name ?== >>> l_Is
   end // l_Is !
   if ( l_Is ! ) then
   begin
    anOurStereo .Inherited.Words 
    .trunc> ( DROP l_Is ! ) 
    .for> (
     ModelElement IN anAncestor
     if ( anAncestor anOtherStereo call.me ) then
     begin
      true >>> l_Is
     end
    ) 
   end // l_Is !
   l_Is
  ) >>> Result
 ; // IsStereoKindOf

 ModelElement VAR l_OurStereo
 Self .Stereotype >>> l_OurStereo
 
 if ( l_OurStereo IsNil ) then
 begin
  false >>> Result
 end // l_OurStereo IsNil
 else
 begin
  ModelElement VAR l_Stereo
  aStereo DO >>> l_Stereo
  l_OurStereo l_Stereo IsStereoKindOf >>> Result
 end // // l_OurStereo IsNil
 
; // IsStereotype

USES
 RoseModel.ms.dict
;  

EXPORTS
 RoseModel.ms.dict
 
BOOLEAN elem_func IsSummoned
 Self 'IsSummoned' false .ElemMember >>> Result
; // IsSummoned

INTEGER elem_func Visibility
 Self 'Visibility' UnknownAccess /*PublicAccess*/ .ElemMember >>> Result
; // Visibility

INTEGER elem_func MDAClass
 Self 'Class' class_Unknown .ElemMember >>> Result
; // MDAClass

INTEGER elem_func LinkType
 Self 'LinkType' lt_unknown .ElemMember >>> Result
; // LinkType

INTEGER elem_func Abstraction
 Self 'Abstraction' /*at_unknown*/ at_final .ElemMember >>> Result
; // Abstraction

STRING elem_func GUID
 Self 'GUID' '' .ElemMember >>> Result
; // GUID

STRING elem_func UID
 Self 'UID' '' .ElemMember >>> Result
; // UID

INTEGER elem_func OpKind
 Self 'OpKind' opkind_Normal .ElemMember >>> Result
; // OpKind

ModelElement elem_func Parent
 Self 'Parent' .ElemWord >>> Result
; // Parent

ModelElement elem_func SpelledFor
 Self 'SpelledFor' .ElemWord >>> Result
; // SpelledFor

ModelElement elem_func Speller
 Self 'Speller' .ElemWord >>> Result
; // Speller

ModelElement elem_func Facet
 Self 'Facet' .ElemWord >>> Result
; // Facet

ModelElement elem_func MixIn
 Self 'Mixin' .ElemWord >>> Result
; // MixIn

ModelElement elem_func Action
 Self 'Action' .ElemWord >>> Result
; // Action

ModelElement elem_func Stub
 Self 'Stub' .ElemWord >>> Result
; // Stub

ModelElement elem_func Implementor
 Self 'Implementor' .ElemWord >>> Result
; // Implementor

STRING elem_func UIDEx
 Cached:
 (
  VAR l_UID
  Self .UID >>> l_UID
  RULES
   ( l_UID IsNil )
    (
     VAR l_Name
     Self .Name >>> l_Name 
     RULES
      ( l_Name IsNil )
       ( Self .WordName )
      DEFAULT
       ( l_Name '_' Self .WordName Cat Cat )
     ; // RULES
    )
   DEFAULT
    l_UID
  ; // RULES
 )
 >>> Result  
; // UIDEx 

BOOLEAN FUNCTION .IsValueValid
  IN aValue
 RULES
  ( aValue IsInt )
   true
  ( aValue IsBool )
   true
  ( aValue IsNil )
   false
  DEFAULT
   true
 ; // RULES
 >>> Result
; // .IsValueValid

STRING FUNCTION ValueToKey
  ANY IN aValue
 RULES
  //( aValue .IsValueValid ! )
  // ''
  ( aValue IsString )
   aValue
  ( aValue IsArray )
   ( 
    aValue 
    .map> call.me
    '|'
    strings:CatSep
   )
  ( aValue IsBool )
   ( aValue ToPrintable )
  ( aValue IsInt )
   ( aValue ToPrintable )  
  ( aValue IsIntf )
   ( aValue pop:WordBox:Boxed .UIDEx )
   //ERROR 'Невозможно построить ключ для интерфейса'
  ( aValue Is class::TkwCompiledWord )
   ( aValue .UIDEx )
  ( aValue Is class::TtfwWord )
   ( aValue .WordName )
  ( aValue IsObj )
   ERROR 'Невозможно построить ключ для абстрактного объекта'
  ( aValue IsNil )
   ''   
  DEFAULT
   ( aValue ToPrintable )
 ; // RULES
 >>> Result
; // ValueToKey

: CacheWordEx
  ANY IN aKey
  ModelElement IN aCacheWhere
  TtfwWord IN aWord
  ^ IN aLambda
 aCacheWhere 
 aKey ValueToKey aWord .WordName Cat 
 nil DoCache ( aLambda DO )
; // CacheWordEx

MACRO :Cached:
 'Self' Ctx:Parser:PushSymbol
 axiom:PushSymbol @SELF
 axiom:PushSymbol CacheWordEx
; // :Cached:

USES
 LoadOnDemand.ms.dict
;

EXPORTS
 LoadOnDemand.ms.dict
 
USES
 MDProcess_CoreTemplates.tpi.script
;

EXPORTS
 MDProcess_CoreTemplates.tpi.script
 
USES
 MDProcess_Templates.tpi.script
;

EXPORTS
 MDProcess_Templates.tpi.script
 
USES
 MDProcess_ForDelphi.tpi.script
;

EXPORTS
 MDProcess_ForDelphi.tpi.script
 
USES
 MDProcess_ForF1.tpi.script
;

EXPORTS
 MDProcess_ForF1.tpi.script 
 
: st_in
 CONST Name 'in'
 @SELF
; // st_in

: st_inout
 CONST Name 'inout'
 @SELF
; // st_inout

: st_out
 CONST Name 'out'
 @SELF
; // st_out

: st_const
 CONST Name 'const'
 @SELF
; // st_const

: st_noconst
 CONST Name 'noconst'
 @SELF
; // st_noconst

: st_NodeType_
 CONST Name 'NodeType_'
 @SELF
; // st_NodeType_
