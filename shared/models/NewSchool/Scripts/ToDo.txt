9. Убить Array:Count.
10. Убить Array:Clear.
11. Это надо переделать на итератор:
PROCEDURE "Добавить документы" IN anID
 	INTEGER VAR l_Loop
	0 >>> l_Loop
	anID Array:Count раз (
	@ ( "Добавить ID" ) MODAL ( "Заполнить ID {( l_Loop anID [i] )}" )
	++! l_Loop
	)
;
12. Заменить Iterate на .for>
13. Сделать Array:IsEmptyStrict (certainly) чтобы не делать лишних View.
14. Сделать вывод занимаемой мамяти в лог. Для скриптов.
15. Перевернуть USES в ProjectUses - anItem array:AddTo l_ProjectUses - перенести ПОСЛЕ RULES.
17. Распространять от родителя (MainAncestorThatNotMixIn) IfDef и IfNDef на наследующийся класс.
18. Переделать на итератор:
STRING elem_func IfDefStr
 Cached:
 (
  Self .GetUP "ifdef" >>> Result
  
  VAR l_Parent
  Self .Parent >>> l_Parent
  if ( l_Parent IsNil ! ) then
  begin
   VAR l_ParentIfDefStr
   l_Parent call.me >>> l_ParentIfDefStr
   if ( l_ParentIfDefStr IsNil ! ) then
   begin
    if ( Result IsNil ) then
    begin
     l_ParentIfDefStr >>> Result
    end // ( Result IsNil )
    else
    begin
     l_ParentIfDefStr ',' Result Cat Cat >>> Result
    end // ( Result IsNil )
   end // ( l_ParentIfDefStr IsNil ! )
  end // ( l_Parent IsNil ! )
  Result RemoveDuplicatedIfDef
 )
 >>> Result 
; // IfDefStr
- чобы как раз пункт 17 сделать.
19. Вообще - обобщить IfDefStr и IfNDefStr.
23. Возможно копирование Dependencies через array:Copy увеличит производительность.
24. Возможно копирование Depends через array:Copy увеличит производительность.
28. Возможно копирование ConstantsEx через array:Copy увеличит производительность.
29. Возможно копирование AllOperationsForOverload через array:Copy увеличит производительность.
30. .Implements .filter> прошерстить насчёт кешируемости
31. .Inherits .filter> прошерстить насчёт кешируемости
33. Закешировать Self .DependsVCMGUI .filter> ( .GetUP "F1Like" false ?== )
39. VCMApplication перенести в новый генератор.
46. Убрать NOT_COMPLETED_ у dfm etc.
48. Заменить ! на .Not.
50. ( .NotInArray: - убрать скобки, скобки выводить в MACRO.
51. Перенести PROGRAM XXX из Generation в DailyTest Auto. Базовые тесты перенести к ежедневным базовым тестам.
52. .Predicate ! заменить на .Not: .Predicate - .IsMixIn ! => .Not: .IsMixIn. Учесть необходимость скобок.
53. Self .Abstraction at_abstract != заменить на Self .Abstraction .NEQ at_abstract - MACRO, а не <>
54. Self .Abstraction at_abstract == заменить на Self .Abstraction .EQ at_abstract - MACRO, а не =
57. nsQuestions AddDefaultChoice.
61. Генерировать коды операций как синглетоны.
64. Выделить Shared Delphi Lib For F1 и Shared Delphi Lib For Archi.
66. Определения предметной области - поставить UseNewGen. Проверив, что там нет форм.
67. Также поставить UseNewGen другим "базовым" пакетам.
68. Расставить NoSpell. Где возможно.
70. Удалить модель Intranet.
72. Удалить модели labs.
73. Заменить .filter> ( .IsEvdSchemaElement ! ) на .filter> .Not: .IsEvdSchemaElement , где .Not: - макрос. См. 48 и 52.
74. При генерации элемента запускать генерацию для всех входящих связей.
75. Сделать слово PROTOTYPE - аналог FORWARD, но с полной сигнатурой и копированием WordInfo и словаря.
76. Заменить .Target на mapToTarget.
79. Сделать array:CopyNoElementDuplicates. Прикрутить к IntfUses и ImplUses. Не забыть .map> .UnitProducer.
80. Сделать array:CopyNoTypeDuplicates.
81. Self SWAP .SomeMethodImplementsThisIterator ! и Self SWAP .ImplementMethod заменить на .SelfSwap: .ImplementMethod
87. Убрать Inline, но чуть позже.
91. dftDocument - почему-то долго генерируется.
92. CrossSegments и eeConst - из ca.cmd два раза в лог выводятся. А также - l3Variants.
94. Удалить TestModel.
95. Удалить TestMPHF.
97. TtfwContext убрать под UseNewGen.
98. Вычистить 'undefined' из ms.pas.script.
99. Вычистить ParamsCount и ParamsTypes для 0. Оно там уже считай вычислено.
 Вот тут:
    ( GarantModel::TtfwWord.GetAllParamsCount .UID IsUID ) // GetAllParamsCount
     Code:
       ( 
        [ 
         ' Result := '
         l_Op .Parameters 
         .filterOutParam>
         .CountIt
         l_Op .HasSelf ? ( 1 + )
         l_Op .IsVarWorker ? ( 1 + )
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
104. Не регистрировать типы в примесях, например EParameterNotExists. W:\quality\test\garant6x\AdapterTest\CoreObjects\atNamedParametersList.imp.pas
 А ещё лучше - перерисовать этот Exception в отдельный UtilityPack.
105. OperationFactory := TatOperationFactory.Create; - вообще-то бывают синглетоны.
107. Поставить TPersistent - register in scripts. И посмотреть, что получится.
108. Определить raises для keyword. И эти исключения тоже регистрировать. Например ListError для Array.
109. Изжить TtfwScriptEngineEx. А нужную аксиоматику типа USES etc привязать к TtfwScriptEngine.
110. Сделать IncludePrim (DoInclude, InclideDictionary). НЕ Immediate. Чтобы звать из блоков EXECUTE ([EXECUTE]). Чтобы съэмулировать ifdef.
141. Убрать Exports.script оставить только Exports.ms.dict.
142. VCMWordsPack поставить NeedsScript и перенести туда ANYUSERTYPE. А также:
  {$IfNDef NoVCM}
  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['vcm:History:DeleteBackItem'],
  [
   'WordAlias history:DeleteBackItem vcm:History:DeleteBackItem'
  ]);

  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['vcm:History:DeleteForwardItem'],
  [
   'WordAlias history:DeleteForwardItem vcm:History:DeleteForwardItem'
  ]);
143. SearchModuleWordsPack поставить needs script и перенести туда:
  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['моп::Поиск_Поиск_лекарственных_средств', 'Ok', 'history:DeleteBackItem'],
  [
   'PROCEDURE RunInpharmSearch OBJECT IN aProc',
   ' // - запускает поиск по КЗ Инфарма',
   ' моп::Поиск_Поиск_лекарственных_средств',
   ' aProc DO',
   ' Ok',
   ' OnTest',
   ' history:DeleteBackItem',
   ' // - удаляем предыдущий элемент истории (КЗ)',
   '; // RunInpharmSearch'

  ]);

  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['ППР_Prim'],
  [
   'PROCEDURE ППР',
   ' ППР_Prim',
   ' OnTest',
   '; // ППР'
  ]);

  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['ППС_Стандартная_Prim'],
  [
   'PROCEDURE "ППС Стандартная"',
   ' ППС_Стандартная_Prim',
   ' OnTest',
   '; // "ППС Стандартная"'
  ]);

  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['ППС_Преемственная_Prim'],
  [
   'PROCEDURE "ППС Преемственная"',
   ' ППС_Преемственная_Prim',
   ' OnTest',
   '; // "ППС Преемственная"'
  ]);

  CompileScriptToAxiomaticsIfDefined(theNewContext.rPrev^,
  ['ППР', 'Ok', 'history:DeleteBackItem', 'class::TevQueryCardEditor', 'focused:control:push'],
  [
   'PROCEDURE RunSearch OBJECT IN aProc',
   ' // - запускает поиск по КЗ ППР',
   ' vcm:Dispatcher:Lock',
   ' TRY',
   '  ППР',
   '  OBJECT VAR l_QC',
   '  focused:control:push >>> l_QC',
   '  l_QC IS class::TevQueryCardEditor',
   '   ?ASSURE ''Фокус не в КЗ''',
   '  aProc DO',
   '  Ok',
   '  OnTest',
   '  history:DeleteBackItem',
   '  // - удаляем предыдущий элемент истории (КЗ)',
   ' FINALLY',
   '  vcm:Dispatcher:Unlock',
   ' END',
   '; // RunSearch'
  ]);

148. extprop:prop_stereo и extprop:prop_name переделать на ссылку на свойство.
150. restrict form def:tribool=undefined
151. restrict form def - понять нельзя ли вообще это убрать. Скорее всего это с фабриками связано.
152. NeedsKeywordDoc - вычистить из шаблонов.
154. TtfwControlString - похоже уже не нужен.
155. put to dfm - убить.
157. Вывести AllControls из OwnControls.
158. Ini_FormFactory_ - перенести в новый генератор.
178. .filter> ( .IsLocalMethod ! ) и вообще .filter> ( .IsXXX ! ) заменить на .filter> .Not: .IsLocalMethod
179. .NotInArray: etc сделать так, чтобы не нужны были скобки.
190. fsList - поправить, чтобы различий при генерации не было.
195. Вывести комментарий // с именем слов после %%Inner.
203. .IsStereotype -> .IsStereotype:
208. Если в диаграммах есть uses/Uses, то делать диаграмму Uses. И вытаскивать туда ВСЕ Depends и Dependencies.
209. CallXXX([] заменить на CallXXX(
210. Сделать модификатор NotCached. Чтобы не кешировать "производные" значения. Типа FullText. Или CanOverride.
211. Не кешировать KeyValuesCreate: Ну или сделать NotCachedKeyValuesCreate:
212. Call заменить на CachedCall, а RawCall смапировать на Call.
214. WordAlias GarantModel::TvcmModuleContractImplementation ME_57A0BF7D02BD переделать на WL?
217.    VAR l_HasUses
   Self .DiagramsNames
   .filter> ( 'uses' SameText )
   .NotEmpty
   >>> l_HasUses
+ Depends
+ Dependencies
220. CanDeleteFinalFile в - GenerationFramework.ms.dict.
222. CanDeleteFinalFile - удалять и UC-файл тоже.
223. ReadUCFromFile в - GenerationFramework.ms.dict.
224. HasUses + Depends + Dependencies - делать диаграммы.
225. Сделать DiagramsAndViewsNotEmpty и использовать его в SaveDiagrams.
226. Можно делать LinkDataToView (для Lister'а например) только если HandleAllocated.
227. DoCurrentElementChangedEvent - тоже как-то надо проверять HandleAllocated.
228. В коде:
  if ( Self .IsTypedef ! ) then
  begin
   .join> ( Self .ImplementedAndOverridden .OperationsNeededElements )
  end // Self .IsTypedef !
- использовать что-то вроде .map> .ReferencedTypeOriginal.
233. Depends тоже превратить в ReferencedType.
234. Сделать MapSelfTo: чтобы можно было писать что-то вроде:
 BOOLEAN elem_func SomeFunc
  MapSelfTo: .ReferencedTypeOriginal
  (
   Cached:
   (
    ...
    Self .XXX
    // - тут Self уже означает Self .ReferencedTypeOriginal
    ...
   )
  )
  >>> Result
 ; // BOOLEAN elem_func SomeFunc
 
 Ну и "краткая запись":
 BOOLEAN elem_func SomeFunc
  MapSelfToReferencedTypeOriginal:
  (
   Cached:
   (
    ...
    Self .XXX
    // - тут Self уже означает Self .ReferencedTypeOriginal
    ...
   )
  )
  >>> Result
 ; // BOOLEAN elem_func SomeFunc
235. inj и impl выводить в поддиректорию.
236. Невалидные связи рисовать ПО-ДРУГОМУ. Например ДРУГИМ цветом. Ну или с "привычной" буквой (M).
239. Не забыть про Decorated и Referenced.
241. И msm:DeleteWordCachedValues. Подумать.
242. Работать с ImsmElementList. Все Array:Add заменить на ImsmElementList.Add. msm:AddChangedElement - туда же убрать. И msm:DeleteWordCachedValues.
244. Убрать ListContentChanged из модели.
245. Сделать подписку в ImsmElemengStringList.
249. -> заменить на SetElementVar.
251. Не кешировать f_SubElementName, там где есть : и ПРОБЕЛ.
253. TmsmLoadedWordsList сделать синглетоном.
254. Не давать AddElement если список стереотипов пустой.
255. Кнопки PgUp, PgDn обрабатывать в TmsmDrawingView. А также стрелки.
257. implements::Dependency - дублируются. "группа генераторов" и "указание что используется".
258. Для Not IsMeStub писать РЕАЛЬНЫЕ стереотипы через WL, а НЕ st_XXX. См. предыдущий пункт - 257.
260. Из NSImplemented удалять методы с совпадающими сигнатурами. Чтобы не морочиться с Exclude.
265. Копировать FactoryOnModule в MixIn.
266. Разрешить DeleteElement в Children.
269. NeededElementsFromInheritsOrImplements - мапировать на ReferencedTypeOriginal.
271. Учитывать Elements Prefix в ExtValueOrValue.
277. Пересортировывать msm:AddWordToIndex при смене имени элемента.
278. Удалять одноимённые свойства от интерфейсов в Implemented.
281. Раскладывать model.script по папкам проектов.
282. FirstElement переделать на Item.
285. Кешировать .?, точнее FindMemberRecur.
286. Учитывать Original в IsDeleted. Для OpKind <> Normal.
287. Сделать аналог .? но для ЛЮБОГО "сервиса". Типа:
 aWord aService .CallService ServiceMethod.
 - для Dependency Inversion.
288.