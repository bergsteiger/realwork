UNIT msm.ms.dict

USES
 core.ms.dict
;

USES
 axiom_push.ms.dict
;

USES
 ModelElementsDefinition.ms.dict
;

USES
 ElemMemberPrim.ms.dict
;

USES
 ElementsRTTI.ms.dict
;

USES
 GarantMetaModel.ms.dict
;

USES
 IsNil.ms.dict
;

USES
 arrays.ms.dict
;

elem_iterator NullList
 [empty] >>> Result
; // NullList

WordAlias ._NullList .NullList

elem_iterator SelfList
 [ Self ] >>> Result
; // SelfList

WordAlias ._SelfList .SelfList

elem_iterator Inner
 Cached:
 (
  Self .Children
  .join> ( Self .Constants )
  .join> ( Self .Attributes )
  .join> ( Self .Operations )
  .join> ( Self .Dependencies )
  .join> ( Self .Parameters )
 ) 
 >>> Result
; // Inner

USES
 FirstElement.ms.dict
;

STRING elem_func UpText
 Self .NameInModel >>> Result
 if ( Result .IsNil ) then
 begin
  Self .WordName >>> Result
 end // ( Result .IsNil )
 if ( Self .IsUP ) then
 begin
  VAR l_Value
  [ Self DO ]
  .map> (
    IN aValue
   RULES 
    ( aValue IsObj )
     ( aValue .Name )
    DEFAULT
     ( aValue ToPrintable )
   ; // RULES 
  ) 
  .FirstElement >>> l_Value
  [ Result ' = ' l_Value ] strings:Cat >>> Result 
 end // ( Self .IsUP )
; // UpText

STRING elem_func LinkName
 '' >>> Result
 VAR l_St
 Self .Stereotype >>> l_St
 if (
     ( l_St .NotIsNil )
     AND ( l_St .NameInModel .NotIsNil )
    ) then
 begin
  [ '<<' l_St .NameInModel '::' string:Split DROP '>>' ] strings:Cat >>> Result
 end // ( l_St .NotIsNil )
 if ( Self .NameInModel .NotIsNil ) then
 begin
  [ Result Self .NameInModel ] ' ' strings:CatSep >>> Result
 end // ( Self .NameInModel .NotIsNil )
; // LinkName

ME ME_EmptyStereo
 MEPROP Name 'empty_stereo'
ENDME

STRING elem_func StereotypeName
 Cached:
 (
  VAR l_St
  Self .Stereotype >>> l_St
  RULES
   ( l_St ME_EmptyStereo ?== )
    ''
   (
      ( l_St .NotIsNil )
      AND ( l_St .NameInModel .NotIsNil )
   )
    begin
     [ '<<' l_St .NameInModel '>>' ] strings:Cat
    end // ( l_St .NotIsNil )
   DEFAULT 
    begin
     [ '[[' Self .MDAClassString ']]' ] strings:Cat
     // '<<default>>'
    end
  ; // RULES
 )
 >>> Result
; // StereotypeName

STRING elem_func NameNotEmpty
 Cached:
 (
  Self .NameInModel
  >>> Result
 
  if ( Result .IsNil ) then
  begin
   '(unnamed)' >>> Result
  end // ( Result .IsNil )
  Result
 )
 >>> Result
; // NameNotEmpty

STRING elem_func NameWithStereo
 Cached:
 (
  Self .NameNotEmpty >>> Result
 
  VAR l_St
  Self .StereotypeName >>> l_St
  if ( l_St .NotIsNil ) then
  begin
   [ l_St ' ' Result ] strings:Cat >>> Result
  end // ( l_St .NotIsNil )
  
  Result
 )
 >>> Result 
; // NameWithStereo

STRING elem_func ValueString
 '' >>> Result
 VAR l_Value
 Self .GetUP 'Value' >>> l_Value

 if ( l_Value .IsValueValid ) then
 begin
  l_Value ToPrintable >>> Result
 end // ( l_Value .IsValueValid )
; // ValueString

USES
 CountIt.ms.dict
;

ModelElement elem_func FirstOperation
 Cached:
 (
  Self .Operations
  .filter> ( .IsLocalMethod ! )
  .FirstElement
 )
 >>> Result
; // FirstOperation

elem_iterator MethodParameters
 Cached:
 (
  RULES
   ( Self .IsMethod )
    ( Self .FirstOperation .Parameters )
   ( Self .IsFunction )
    ( Self .FirstOperation .Parameters )
   DEFAULT
    ( Self .Parameters )
  ; // RULES
 )
 >>> Result
; // MethodParameters

ModelElement elem_func MethodTarget
 Cached:
 (
  RULES
   ( Self .IsMethod )
    ( Self .FirstOperation .Target )
   ( Self .IsFunction )
    ( Self .FirstOperation .Target )
   ( Self .IsViewLink )
    RULES
     ( Self .Target .IsNil )
      ( Self .To )
     DEFAULT
      ( Self .Target )
    ; // RULES
   DEFAULT
    ( Self .Target )
  ; // RULES
 ) 
 >>> Result
; // MethodTarget

STRING elem_func ParametersString
 '' >>> Result
 VAR l_P
 VAR l_Open
 VAR l_Close
 if ( Self .MDAClass class_Attribute == ) then
 begin
  Self .Attributes >>> l_P
  '[' >>> l_Open
  ']' >>> l_Close
 end // ( Self .MDAClass class_Attribute == )
 else
 begin
  Self .MethodParameters >>> l_P
  '(' >>> l_Open
  ')' >>> l_Close
 end // ( Self .MDAClass class_Attribute == )
 if ( l_P .NotEmpty ) then
 begin
  [
   VAR l_WasParam
   false >>> l_WasParam
   l_Open
   l_P .for> (
     IN aParam
    if l_WasParam then
     ', '
    VAR l_St
    aParam .Stereotype >>> l_St
    if ( l_St .NotIsNil ) then
    begin
     if ( l_St .NameInModel 'in' != ) then
     begin
      l_St .NameInModel ' '
     end // ( l_St .NameInModel 'in' != )
    end // ( l_St .NotIsNil )
    aParam .NameInModel
    VAR l_T
    aParam .Target >>> l_T
    VAR l_N
    if ( l_T .IsNil ) then
    begin
     'void' >>> l_N
    end // ( l_T .IsNil )
    else
    begin
     l_T .NameInModel >>> l_N
    end // ( l_T .IsNil )
    ': ' l_N
    VAR l_V
    aParam .ValueString >>> l_V
    if ( l_V .NotIsNil ) then
    begin
     ' = ' l_V
    end // ( l_V .NotIsNil )
    true >>> l_WasParam
   ) //l_P .for>
   l_Close
  ] strings:Cat >>> Result
 end // l_P .NotEmpty
; // ParametersString

STRING elem_func Signature
 Cached:
 (
  [ Self .NameNotEmpty Self .ParametersString ] strings:Cat >>> Result
  
  if ( Self .IsViewLink ) then
  begin
   if ( Self .From .NotIsNil ) then
   begin
    [ Result ' ' Self .From .NameInModel ] strings:Cat >>> Result
   end // ( Self .From .NotIsNil )
   if ( Self .To .NotIsNil ) then
   begin
    [ Result ' -> ' Self .To .NameInModel ] strings:Cat >>> Result
   end // ( Self .To .NotIsNil )
  end // ( Self .IsViewLink )
  else
  begin
   VAR l_T
   Self .MethodTarget >>> l_T
   
   if ( l_T .NotIsNil ) then
   begin
    VAR l_Name
    l_T .NameInModel >>> l_Name
    if ( l_Name .IsNil ) then
    begin
     'void' >>> l_Name
    end // ( l_Name .IsNil )
    [ Result ': ' l_Name ] strings:Cat >>> Result
   end // ( l_T .NotIsNil )
  end // ( Self .IsViewLink )
  
  Result
 )
 >>> Result
; // NameNotEmpty

STRING elem_func NameWithStereoAndTarget
 Cached:
 (
  [ Self .StereotypeName Self .Signature ] ' ' strings:CatSep
 )
 >>> Result 
; // NameWithStereoAndTarget

STRING elem_func NameWithStereoAndTargetAndValue
 Cached:
 (
  Self .NameWithStereoAndTarget
  >>> Result
 
  VAR l_Value
  Self .ValueString >>> l_Value
  if ( l_Value .NotIsNil ) then
  begin
   [ Result ' = ' l_Value  ] strings:Cat >>> Result
  end // ( l_Value .NotIsNil )
  Result
 )
 >>> Result 
; // NameWithStereoAndTargetAndValue

STRING elem_func NameWithStereoAndTargetAndValueAndDoc
 Self .NameWithStereoAndTargetAndValue >>> Result
 VAR l_D
 Self .Documentation >>> l_D
 if ( l_D .NotIsNil ) then
 begin
  [ Result #10 ' - ' l_D ] strings:Cat >>> Result
 end // ( l_D .NotIsNil )
; // NameWithStereoAndTargetAndValueAndDoc

STRING elem_func DocumentationNotEmpty
 Self .Documentation >>> Result
 if ( Result .IsNil ) then
 begin
  'Элемент не документирован' >>> Result
 end // ( Result .IsNil )
; // DocumentationNotEmpty

BOOLEAN elem_func IsFinished
 Self .GetUP "finished" false ?!=
 >>> Result
; // IsFinished

WordAlias .DefaultShortText .NameWithStereo
//WordAlias .DefaultText .Name
//WordAlias .DefaultSearchText .Name
WordAlias .DefaultSearchText .NameInModel
WordAlias .DefaultText .NameWithStereoAndTargetAndValue
WordAlias .DefaultFullText .DefaultText
WordAlias .DefaultTextAndDoc .NameWithStereoAndTargetAndValueAndDoc

USES
 CompileTimeVar.ms.dict
;

USES
 Log.ms.dict
;

BOOLEAN CompileTime-VAR g_NeedTerminate false

PROCEDURE TerminateLoadInner
 true >>> g_NeedTerminate
 Log: 'Terminate Request'
; // TerminateLoadInner

FORWARD .MainDiagram

elem_proc LoadChildInfo
 if ( g_NeedTerminate ! ) then
 begin
  Self .Stereotype DROP
  Self .NameWithStereo DROP
  Self .DefaultText DROP
  Self .Parent DROP
  Self .IsSummoned DROP
  Self .MainDiagram DROP
  
  Self .Depends DROP
  Self .Inherits DROP
  Self .Implements DROP
  
  //Self .Implemented DROP
  //Self .Overridden DROP
  //Self .Dependencies DROP
  //Self .UpList DROP
  //Self .DocumentationNotEmpty DROP
  Self .Inner DROP
 end // ( g_NeedTerminate ! )
; // LoadChildInfo

elem_proc LoadInnerPrim
 if ( g_NeedTerminate ! ) then
 begin
  Self .LoadChildInfo
  Self .Inner .for> (
   if g_NeedTerminate then
   begin
    DROP
   end // g_NeedTerminate
   else
   begin
    call.me
   end // g_NeedTerminate
  ) // Self .Inner .for>
 end // ( g_NeedTerminate ! )
; // LoadInnerPrim

BOOLEAN elem_func LoadLevel
 true >>> Result
 if ( g_NeedTerminate ! ) then
 begin
  Self .LoadChildInfo
/*{  Self .Inner .for> (
   if g_NeedTerminate then
   begin
    DROP
   end // g_NeedTerminate
   else
   begin
    .LoadChildInfo
   end // g_NeedTerminate
  ) // Self .Inner .for>}*/
 end // ( g_NeedTerminate ! )
; // LoadLevel

BOOLEAN elem_func LoadInner
 Log: 'Loading'
 true >>> Result
 Self .LoadInnerPrim
 if g_NeedTerminate then
 begin
  Log: 'Terminated'
 end // g_NeedTerminate
 else
 begin
  Log: 'Loaded'
 end // g_NeedTerminate
; // LoadInner

USES
 axiom:TColor
;

INTEGER elem_func msm:View:ForeColor
 RULES
  ( Self .IsProject )
   TColor::clGreen
  ( Self .IsUnit )
   TColor::clGreen
  ( Self .IsExeTarget )
   TColor::clGreen
  ( Self .IsLibrary )
   TColor::clBlue
  ( Self .IsInterfaces )
   TColor::clNavy
  ( Self .IsStereotype st_Facet )
   TColor::clNavy
  ( Self .IsStereotype st_Interface )
   TColor::clNavy
  ( Self .IsMixIn )
   TColor::clFuchsia
   //TColor::clMoneyGreen
   //TColor::clLime
  ( Self .IsSimpleClass )
   TColor::clGreen
  ( Self .IsUtilityPack )
   TColor::clRed
  ( Self .IsMixInMirror )
   TColor::clAqua
  ( Self .IsEnum )
   TColor::clOlive
  ( Self .IsTypedef )
   TColor::clMedGray
  DEFAULT
   TColor::clDefault
 ; // RULES
 >>> Result
; // msm:View:ForeColor

USES
 WordsRTTI.ms.dict
;

INTEGER elem_func StereotypeBackColor
 Cached:
 (
  VAR l_Color
  Self .StereotypeInModel .GetUP "visualization bg color" >>> l_Color
  RULES
   ( l_Color IsInt )
    l_Color
   DEFAULT
    begin
     TColor::clDefault >>> l_Color
     Self .StereotypeAncestors
     .for> (
       IN anAncestor
      VAR l_AncestorColor 
      anAncestor call.me >>> l_AncestorColor
      RULES
       (
        ( l_AncestorColor IsInt )
        AND ( l_AncestorColor TColor::clDefault != )
       ) 
        ( 
         l_AncestorColor >>> l_Color 
         BREAK-ITERATOR
        )
      ; // RULES
     ) // Self .Inherited.Words .for>
     l_Color
    end // DEFAULT
  ; // RULES
 )
 >>> Result
; // StereotypeBackColor
 
INTEGER elem_func msm:View:BackColor
 RULES
  ( Self .Parent .Viewed Self .Viewed .Parent ?!= )
   TColor::clWhite
  DEFAULT
   begin
    VAR l_Color
    Self .Stereotype .StereotypeInModel .StereotypeBackColor >>> l_Color
    RULES
     ( l_Color IsInt )
      RULES
       ( l_Color TColor::clDefault == )
        ( Self .msm:View:ForeColor )
       DEFAULT
        l_Color
      ; // RULES
     DEFAULT 
      ( Self .msm:View:ForeColor )
    ; // RULES
   end // DEFAULT
 ; // RULES  
 >>> Result
; // msm:View:BackColor

INTEGER elem_func StereotypeTextColor
 Cached:
 (
  VAR l_Color
  Self .StereotypeInModel .GetUP "visualization f-font color" >>> l_Color
  RULES
   ( l_Color IsInt )
    l_Color
   DEFAULT
    begin
     TColor::clDefault >>> l_Color
     Self .StereotypeAncestors
     .for> (
       IN anAncestor
      VAR l_AncestorColor 
      anAncestor call.me >>> l_AncestorColor
      RULES
       (
        ( l_AncestorColor IsInt )
        AND ( l_AncestorColor TColor::clDefault != )
       ) 
        ( 
         l_AncestorColor >>> l_Color 
         BREAK-ITERATOR
        )
      ; // RULES
     ) // Self .Inherited.Words .for>
     l_Color
    end // DEFAULT
  ; // RULES
 )
 >>> Result
; // StereotypeTextColor
 
INTEGER elem_func msm:View:TextColor
 RULES
  ( Self .Parent .Viewed Self .Viewed .Parent ?!= )
   ( Self .Stereotype .StereotypeInModel .StereotypeTextColor )
   //TColor::clNavy
  DEFAULT
   TColor::clBlack
 ; // RULES
 >>> Result
; // msm:View:TextColor

STRING elem_func StereotypeLabelName
 Cached:
 (
  VAR l_Label
  Self .GetUP "personal label" >>> l_Label
  RULES
   ( l_Label .NotIsNil )
    l_Label
   DEFAULT
    begin
     '' >>> l_Label
     RULES
      ( Self IsString )
       ()
      DEFAULT
       begin
        Self .StereotypeAncestors
        .for> (
          IN anAncestor
         VAR l_AncestorLabel 
         anAncestor call.me >>> l_AncestorLabel
         RULES
          ( l_AncestorLabel .NotIsNil )
           ( 
            l_AncestorLabel >>> l_Label
            BREAK-ITERATOR
           )
         ; // RULES
        ) // .for>
       end // DEFAULT
     ; // RULES
     l_Label
    end // DEFAULT 
  ; // RULES  
 )
 >>> Result
; // StereotypeLabelName

STRING elem_func msm:View:LabelName
 VAR l_Label
 Self .Stereotype .StereotypeInModel .StereotypeLabelName >>> l_Label
 RULES
  ( l_Label .NotIsNil )
   l_Label
  ( Self .IsUseCase )
   'code_use_case'
  ( Self .MDAClass class_Operation == ) 
   'code_method'
  ( Self .MDAClass class_Attribute == ) 
   'code_attr'
  ( Self .MDAClass class_Parameter == ) 
   'code_param'
  ( Self .MDAClass class_Dependency == ) 
   'code_mda_dependency'
  ( Self .MDAClass class_Inherits == ) 
   'code_mda_dependency'
  ( Self .MDAClass class_Implements == ) 
   'code_mda_dependency'
  ( Self .MDAClass class_Depends == ) 
   'code_dep'
  DEFAULT 
   ''
 ; // RESULT  
 >>> Result
; // msm:View:LabelName

STRING elem_func msm:View:VisibilityLabel
 RULES
  ( Self .Visibility PublicAccess == )
   //'public'
   ''
  ( Self .Visibility PrivateAccess == )
   'private'
  ( Self .Visibility ProtectedAccess == )
   'protected'
  ( Self .Visibility ImplementationAccess == )
   'implemented'
  ( Self .Visibility PublishedAccess == )
   'published'
  DEFAULT
   'undefined'
 ; // RULES
 >>> Result
; // msm:View:VisibilityLabel

USES
 joinWithLambded.ms.dict
;

ARRAY FUNCTION array:CopyWithoutDuplicatedNames
  IN anArray
 RULES
  ( anArray .IsNil )
   [nil]
  DEFAULT 
   (
    VAR l_CopyNames
    [] >>> l_CopyNames
    VAR l_Copy
    [] >>> l_Copy
    VAR l_Empty
    true >>> l_Empty
    anArray 
    .filter> ( .Name .AddToArray?: l_CopyNames )
    .for> ( 
      IN anElement
     anElement .AddToArray: l_Copy
     false >>> l_Empty
    ) // anArray .for>
    RULES
     l_Empty
      [nil]
     DEFAULT
      l_Copy 
    ; // RULES
   ) 
 ; // RULES 
 >>> Result
; // array:CopyWithoutDuplicatedNames

elem_iterator StereotypeAllowedElements
 Cached:
 (
  RULES
   ( Self .IsNil )
    [empty]
   DEFAULT
    begin
     Self .Dependencies
     .filter> ( .IsStereotype st_include::Dependency )
     .map> .Target
     .join> (
      Self .Children
      .filter> (
        IN anElement
       RULES
        ( anElement .IsStereotype: st_MDAAttribute )
         true
        ( anElement .IsStereotype: st_MDAOperation )
         true
        ( anElement .IsStereotype: st_MDADependency )
         true
        DEFAULT
         false
       ; // RULES 
      ) // .filter>
     ) // .join>
     
     if ( Self .GetUP "inherite constraints" false ?!= ) then
     begin
      .joinWithLambded> 
      ( Self .StereotypeAncestors ) 
      call.me
     end // ( Self .GetUP "inherite constraints" false ?!= )
    end // DEFAULT
  ; // RULES
  array:CopyWithoutDuplicates
  array:CopyWithoutDuplicatedNames
 ) 
 >>> Result  
; // StereotypeAllowedElements

elem_iterator AllowedElements
 Self .Stereotype .StereotypeInModel 
 .StereotypeAllowedElements
 >>> Result
; // AllowedElements

elem_iterator CanOverride
 [empty]
 
 elem: CanOverrideFromAncestors
  .joinWithLambded> 
  (
   ( Self .Inherits )
   .join> ( Self .Implements )
  ) 
  ( 
    IN anItem
   anItem .Operations 
   .join> ( anItem .Attributes )
   .filter> (
     IN anOp
     RULES
      ( anOp .Abstraction at_abstract ?== )
       true
      ( anOp .Abstraction at_regular ?== )
       true
      DEFAULT
       false
     ; //RULES
   )
   //.join> 
   ( anItem call.me )
  )
 ; // CanOverrideFromAncestors
 
 Self .CanOverrideFromAncestors
 array:CopyWithoutDuplicates
 >>> Result
; // CanOverride

USES
 DictionaryByName.ms.dict
;

USES
 Out.ms.dict
;

STRING FUNCTION .LabelNameToImageFileName
  STRING IN Self
 Self >>> Result 
 if ( Result .NotIsNil ) then
 begin
  VAR l_Path
  thisDictionary pop:DictionaryEx:FileName sysutils:ExtractFilePath >>> l_Path
  [ l_Path 'images' ] cPathSep strings:CatSep >>> l_Path
  l_Path sysutils:DirectoryExists ?ASSURE [ 'Директория не существует: "' l_Path '"']
  [ [ l_Path Result ] cPathSep strings:CatSep '.gif' ] strings:Cat >>> Result
  //[ 'W:\MDProcess\MDAGenerator\other\images\' Result '.gif' ] strings:Cat >>> Result
 end // ( Result .NotIsNil )
; // .LabelNameToImageFileName

STRING elem_func msm:View:ImageFileName
 Self .msm:View:LabelName 
 .LabelNameToImageFileName
 >>> Result
; // msm:View:ImageFileName

STRING elem_func msm:View:StereotypeImageFileName
 Self .StereotypeLabelName
 .LabelNameToImageFileName
 >>> Result
; // msm:View:StereotypeImageFileName

BOOLEAN elem_func IsCategory
 Self .MDAClass class_Category ==
 >>> Result
; // IsCategory

BOOLEAN elem_func IsAttribute
 Self .MDAClass class_Attribute ==
 >>> Result
; // IsAttribute

BOOLEAN elem_func IsAbstract
 Self .Abstraction at_abstract ==
 >>> Result
; // IsAbstract

BOOLEAN elem_func IsFinal
 Self .Abstraction at_final ==
 >>> Result
; // IsFinal

USES
 axiom:TPenStyle
;

INTEGER elem_func msm:View:LinkLineStyle
 Cached:
 (
  RULES
   ( Self .IsAttribute )
    TPenStyle::psSolid
   ( Self .MDAClass class_Inherits ?== )
    TPenStyle::psSolid
   ( Self .MDAClass class_Implements ?== )
    TPenStyle::psDash
   DEFAULT
    TPenStyle::psDash
  ; // RULES  
 )
 >>> Result
; // msm:View:LinkLineStyle

INTEGER elem_func msm:View:LinkLineColor
 Cached:
 (
  RULES
   ( Self .IsAttribute )
    TColor::clBlack
   ( Self .MDAClass class_Inherits ?== )
    TColor::clBlack
   ( Self .MDAClass class_Implements ?== )
    TColor::clBlack
   DEFAULT
    TColor::clDefault
  ; // RULES  
 )
 >>> Result
; // msm:View:LinkLineColor

BOOLEAN elem_func msm:View:LinkArrowIsPolygon
 Cached:
 (
  RULES
   ( Self .IsAttribute )
    false
   ( Self .MDAClass class_Inherits ?== )
    true
   ( Self .MDAClass class_Implements ?== )
    true
   DEFAULT
    false
  ; // RULES  
 )
 >>> Result
; // msm:View:LinkArrowIsPolygon

USES
 LoadOnDemand.ms.dict
;

USES
 CutSuffix.ms.dict
;

USES
 CutPrefix.ms.dict
;

USES
 Diagrams.ms.dict
;

WordAlias .msm:View:X .X
WordAlias .msm:View:Y .Y
WordAlias .msm:View:Width .Width
WordAlias .msm:View:Height .Height

WordAlias .msm:View:From .From
WordAlias .msm:View:To .To

ModelElement elem_func DiagramByName
  STRING IN aName
 Self .msm:Diagrams 
 .filter> ( .Name aName SameText )
 .FirstElement
 >>> Result
; // DiagramByName

ModelElement elem_func DiagramByName:
  ^L IN aName
 Self aName |N .DiagramByName
 >>> Result
; // DiagramByName:

ModelElement elem_func MainDiagram
 Self .DiagramByName: main
 //Self 'main' .DiagramByName
 >>> Result
; // MainDiagram

BOOLEAN elem_func HasMainDiagram
 Self .MainDiagram .NotIsNil
 >>> Result
; // HasMainDiagram

ModelElement FUNCTION .WordByDictionaryPath
  IN aPath
 aPath DictionaryAndMainWordByName
 >>> Result // - возвращаем слово 
 DROP // - выкидываем словарь
; // .WordByDictionaryPath

USES
 CheckValue.ms.dict
;
 
: .CheckValueSafe
 if ( StackLevel > 0 ) then
  .CheckValue
; // .CheckValueSafe

USES
 DictFileName.ms.dict
;

USES
 WordIsVar.ms.dict
;

USES
 ModelRoot.ms.dict
;

USES
 GenerationFramework.ms.dict
;

elem_proc GenerateElement
 RULES
  (
   ( Self .IsSomeView )
   AND ( Self .Viewed Self ?!= )   
  ) 
    ( Self .Viewed call.me )
  ( Self .UID .IsNil ) then
    ( Self .Parent call.me )
  DEFAULT
   begin
    VAR l_DictFileName
    Self .DictFileName >>> l_DictFileName
    
    if ( l_DictFileName .IsNil ) then
    begin
     ERROR [ 'Не задано имя словаря для ' Self .Name ]
    end // ( l_DictFileName .IsNil )
    
    if ( l_DictFileName sysutils:ExtractFilePath .IsNil ) then
    begin
     [ ModelRoot .CheckDrive l_DictFileName ] cPathSep strings:CatSep >>> l_DictFileName
    end // ( l_DictFileName sysutils:ExtractFilePath .IsNil )
    
    VAR l_ListName 
    Self .Name >>> l_ListName
    l_ListName ' ' '_' string:Replace >>> l_ListName
    [ 'C:\Temp\' l_ListName '.list' ] strings:Cat >>> l_ListName
    //[ 'C:\Temp\' l_DictFileName sysutils:ExtractFileName '.list' ] strings:Cat >>> l_ListName
    l_ListName .ProcessTmpOut: (
     l_DictFileName .Out
    ) // l_ListName .ProcessTmpOut:
    l_ListName sysutils:FileExists ?ASSURE [ 'Файл не существует: "' l_ListName '"']
    VAR l_CmdFileName
    [ l_DictFileName sysutils:ExtractFilePath 'cal.cmd' ] strings:Cat >>> l_CmdFileName
    l_CmdFileName sysutils:FileExists ?ASSURE [ 'Файл не существует: "' l_CmdFileName '"']
    [ l_CmdFileName ' ' '-list:' l_ListName ' ' '-nomodel' ] strings:Cat WinExec
    //[ l_DictFileName sysutils:ExtractFilePath 'cal.cmd' ' ' l_DictFileName ' ' '-nomodel' ] strings:Cat WinExec
   end // ( Self .UID .IsNil )
 ; // RULES
; // GenerateElement

USES
 SetElementVar.ms.dict
;

USES
 ModelGeneration.ms.dict
;

USES
 DiagramGeneration.ms.dict
;

USES
 DiagramSaving.ms.dict
;

elem_proc SaveDiagrams
 Self @ .diagram.save.script .Save
; // SaveDiagrams

elem_proc SaveModel
 Self @ .model.script .Save
; // SaveModel

PROCEDURE .SaveElements
  ARRAY IN anElements
 ARRAY VAR l_SavedElements 
 [] >>> l_SavedElements
 anElements .for> (
   IN anElementToSave
  RULES
   ( anElementToSave .IsView )
    ( anElementToSave .Parent >>> anElementToSave )
   ( anElementToSave .IsViewLink )
    ( anElementToSave .Parent >>> anElementToSave )
  ; // RULES
  //if ( anElementToSave .AddToArray?: l_SavedElements ) then
  begin
   RULES
    ( anElementToSave .IsDiagram )
     begin
      if ( anElementToSave /*{.Viewed}*/ .AddToArray?: l_SavedElements ) then
       ( anElementToSave .Viewed .SaveDiagrams )
     end // ( anElementToSave .IsDiagram )
    DEFAULT
     begin
      if ( anElementToSave .AddToArray?: l_SavedElements ) then
       ( anElementToSave .SaveModel ) 
     end // DEFAULT
   ; // RULES
  end // ( anElementToSave .AddToArray?: l_SavedElements )
 ) // anElements .for>
; // .SaveElements

USES
 CreateGUID.ms.dict
;

USES
 LUID.ms.dict
;

USES
 axiom:msm
;

USES
 KeyValuesCreateAndDo.ms.dict
;

USES
 Predicates.ms.dict
;

USES
 MEPrefix.ms.dict
;

ModelElement elem_func msm:Diagram:AddView:
  ModelElement IN aView
  INTEGER IN anX
  INTEGER IN anY
  ^ IN aLambda
 nil >>> Result 
 VAR l_UID
 CreateMUID >>> l_UID
 VAR l_ViewName 
 [ MEPrefix l_UID ] strings:Cat >>> l_ViewName 
 
 VAR l_KeyWord
 l_ViewName Self pop:NewWordDefinitor:CheckWord >>> l_KeyWord
 if ( l_KeyWord pop:KeyWord:Word IsNil ) then
 begin
  KeyValuesCreateAndDo: (
    IN aMade
   @ MEVIEW aMade pop:Word:SetProducer 
   aMade l_KeyWord pop:KeyWord:SetWord 
   l_KeyWord aMade pop:Word:SetKey 
   aMade -> X := anX
   aMade -> Y := anY
   aMade -> Original := ( aView .Viewed )
   aMade -> Parent := Self
   aMade aLambda DO
   aMade Self .Views Array:Add
   aMade >>> Result
  ) // KeyValuesCreateAndDo:
 end // ( l_KeyWord pop:KeyWord:Word IsNil )
 else
 begin
  ERROR [ 'Слово ' l_ViewName ' уже есть' ]
 end // ( l_KeyWord pop:KeyWord:Word IsNil )
 Self msm:AddChangedElement
; // msm:Diagram:AddView:

ModelElement elem_func msm:Diagram:AddViewLink:
  ModelElement IN aFrom
  ModelElement IN aTo
  ^ IN aLambda
 nil >>> Result 
 VAR l_UID
 CreateMUID >>> l_UID
 VAR l_ViewName 
 [ MEPrefix l_UID ] strings:Cat >>> l_ViewName 
 
 VAR l_KeyWord
 l_ViewName Self pop:NewWordDefinitor:CheckWord >>> l_KeyWord
 if ( l_KeyWord pop:KeyWord:Word IsNil ) then
 begin
  KeyValuesCreateAndDo: (
    IN aMade
   @ MEVIEWLINK aMade pop:Word:SetProducer 
   aMade l_KeyWord pop:KeyWord:SetWord 
   l_KeyWord aMade pop:Word:SetKey 
   aMade -> From := aFrom
   aMade -> To := aTo
   //aMade -> Original := ( aView .Viewed )
   //aMade -> Parent := Self
   aMade aLambda DO
   aMade Self .Views Array:Add
   aMade >>> Result
  ) // KeyValuesCreateAndDo:
 end // ( l_KeyWord pop:KeyWord:Word IsNil )
 else
 begin
  ERROR [ 'Слово ' l_ViewName ' уже есть' ]
 end // ( l_KeyWord pop:KeyWord:Word IsNil )
 Self msm:AddChangedElement
; // msm:Diagram:AddViewLink:

USES
 IsSameModelElement.ms.dict
;

ModelElement elem_func msm:Diagram:PasteElement
  ModelElement IN aView
  INTEGER IN anX
  INTEGER IN anY
 nil >>> Result 
 RULES  
  ( aView .IsViewLink )
   ( ERROR [ 'Вставка View от связей пока не поддерживается' ] )
  ( Self .IsDiagram )
   begin
    Self aView anX anY .msm:Diagram:AddView: (
      IN aMade
    ) // Self aView anX anY .msm:Diagram:AddView:
    >>> Result
    Self .Views .for> (
      IN aFrom
     aFrom .Inherits 
     .filter> ( aView .IsSameModelElement )
     .for> ( 
       IN aTo
      Self aFrom Result .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Class := class_Inherits 
      ) DROP
     ) // .for>
     
     aView .Inherits 
     .filter> ( aFrom .IsSameModelElement )
     .for> ( 
       IN aTo
      Self Result aFrom .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Class := class_Inherits 
      ) DROP
     ) // .for>
     
     aFrom .Implements
     .filter> ( aView .IsSameModelElement )
     .for> ( 
       IN aTo
      Self aFrom Result .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Class := class_Implements
      ) DROP
     ) // .for>
     
     aView .Implements
     .filter> ( aFrom .IsSameModelElement )
     .for> ( 
       IN aTo
      Self Result aFrom .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Class := class_Implements
      ) DROP
     ) // .for>
     
     aFrom .Depends
     .filter> ( aView .IsSameModelElement )
     .for> ( 
       IN aTo
      Self aFrom Result .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Class := class_Depends
      ) DROP
     ) // .for>
     
     aView .Depends
     .filter> ( aFrom .IsSameModelElement )
     .for> ( 
       IN aTo
      Self Result aFrom .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Class := class_Depends
      ) DROP
     ) // .for>
     
     aFrom .Dependencies
     .join> ( aFrom .Attributes )
     .filter> ( .Target aView .IsSameModelElement )
     .for> ( 
       IN aDep
      Self aFrom Result .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Original := aDep 
      ) DROP
     ) // .for>
     
     aView .Dependencies
     .join> ( aView .Attributes )
     .filter> ( .Target aFrom .IsSameModelElement )
     .for> ( 
       IN aDep
      Self Result aFrom .msm:Diagram:AddViewLink: (
        IN aMade
       aMade -> Original := aDep 
      ) DROP
     ) // .for>
     
    ) // Self .Views .for>
   end // ( Self .IsDiagram )
  DEFAULT
   ( Self pop:Word:Producer pop:Word:Name Msg )
 ; // RULES  
; // msm:Diagram:PasteElement

USES
 DictName.ms.dict
;

USES
 DiagramExt.ms.dict
;

elem_proc AddDiagram
  STRING IN aDiagramName
 // - тут добавляем диаграмму
 RULES
  ( Self .IsSomeView )
   RULES
    ( Self .Viewed Self ?!= )
     ( Self .Viewed call.me )
    DEFAULT
     ( ERROR [ 'Некуда добавлять диаграмму.' ] )
   ; // RULES
  DEFAULT
   begin
    VAR l_DiagramsList
    Self .msm:Diagrams >>> l_DiagramsList
    VAR l_UID
    Self .LUID >>> l_UID
    VAR l_DiagramDict
    [ l_UID DiagramExt ] strings:Cat DictionaryEx:CheckNamedDictionary >>> l_DiagramDict
    VAR l_DiagramsName
    [ Self .WordName '_' 'diagrams' ] strings:Cat >>> l_DiagramsName
    VAR l_KeyWord
    l_DiagramsName l_DiagramDict pop:Dictionary:CheckWord >>> l_KeyWord
    VAR l_Diagrams
    nil >>> l_Diagrams
    if ( l_KeyWord pop:KeyWord:Word IsNil ) then
    begin
     KeyValuesCreateAndDo: (
       IN aDiagrams
      @ MEDIAGRAMS aDiagrams pop:Word:SetProducer 
      aDiagrams l_KeyWord pop:KeyWord:SetWord 
      l_KeyWord aDiagrams pop:Word:SetKey 
      aDiagrams >>> l_Diagrams
     ) // KeyValuesCreateAndDo:
    end // ( l_KeyWord pop:KeyWord:Word IsNil )
    else
    begin
     ERROR [ 'Слово ' l_DiagramsName ' уже есть' ]
    end // ( l_KeyWord pop:KeyWord:Word IsNil )
    
    begin
     VAR l_Name
     aDiagramName >>> l_Name
     VAR l_DiagramName
     [ Self .WordName '_' l_Name ] strings:Cat >>> l_DiagramName
     VAR l_KeyWord
     l_DiagramName l_Diagrams pop:NewWordDefinitor:CheckWord >>> l_KeyWord
     if ( l_KeyWord pop:KeyWord:Word IsNil ) then
     begin
      KeyValuesCreateAndDo: (
        IN aDiagram
       @ MEDIAGRAM aDiagram pop:Word:SetProducer 
       aDiagram l_KeyWord pop:KeyWord:SetWord 
       l_KeyWord aDiagram pop:Word:SetKey 
       aDiagram -> Name := l_Name
       aDiagram -> Original := Self
       aDiagram -> Views := []
       Self -> Diagrams := ( l_DiagramsList .join> [ aDiagram ] )
       aDiagram msm:AddChangedElement
       Self msm:DeleteWordCachedValues
      ) // KeyValuesCreateAndDo:
     end // ( l_KeyWord pop:KeyWord:Word IsNil )
     else
     begin
      ERROR [ 'Слово ' l_DiagramName ' уже есть' ]
     end // ( l_KeyWord pop:KeyWord:Word IsNil )
    end
   end // DEFAULT
 ; // RULES   
; // AddDiagram

elem_proc AddDiagrams
 Self 'main' .AddDiagram
; // AddDiagrams

elem_proc CheckMainDiagram
 if ( Self .HasMainDiagram ! ) then
 begin
  Self .AddDiagrams
  Self msm:DeleteWordCachedValues
  // - ещё у View надо сбрасывать иначе например красная рамка не рисуется
  Self .Viewed msm:DeleteWordCachedValues
 end // ( Self .HasMainDiagram ! )
; // CheckMainDiagram

STRING elem_func msm:Name
 Self 'msm:Name' .ElemString >>> Result
; // msm:Name

ANY elem_func msm:Value
 Self 'msm:Value' nil .ElemMember >>> Result
; // msm:Value

elem_iterator msm:ValueList
 Self 'msm:ValueList' .ElemList >>> Result
; // msm:Value

BOOLEAN elem_func msm:IsMemo
 RULES
  ( Self .msm:Name 'Doc' ?== )
   true
  ( Self .msm:Name 'Documentation' ?== )
   true
  DEFAULT
   false
 ; // RULES
 >>> Result
; // msm:IsMemo

ME ME_PublicAccess
 MEPROP Name 'public'
 MEPROP msm:Value PublicAccess
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_ProtectedAccess
 MEPROP Name 'protected'
 MEPROP msm:Value ProtectedAccess
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_PrivateAccess
 MEPROP Name 'private'
 MEPROP msm:Value PrivateAccess
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_Regular
 MEPROP Name 'regular'
 MEPROP msm:Value at_regular
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_Abstract
 MEPROP Name 'abstract'
 MEPROP msm:Value at_abstract
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_Final
 MEPROP Name 'final'
 MEPROP msm:Value at_final
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_Undefined
 MEPROP Name 'undefined'
 MEPROP msm:Value 'undefined'
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_False
 MEPROP Name 'false'
 MEPROP msm:Value false
 MEPROP Stereotype ME_EmptyStereo
ENDME

ME ME_True
 MEPROP Name 'true'
 MEPROP msm:Value true
 MEPROP Stereotype ME_EmptyStereo
ENDME

elem_iterator msm:KeyValuesForNewElement
 [
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Name'
   aMade -> msm:Value := 'NewElement'
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Stereotype'
   aMade -> msm:ValueList := ( Self .AllowedElements )
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Visibility'
   aMade -> msm:ValueList := [ ME_PublicAccess ME_ProtectedAccess ME_PrivateAccess ]
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Abstraction'
   aMade -> msm:ValueList := [ ME_Regular ME_Abstract ME_Final ]
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Doc'
   aMade -> msm:Value := ''
  ) // KeyValuesCreate:
 ]
 >>> Result   
; // msm:KeyValuesForNewElement    


ModelElement FUNCTION .msm:ElementByValue
  ARRAY IN anArray
  IN aValue
 anArray 
 .filter> ( .msm:Value aValue ?== )
 .FirstElement
 >>> Result
; // .msm:ElementByValue

ModelElement FUNCTION .msm:ElementByName
  ARRAY IN anArray
  IN aName
 anArray 
 .filter> ( .NameInModel aName ?== )
 .FirstElement
 >>> Result
; // .msm:ElementByName

USES
 MDProcess_Templates.tpi.script
;

elem_iterator StereotypeUPs
 Cached:
 (
  Self .Attributes
  .filter> ( .IsStereotype: st_UserProperty::Attribute )
  .joinWithLambded> 
  ( Self .StereotypeAncestors ) 
  call.me
  array:CopyWithoutDuplicates
  array:CopyWithoutDuplicatedNames
 )
 >>> Result
; // StereotypeUPs

USES
 string.ms.dict
;

elem_iterator UPValueList
 Cached:
 (
  RULES
   ( Self .IsStereotype: st_list::Attribute )
    begin
     [
      Self .GetUP 'Value' '|' string:Split:for> (
        IN aSubstr
       KeyValuesCreate: (
         IN aMade
        aMade -> Name := aSubstr
        aMade -> msm:Value := aSubstr
        aMade -> Stereotype := ME_EmptyStereo
       ) // KeyValuesCreate: 
      ) // Self .GetUP 'Value' '|' string:Split:for>
     ]
    end // ( Self .IsStereotype: st_list::Attribute )
   ( Self .IsStereotype: st_tribool::Attribute )
     ( [ ME_Undefined ME_False ME_True ] )
   ( Self .IsStereotype: st_bool::Attribute )
     ( [ ME_False ME_True ] )
   DEFAULT
    nil 
  ; // RULES
 )
 >>> Result
; // UPValueList

ANY elem_func UPDefaultValue
 Cached:
 (
  VAR l_DefaultValue
  '' >>> l_DefaultValue
  RULES
   ( Self .IsStereotype: st_list::Attribute )
    begin
     Self .UPValueList
     .FirstElement
     >>> l_DefaultValue
    end // ( Self .IsStereotype: st_list::Attribute )
   ( Self .IsStereotype: st_tribool::Attribute )
    begin
     Self .GetUP 'Value' >>> l_DefaultValue
     if ( l_DefaultValue .IsValueValid ! ) then
     begin
      'undefined' >>> l_DefaultValue
     end // ( l_DefaultValue .IsValueValid ! )
    end // ( aUP .IsStereotype: st_bool::Attribute )
   ( Self .IsStereotype: st_bool::Attribute )
    begin
     Self .GetUP 'Value' >>> l_DefaultValue
     if ( l_DefaultValue .IsValueValid ! ) then
     begin
      false >>> l_DefaultValue
     end // ( l_DefaultValue .IsValueValid ! )
    end // ( aUP .IsStereotype: st_bool::Attribute )
   ( Self .IsStereotype: st_string::Attribute )
    begin
     Self .GetUP 'Value' >>> l_DefaultValue
     if ( l_DefaultValue .IsValueValid ! ) then
     begin
      '' >>> l_DefaultValue
     end // ( l_DefaultValue .IsValueValid ! )
    end // ( aUP .IsStereotype: st_string::Attribute )
   DEFAULT
    begin
     Self .GetUP 'Value' >>> l_DefaultValue
    end // DEFAULT
  ; // RULES
  l_DefaultValue
 )
 >>> Result
; // UPDefaultValue    

elem_iterator msm:KeyValuesForElement
 [
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Name'
   aMade -> msm:Value := ( Self .NameInModel )
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Stereotype'
   aMade -> msm:ValueList := ( 
    if ( Self .Stereotype .StereotypeInModel .NotIsNil ) then
    begin
     [ Self .Stereotype .StereotypeInModel ]
     .join> ( Self .Parent .AllowedElements )
     array:CopyWithoutDuplicates
    end
    else
    begin
     Self .Parent .AllowedElements
    end // ( Self .Stereotype .StereotypeInModel .NotIsNil )
   )
   aMade -> msm:Value := ( aMade -> msm:ValueList Self .Stereotype .StereotypeInModel .NameInModel .msm:ElementByName )
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Visibility'
   aMade -> msm:ValueList := [ ME_PublicAccess ME_ProtectedAccess ME_PrivateAccess ]
   aMade -> msm:Value := ( aMade -> msm:ValueList  Self .Visibility .msm:ElementByValue )
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Abstraction'
   aMade -> msm:ValueList := [ ME_Regular ME_Abstract ME_Final ]
   aMade -> msm:Value := ( aMade -> msm:ValueList  Self .Abstraction .msm:ElementByValue )
  ) // KeyValuesCreate:
  KeyValuesCreate: (
    IN aMade
   aMade -> msm:Name := 'Doc'
   aMade -> msm:Value := ( Self .Documentation )
  ) // KeyValuesCreate:
  Self .Stereotype .StereotypeInModel .StereotypeUPs .for> (
    IN aUP
   KeyValuesCreate: (
     IN aMade
    VAR l_Name 
    [ '"' aUP .Name '"' ] strings:Cat >>> l_Name
    aMade -> msm:Name := l_Name
    VAR l_DefaultValue
    aUP .UPDefaultValue >>> l_DefaultValue
    
    VAR l_List
    aUP .UPValueList >>> l_List
    
    if ( l_List .NotIsNil ) then
    begin
     aMade -> msm:ValueList := l_List
    end // ( l_List .NotIsNil )
    VAR l_Value
    Self l_Name l_DefaultValue .ElemMember >>> l_Value
    if ( l_Value .IsNil ) then
    begin
     l_DefaultValue >>> l_Value
    end // ( l_Value .IsNil )
    aMade -> msm:Value := l_Value
    if ( l_List .NotIsNil ) then
    begin
     aMade -> msm:Value := ( l_List aMade -> msm:Value .msm:ElementByValue )
    end // ( l_List .NotIsNil )
   ) // KeyValuesCreate:
  ) // Self .Stereotype .StereotypeInModel .StereotypeUPs .for>
 ]
 >>> Result   
; // msm:KeyValuesForElement
    
elem_iterator msm:GetProperties
 Self .Viewed .msm:KeyValuesForElement
 >>> Result
; // msm:GetProperties

STRING FUNCTION .NormalizedName
  STRING IN aString
 aString '$' string:Split DROP >>> Result
; // NormalizedName

elem_proc msm:ApplyValues
  ARRAY IN aKeyValues
 RULES 
  DEFAULT
   begin
    aKeyValues .for> (
      IN anItem
     VAR l_Name
     anItem .msm:Name >>> l_Name
     VAR l_Value
     anItem .msm:Value >>> l_Value
     VAR l_ValueValue
     l_Value .msm:Value >>> l_ValueValue
     if ( l_ValueValue .NotIsNil ) then
     begin
      l_ValueValue >>> l_Value
     end // ( l_ValueValue .NotIsNil )
     
     RULES
      ( l_Name 'Doc' == )
       ( '%SUM' >>> l_Name ) 
      ( l_Name 'Documentation' == )
       ( '%SUM' >>> l_Name ) 
     ; // RULES 
     
     RULES
      ( l_Name 'Name' == )
       begin
        VAR l_NormalizedName
        l_Value .NormalizedName >>> l_NormalizedName
        Self l_Name l_NormalizedName .SetElementVar
        if ( l_Value l_NormalizedName != ) then
        begin
         Self 'OriginalName' l_Value .SetElementVar
        end // ( l_Value l_NormalizedName != )
        else
        begin
         Self 'OriginalName' '' .SetElementVar
        end // ( l_Value l_NormalizedName != )     
       end // ( l_Name 'Name' == )
      DEFAULT
       ( Self l_Name l_Value .SetElementVar )
     ; // RULES
     Self msm:DeleteWordCachedValues
     Self msm:AddChangedElement
     //msm:ClearCachedValues
    ) // aKeyValues .for> 
   end // DEFAULT 
 ; // RULES 
; // msm:ApplyValues

elem_proc msm:ChangeProperties
  ARRAY IN aKeyValues
 Self .Viewed aKeyValues .msm:ApplyValues
 Self msm:DeleteWordCachedValues
 //msm:ClearCachedValues
 // - пока опять закомментировал ибо там есть вопросы с сохранением вновь созданного элемента
; // msm:ChangeProperties

USES
 DoCache.ms.dict
;

elem_proc msm:AddToCollection
  ModelElement IN aMade
  FUNCTOR IN aLamda
 RULES 
  ( Self .IsSomeView ) 
   ( ERROR [ 'Для View пока не реализовано ' Self .Name ] )
  DEFAULT
   begin
    STRING VAR l_Name
    aLamda pop:Word:Name '.' .CutPrefix >>> l_Name
    if ( Self aLamda DO .IsNil ) then
    begin
     Self ->^ l_Name ^:= []
     Self msm:DeleteWordCachedValues
    end // ( Self aLamda DO .IsNil )
    aMade Self aLamda DO Array:Add
    Self msm:AddChangedElement
    l_Name Self msm:RegetViewedLists
   end // DEFAULT
 ; // RULES
; // msm:AddToCollection

elem_proc msm:AddToCollection:
  ModelElement IN aMade
  ^ IN aLamda
 Self aMade aLamda .msm:AddToCollection
; // msm:AddToCollection:

elem_proc msm:AddOverride
  ModelElement IN anOp
; // msm:AddOverride

ModelElement elem_func msm:Diagram:AddElement
  STRING IN aName
  ModelElement IN aStereotype
  ARRAY IN aKeyValues
 nil >>> Result
 RULES  
  ( Self .IsDiagram )
   begin
    VAR l_Original
    Self .Viewed >>> l_Original
    
    BOOLEAN VAR l_IsSubRoot
    RULES
     ( aStereotype .IsStereotype st_MDACategory )
      true
     ( aStereotype .IsStereotypeInModelKindOf: st_UtilityPack )
      true
     ( l_Original .MDAClass class_Class == )
      false
     ( aStereotype .IsStereotypeInModelKindOf: st_SimpleClass )
      true
     ( aStereotype .IsStereotypeInModelKindOf: st_Impurity )
      true
     DEFAULT
      false
    ; // RULES
    >>> l_IsSubRoot
    
    VAR l_UID
    CreateMUID >>> l_UID
    VAR l_ViewName 
    [ MEPrefix l_UID ] strings:Cat >>> l_ViewName 
    
    VAR l_Dict
    RULES
     l_IsSubRoot
      ( [ l_UID cModelScript ] strings:Cat DictionaryEx:CheckNamedDictionary )
     DEFAULT
      ( l_Original pop:Word:KeyWord pop:KeyWord:Dictionary )
    ; // RULES 
    >>> l_Dict
    
    l_Dict Is class::TtfwDictionaryEx ?ASSURE [ 'Несовместимый тип словаря: ' l_Dict pop:Object:ClassName ]
    VAR l_KeyWord
    //l_ViewName l_Original pop:NewWordDefinitor:CheckWord >>> l_KeyWord
    l_ViewName l_Dict pop:Dictionary:CheckWord >>> l_KeyWord
    if ( l_KeyWord pop:KeyWord:Word IsNil ) then
    begin
     KeyValuesCreateAndDo: (
       IN aMade
      @ ME aMade pop:Word:SetProducer 
      aMade l_KeyWord pop:KeyWord:SetWord 
      l_KeyWord aMade pop:Word:SetKey 
      RULES
       ( aStereotype .IsStereotype st_MDACategory )
        ( aMade -> Class := class_Category )
       ( aStereotype .IsStereotype st_MDAClass )
        ( aMade -> Class := class_Class )
       ( aStereotype .IsStereotype st_MDAOperation )
        ( aMade -> Class := class_Operation )
       ( aStereotype .IsStereotype st_MDAAttribute )
        ( aMade -> Class := class_Attribute )
       ( aStereotype .IsStereotype st_MDADependency )
        ( aMade -> Class := class_Dependency )
       DEFAULT
        begin
         ERROR [ 'Непонятный стереотип' aStereotype .Stereotype .Name ]
        end // DEFAULT
      ; // RULES
      aMade -> IsSubRoot := l_IsSubRoot
      aMade -> UID := l_UID
      VAR l_Name
      aName .NormalizedName >>> l_Name
      aMade -> Name := l_Name
      if ( aName l_Name != ) then
      begin
       aMade -> OriginalName := aName
      end // ( aName l_Name != )
      aMade -> Stereotype := aStereotype
      //aMade -> Original := ( aView .Viewed )
      aMade -> Parent := l_Original
      aMade -> Visibility := PublicAccess
      aMade -> Abstraction := at_regular
      // - вообще это надо брать из стереотипа
      aMade aKeyValues .msm:ApplyValues
      
      RULES
       ( aMade .MDAClass class_Dependency ?== )
        ( l_Original aMade .msm:AddToCollection: .Dependencies )
       ( aMade .MDAClass class_Attribute ?== )
        ( l_Original aMade .msm:AddToCollection: .Attributes )
       ( aMade .MDAClass class_Operation ?== )
        ( l_Original aMade .msm:AddToCollection: .Operations )
       ( aStereotype .IsStereotypeInModelKindOf: st_method )
        ( l_Original aMade .msm:AddToCollection: .Operations )
       DEFAULT
        ( l_Original aMade .msm:AddToCollection: .Children )
      ; // RULES  
      
      aMade >>> Result
     ) // KeyValuesCreateAndDo:
    end // ( l_KeyWord pop:KeyWord:Word IsNil )
    else
    begin
     ERROR [ 'Слово ' l_ViewName ' уже есть' ]
    end // ( l_KeyWord pop:KeyWord:Word IsNil )
    l_Original msm:AddChangedElement
    // - надо сохранять и родителя
    Result msm:AddChangedElement
    // - и ребёнка

    Result .AddDiagrams
    
    Self Result 10 10 .msm:Diagram:PasteElement >>> Result
   end // ( Self .IsDiagram )
  DEFAULT
   ( Self pop:Word:Producer pop:Word:Name Msg )
 ; // RULES  
; // msm:Diagram:AddElement

elem_iterator msm:Diagram:PasteElements
  ARRAY IN anElements
 [] >>> Result 
 RULES  
  ( Self .IsDiagram )
   begin
    anElements
    .filter> .Not: .IsViewLink
    .for> (
      IN aView
     Self 
     aView 
     aView .X 10 +
     aView .Y 10 +
     .msm:Diagram:PasteElement .AddToArray: Result
    ) // .for>
   end // ( Self .IsDiagram )
  DEFAULT
   ( Self pop:Word:Producer pop:Word:Name Msg )
 ; // RULES  
; // msm:Diagram:PasteElements

ModelElement FUNCTION .FindWord
  ARRAY IN aWords
  STRING IN aName
 aWords 
 .filter> ( .NameInModel aName SameText )
 .filter> ( pop:Word:Producer @ ME ?== )
 .FirstElement
 >>> Result
; // .FindWord

USES
 Chars.ms.dict
;

USES
 ProcessModelFiles.ms.dict
;

BOOLEAN FUNCTION .TryLoadWord
  STRING IN aName
  STRING IN aPath

 : DoFile
   STRING IN anItem
  if ( [ 'MEPROP OriginalName ' cQuote aName cQuote ] strings:Cat anItem FindInFile ) then
  begin
   true >>> Result
   anItem .DictionaryByName DROP
  end // ( aName anItem FindInFile )
  else
  if ( [ 'MEPROP Name ' cQuote aName cQuote ] strings:Cat anItem FindInFile ) then
  begin
   true >>> Result
   anItem .DictionaryByName DROP
  end // ( aName anItem FindInFile )
 ; // DoFile
 
 false >>> Result
 aPath .ProcessModelFiles: DoFile
; // .TryLoadWord

EXPORTS
 arrays.ms.dict
 
EXPORTS
 ElementsRTTI.ms.dict
 
EXPORTS
 CheckValue.ms.dict

EXPORTS
 GarantMetaModel.ms.dict
 
USES
 ElemMemberPrim.ms.dict
;
 
EXPORTS
 ElemMemberPrim.ms.dict
 
EXPORTS
 Diagrams.ms.dict
 
EXPORTS
 DictionaryByName.ms.dict
 
EXPORTS
 SetElementVar.ms.dict