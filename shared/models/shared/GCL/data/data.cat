
(object Petal
    version    	50
    _written   	"Rose 2006.0.0.061205"
    charSet    	204)

(object Class_Category "data"
    is_unit    	TRUE
    is_loaded  	TRUE
    attributes 	(list Attribute_Set
	(object Attribute
	    tool       	"MDA Generator User Properties"
	    name       	"is namespace"
	    value      	"false")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"AbstarctOperation"
	    value      	"regular")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"IsNative"
	    value      	"false")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (h)"
	    value      	"w:/shared/GCL/data/Buffer.h::450135270167,w:/shared/GCL/data/DirectMap.h::44FEC13E0149,w:/shared/GCL/data/OnDemandFile.h::450135840290,w:/shared/GCL/data/OrphanStr.h::450135E90109,w:/shared/GCL/data/PackedStrStream.h::4501364F0290,w:/shared/GCL/data/StaticNode.h::4501367B01C5,w:/shared/GCL/data/StaticNodeIterator.h::45C70B45008C,w:/shared/GCL/data/StaticNodeMng.h::450137530213,w:/shared/GCL/data/StaticNodeStub.h::450136CE01F4,w:/shared/GCL/data/StaticNodeStubBase.h::450136B500FA,w:/shared/GCL/data/Tree.h::450138270399,w:/shared/GCL/data/std_defs.h::44FEBDF3039B")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (cpp)"
	    value      	"w:/shared/GCL/data/StaticNode.cpp::4501367B01C5,w:/shared/GCL/data/StaticNodeIterator.cpp::45C70B45008C,w:/shared/GCL/data/StaticNodeStubBase.cpp::450136B500FA")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (i.h)"
	    value      	"w:/shared/GCL/data/DirectMap.i.h::44FEC13E0149,w:/shared/GCL/data/StaticNodeStub.i.h::450136CE01F4,w:/shared/GCL/data/Tree.i.h::450138270399")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED WikiPageID (wiki)"
	    value      	(value Text 
|Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Buffer|450135270167::450135270167;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/DirectMap|44FEC13E0149::44FEC13E0149;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OnDemandFile|450135840290::450135840290;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OrphanStr|450135E90109::450135E90109;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/PackedStrStream|4501364F0290::4501364F0290;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeIterator|45C70B45008C::45C70B45008C;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeMng|450137530213::450137530213;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStubBase|450136B500FA::450136B500FA;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStub|450136CE01F4::450136CE01F4;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNode|4501367B01C5::4501367B01C5;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Tree|450138270399::450138270399;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/std_defs|44FEBDF3039B::44FEBDF3039B;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/Модель проекта "shared"/GCL/data/StaticNodeIterator|45C70B45008C::45C70B45008C;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/Модель проекта "shared"/GCL/data/StaticNode|4501367B01C5::4501367B01C5;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Buffer|450135270167::450135270167;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/DirectMap|44FEC13E0149::44FEC13E0149;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OnDemandFile|450135840290::450135840290;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OrphanStr|450135E90109::450135E90109;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/PackedStrStream|4501364F0290::4501364F0290;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeIterator|45C70B45008C::45C70B45008C;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeMng|450137530213::450137530213;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStubBase|450136B500FA::450136B500FA;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStub|450136CE01F4::450136CE01F4;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNode|4501367B01C5::4501367B01C5;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Tree|450138270399::450138270399;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/std_defs|44FEBDF3039B::44FEBDF3039B;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Buffer|450135270167::450135270167;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/DirectMap|44FEC13E0149::44FEC13E0149;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OnDemandFile|450135840290::450135840290;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OrphanStr|450135E90109::450135E90109;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/PackedStrStream|4501364F0290::4501364F0290;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeMng|450137530213::450137530213;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStubBase|450136B500FA::450136B500FA;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStub|450136CE01F4::450136CE01F4;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNode|4501367B01C5::4501367B01C5;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Tree|450138270399::450138270399;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/std_defs|44FEBDF3039B::44FEBDF3039B
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"WikiPageID (wiki)"
	    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data|44FEB6B3010B
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ApplyedGens"
	    value      	"C++ интерфейсы и реализация|Java|Документация")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SourceType (wiki)"
	    value      	"wiki")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ElementCreationOrder"
	    value      	"16662883382"))
    quid       	"44FEB6B3010B"
    documentation 	"менеджеры данных, типы данных все что связанно с представлением или расширением информации"
    stereotype 	"Unit"
    exportControl 	"Public"
    logical_models 	(list unit_reference_list
	(object Class "std_defs"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*44FEBDF3039B_USER_INCLUDES*"
		    value      	"//#UC START# *44FEBDF3039B_USER_INCLUDES*¤//#UC END# *44FEBDF3039B_USER_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*44FEBDF3039B_USER_DEFINITION*"
		    value      	"//#UC START# *44FEBDF3039B_USER_DEFINITION*¤¤typedef Core::Aptr<FILE, File_boxDeallocator> File_aptr;¤¤//#UC END# *44FEBDF3039B_USER_DEFINITION*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*44FEBDF3039B_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *44FEBDF3039B_CUSTOM_INCLUDES*¤//#UC END# *44FEBDF3039B_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*44FEBDF3039B*"
		    value      	"//#UC START# *44FEBDF3039B*¤//#UC END# *44FEBDF3039B*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*44FEBDF3039B_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *44FEBDF3039B_CUSTOM_INCLUDES*¤//#UC END# *44FEBDF3039B_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*44FEBDF3039B*"
		    value      	"//#UC START# *44FEBDF3039B*¤//#UC END# *44FEBDF3039B*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/std_defs.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/std_defs|44FEBDF3039B
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (java)"
		    value      	"w:/shared/java/src/java/ru/garant/shared/GCL/std_defs.java")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (java)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16662293998"))
	    quid       	"44FEBDF3039B"
	    documentation 	"несколько макросов для часто употребительных стандартных типов: некоторые stl-контейнеры; авто-менеджер указателя на файл (при разрушении закрывает файл которым владеет)"
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator"
	    nestedClasses 	(list nestedClasses
		(object Class "StrSet"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force usage"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16662934322"))
		    quid       	"44FEBE140197"
		    documentation 	"set-контейнер атомарных строк"
		    stereotype 	"Set")
		(object Class "StrVector"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force usage"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16662979089"))
		    quid       	"44FEBE2F034D"
		    documentation 	"vector-контейнер атомарных строк"
		    stereotype 	"Vector")
		(object Class "File_box"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"Need deallocator"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"h:*44FEBE6E005F*"
			    value      	(value Text 
|//#UC START# *44FEBE6E005F*¤		fclose(content);¤	//#UC END# *44FEBE6E005F*
			    ))
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force usage"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657700932"))
		    quid       	"44FEBE6E005F"
		    documentation 	"Бокс для файлового хендла - в деструкторе закрывает файл"
		    stereotype 	"Box"
		    superclasses 	(list inheritance_relationship_list
			(object Inheritance_Relationship
			    quid       	"44FED78F02EF"
			    supplier   	"Logical View::shared::GCL::data::std_defs::FILE"
			    quidu      	"44FEBEBC0030")))
		(object Class "FILE"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16662219748"))
		    quid       	"44FEBEBC0030"
		    documentation 	"нужно перенести во внешнюю либу"
		    stereotype 	"Typedef")))
	(object Parameterized_Class "DirectMap"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*44FEC13E0149_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *44FEC13E0149_CUSTOM_INCLUDES*¤#include <vector>¤//#UC END# *44FEC13E0149_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*44FEC13E0149*"
		    value      	(value Text 
|//#UC START# *44FEC13E0149*¤public:¤	class InvalidKey : public std::exception {¤	};¤	class UnsortedKey : public std::exception {¤	};¤¤protected:¤	struct Node {¤		_Key key;¤		_Data data;¤	};¤¤	typedef std::vector<Node> NodeBuff;¤¤	class NodeCache {¤		struct Item {¤			Item(const Node* n = 0) : node (n), access_value(2) {¤			}¤¤			const Node* node;¤			mutable unsigned short access_value;¤		};¤		typedef std::vector<Item> CacheBuf;¤¤	public:¤		NodeCache (size_t size) : m_last (size), m_size(size) {¤			m_last_node = 0;¤		}¤		¤		void clear () {¤			m_last_node = 0;¤			m_last = m_size;¤			m_remove_ind = 0;¤			m_cache_buf.clear();¤		}¤¤		inline const Node* find (const _Key& key) const {¤			if (m_last_node && m_last_node->key == key) {¤				return m_last_node;¤			} else {¤				return 0;¤			}¤¤			if (m_last < m_cache_buf.size() && m_cache_buf[m_last].node->key == key) {¤				return m_cache_buf[m_last].node;¤			} ¤			¤			m_remove_ind = 0;¤			const Node* ret = 0;¤¤			for (size_t i = 0; i < m_cache_buf.size(); i++) {¤				if (m_cache_buf[i].node->key == key) {¤					ret = m_cache_buf[i].node;¤					m_last = i;¤					m_cache_buf[i].access_value += 2;¤					break;¤				} else {¤					if (m_cache_buf[i].access_value > m_size) {¤						m_cache_buf[i].access_value -= 2;¤					} else if (m_cache_buf[i].access_value) {¤						--m_cache_buf[i].access_value;¤					}¤¤					if (m_cache_buf[m_remove_ind].access_value > m_cache_buf[i].access_value) {¤						m_remove_ind = i;¤					}¤				}¤			}¤¤			return ret;¤		}¤		inline void add (const Node* node) {¤			m_last_node = node;¤			return;¤¤			if (m_cache_buf.size() < m_size) {¤				m_cache_buf.push_back (Item(node));¤				m_last = m_cache_buf.size() - 1;¤			} else {¤				m_cache_buf[m_remove_ind].node = node;¤				m_cache_buf[m_remove_ind].access_value = 2;¤				m_last = m_remove_ind;¤			}¤		}¤	private:¤		mutable const Node* m_last_node;¤¤		mutable size_t m_last;¤		mutable size_t m_remove_ind;¤		size_t m_size;¤		CacheBuf m_cache_buf;¤	};¤public:¤	DirectMap (size_t resize_step = 1, size_t init_size = 0/*, bool use_cache = 0*/) ¤		: m_cache(10)¤		, m_resize_step(resize_step)¤		, m_count(0)¤//		, m_use_cache(use_cache)¤	{¤		m_last = 0;¤		if (init_size) {¤			this->resize_buff (init_size);¤		}¤		//m_ps_count = 0;¤		//m_bs_count = 0;¤	}¤¤	unsigned long size () const {¤		return m_count;¤	}¤¤	void clear () {¤		m_last = 0;¤		//m_ps_count = 0;¤		//m_bs_count = 0;¤		m_count = 0;¤		m_buff.clear();¤		m_cache.clear();¤	}¤¤	void reserve (unsigned long size) {¤		this->resize_buff (size);¤	}¤¤	inline void add (const _Key& key, const _Data& data) {¤		if (m_count && m_buff[m_count-1].key > key) {¤			throw UnsortedKey();¤		}¤		if (m_count >= m_buff.size()) {¤			this->resize_buff (m_buff.size() + m_resize_step);			¤		}¤¤		m_buff[m_count].key = key;¤		m_buff[m_count].data = data;¤		m_count++;¤	}¤	const _Data& operator [] (const _Key& key) const {¤		//const Node* ret = m_use_cache ? this->p_search(key) : this->bin_search(key);¤		const Node* ret = this->bin_search(key);¤		if (!ret) {¤			throw InvalidKey();¤		}¤		return ret->data;¤	}¤	_Data& operator [] (const _Key& key) {¤		//const Node* ret = m_use_cache ? this->p_search(key) : this->bin_search(key);¤		const Node* ret = this->bin_search(key);¤		if (!ret) {¤			throw InvalidKey();¤		}¤		return const_cast<_Data&>(ret->data);¤	}¤	bool find (const _Key& key) const {¤		return this->bin_search(key) != 0;¤	}¤	unsigned long index (const _Key& key) const¤	throw (InvalidKey) ¤	{¤		const Node* f = this->bin_search(key);¤		if (!f) {¤			throw InvalidKey ();¤		}¤		return f - &m_buff.front();¤	}¤	const _Key key (unsigned long ind) const {¤		GDS_ASSERT (ind <= this->size ());¤		return m_buff[ind].key;¤	}¤¤	const _Data& data (unsigned long ind) const {¤		GDS_ASSERT (ind <= this->size ());¤		return m_buff[ind].data;¤	}¤¤	void save_to_disk () {¤		if (!this->size ()) {¤			return;¤		}¤		FILE* out = mpcxc_fopen ("t:\\etalon.lst", "wb"); // GARANT_XXX¤¤		fwrite (&m_count, 1, sizeof(unsigned long), out);¤		fwrite (&m_buff[0], m_count, sizeof(Node), out);¤		¤		fclose (out);¤	}¤¤	void load_from_disk () {¤		FILE* in = mpcxc_fopen ("t:\\etalon.lst", "rb");¤		fread (&m_count, 1, sizeof(unsigned long), in);¤		if (!m_count) {¤			return;¤		}¤¤		this->resize_buff (m_count);¤¤		if (fread (&m_buff[0], sizeof(Node), m_count, in) != m_count) {¤			assert (0);¤		}¤		fclose (in);¤	}¤¤protected:¤	struct NodeFinder {¤		bool operator () (const Node& lhs, const _Key& key) {¤			return lhs.key < key;¤		}¤¤		bool operator () (const _Key& key, const Node& rhs) {¤			return key < rhs.key;¤		}¤¤		// for debug version of Microsoft STL¤		bool operator () (const Node& lhs, const Node& rhs) {¤			return lhs.key < rhs.key;¤		}¤	};¤¤	const Node* bin_search (const _Key& key) const {¤		const Node* ret = m_cache.find(key);				¤		if (ret) {¤			return ret;¤		}¤		typedef typename NodeBuff::const_iterator NodeIterator;¤		typedef std::pair<NodeIterator,NodeIterator> NodeIteratorPair;¤		NodeIteratorPair it_pair = std::equal_range (m_buff.begin (), m_buff.end (), key, NodeFinder ());¤		if (it_pair.first == it_pair.second) {¤			return 0;¤		}¤		GDS_ASSERT (std::distance (it_pair.first, it_pair.second) == 1);¤		m_cache.add (&*it_pair.first);¤¤		return &*it_pair.first;¤	}¤¤¤protected:¤	void resize_buff (size_t count) {¤		m_buff.resize(count);	¤		m_cache.clear ();¤	}¤¤protected:¤	unsigned long m_count;¤	size_t m_resize_step;¤	NodeBuff m_buff;¤	mutable NodeCache m_cache;¤	//bool m_use_cache;¤¤	mutable const Node* m_last;¤	//mutable unsigned long m_bs_count;¤	//mutable unsigned long m_ps_count;¤//#UC END# *44FEC13E0149*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*44FEC13E0149_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *44FEC13E0149_CUSTOM_INCLUDES*¤//#UC END# *44FEC13E0149_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*44FEC13E0149*"
		    value      	"//#UC START# *44FEC13E0149*¤//#UC END# *44FEC13E0149*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*44FEC13E0149_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *44FEC13E0149_DESTR_BODY*¤	//#UC END# *44FEC13E0149_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*44FEC13E0149_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *44FEC13E0149_CUSTOM_INCLUDES*¤//#UC END# *44FEC13E0149_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*44FEC13E0149*"
		    value      	"//#UC START# *44FEC13E0149*¤//#UC END# *44FEC13E0149*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*44FEC13E0149_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *44FEC13E0149_DESTR_BODY*¤	//#UC END# *44FEC13E0149_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/DirectMap.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (i.h)"
		    value      	"w:/shared/GCL/data/DirectMap.i.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/DirectMap|44FEC13E0149
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (i.h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657702327"))
	    quid       	"44FEC13E0149"
	    documentation 	"быстрая мапа для сортированных последовательностей больших объемов"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator"
	    parameters 	(list Parameters
		(object Parameter "class _Key"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657702632"))
		    quid       	"44FEC5CE02A1")
		(object Parameter "class _Data"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657702960"))
		    quid       	"44FEC5CE0291")))
	(object Class "Buffer"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450135270167_USER_INCLUDES*"
		    value      	(value Text 
|//#UC START# *450135270167_USER_INCLUDES*¤#include <map>¤#include "shared/GCL/meta/select.h"¤//#UC END# *450135270167_USER_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450135270167_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *450135270167_USER_DEFINITION*¤#define GCL_BUFFER_PAGE_SIZE (65536)¤¤class NullGuard {¤public:¤	NullGuard (Core::NullMutex& nm) {¤	}¤};¤¤template <bool use_guard>¤class BufferBase {¤public:¤	typedef typename GCL::Templates::select<use_guard, Core::RWMutex, Core::NullMutex>::Type BufferMutex;¤	typedef typename GCL::Templates::select<use_guard, Core::ReadGuard, NullGuard>::Type BufferReadGuard;¤	typedef typename GCL::Templates::select<use_guard, Core::WriteGuard, NullGuard>::Type BufferWriteGuard;¤¤public:¤	BufferBase() {¤	}¤¤	~BufferBase() {¤		this->clean();¤	}¤¤	void clean () {¤		BufferWriteGuard _local_bg (m_mutex);¤		for (typename PageMap::iterator it = m_pages.begin(); it != m_pages.end(); ++it) {¤			delete (*it);¤		}¤		m_pages.clear();¤	}¤¤	int read (void* buf, unsigned from, unsigned count) {		¤		BufferReadGuard _local_bg (m_mutex);¤		size_t len = length_i ();		¤		¤		if (from > len) {¤			return 0;¤		}¤¤		size_t real_count = count;¤		if (from + count > len) {¤			real_count = len - from;¤		}¤		size_t first_page = from / GCL_BUFFER_PAGE_SIZE;¤		size_t last_page = (from+real_count) / GCL_BUFFER_PAGE_SIZE;¤		size_t first_offset = from % GCL_BUFFER_PAGE_SIZE;¤		size_t last_offset = (from+real_count) % GCL_BUFFER_PAGE_SIZE;¤¤		if ( first_page == last_page ) {¤			memcpy ( (char*)buf, m_pages[first_page]->buf+first_offset, last_offset - first_offset);¤		} else {¤			size_t buf_offset = 0;¤			size_t page = first_page;¤¤			// first page¤			memcpy ( (char*)buf+buf_offset, m_pages[page++]->buf+first_offset, GCL_BUFFER_PAGE_SIZE - first_offset);¤			buf_offset += GCL_BUFFER_PAGE_SIZE - first_offset;¤¤			// all middle pages¤			for ( ; page < last_page; page++ ) {¤				memcpy ( (char*)buf+buf_offset, m_pages[page]->buf, GCL_BUFFER_PAGE_SIZE );¤				buf_offset += GCL_BUFFER_PAGE_SIZE;¤			};¤¤			// last page¤			if (last_offset) {¤				memcpy ( (char*)buf+buf_offset, m_pages[last_page]->buf, last_offset );¤			}¤		}¤¤		return static_cast<int> (real_count);¤	}¤¤	void append (const void* buf, unsigned count) {¤		BufferWriteGuard _local_bg (m_mutex);¤		if (0 == m_pages.size ()) {¤			this->add_page ();¤		}¤		size_t page = m_pages.size () - 1;¤		¤		unsigned buf_offset = 0;¤		¤		while (count) {¤			unsigned move_count = GCL_BUFFER_PAGE_SIZE - m_pages[page]->len < count ¤				? GCL_BUFFER_PAGE_SIZE - m_pages[page]->len : count;¤			¤			try {¤				memcpy ( m_pages[page]->buf+m_pages[page]->len, (char*)buf + buf_offset, move_count);¤			} catch (...) {¤				//LOG_UEX (( "GCL::Buffer::append (%M)" ));¤			}¤¤			m_pages[page]->len += move_count;¤			buf_offset += move_count;¤			count -= move_count;¤¤			if (count) {¤				this->add_page ();¤			}¤			page++;¤		}¤	}¤¤	unsigned length () {¤		BufferReadGuard _local_bg (m_mutex);¤		return static_cast<unsigned> (length_i ());¤	}¤¤protected:¤	void add_page () {¤		MemPage* page = new MemPage;¤		m_pages.push_back (page);¤	}¤¤private:¤	size_t length_i () {¤¤		if (m_pages.empty ()) {¤			return 0;¤		}¤¤		size_t page_count = m_pages.size ();¤		return  (page_count - 1) * GCL_BUFFER_PAGE_SIZE + m_pages[page_count - 1]->len;		¤	}¤¤protected:¤	struct MemPage {¤		unsigned char* buf;¤		unsigned len;¤		MemPage () {¤			buf = new unsigned char [GCL_BUFFER_PAGE_SIZE];¤			len = 0;¤		}¤		~MemPage () {¤			delete [] buf;¤		}¤	};¤¤	typedef std::vector <MemPage*> PageMap;¤	PageMap m_pages;¤	¤	BufferMutex m_mutex;¤¤};¤¤typedef BufferBase<true> Buffer;¤¤template<bool is_guard>¤class BufferExBase {¤public:¤	BufferExBase () : m_position (0) {¤	}¤	¤	void clean () {¤		m_buffer.clean ();¤	}¤¤	int read (void* buf, unsigned count) {¤		assert (m_position < this->length ());¤		assert (m_position + count <= this->length ());¤¤		int readed = m_buffer.read (buf, m_position, count);¤		m_position += readed;¤		assert (readed == count);¤		return readed;¤	}¤¤	void append(const void* buf, unsigned count) {¤		m_buffer.append (buf, count);¤	}¤¤	unsigned length () {¤		return m_buffer.length ();¤	}¤	¤	void seek (unsigned position) {¤		assert (position < this->length ());¤		m_position = position;¤	}¤¤	bool is_end_position () {¤		return m_position >= this->length ();¤	}¤	¤private:¤	BufferBase<is_guard> m_buffer;¤	unsigned m_position;¤};¤¤typedef BufferExBase<false> BufferEx;¤¤//#UC END# *450135270167_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/Buffer.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Buffer|450135270167
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657703507"))
	    quid       	"450135270167"
	    documentation 	"класс для работы с линейным буфером данных, неограниченной длинны, внутри организован как страничный вектор"
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator")
	(object Class "OnDemandFile"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450135840290_USER_INCLUDES*"
		    value      	"//#UC START# *450135840290_USER_INCLUDES*¤#include <fstream>¤#include <string>¤//#UC END# *450135840290_USER_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450135840290_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *450135840290_USER_DEFINITION*¤class OnDemandFile : public std::ofstream {¤	int m_mode;¤	std::string m_file_name;¤	bool m_is_file_open;	¤¤public:¤	class FileOpenError : public std::exception {¤	};¤¤	OnDemandFile (std::string file_name, int mode) ¤		: m_file_name (file_name)¤		, m_mode (mode)¤		, m_is_file_open (false)¤	{¤	};¤¤	void check_open () {¤		if (!m_is_file_open) {¤			open (m_file_name.data(), m_mode);¤			if (!is_open()) throw FileOpenError();¤			else m_is_file_open = true;¤		}¤	}¤};¤¤}; //GCL¤¤// INSERTERS¤inline GCL::OnDemandFile& __cdecl operator<< (GCL::OnDemandFile& _O, std::string _S) {¤	_O.check_open ();¤	std::ofstream* stdf = &_O;¤	(*stdf) << _S.data();¤	return (_O); ¤};¤¤template<class _E> ¤inline GCL::OnDemandFile& __cdecl operator<< (GCL::OnDemandFile& _O, _E _C) {¤	_O.check_open ();¤	std::ofstream* stdf = &_O;¤	(*stdf) << _C;¤	return (_O); ¤};¤¤namespace GCL {¤//#UC END# *450135840290_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/OnDemandFile.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OnDemandFile|450135840290
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657703979"))
	    quid       	"450135840290"
	    documentation 	"обвязка над std::ofstream, создающая выходной файл, только при первом к нему обращении"
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator")
	(object Class "OrphanStr"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450135E90109_USER_INCLUDES*"
		    value      	"//#UC START# *450135E90109_USER_INCLUDES*¤//#UC END# *450135E90109_USER_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450135E90109_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *450135E90109_USER_DEFINITION*¤struct OrphanStr {¤	typedef unsigned OrphanType;¤	const char* str;¤	OrphanStr (char* s, OrphanType orphan) : str (s), m_orphan (orphan) {}¤	OrphanStr (const char* s) : str (s), m_orphan (false) {}¤	~OrphanStr () {¤		if (m_orphan) {¤			// это ошибка: мы не знаем как была выделена память, а как удалять типа знаем...¤			// надо параметризовать класс DeleteDestructor'ом¤			delete str;¤		}¤	}¤	// There are not a real copy. It is to return OrphanStr from functions ONLY¤	OrphanStr (const OrphanStr& os) {¤		str = os.str;¤		m_orphan = os.m_orphan;¤		const_cast <OrphanStr&> (os).m_orphan = false;¤	}¤	OrphanStr& operator= (const OrphanStr& os); /* { GARANT_ISOCPP: is NOT used by linker¤		if (m_orphan) {¤			delete str;¤		}¤		str = os.str;¤		m_orphan = os.m_orphan;¤		const_cast <OrphanStr&> (os).m_orphan = false;¤	} */¤	// It is DANGEROUSLY to use because of temporary objects.¤	/*inline operator const char* () const;*/¤	inline char* get (OrphanType orphan) {¤		m_orphan = orphan;¤		return const_cast <char*> (str);¤	}¤	inline bool is_orphan () const {¤		return m_orphan != 0;¤	}¤private:¤	OrphanType m_orphan;¤};¤//#UC END# *450135E90109_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/OrphanStr.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/OrphanStr|450135E90109
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657704456"))
	    quid       	"450135E90109"
	    documentation 	"менеджер строки позволяющие при возврате результата указывать нужно ли освобождать буфер или нет, за счет чего можно экономит кол-во реаллокаций памяти"
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator")
	(object Class "PackedStrStream"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4501364F0290_USER_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4501364F0290_USER_INCLUDES*¤#include <vector>¤¤/*¤usage:¤	GCL::PackedStrStream pss;¤	¤	const char* in1 = "abcd";¤	long in2 = 100;¤	long in3 = 101;¤¤	pss << in1;¤	pss << in2;¤	pss << in3;¤¤	LOG_D (("pss is \"%s\" (%d, %d)", pss.str(), pss.length(), pss.item_count()));¤¤	Core::Aptr<char> out;¤	pss >> out.out();¤	LOG_D (("out1 is \"%s\"", out.ptr()));¤	¤	long l_out;¤	pss >> l_out;¤	LOG_D (("out2 is %d", l_out));¤	pss >> l_out;¤	LOG_D (("out2 is %d", l_out));¤¤output:¤	pss is "Дabcdфх" (7, 3)¤	out1 is "abcd"¤	out2 is 100¤	out2 is 101¤¤implementation buffer format:¤		  byte 1    byte 2     byte 3     byte 4    byte 5¤		1VVVVVVV      -          -          -          -¤		01VVVVVV   VVVVVVVV      -          -          -¤		001VVVVV   VVVVVVVV   VVVVVVVV      -          -¤		0001VVVV   VVVVVVVV   VVVVVVVV   VVVVVVVV      -¤		0000MMMM      D         D(?)       D(?)       D(?)¤¤  V..V - value (non zerro)¤  M..M - byte mask¤  D    - data (non zerro)¤*/¤¤//#UC END# *4501364F0290_USER_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4501364F0290_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *4501364F0290_USER_DEFINITION*¤class PackedStrStream {¤public:¤	PackedStrStream (unsigned size = 0) {¤		m_buf.resize(size);¤		m_item_count = 0;		¤	}¤	¤	PackedStrStream (const char* str) : m_buf (str) {¤		m_item_count = 0;		¤	}¤¤	virtual ~PackedStrStream () {¤	}¤¤	bool operator < (const PackedStrStream& c) const {¤		return m_buf < c.m_buf;¤	}¤¤	void operator << (const char* str) {¤		size_t len = strlen(str);¤		(*this) << (unsigned long)len;¤¤		for (unsigned int l=0; l < len; l++) {¤			m_buf << str[l];¤		}¤	}¤¤	void operator >> (char*& str) {¤		unsigned long len;¤		(*this) >> len;¤¤		str = new char[len+1];¤		str[len] = 0;¤¤		for (unsigned long l=0; l < len; l++) {¤			m_buf >> str[l];¤		}¤	}¤¤	void operator << (long l) {¤		this->operator << ((unsigned long)l);¤	}¤¤	void operator << (unsigned long l) {¤		// this code may be not optimized¤		m_item_count++;¤¤		register char first_byte = 0;¤		register const char* p = (const char*) &l;¤		¤		if (p[3]&0xF0) {¤			first_byte |= 0x08;¤		}				¤	¤		if (p[2]) {¤			if (first_byte || p[2]&0xE0) {¤				first_byte |= 0x04;¤				if (p[3]) {¤					first_byte |= 0x08;¤				}¤			} ¤		} else if (p[3]) {¤			first_byte |= 0x08;¤		}¤¤		if (p[1]) {¤			if (first_byte || p[1]&0xC0) {¤				first_byte |= 0x02;¤				if (p[2]) {¤					first_byte |= 0x04;¤				}¤				if (p[3]) {¤					first_byte |= 0x08;¤				}¤			}¤		} else {¤			if (p[2]) {¤				first_byte |= 0x04;¤			}¤			if (p[3]) {¤				first_byte |= 0x08;¤			}¤		}¤¤		if (p[0]) {¤			if (first_byte || p[0]&0x80) {¤				first_byte |= 0x01;¤				if (p[1]) {¤					first_byte |= 0x02;¤				}¤				if (p[2]) {¤					first_byte |= 0x04;¤				}¤				if (p[3]) {¤					first_byte |= 0x08;¤				}¤			}¤		} else {¤			if (p[1]) {¤				first_byte |= 0x02;¤			}¤			if (p[2]) {¤				first_byte |= 0x04;¤			}¤			if (p[3]) {¤				first_byte |= 0x08;¤			}¤		}¤¤		if (first_byte) {¤			m_buf << first_byte;¤			if (p[3]) {¤				m_buf << p[3];¤			}¤			if (p[2]) {¤				m_buf << p[2];¤			}¤			if (p[1]) {¤				m_buf << p[1];¤			}¤			if (p[0]) {¤				m_buf << p[0];¤			}			¤		} else {¤			if (p[3]) {¤				first_byte = p[3];¤				first_byte |= 0x10;¤				m_buf << first_byte;¤				m_buf << p[2];¤				m_buf << p[1];¤				m_buf << p[0];¤			} else if (p[2]) {¤				first_byte = p[2];¤				first_byte |= 0x20;¤				m_buf << first_byte;¤				m_buf << p[1];¤				m_buf << p[0];¤			} else if (p[1]) {¤				first_byte = p[1];¤				first_byte |= 0x40;¤				m_buf << first_byte;¤				m_buf << p[0];¤			} else {¤				first_byte = p[0];¤				first_byte |= 0x80;¤				m_buf << first_byte;¤			}¤		}¤	}¤¤	void operator >> (long& l) {¤		unsigned long wrap;¤		this->operator >> (wrap);¤		l = (long)wrap;¤	}¤¤	void operator >> (unsigned long& l) {¤		l = 0;¤		register char* p = (char*) &l;¤		register char first_byte;¤		m_buf >> first_byte;¤¤		if ((first_byte & 0xF0) == 0x10) {¤			p[3] = first_byte & 0x0F;¤			m_buf >> p[2];¤			m_buf >> p[1];¤			m_buf >> p[0];¤		} else if ((first_byte & 0xE0) == 0x20) {¤			p[2] = first_byte & 0x1F;¤			m_buf >> p[1];¤			m_buf >> p[0];¤		} else if ((first_byte & 0xC0) == 0x40) {¤			p[1] = first_byte & 0x3F;¤			m_buf >> p[0];¤		} else if (first_byte & 0x80) {¤			p[0] = first_byte & 0x7F;¤		} else {¤			if (first_byte & 0x08) {¤				m_buf >> p[3];¤			}¤			if (first_byte & 0x04) {¤				m_buf >> p[2];¤			}¤			if (first_byte & 0x02) {¤				m_buf >> p[1];¤			}¤			if (first_byte & 0x01) {¤				m_buf >> p[0];¤			}¤		}¤	}¤¤	const char* str () const {¤		m_buf << 0;¤		return m_buf.begin();		¤	}¤	unsigned length () {¤		return m_buf.size();¤	}¤	unsigned item_count () {¤		return m_item_count;¤	}¤¤private:¤	// std::vector is not good solution for dynamic binary stream¤	class IOStream: public std::vector<char> {¤	public:¤		IOStream () {¤			m_it = 0;¤		}¤¤		IOStream (const char* str) : std::vector<char>(str, str + strlen(str)) {¤			m_it = 0;¤		}¤¤		inline void operator << (char c) {¤			this->push_back(c);¤		}¤¤		inline void operator >> (char& c) {¤			c = *(this->begin() + m_it);¤			m_it++;¤		}¤¤	protected:¤		unsigned m_it;¤	};¤¤private:¤	mutable IOStream m_buf;¤	unsigned m_item_count;¤};¤//#UC END# *4501364F0290_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/PackedStrStream.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/PackedStrStream|4501364F0290
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657704916"))
	    quid       	"4501364F0290"
	    documentation 	"объединяет любое кол-во входных данных (целых чисел, строк (без ограничения формата)) в один непрерывный строковый ASCII буфер, с возможностью последующего извлечения всех введенных данных (по принципу стека). имеет лучшие показатели размера объединенного буфера, за счет строковой упаковки чисел. "
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator")
	(object Class "StaticNode"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4501367B01C5_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4501367B01C5_CUSTOM_INCLUDES*¤//#UC END# *4501367B01C5_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4501367B01C5*"
		    value      	(value Text 
|//#UC START# *4501367B01C5*¤#ifdef _DEBUG¤bool StaticNode::s_need_print = 1;¤//long StaticNode::s_id = 0;¤#endif¤¤StaticNode::StaticNode () : m_parent (0), m_last_child (0), m_prev (0) {¤	//LOG_D (("StaticNode[%d]::StaticNode", this));¤	//ADD_OBJECT_WATCHER¤	//m_id__ = ++s_id;¤}¤¤unsigned StaticNode::get_parents_count () const {¤	unsigned n = 1;¤	const StaticNode* p = this;¤	while (p = p->m_parent) {¤		++n;¤	}¤	return n;¤}¤¤void StaticNode::insert_next (StaticNode* node) {  // справо от себя (next)¤	node->m_prev = this;¤	node->m_next = m_next;¤	node->m_parent = m_parent; ¤	¤	// fix next¤	if (m_next.ptr()) {¤		m_next->m_prev = node;¤	} ¤¤	// fix self¤	m_next = node;	¤¤	// fix parent¤	if (m_parent) {¤		if (this == m_parent->m_last_child) {¤			m_parent->m_last_child = node;¤		}¤		m_parent->invalidate_children_count();¤	}	¤}¤¤void StaticNode::insert_prev (StaticNode* node) {  // слева от себя (prev)¤	StaticNode* prev_prev = m_prev;¤¤	node->m_next = StaticNode::_duplicate (this);¤	node->m_prev = prev_prev;¤	node->m_parent = m_parent;¤	¤	// fix self¤	m_prev = node;¤¤	// fix prev¤	if (prev_prev) {¤		prev_prev->m_next = node;¤	} ¤¤	// fix parent	¤	if (m_parent) {¤		if (this == m_parent->m_first_child.ptr()) {¤			m_parent->m_first_child = node;¤		}¤		m_parent->invalidate_children_count();¤	}	¤}¤¤// изменение (удаление/перемещение)¤void StaticNode::remove_from_tree () {	¤	//fix next¤	if (m_next.ptr()) {¤		m_next->m_prev = m_prev;¤	}¤¤	StaticNode_var tmp_next = m_next._retn();¤¤	//fix parent¤	if (m_parent) {¤		m_parent->invalidate_children_count();¤		if (this == m_parent->m_last_child) {¤			m_parent->m_last_child = m_prev;¤		}¤¤		if (this == m_parent->m_first_child.ptr()) {¤			StaticNode* tmp_parent = m_parent;¤			m_parent = 0;¤			tmp_parent->m_first_child = tmp_next; // may be this is last referens for me			¤			return; // m_prev is 0 - no need to fix¤		} else {¤			m_parent = 0;¤		}¤	}¤	¤	// fix prev¤	if (m_prev) {¤		StaticNode* tmp_prev = m_prev;¤		m_prev = 0;¤		tmp_prev->m_next = tmp_next; // may be this is last referens for me¤		return;¤	}	¤}¤¤¤void StaticNode::move_to_destination (StaticNode* dest_node) {¤	StaticNode::_duplicate (this);¤	this->remove_from_tree();¤	dest_node->insert_back_child(this);¤}¤¤void StaticNode::copy_to_destination (StaticNode* dest_node) const {	¤	dest_node->insert_back_child(this->copy());¤}¤¤StaticNode* StaticNode::copy () const {¤	StaticNode_var copy = this->create_data_copy();¤¤	for (const StaticNode* n = m_first_child.ptr(); n; n = n->m_next.ptr()) {¤		copy->insert_back_child(n->copy());¤	}¤	return copy._retn();¤}¤¤// очистить все дочерние узлы¤void StaticNode::clear_children () {¤	m_first_child = 0;¤	m_last_child = 0;¤}¤¤// доступ к атрибутам узла¤unsigned long StaticNode::level () const { //получить уровень ноды ¤	unsigned long ret = 0;¤	¤	if (!m_parent) {¤		return ret;¤	} else {¤		ret = 1;¤	}¤	¤	StaticNode* parent = m_parent;¤	while (parent = parent->m_parent) {¤		ret++;¤	}¤¤	return ret;¤}¤¤unsigned long StaticNode::_load_children_count () const { //количество непосредственных детей ¤	unsigned long ret = 0;¤¤	//for (const StaticNode* cp = m_first_child.ptr ()/*m_last_child*/; cp; cp = cp->m_next.ptr ()/*m_prev*/) {¤	for (const StaticNode* cp = m_last_child; cp; cp = cp->m_prev) {¤		const StaticNodeStubBase* snsb = dynamic_cast<const StaticNodeStubBase*>(cp);¤		if (snsb) {¤			long stub_count = snsb->stub_count();¤			ret += abs(stub_count);¤			if (stub_count != 1 && snsb->has_pair()) {¤				ret++;¤				cp = cp->m_prev;¤			}¤		} else {¤			ret++;¤		}¤	}¤¤	return ret;¤}¤¤const StaticNode* StaticNode::child_by_index (unsigned long index) const {¤	for (const StaticNode* cp = m_first_child.ptr(); cp; cp = cp->m_next.ptr()) {¤		if (!index) {¤			return StaticNode::_duplicate (cp);¤		}¤¤		const StaticNodeStubBase* snsb = dynamic_cast<const StaticNodeStubBase*>(cp);¤		if (snsb) {¤			long stub_count = snsb->stub_count();¤			GDS_ASSERT (stub_count >= -1); //ses: incredible!!! algorithm error¤¤			unsigned long ind = abs(stub_count);¤¤			if (index < ind) {¤				if (!index) {¤					return StaticNode::_duplicate (cp);¤				}¤				return snsb->get_at (index);¤			} else {¤				index -= ind;¤				if (!index) {¤					return cp->m_next._sretn ();¤				}¤			}¤¤			if (ind != 1 && snsb->has_pair()) {¤				index--;¤				cp = cp->m_next.in ();¤			}¤		} else {¤			index--;¤		}¤	}¤	¤	return 0;¤}¤¤void StaticNode::invalidate_children_count () const {¤	ChildrenMapSingleton::instance ()->invalidate (this);¤}¤¤unsigned long StaticNode::parent_level (const StaticNode* node) const {¤	unsigned long ret = 0;¤	const StaticNode* parent = this;¤¤	while (parent = parent->m_parent) {¤		ret++;¤		if (parent == node) {¤			return ret;¤		}¤	}¤	return 0;¤}¤¤long StaticNode::get_index_from_parent () const {¤	long count = 1;¤	StaticNode* p = this->m_prev;¤¤	long i;¤	bool negative_stub = false;¤	for (; p; p = p->m_prev) {¤		i = p->get_nodes_count_for_me ();¤		if (negative_stub) {¤			if (i > 1) {¤				i = 1;¤			}¤			negative_stub = false;¤		}¤		if (i < 0) {¤			negative_stub = true;¤			i = -i;¤		}¤		count += i;¤	}¤¤	return count;¤}¤¤/*unsigned long NodeBase::index () const {¤	unsigned long ret = 0;¤	const StaticNode* node = this;¤		¤	for (const StaticNode* cp = m_prev; cp; cp = cp->m_prev) {		¤			¤		StaticNodeStubBase* snsb = dynamic_cast<StaticNodeStubBase*>(cp);¤¤		if (snsb) {¤			long sc = snsb->stub_count();¤			if (sc < 0) {¤				ret += -sc;¤			} else {¤				ret++;¤			}¤		} else {¤			ret++;			¤		}¤	}¤¤	return ret;¤}*/¤¤bool StaticNode::is_first_child_of_child_of_root () const {¤	//is_first_child¤	if (this->m_prev) {¤		return false;¤	}¤¤	//is_child_of_child_of_root¤	StaticNode* parent = this->m_parent;¤	if (!parent) {¤		return false;¤	}¤	StaticNode* maybe_root = parent->m_parent;¤	if (!maybe_root) {¤		return false;¤	}¤¤	return !maybe_root->m_parent;¤}¤//#UC END# *4501367B01C5*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4501367B01C5_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4501367B01C5_DESTR_BODY*¤	//LOG_D (("StaticNode[%d]::~StaticNode", this));¤	StaticNode* n = m_first_child.ptr();¤	if (n) {¤		while (n && n->ref_count() == 1) {¤			n = n->m_next.ptr();¤		}¤		if (!n) {¤			n = m_last_child;¤		}¤¤		for (; n; n = n->m_prev) {¤			n->m_next = 0;¤		}¤¤		// reqursive occures!  why???¤	}¤¤	ChildrenMapSingleton::instance ()->invalidate(this);¤	//REMOVE_OBJECT_WATCHER¤	//#UC END# *4501367B01C5_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4501367B01C5_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4501367B01C5_CUSTOM_INCLUDES*¤#include "shared/Core/mng/CacheMap.h"¤//#UC END# *4501367B01C5_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4501367B01C5*"
		    value      	(value Text 
|//#UC START# *4501367B01C5*¤	// exceptions¤	class ConcreteClassMustImplement {¤	};¤¤public:¤	static const StaticNode* shift_prev (const StaticNode*& node) {¤		return node = node->m_prev;¤	}¤¤	static StaticNode* shift_prev (StaticNode*& node) {¤		return node = node->m_prev;¤	}¤¤	static const StaticNode* shift_next (const StaticNode*& node) {¤		return node = node->m_next.ptr();¤	}¤¤	static StaticNode* shift_next (StaticNode*& node) {¤		return node = node->m_next.ptr();¤	}¤¤	static const StaticNode* shift_up (const StaticNode*& node) {¤		return node = node->m_parent;¤	}¤¤	static StaticNode* shift_up (StaticNode*& node) {¤		return node = node->m_parent;¤	}¤¤	struct VoidCloneFilter {¤		static bool is_meet (const StaticNode*) {¤			return true;¤		}¤	};¤¤	template <class _StaticNodeType, class _StaticNodeFactory, class _CloneFilter>¤	static _StaticNodeType* clone_tree (const _StaticNodeType* source, _StaticNodeFactory* factory, const _CloneFilter& filter) {¤		Core::Var<_StaticNodeType> new_node = factory->make_copy(source);¤		¤		_StaticNodeType* source_ch = dynamic_cast<_StaticNodeType*>(source->m_last_child);¤		while (source_ch) {¤			if (filter.is_meet (source_ch)) {¤				new_node->insert_front_child (clone_tree (source_ch, factory, filter));¤			}¤			source_ch = dynamic_cast<_StaticNodeType*>(source_ch->m_prev);¤		}¤¤		return new_node._retn();¤	}¤¤	template <class _EachFunc, class _EachArgs>¤	void for_each (_EachFunc& func, _EachArgs& res) {¤		func.each_func (this, res);¤		¤		StaticNode* ch = m_last_child;¤		while (ch) {¤			ch->for_each (func, res);¤			ch = ch->m_prev;¤		}¤	}¤¤	template <class _EachFunc, class _EachArgs>¤	void for_each (_EachFunc& func, _EachArgs& res) const {¤		func.each_func (this, res);¤		¤		StaticNode* ch = m_last_child;¤		while (ch) {¤			ch->for_each (func, res);¤			ch = ch->m_prev;¤		}¤	}¤¤protected:¤	unsigned get_parents_count () const;¤¤public:¤	virtual const StaticNode* child_by_index (unsigned long index) const; // NOT CONSTRUCTOR!!!!¤	virtual StaticNode* child_by_index (unsigned long index) { // NOT CONSTRUCTOR!!!!¤		return const_cast<StaticNode*>(((const StaticNode*const)this)->child_by_index (index));¤	}¤¤	virtual StaticNode* create_data_copy () const {¤		throw ConcreteClassMustImplement ();¤	}¤¤	virtual StaticNode* remove_me_and_siblings (unsigned long& count) {¤		StaticNode_var ret = StaticNode::_duplicate(m_next.ptr());¤		this->remove_from_tree ();¤		count--;¤		return ret._retn();¤	}¤¤	virtual long get_nodes_count_for_me () {¤		return 1;¤	}¤¤	virtual long get_index_from_parent () const;¤¤ ¤public:¤	StaticNode ();¤¤#ifdef _DEBUG¤	static bool s_need_print;¤¤	void print_tree() const {¤		if (s_need_print) {¤			StaticNode* root = const_cast<StaticNode*>(this);¤			while (root->m_parent) {¤				root = root->m_parent;¤			}¤¤			root->draw_node(0, 0);¤			root->print_childs(0);¤		}¤	}¤¤	virtual void draw_node (unsigned level, unsigned index) const {¤		// empty¤	};¤¤	void print_childs (unsigned level) const {¤		level++;¤		unsigned index = 0;¤		for (const StaticNode* n = m_first_child.ptr(); n; n = n->m_next.in ()) {¤			n->draw_node(level, index++);¤			n->print_childs(level);¤		}¤	}¤#endif¤¤	bool is_it_higher (const StaticNode* it) const {¤		if (it == this || !it) {¤			return false;¤		}¤		¤		// balance levels¤		unsigned my_level = this->level();¤		unsigned it_level = it->level();¤¤		const StaticNode* my_branch = this;¤		const StaticNode* it_branch = it;¤¤		long delta = my_level - it_level;¤		if (delta > 0) {¤			for (; delta; delta--) {¤				StaticNode::shift_up (my_branch);¤			}¤		} else if (delta < 0) {¤			for (; delta; delta++) {¤				StaticNode::shift_up (it_branch);¤			}¤		}¤¤		if (my_branch == it_branch) {¤			return my_level - it_level > 0;¤		}¤¤		//find common parent¤		while (it_branch->m_parent != my_branch->m_parent) {¤			StaticNode::shift_up (my_branch);¤			StaticNode::shift_up (it_branch);¤		}¤¤		//gos up from smaler adress¤		if (my_branch > it_branch) {¤			const StaticNode* tmp_my_branch = my_branch;¤			while (tmp_my_branch) {¤				StaticNode::shift_prev (tmp_my_branch);¤				if (tmp_my_branch == it_branch) {¤					return false;¤				}¤			}¤			return true;¤		} else {¤			const StaticNode* tmp_it_branch = it_branch;¤			while (tmp_it_branch) {¤				StaticNode::shift_prev (tmp_it_branch);¤				if (tmp_it_branch == my_branch) {¤					return true;¤				}¤			}¤			return false;¤		}		¤	}¤¤	bool is_my_child (const StaticNode* child) {¤		for (const StaticNode* c = m_last_child; c; c = c->m_prev) {¤			if (c == child) {¤				return true;¤			}¤		}¤		return false;¤	}¤¤	/* [Tree DEBUG Start]¤	bool is_my_child_ex (const StaticNode* child, std::vector<const StaticNode*>& vec) {¤		for (const StaticNode* y = m_last_child; y; y = y->m_prev) {¤			int x = 0;¤		}¤¤		for (const StaticNode* c = m_last_child; c; c = c->m_prev) {¤			vec.push_back (c);¤			if (c == child) {¤				return true;¤			}¤		}¤		return false;¤	}¤	*/ ¤	// [Tree DEBUG End]¤¤	virtual bool is_equal (const StaticNode* e) const {¤		return e == this;¤	}¤	¤	// доступ к структуре¤	const StaticNode* root () const {¤		const StaticNode* node = this;¤		while (node->m_parent) {¤			node = node->m_parent;¤		}¤		return StaticNode::_duplicate(node);¤	}¤	¤	StaticNode* root () {¤		StaticNode* node = this;¤		while (node->m_parent) {¤			node = node->m_parent;¤		}¤		return StaticNode::_duplicate(node);¤	}¤¤	const StaticNode* parent () const {¤		return StaticNode::_duplicate (m_parent);¤	}¤¤	StaticNode* parent () {¤		return StaticNode::_duplicate (m_parent);¤	}¤¤	virtual const StaticNode* next () const {¤		return m_next._sretn();¤	}¤¤	virtual StaticNode* next () {¤		return m_next._sretn();¤	}¤¤	virtual StaticNode* prev () {¤		return StaticNode::_duplicate (m_prev);¤	}¤¤	virtual const StaticNode* prev () const {¤		return StaticNode::_duplicate (m_prev);¤	}¤¤	bool is_prev (const StaticNode* prev) const {¤		return prev ? m_prev == prev : false;¤	}¤¤	const StaticNode* first_child () const {¤		return m_first_child._sretn();¤	}¤¤	StaticNode* first_child () {¤		return m_first_child._sretn();¤	}¤¤	StaticNode* last_child () {¤		return StaticNode::_duplicate (m_last_child);¤	}¤¤	const StaticNode* last_child () const {¤		return StaticNode::_duplicate (m_last_child);¤	}¤¤	bool is_last () const {¤		return m_next.ptr() == 0;¤	}¤¤	// Первый элемент.¤	bool is_first () const {¤		return m_prev == 0;¤	}¤¤	// Есть ли дочерние элементы.¤	bool has_children () const {¤		return m_last_child != 0;¤	}¤¤	/*bool has_sub_child () const {¤		for (StaticNode* cp = m_last_child; cp; cp = cp->_prev()) {¤			if (cp->m_last_child) {¤				return true;¤			}¤		}¤		return false;¤	}*/¤¤	bool is_root() const {¤		return m_parent == 0;¤	}¤¤	// создание структуры¤	void insert_back_child (StaticNode* node) {  // в конец списка детей¤		if (this->m_last_child != 0) {¤			m_last_child->insert_next(node);¤		} else {¤			this->insert_front_child(node);¤		}¤	}¤¤	void parent_is_dead () {¤		m_parent = 0;¤	}¤¤	void insert_front_child (StaticNode* node) {  // в начало списка детей¤		if (m_first_child.ptr()) {¤			m_first_child->insert_prev(node);¤		} else {¤			m_first_child = node;¤			m_last_child = node;			¤			node->m_parent = this;¤			this->invalidate_children_count();¤		}¤	}¤	void insert_next (StaticNode* node);  // справо от себя¤	void insert_prev (StaticNode* node);  // слево от себя¤¤	// изменение (удаление/перемещение)¤	void remove_from_tree ();¤	void move_to_destination (StaticNode* dest_node); // work inside one tree¤	void copy_to_destination (StaticNode* dest_node) const; // recursive, work inside one tree¤¤	// make node copy¤	StaticNode* copy () const;¤	// очистить все дочерние узлы¤	void clear_children ();¤¤	// доступ к атрибутам узла¤	virtual unsigned long level () const; //получить уровень ноды ¤	¤	unsigned long children_count () const { //количество непосредственных детей ¤		return m_last_child ? ChildrenMapSingleton::instance ()->get_value (this) : 0;¤	}¤¤	unsigned long parent_level (const StaticNode* node) const; // уровень вложенности в node, 0 если node не является предком¤		¤	virtual bool operator == (const StaticNode& c) const {¤		return this == &c;¤	}¤	virtual bool operator != (const StaticNode& c) const {¤		return this != &c;¤	}¤	virtual bool operator < (const StaticNode& c) const {¤		return this < &c;¤	}¤¤	virtual void invalidate_children_count () const;¤¤protected:¤	virtual unsigned long _load_children_count() const;¤¤protected:¤	friend class StaticNodeStubBase; // GARANT_FRIEND¤¤	struct ChildrenCountLoader {¤		static unsigned long load_value (const StaticNode* node) {¤			return node->_load_children_count();¤		}¤	};¤¤public:¤	typedef Core::CacheMap<const StaticNode*, unsigned long, ChildrenCountLoader> ChildrenMap;¤	typedef ACE_Singleton <StaticNode::ChildrenMap, ACE_SYNCH_RECURSIVE_MUTEX> ChildrenMapSingleton;¤	¤protected:¤	StaticNode* m_parent;¤	StaticNode_var m_next;¤	StaticNode* m_prev;¤	StaticNode_var m_first_child;¤	StaticNode* m_last_child;¤¤#ifdef _DEBUG¤	//static long s_id;¤	//long m_id__;¤public:¤	//void _dump (FILE* to_dump) const {¤	//	fprintf (to_dump, "StaticNode [%d] id:[%d]", this, m_id__);¤	//}¤#endif¤¤public:¤	bool is_first_child_of_child_of_root () const;¤//#UC END# *4501367B01C5*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/GCL/data/StaticNode.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/StaticNode.h")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNode|4501367B01C5
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Refcount"
		    value      	"standard")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16662223031"))
	    quid       	"4501367B01C5"
	    documentation 	"реализация ноды дерева (двух-направленные связи родитель->ребенок; лево->право)"
	    stereotype 	"SimpleClass"
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657705799"))
		    quid       	"45018B6503D8"
		    stereotype 	"uses"
		    supplier   	"Logical View::shared::GCL::data::StaticNodeStubBase"
		    quidu      	"450136B500FA"))
	    language   	"MDA Generator")
	(object Class "StaticNodeStubBase"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450136B500FA_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *450136B500FA_CUSTOM_INCLUDES*¤//#UC END# *450136B500FA_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450136B500FA*"
		    value      	"//#UC START# *450136B500FA*¤//#UC END# *450136B500FA*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450136B500FA_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *450136B500FA_DESTR_BODY*¤	//#UC END# *450136B500FA_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450136B500FA_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *450136B500FA_CUSTOM_INCLUDES*¤//#UC END# *450136B500FA_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450136B500FA*"
		    value      	(value Text 
|//#UC START# *450136B500FA*¤	virtual long stub_count () const = 0;¤	virtual long stub_ind () const = 0;¤	virtual bool has_pair () const = 0;¤	virtual StaticNodeStubBase* const get_at (long ind) const = 0;¤¤	virtual StaticNode* transform_to_real_node () = 0;¤	void transform_to_real_node (¤		StaticNode* real_node¤		, StaticNodeStubBase* prev_sibbling_stub¤		, StaticNodeStubBase* next_sibbling_stub¤	) {¤		if (!real_node) {¤			GDS_ASSERT (real_node);¤			return;¤		}¤		GDS_ASSERT (!m_real_node);¤		/*LOG_D ((¤			"transform_to_real_node (%d,%d) prev(%d,%d) next (%d,%d)"¤			, this->stub_count()¤			, this->stub_ind()¤			, prev_sibbling_stub ? prev_sibbling_stub->stub_count() : 0¤			, prev_sibbling_stub ? prev_sibbling_stub->stub_ind() : 0¤			, next_sibbling_stub ? next_sibbling_stub->stub_count() : 0¤			, next_sibbling_stub ? next_sibbling_stub->stub_ind() : 0¤		));¤¤		bool need_print = true;*/¤		/*if (next_sibbling_stub && next_sibbling_stub->stub_count() > 0 && next_sibbling_stub->stub_ind() == 1) {¤			this->print_tree();¤			need_print = true;¤		}*/¤									¤		m_real_node = StaticNode::_duplicate(real_node);¤		this->correct_tree (prev_sibbling_stub, next_sibbling_stub);¤¤		/*if (need_print) {¤			LOG_D (("TREE SNAP after transform_to_real_node (...)"));¤			m_real_node->print_tree();¤		}*/¤	}¤¤protected:¤	StaticNodeStubBase() : m_real_node(0) {¤	}¤¤	const StaticNode* child_by_index (unsigned long index) const {¤		if (!m_real_node) {¤			m_real_node = const_cast<StaticNodeStubBase*>(this)->transform_to_real_node ();¤		}¤		return m_real_node->child_by_index (index);¤	}¤¤	inline GCL::StaticNode* real_node_prev () const {¤		return m_real_node->m_prev;¤	}¤¤	inline GCL::StaticNode_var& real_node_next () const {¤		return m_real_node->m_next;¤	}¤¤	virtual void correct_tree (StaticNodeStubBase* prev_sibbling_stub, StaticNodeStubBase* next_sibbling_stub) = 0;¤¤protected:¤	mutable StaticNode* m_real_node;¤¤//#UC END# *450136B500FA*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/GCL/data/StaticNodeStubBase.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/StaticNodeStubBase.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStubBase|450136B500FA
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16662223967"))
	    quid       	"450136B500FA"
	    documentation 	"базовый класс для StaticNodeStub"
	    stereotype 	"SimpleClass"
	    superclasses 	(list inheritance_relationship_list
		(object Inheritance_Relationship
		    quid       	"450136BC008C"
		    supplier   	"Logical View::shared::GCL::data::StaticNode"
		    quidu      	"4501367B01C5"))
	    language   	"MDA Generator")
	(object Parameterized_Class "StaticNodeStub"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450136CE01F4_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *450136CE01F4_CUSTOM_INCLUDES*¤#include "shared/Core/mng/PoolObjectManager.h"¤#include "shared/GCL/data/StaticNodeMng.h"¤¤namespace GCL {¤struct NullStubPostProcess {¤	void operator () (GCL::StaticNode*, GCL::StaticNode*) {}¤};¤}¤//#UC END# *450136CE01F4_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450136CE01F4*"
		    value      	(value Text 
|//#UC START# *450136CE01F4*¤	template <typename StubPostProcess>¤	static void make_as_back_child (GCL::StaticNode* parent, unsigned long count, StaticNodeMng* mng, StubPostProcess post_process) {¤		GDS_ASSERT (count); ¤¤		_StubImpl* st1 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤		_StubImpl* st2 = 0;¤¤		if (count>1) {¤			st2 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤			count--;¤		}¤¤		SharedData_box d = new SharedData(count, st1, st2, mng);¤		st1->init (d, 0, 0);¤		parent->insert_back_child(st1);¤		¤		if (st2) {¤			d = new SharedData(-static_cast<long>(count), st2, st1, mng);¤			st2->init(d, 0, 0);¤			parent->insert_back_child(st2);¤		}¤		¤		post_process (st1, st2); // may be we need to add similar 'processer' to other 'make_as_x_child'¤	}¤¤	static void make_as_front_child (GCL::StaticNode* parent, unsigned long count, StaticNodeMng* mng) {¤		GDS_ASSERT (count); ¤¤		_StubImpl* st1 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤		_StubImpl* st2 = 0;¤¤		if (count>1) {¤			st2 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤			count--;¤		}¤¤		SharedData_box d = new SharedData(count, st1, st2, mng);¤		st1->init (d, 0, 0);¤		parent->insert_front_child(st1);¤		¤		if (st2) {¤			d = new SharedData(-static_cast<long>(count), st2, st1, mng);¤			st2->init(d, 0, 0);¤			st1->insert_next(st2);¤		}¤	}¤¤¤	static void make_as_next_sibling (GCL::StaticNode* left_sibling, unsigned long count, StaticNodeMng* mng) {¤		GDS_ASSERT (count); ¤¤		StaticNodeStub* sns = dynamic_cast<StaticNodeStub*> (left_sibling);¤		if (sns) {¤			sns->resize_stub (count);¤		} else {¤			_StubImpl* st1 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤			_StubImpl* st2 = 0;¤¤			if (count>1) {¤				st2 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤				count--;¤			}¤¤			SharedData_box d = new SharedData(count, st1, st2, mng);¤			st1->init (d, 0, 0);¤			left_sibling->insert_next(st1);¤			¤			if (st2) {¤				d = new SharedData(-static_cast<long>(count), st2, st1, mng);¤				st2->init(d, 0, 0);¤				st1->insert_next(st2);¤			}¤		}¤	}¤¤	static void make_as_prev_sibling (GCL::StaticNode* sibling, unsigned long count, StaticNodeMng* mng) {¤		GDS_ASSERT (count); ¤¤		StaticNodeStub* sns = dynamic_cast<StaticNodeStub*> (sibling);¤		if (sns) {¤			GDS_ASSERT (false); // need to check this code¤			sns->resize_stub (count);¤		} else {¤			_StubImpl* st1 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤			_StubImpl* st2 = 0;¤¤			if (count>1) {¤				st2 = NodeStubPool::instance()->new_obj();//new _StubImpl ();¤				count--;¤			}¤¤			SharedData_box d = new SharedData(count, st1, st2, mng);¤			st1->init (d, 0, 0);¤					¤			if (st2) {¤				d = new SharedData(-static_cast<long>(count), st2, st1, mng);¤				st2->init(d, 0, 0);¤				sibling->insert_prev(st2);¤				st2->insert_prev(st1);¤			} else {¤				sibling->insert_prev(st1);¤			}¤		}¤	}¤¤public:	¤	bool has_pair () const {¤		return m_data->negative_pair != 0;¤	}¤¤	long stub_count () const {¤		return m_data->stub_count;¤	}¤¤	long stub_ind () const {¤		return m_ind;¤	}¤¤	typedef Core::Var<StaticNodeStub> StaticNodeStub_var;¤¤	StaticNodeStubBase* const get_at (long ind) const {¤		GDS_ASSERT (m_data->stub_count > 0 ? ind < m_data->stub_count && ind >= 0 : ind > m_data->stub_count && ind <= 0);¤		GDS_ASSERT (ind != m_ind);¤		¤		return this->make(ind);		¤	}¤¤	virtual StaticNode* transform_to_real_node () {¤		¤		//LOG_D (("TRANSFORM_TO_REAL_NODE (%d,%d)", this->stub_count(), this->stub_ind()));¤		//m_data->owner->m_parent->print_tree ();¤		¤		StaticNode* ret_val = m_real_node;¤¤		if (!m_real_node) {¤			bool am_i_positive = m_data->stub_count > 0;¤			long offset = am_i_positive ? m_ind + 1 : m_ind - 1;¤			const GCL::StaticNode* point;¤			¤			if (am_i_positive) {¤				point = m_data->owner->m_prev;¤				if (!point) {¤					offset--;¤				}¤			} else {¤				if (m_data->negative_pair) {¤					point = m_data->negative_pair->m_prev;¤					offset = m_ind - m_data->stub_count + 1;¤				} else {¤					point = m_data->owner->m_prev;¤					offset = m_ind - m_data->stub_count;¤				}				¤			}¤¤¤			// при входе в make_real_node point должен указывать на реальную ноду¤			// (т.е. должен приводится к NodeBase: dynamic_cast<Nodebase*> (point) != 0¤			// для этого необходим рекурсивный проход по предыдушим нодам с коррекцией offset¤			// последняя версия этого цикла писалась для [$278832098]¤			¤			while (point && dynamic_cast<const StaticNodeStub*> (point)) {¤				¤				GDS_ASSERT (am_i_positive); // хрен знает чего случиться, если мы сюда попадем с am_i_positive == false¤				                            // может быть надо крутить такой же цикл но с уменьшением offset'а¤				                            // а и может двигаться надо не вверх а вниз ? ...¤				¤				// тут мы на нижей паре заглушки или на одинарной заглушке¤				if (!StaticNode::shift_prev (point)) {¤					break;                                          // достигли parent'а, т.е. вся ветка сверху - одни заглушки¤				}¤			¤				const StaticNodeStub* stub = dynamic_cast<const StaticNodeStub*> (point);¤				¤				if (!stub) {¤					++offset;                                       // до сдвига мы были на одинарной заглушке,¤					break;                                          // сейчас на реальной ноде => выходим¤				}¤¤				// тут мы на верхней паре заглушки или на предыдущей одинарной заглушке¤				if (stub->stub_count () == 1)  {                    ¤					offset += stub->stub_count ();                  // одинарная заглушка¤				} else {                                            ¤					offset += stub->stub_count () + 1;              // верхняя пара заглушки¤					StaticNode::shift_prev (point);¤				}¤			}¤			¤			ret_val = m_real_node = m_data->mng->make_real_node (m_data->owner->m_parent, point, offset, this);¤			GDS_ASSERT (m_real_node);¤¤			this->correct_tree (0, 0);			¤		}¤		¤		//LOG_D (("TREE SNAP after transform_to_real_node ()"));¤		//m_real_node->print_tree ();¤¤		return ret_val;¤	}¤	¤	virtual StaticNode* remove_me_and_siblings (unsigned long& count) {¤		GDS_ASSERT (count);¤		GDS_ASSERT (m_ind >= 0); // обработка виртуальных отрицательных нод не реализована.¤		// Вернее сейчас удаление виртуальной отрицательной ноды ¤		// возможно, только если она последняя. Это может быть, если¤		// в дереве 61 нода (по умолчанию загружается 30 нод сверху и 30 снизу)¤		// См. ошибку 22750. Чтобы удалить эту ноду вставили проверку на¤		// this->stub_count () == -1 для случая с единственной нодой заглушкой¤		¤		// single stub node ¤		if ((this->stub_count () == 1 || this->stub_count () == -1)  && !this->has_pair ()) {¤			StaticNode_var ret = StaticNode::_duplicate (m_next.ptr ());¤			this->remove_from_tree ();¤			count--;¤			return ret._retn();¤		} ¤¤		// we have to do with stub pair further¤		GDS_ASSERT (this->has_pair ()); ¤		¤		// попали на нижнюю (отрицательную) заглушку¤		if (m_ind == 0 &&  this->stub_count () < 0) {¤			count--;¤			StaticNode_var ret = StaticNode::_duplicate (m_next.ptr ());¤			long new_stub_count = this->stub_count () + 1; // увеличиваем отрицательное значение (по модулю - уменьшаем)¤¤			if (new_stub_count == 0) { // удаляем нижнюю заглушку¤				m_data->negative_pair->m_data->negative_pair = 0;¤				this->remove_from_tree ();¤			} else {¤				m_data->stub_count = new_stub_count;¤				m_data->negative_pair->m_data->stub_count = -new_stub_count;¤			}¤			¤			return ret._retn();¤		}¤		¤		¤		¤		// remove pair at all¤		if (m_ind == 0 && static_cast<long> (count) > this->stub_count ()) { ¤			count -= this->stub_count () + 1;¤			StaticNode_var ret = StaticNode::_duplicate (m_data->negative_pair->m_next.ptr ());¤			GDS_ASSERT (m_data->owner == this);¤			m_data->negative_pair->remove_from_tree ();¤			this->remove_from_tree ();¤			return ret._retn();¤		}¤		¤		// modify stub pair¤		long stub_count = this->stub_count ();¤		long count_to_delete = count;¤		¤		// новый stub_count = индекс + положительная разница между величиной хвоста и кол-вом удаляемых¤		long new_stub_count = m_ind + (((stub_count - m_ind) - count_to_delete) > 0 ? (stub_count - m_ind) - count_to_delete : 0);¤		// модифицированный count = положительной разнице между кол-вом удаляемых и величиной хвоста¤		long new_count_to_delete = (count_to_delete - (stub_count - m_ind)) > 0 ? count_to_delete - (stub_count - m_ind) : 0;¤		¤		StaticNode_var ret = StaticNode::_duplicate (m_data->negative_pair->m_next.ptr ());¤¤		// если удаляем от верхней заглушки кол-во эл-тов равное stub_count => остается единственная (нижняя) заглушка¤		if (m_ind == 0 && static_cast<long> (count) == this->stub_count ()) {¤			new_stub_count += 1; // требуется коррекция stub_count, высчитанного по формуле выше (сказывается неявное участие второй заглушки)¤			m_data->negative_pair->remove_from_tree ();¤			m_data->negative_pair = 0;¤			GDS_ASSERT (new_stub_count == 1);¤			GDS_ASSERT (new_count_to_delete == 0);¤		}¤		¤		// если удаляем с первого эл-та по нижнюю заглушку включительно => остается единственная (верхняя) заглушка¤		if (m_ind == 1 && static_cast<long> (count) >= this->stub_count ()) {¤			new_count_to_delete -= 1; // требуется коррекция new_count_to_delete, высчитанного по формуле выше (неявное участие второй заглушки)¤			m_data->negative_pair->remove_from_tree ();¤			m_data->negative_pair = 0;¤			GDS_ASSERT (new_stub_count == 1);¤		}¤		¤		// основная коррекция данных¤		m_data->stub_count = new_stub_count;¤		count = new_count_to_delete;¤		¤		if (m_data->negative_pair) {¤			m_data->negative_pair->m_data->stub_count = -new_stub_count;¤		}¤		¤		// если последний удаляемый внутри интервала, возвращаем указаталь на эл-т внутри интевала¤		if (static_cast<long> (count) < this->stub_count () - m_ind) { ¤			if (m_ind) {¤				ret = m_data->owner->get_at (m_ind);¤			} else {¤				ret = GCL::StaticNode::_duplicate(this);¤			}¤		}¤		¤		GDS_ASSERT (this->stub_count () > 0);¤	¤		return ret._retn();¤	}¤¤	void correct_tree (StaticNodeStubBase* prev_sibbling_stub, StaticNodeStubBase* next_sibbling_stub) {¤		bool am_i_positive = m_data->stub_count > 0;			¤		long offset = am_i_positive ? m_ind + 1 : m_ind - 1;¤¤		long remain_count = m_data->stub_count - offset;¤		¤		if (remain_count) {			¤			StaticNodeStub* l;¤			if (am_i_positive ? next_sibbling_stub : prev_sibbling_stub) {¤				l = dynamic_cast<StaticNodeStub*>(am_i_positive ? next_sibbling_stub : prev_sibbling_stub);¤				GDS_ASSERT (l);¤				StaticNode::_duplicate (l);¤			} else {¤				l = NodeStubPool::instance()->new_obj();¤			}¤¤			{¤				SharedData_box data (new SharedData(remain_count, l, m_data->negative_pair, m_data->mng));¤				l->init (data, 0, this);¤				if (m_data->negative_pair) {¤					m_data->negative_pair->reset_pair(data.in());¤				}¤			}				¤			¤			if (am_i_positive) {¤				m_data->owner->insert_next (l);¤			} else {¤				m_data->owner->insert_prev (l);¤			}¤		} else {¤			if (m_data->negative_pair) {¤				m_data->negative_pair->reset_pair(0);¤			}¤		}¤¤		if (am_i_positive) {¤			m_data->owner->insert_next (m_real_node);¤		} else {¤			m_data->owner->insert_prev (m_real_node);¤		}¤¤		if (m_ind) { // i am slave¤			m_data->stub_count = am_i_positive ? m_ind - 1 : m_ind + 1;¤			¤			if (m_data->stub_count) {¤				StaticNodeStub* l;¤				if (am_i_positive ? prev_sibbling_stub : next_sibbling_stub) {¤					l = dynamic_cast<StaticNodeStub*>(am_i_positive ? prev_sibbling_stub : next_sibbling_stub);¤					GDS_ASSERT (l);¤				} else {¤					l = NodeStubPool::instance()->new_obj();¤				}¤¤				{¤					SharedData_box data (new SharedData(-m_data->stub_count, l, m_data->owner, m_data->mng));¤					l->init (data, 0, this);¤					m_data->owner->reset_pair(data.in());¤				}¤¤				if (am_i_positive) {¤					m_data->owner->insert_next (l);¤				} else {¤					m_data->owner->insert_prev (l);¤				}¤			} else {¤				m_data->stub_count = am_i_positive ? 1 : -1;¤				m_data->owner->reset_pair (0);¤			}¤		}¤¤		const_cast<StaticNodeStub*>(this)->remove_from_tree();		¤	}¤¤	virtual GCL::StaticNode* next () {¤		return const_cast<GCL::StaticNode*>(((const StaticNodeStub*const)this)->next());¤	}¤	virtual const GCL::StaticNode* next () const {¤		if (m_real_node) {¤			return m_real_node->next();			¤		}  ¤¤		if (m_data->stub_count > 0) {¤			if (m_data->owner == this) {¤				if (m_data->stub_count > 1) {¤					return this->make(1);¤				} else {¤					return m_next._sretn();¤				}¤			} else {¤				if (m_ind < m_data->stub_count - 1) {¤					return this->make (m_ind + 1);¤				} else {¤					return m_data->owner->m_next._sretn();¤				}¤			}¤		} else {¤			if (m_data->owner == this) {¤				return m_next._sretn();¤			} else {¤				return this->make (m_ind + 1);¤			}¤		}¤	}¤¤	virtual GCL::StaticNode* prev () {¤		return const_cast<GCL::StaticNode*>(((const StaticNodeStub*const)this)->prev());¤	}¤	virtual const GCL::StaticNode* prev () const {¤		if (m_real_node) {¤			return m_real_node->prev();¤		}¤¤		if (m_data->stub_count > 0) {¤			if (m_data->owner == this) {¤				return Core::IObject::_duplicate(m_prev);¤			} else {¤				return this->make (m_ind - 1);¤			}¤		} else {¤			if (m_data->owner == this) {¤				if (m_data->stub_count < -1) {¤					return this->make (m_ind - 1);¤				} else {¤					return Core::IObject::_duplicate(m_prev);¤				}¤			} else {¤				if (m_ind > m_data->stub_count + 1) {¤					return this->make (m_ind - 1);¤				} else {¤					return Core::IObject::_duplicate(m_data->owner->m_prev);¤				}¤			}¤		}¤	}¤¤	virtual bool is_equal (const StaticNode* e) const {		¤		return (e == this) || (m_real_node && m_real_node == e);¤	}¤¤	bool is_last () {¤		if (m_real_node) {¤			return m_real_node->is_last();¤		}¤		¤		if (m_data->stub_count > 0) {¤			if (m_data->owner == this) {¤				if (m_data->stub_count > 1) {¤					return false;¤				} else {¤					return m_next.ptr() == 0;¤				}¤			} else {¤				if (m_ind < m_data->stub_count - 1) {¤					return false;¤				} else {¤					return m_data->owner->m_next.ptr() == 0;¤				}¤			}¤		} else {¤			if (m_data->owner == this) {¤				return m_next.ptr() == 0;¤			} else {¤				return false;¤			}¤		}¤	}¤¤	// Первый элемент.¤	bool is_first () {¤		if (m_real_node) {¤			return m_real_node->is_first();¤		}¤		¤		if (m_data->stub_count > 0) {¤			if (m_data->owner == this) {¤				return m_prev == 0;¤			} else {¤				return false;¤			}¤		} else {¤			if (m_data->owner == this) {¤				if (m_data->stub_count < -1) {¤					return false;¤				} else {¤					return m_prev == 0;¤				}¤			} else {¤				if (m_ind > m_data->stub_count + 1) {¤					return false;¤				} else {¤					return m_data->owner->m_prev == 0;¤				}¤			}¤		}¤	}¤¤protected:¤	typedef typename Core::PoolObjectManager<_StubImpl>::PoolObjectManagerSingleton NodeStubPool;¤	typedef Core::PoolObjectManager<_StubImpl> Pool;¤	friend Pool;¤¤private:¤	struct SharedData {¤		long stub_count; // кол-во виртуальных ноду внутри заглушки¤		StaticNodeStub* owner; // "основная" заглушка¤		StaticNodeStub* negative_pair; // ссылка на парную "отрицательную" заглушку¤		StaticNodeMng* mng; // ссылка на менеджера нод¤¤		SharedData (¤			long sc¤			, StaticNodeStub* owner¤			, StaticNodeStub* np¤			, StaticNodeMng* m¤		) ¤			: stub_count(sc)¤			, owner(owner)¤			, negative_pair(np)¤			, mng(m) ¤		{¤			GDS_ASSERT (stub_count && owner);			¤		}¤	};¤¤	//typedef Core::Box<SharedData> SharedData_box;¤¤protected:	¤	typedef Core::Box<SharedData> SharedData_box; // GARANT_PRIVATE¤¤	StaticNodeStub () {¤		m_data = 0;¤		m_ind = 0;¤		m_real_node = 0;¤		m_parent = 0;¤	}¤¤	void resize_stub (long delta) {¤		if (m_data->stub_count > 0) {¤			GDS_ASSERT (m_data->stub_count + delta > 1);¤¤			if (m_data->negative_pair) {¤				m_data->stub_count += +delta;¤				m_data->negative_pair->m_data->stub_count += -delta;¤			} else {¤				m_data->stub_count += +delta-1;¤¤				_StubImpl* stub = NodeStubPool::instance ()->new_obj ();¤				SharedData_box shared_data = new SharedData (-delta, stub, m_data->owner, m_data->mng);¤¤				stub->init (shared_data, 0, 0);¤				m_data->negative_pair = stub;¤¤				this->insert_next (stub);¤			}¤		} else {¤			GDS_ASSERT (-m_data->stub_count + delta > 1);¤¤			if (m_data->negative_pair) {¤				m_data->stub_count += -delta;¤				m_data->negative_pair->m_data->stub_count += +delta;¤			} else {¤				m_data->stub_count += -delta+1;¤¤				_StubImpl* stub = NodeStubPool::instance ()->new_obj ();¤				SharedData_box shared_data = new SharedData (+delta, stub, m_data->owner, m_data->mng);¤¤				stub->init (shared_data, 0, 0);¤				m_data->negative_pair = stub;¤¤				this->insert_prev (stub);¤			}¤		}¤	}¤¤¤	virtual long get_nodes_count_for_me () {¤		return this->stub_count ();¤	}¤¤	virtual void init (const SharedData_box& data, long ind, const GCL::StaticNode* master) {¤		m_data = data;¤		m_ind = ind;¤		m_parent = m_data->owner->m_parent;¤		m_real_node = 0;¤		m_next = 0;¤		m_prev = 0;¤		m_first_child = 0;¤		m_last_child = 0;¤		// m_id__ = ++s_id; // debug helper¤	}¤	¤	inline StaticNodeStubBase* make (long ind) const {¤		if (ind) {¤			register StaticNodeStub* ret = NodeStubPool::instance()->new_obj();¤			ret->init(m_data, ind, this);¤			return ret;¤		} else {¤			return Core::IObject::_duplicate(m_data->owner); // !!¤		}¤	}¤¤	void reset_pair (const SharedData* sd) {¤		if (sd) {¤			m_data->negative_pair = sd->owner;¤			m_data->stub_count = - sd->stub_count;¤		} else {¤			m_data->negative_pair = 0;¤			m_data->stub_count = m_data->stub_count > 0 ? 1 : -1;¤		}¤	}¤¤#ifdef _DEBUG¤	virtual void draw_node (unsigned level, unsigned index) const {¤		char buf [1024];¤		¤		unsigned i=0;¤		for(; i < level; i++) {¤			sprintf (buf+i, "\t");¤		}¤		sprintf (buf+i, "%d: Stub[%d] - (%d, %d)", index, (GCL::StaticNode*)this, m_data->stub_count, m_ind);¤		LOG_D ((buf));	¤	}¤¤public:	¤	//void _dump (FILE* to_dump) const {¤	//	fprintf (to_dump, "StaticNodeStub [%d] id:[%d]", this, m_id__);¤	//}¤#endif¤¤protected:¤	virtual void delete_obj () {¤		NodeStubPool::instance()->release_obj(dynamic_cast<_StubImpl*>(this));¤	}¤¤protected:¤	mutable SharedData_box m_data;¤	mutable long m_ind;¤//#UC END# *450136CE01F4*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*450136CE01F4_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *450136CE01F4_CUSTOM_INCLUDES*¤//#UC END# *450136CE01F4_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*450136CE01F4*"
		    value      	"//#UC START# *450136CE01F4*¤//#UC END# *450136CE01F4*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*450136CE01F4_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *450136CE01F4_DESTR_BODY*¤	//#UC END# *450136CE01F4_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450136CE01F4_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *450136CE01F4_DESTR_BODY*¤	//#UC END# *450136CE01F4_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/StaticNodeStub.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (i.h)"
		    value      	"w:/shared/GCL/data/StaticNodeStub.i.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeStub|450136CE01F4
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (i.h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657706951"))
	    quid       	"450136CE01F4"
	    documentation 	"реализация ноды-заглушки, которая может быть вставлена в дерево StaticNode и эмулировать заданное кол-во элементов одного уровня"
	    stereotype 	"SimpleClass"
	    superclasses 	(list inheritance_relationship_list
		(object Inheritance_Relationship
		    quid       	"450136E30290"
		    supplier   	"Logical View::shared::GCL::data::StaticNodeStubBase"
		    quidu      	"450136B500FA"))
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657707623"))
		    quid       	"4501376001B5"
		    stereotype 	"uses"
		    supplier   	"Logical View::shared::GCL::data::StaticNodeMng"
		    quidu      	"450137530213"))
	    language   	"MDA Generator"
	    parameters 	(list Parameters
		(object Parameter "class _StubImpl"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657707253"))
		    quid       	"450137D30186")))
	(object Class "StaticNodeMng"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"abstract")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450137530213_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *450137530213_CUSTOM_INCLUDES*¤//#UC END# *450137530213_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450137530213*"
		    value      	"//#UC START# *450137530213*¤//#UC END# *450137530213*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450137530213_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *450137530213_CUSTOM_INCLUDES*¤//#UC END# *450137530213_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450137530213*"
		    value      	"//#UC START# *450137530213*¤//#UC END# *450137530213*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450137530213_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *450137530213_DESTR_BODY*¤	//#UC END# *450137530213_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/StaticNodeMng.h")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeMng|450137530213
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ImplementSelectType"
		    value      	"all")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"OverloadSelectType"
		    value      	"include")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16662225454"))
	    quid       	"450137530213"
	    documentation 	
|"интерфейс" менеджера нод, умеющий создавать реальные ноды
	    
	    stereotype 	"SimpleClass"
	    operations 	(list Operations
		(object Operation "make_real_node"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4614ACDC008C_45F554750213*"
			    value      	(value Text 
|//#UC START# *4614ACDC008C_45F554750213*¤	GTree::NodePointer parent_point = GTree::ROOT_PARENT_POINT;¤	GTree::NodePointer child_point = GTree::FIRST_CHILD_POINT;¤¤	if (prev) {¤		const DefaultNodeBase* node_prev = dynamic_cast<const DefaultNodeBase*> (prev);¤		GDS_ASSERT (node_prev);¤		¤		child_point = node_prev->get_server_pointer();¤	} ¤	if (parent) {¤		const DefaultNodeBase* node_par = dynamic_cast<const DefaultNodeBase*> (parent);¤		GDS_ASSERT (node_par);¤		¤		parent_point = node_par->get_server_pointer();¤	}¤¤	//SLOG_SHIFT¤	//SLOG_D (("\nMAKE_REAL_NODE (par=%d, ch=%d, offset=%d, stub_count=%d, ind=%d)\n", parent_point, child_point, offset, current_stub ? current_stub->stub_count() : 0, current_stub ? current_stub->stub_ind() : 0));¤¤	/*if (current_stub && current_stub->stub_count() < 0 && child_point == 0 && offset > this->get_load_block_half_size ()) {¤		LOG_D (("catch one"));¤	}*/¤¤	long from = 0;¤	unsigned long in_block_position = 0;¤	this->calc_from_position (offset, child_point, current_stub, from, in_block_position);¤¤	return this->load_nodes_from_server (parent_point, child_point, from, in_block_position, current_stub);¤	//#UC END# *4614ACDC008C_45F554750213*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"4501367B01C5")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657708566"))
		    quid       	"4614ACDC008C"
		    documentation 	"создать ноду"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "parent"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4501367B01C5")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657708883"))
			    quid       	"4614ADA80242"
			    type       	"StaticNode"
			    quidu      	"4501367B01C5")
			(object Parameter "prev"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4501367B01C5")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657709241"))
			    quid       	"4614ADA80271"
			    type       	"StaticNode"
			    quidu      	"4501367B01C5")
			(object Parameter "offset"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFD7002C2")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657709594"))
			    quid       	"4614ADA802AF"
			    type       	"long"
			    quidu      	"3DBFFD7002C2")
			(object Parameter "inout current_stub"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450136B500FA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657709986"))
			    quid       	"4614ADA802EE"
			    type       	"StaticNodeStubBase"
			    quidu      	"450136B500FA"))
		    result     	"StaticNode"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"4501367B01C5")
		(object Operation "pre_remove"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4614AD470109_45F554750213*"
			    value      	(value Text 
|//#UC START# *4614AD470109_45F554750213*¤	const FlagNodeBase* flag_node = dynamic_cast<const FlagNodeBase*> (node);¤	for (NodeFlagMap::iterator it = m_flags_map.begin(); it != m_flags_map.end(); it++) {¤		unsigned removed_count = 0;¤¤		if (flag_node->has_flag (it->first)) {¤			const GCL::StaticNodeStubBase* stub = dynamic_cast<const GCL::StaticNodeStubBase*> (node);¤			if (stub && 1 < stub->stub_count ()) {¤				unsigned long stubs_removed = 0;¤				if (stub->has_pair ()) {¤					if (static_cast<unsigned long> (stub->stub_count ()) < count) {¤						removed_count += stub->stub_count () + 1;¤					} else {¤						if (static_cast<unsigned long> (stub->stub_count ()) == count) {¤							removed_count += stub->stub_count ();¤						} else {¤							removed_count += count;¤						}¤					}¤				} else {¤					if (static_cast<unsigned long> (stub->stub_count ()) < count) {¤						removed_count += stub->stub_count ();¤					} else {¤						removed_count += count;¤					}¤				}¤			} else {¤				removed_count++;¤			}¤		}¤¤		CountMap::iterator f = it->second.find (flag_node);¤¤		if (f != it->second.end ()) {¤			removed_count += f->second;¤			it->second.erase (f);¤		}¤¤		DefaultNodeBase_var parent = const_cast<DefaultNodeBase*> (dynamic_cast<const DefaultNodeBase*>(flag_node->parent ()));¤		for (; parent.ptr (); parent = dynamic_cast<DefaultNodeBase*> (parent->parent ())) {¤			CountMap::iterator f = it->second.find (parent.in ());¤			¤			if (f != it->second.end ()) {¤				f->second -= removed_count;¤				if (f->second == 0) {¤					parent->set_children_flag (it->first, false);¤					it->second.erase (f);¤				}¤			} else {¤				break;¤			}¤		}¤	}¤¤	const DefaultNodeBase* node_base = dynamic_cast<const DefaultNodeBase*> (node);¤	if (node_base) {¤		m_nodes.erase (node_base->get_server_pointer ());¤		LastSelectMap::iterator lsm_it = m_last_select.find (flag_node->get_flags ());¤		if (lsm_it != m_last_select.end () && (lsm_it->second == node_base)) {¤			m_last_select[flag_node->get_flags ()] = 0;¤		}¤	}¤	//#UC END# *4614AD470109_45F554750213*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657710408"))
		    quid       	"4614AD470109"
		    documentation 	"функция вызывается перед удалением?"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "node"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4501367B01C5")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657710717"))
			    quid       	"4614ADBF0177"
			    type       	"StaticNode"
			    quidu      	"4501367B01C5")
			(object Parameter "count"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A6117003E")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657711086"))
			    quid       	"4614ADBF01A5"
			    type       	"unsigned integer"
			    quidu      	"450A6117003E"
			    initv      	"0"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0))
	    language   	"MDA Generator"
	    abstract   	TRUE)
	(object Parameterized_Class "Tree"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450138270399_CUSTOM_INCLUDES*"
		    value      	(value Text "//#UC START# *450138270399_CUSTOM_INCLUDES*¤#include <vector>¤#include <functional>¤#include <map>¤#include <set>¤//#UC END# *450138270399_CUSTOM_INCLUDES*"))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*450138270399*"
		    value      	(value Text 
|//#UC START# *450138270399*¤public:¤	typedef T* Item_ptr;¤	typedef std::vector<Item_ptr> Items;¤¤	class UnknownElement : public Core::Exception {¤		const char* what () const throw () {¤			return "UnknownElement (исключение при обращении к элементу не пренадлежащему дереву)";¤		}¤¤		const char* uid () const /*throw ()*/ {¤			return "GCL::Tree::UnknownElement";¤		}¤	};¤	¤	class AlreadyInTree : public Core::Exception {¤		const char* what () const throw () {¤			return "AlreadyInTree (исключение при попытки вставить элемент уже находящийся в дереве)";¤		}¤¤		const char* uid () const /*throw ()*/ {¤			return "GCL::Tree::AlreadyInTree";¤		}		¤	};¤¤protected:¤	struct Node;¤¤	struct NodeSort : public std::binary_function<const Node*, const Node*, bool> {¤		bool operator()(const Node* const x, const Node* const y) const {¤			return *x->item < *y->item;¤		}¤    };¤	¤	typedef std::vector<Node*> VectorCont;¤	typedef std::set<Node*,NodeSort> SetCont;¤	typedef typename Loki::Select<is_sort, SetCont, VectorCont>::Result NodeChilds;¤¤	struct Node {¤		Node* parent;¤		Item_ptr item;¤		NodeChilds childs;¤		Node () : parent (0), item (0) {¤		}		¤	};¤	typedef std::map<T, Node, Pred> NodeTree;¤¤public:¤	// простой итератор аналогичный stl-евскому¤	// обертка над итератором от map-шаблона, возврящает только ключ аналогично итератору от set-шаблона¤	class iterator {¤		typename NodeTree::iterator m_it;¤	public:¤		iterator ( typename NodeTree::iterator it ) : m_it (it) {¤		}¤		void operator ++ (int) {¤			m_it++;¤		}¤		Item_ptr operator *() {¤			const T& item = (*m_it).first;¤			return (Item_ptr)&item;¤		}¤		bool operator == (iterator it) {¤			return it.m_it == m_it;¤		}¤		bool operator != (iterator it) {¤			return it.m_it != m_it;¤		}¤	};¤¤public:¤	// создает дерево начиная с переданного элемента¤	Tree(const T& root);¤	// добавляет "соседа"¤	void add_sibling (const T& to, const T& subling);¤	// добавляет "ребенка"¤	void add_child (const T& to, const T& child);¤	// возвращает родителя¤	Item_ptr parent (const T& to) const;¤¤	bool is_child_of_parent ( const T& child, const T& parent ) const;¤¤	// возвращает детей¤	Items childs (const T& to) const;¤	// возвращает всех детей (рекурсивно)¤	Items all_childs (const T& to) const;¤	// возвращает всех "братьев"¤	Items sublings (const T& to) const;¤	¤	Item_ptr find (const T& key) {¤		NodeTree::iterator it =  m_tree.find ( key );¤		if ( it != m_tree.end() ) return (*it).second.item;¤		return 0;¤	}¤	¤	void remove (const T& key);¤	// методы для удаления или перемещения элементов пока отсутствют¤	¤	unsigned long get_level (const T& to) const;	¤	unsigned long get_child_count(const T& to) const;¤	unsigned long get_all_child_count (const T& to) const;¤	unsigned long get_index (const T& to) const;¤	unsigned long get_through_index (const T& to) const;¤¤	// возвращает итератор на первый элемент развернутого дерева ¤	// отсортированного по возрастанию элементов¤	iterator begin () {¤		iterator it (m_tree.begin());¤		return it;¤	}¤	¤	// возвращает конец развернутого дерева ¤	iterator end () {¤		iterator it (m_tree.end());¤		return it;¤	}¤¤protected:¤	const Node& find_node (const T& key) const;¤	Node& create_node (const T& key);¤	void collect_childs (const T& to, Items& items) const;¤	void collect_childs_count (const Node* to, unsigned long& count) const;¤¤	void insert_child (Node* to, Node* node, Loki::Int2Type<true>) {¤		to->childs.insert(node);¤	}¤	void insert_child (Node* to, Node* node, Loki::Int2Type<false>) {¤		to->childs.push_back(node);¤	}¤¤	void remove_child (Node* from, Node* node, Loki::Int2Type<true>) {¤		from->childs.erase(node);¤	}¤¤	void remove_child (Node* from, Node* node, Loki::Int2Type<false>) {¤		from->childs.erase (std::remove (from->childs.begin (), from->childs.end (), node), from->childs.end ());¤	}¤¤¤private:¤	NodeTree m_tree;¤//#UC END# *450138270399*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*450138270399_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *450138270399_CUSTOM_INCLUDES*¤//#UC END# *450138270399_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*450138270399*"
		    value      	(value Text 
|//#UC START# *450138270399*¤template <class T, bool is_sort, class Pred>¤Tree<T,is_sort,Pred>::Tree( const T& root) {¤	create_node (root);¤}¤¤template <class T, bool is_sort, class Pred>¤void Tree<T,is_sort,Pred>::add_sibling ( const T& to, const T& subling ) {¤	if ( !to ) return add_child (to, subling);¤	else return add_child (parent(to), subling);		¤}¤¤template <class T, bool is_sort, class Pred>¤void Tree<T,is_sort,Pred>::add_child ( const T& to, const T& child ) {¤	const Node& parent_node = find_node (to);¤	//hask const¤	Node* no_const_parent_node = const_cast<Node*>(&parent_node);¤	Node& node = create_node (child);¤	node.parent = no_const_parent_node;¤	insert_child (no_const_parent_node, &node, Loki::Int2Type<is_sort>());¤}¤¤template <class T, bool is_sort, class Pred>¤typename Tree<T,is_sort,Pred>::Item_ptr Tree<T,is_sort,Pred>::parent ( const T& to ) const {¤	const Node& node = find_node(to);¤	if (!node.parent) return 0;¤	else return node.parent->item;¤}¤¤template <class T, bool is_sort, class Pred>¤bool Tree<T,is_sort,Pred>::is_child_of_parent ( const T& child, const T& parent ) const {¤	const Node* node = &find_node(child);¤	¤	if (!node) {¤		return false;¤	}¤¤	while (node->parent) {¤		if (*(node->parent->item) == parent) {¤			return true;¤		}¤		node = node->parent;¤	}¤	return false;¤}¤¤template <class T, bool is_sort, class Pred>¤typename Tree<T,is_sort,Pred>::Items Tree<T,is_sort,Pred>::childs ( const T& to ) const {¤	const Node& node = find_node(to);¤	Items ch;¤	for (NodeChilds::const_iterator it = node.childs.begin(); it != node.childs.end(); it++) {¤		ch.push_back ((*it)->item);¤	}¤	return ch;¤}¤¤template <class T, bool is_sort, class Pred>¤typename Tree<T,is_sort,Pred>::Items Tree<T,is_sort,Pred>::all_childs ( const T& to ) const {¤	Items ch;¤	this->collect_childs (to, ch);	¤	return ch;¤}¤¤template <class T, bool is_sort, class Pred>¤void Tree<T,is_sort,Pred>::collect_childs ( const T& to, Items& items ) const {¤	const Node& node = find_node(to);¤	for (NodeChilds::const_iterator it = node.childs.begin(); it != node.childs.end(); it++) {¤		items.push_back ((*it)->item);¤		this->collect_childs (*(*it)->item, items);¤	}¤}¤¤template <class T, bool is_sort, class Pred>¤typename Tree<T,is_sort,Pred>::Items Tree<T,is_sort,Pred>::sublings ( const T& to ) const {¤	Item_ptr p = parent(to);¤	if (p) {¤		const Node& node = find_node(*p);¤		Items ch;¤		for (NodeChilds::const_iterator it = node.childs.begin(); it != node.childs.end(); it++) {¤			if ( (*(*it)->item) != to ) ch.push_back ((*it)->item);¤		}¤		return ch;¤	} else return Items();¤};¤¤¤template <class T, bool is_sort, class Pred>¤const typename Tree<T,is_sort,Pred>::Node& Tree<T,is_sort,Pred>::find_node ( const T& key ) const {¤	NodeTree::const_iterator it =  m_tree.find ( key );¤	if ( it != m_tree.end() ) return (*it).second;¤	else throw UnknownElement ();¤}¤¤template <class T, bool is_sort, class Pred>¤typename Tree<T,is_sort,Pred>::Node& Tree<T,is_sort,Pred>::create_node ( const T& key ) {¤	NodeTree::iterator it =  m_tree.find ( key );¤	if ( it != m_tree.end() ) {¤		throw AlreadyInTree();¤	}¤	¤	it = m_tree.insert (NodeTree::value_type (key, Node())).first;¤¤	it->second.item = (Item_ptr)&it->first;¤	return it->second;¤¤	/*Node& node = m_tree[key];¤	¤	it =  m_tree.find ( key );¤	const T& item = (*it).first;¤	node.item = (Item_ptr)&item;¤	return node;*/¤}¤¤template <class T, bool is_sort, class Pred>¤unsigned long Tree<T,is_sort,Pred>::get_level(const T& to) const {¤	unsigned long ret = 0;¤¤	const Node& node = find_node(to);¤	const Node* parent = &node;¤¤	while (parent = parent->parent) {¤		ret++;¤	}¤¤	return ret;¤}¤¤template <class T, bool is_sort, class Pred>¤unsigned long Tree<T,is_sort,Pred>::get_child_count(const T& to) const {¤	const Node& node = find_node(to);¤	return node.childs.size();¤}¤¤template <class T, bool is_sort, class Pred>¤void Tree<T,is_sort,Pred>::collect_childs_count (const Node* to, unsigned long& count) const {¤	count++;¤	for (NodeChilds::const_iterator it = to->childs.begin(); it != to->childs.end(); it++) {¤		this->collect_childs_count(*it, count);¤	}¤}¤¤template <class T, bool is_sort, class Pred>¤unsigned long Tree<T,is_sort,Pred>::get_all_child_count(const T& to) const {¤	unsigned long ret = 0;¤	const Node& node = find_node(to);¤	this->collect_childs_count(&node, ret);¤	ret--;¤	¤	return ret;¤}¤¤template <class T, bool is_sort, class Pred>¤unsigned long Tree<T,is_sort,Pred>::get_index(const T& to) const {¤	unsigned long ret = 0;¤	const Node& node = find_node(to);¤	¤	if (!node.parent) return 0;¤	for (¤		NodeChilds::iterator it = node.parent->childs.begin()¤		; it != node.parent->childs.end() && *it != &node¤		; it++¤	) {	¤		ret++;¤	}¤	¤	return ret;¤}¤¤template <class T, bool is_sort, class Pred>¤unsigned long Tree<T,is_sort,Pred>::get_through_index(const T& to) const {¤	unsigned long ret = 0;¤	const Node& node = find_node(to);¤¤	if (!node.parent) return 0;¤	¤	for (¤		NodeChilds::iterator it = node.parent->childs.begin()¤		; it != node.parent->childs.end() && *it != &node¤		; it++¤	) {	¤		this->collect_childs_count(*it, ret);¤	}¤	¤	return ret;¤}¤template <class T, bool is_sort, class Pred>¤void Tree<T,is_sort,Pred>::remove (const T& key) {¤	NodeTree::iterator it =  m_tree.find (key);¤	if (it != m_tree.end ()) {¤		Node& node = (*it).second;¤		if (node.parent) {¤			remove_child (node.parent, &node, Loki::Int2Type<is_sort> ());¤		}¤		m_tree.erase (it);¤	}¤}¤//#UC END# *450138270399*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*450138270399_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *450138270399_DESTR_BODY*¤	//#UC END# *450138270399_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*450138270399_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *450138270399_DESTR_BODY*¤	//#UC END# *450138270399_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/Tree.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (i.h)"
		    value      	"w:/shared/GCL/data/Tree.i.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/Tree|450138270399
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (i.h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657711713"))
	    quid       	"450138270399"
	    documentation 	"Шаблонный класс, позволяет создавать древовидные структуры из любых объектов и типов (включая примитивные)"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator"
	    parameters 	(list Parameters
		(object Parameter "class T"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657712012"))
		    quid       	"4770F67B0116")
		(object Parameter "bool is_sort"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657712333"))
		    quid       	"4770F67B00FC"
		    initv      	"true")
		(object Parameter "class Pred"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657712667"))
		    quid       	"4770F67B00E2"
		    initv      	"std::less<T>")))
	(object Class "StaticNodeIterator"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/GCL/data/StaticNodeIterator.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/data/StaticNodeIterator.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*45C70B45008C_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *45C70B45008C_DESTR_BODY*¤	//#UC END# *45C70B45008C_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/data/StaticNodeIterator|45C70B45008C
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ApplyedGens"
		    value      	"C++ интерфейсы и реализация|Документация")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657713231"))
	    quid       	"45C70B45008C"
	    documentation 	"итератор по дереву"
	    stereotype 	"SimpleClass"
	    operations 	(list Operations
		(object Operation "get_next"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*45C70BA40000*"
			    value      	(value Text 
|//#UC START# *45C70BA40000*¤	if (m_is_first) {¤		m_is_first = false;¤		return m_current._sretn ();		¤	} else {		¤		GCL::StaticNode_var node_out;¤		GCL::StaticNode* out_node;¤		if (m_current->has_children ()) {¤			node_out = m_current->first_child ();¤		} else {¤			node_out = m_current->next ();¤			if (node_out.in () == 0)¤			{¤				GCL::StaticNode_var parent;¤				parent = m_current->parent ();¤				if (parent.in () != 0) {¤					GCL::StaticNode_var up_node_out;¤					up_node_out = up_level ();¤					node_out = up_node_out._sretn ();¤				}¤			}¤		}¤		//m_parent = m_current;¤		m_current = node_out;¤		out_node = m_current._sretn ();¤		return out_node;¤	}¤	//#UC END# *45C70BA40000*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"4501367B01C5")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657714260"))
		    quid       	"45C70BA40000"
		    documentation 	"получение следующего элемента дерева"
		    stereotype 	"chg"
		    result     	"StaticNode"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"4501367B01C5")
		(object Operation "up_level"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*45C70BCC01F4*"
			    value      	(value Text 
|//#UC START# *45C70BCC01F4*¤	GCL::StaticNode* out_node;¤	GCL::StaticNode_var parent;¤	parent = m_current->parent ();¤¤	if (parent.in () != 0) {¤		GCL::StaticNode_var next_node;¤		next_node = parent->next ();¤		if (next_node.in () == 0){¤			m_current = parent;¤			out_node = up_level ();¤		} else {¤			out_node = next_node._sretn ();¤		}¤	} else {¤		out_node = 0;¤	}¤	return out_node;¤	//#UC END# *45C70BCC01F4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"4501367B01C5")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657714621"))
		    quid       	"45C70BCC01F4"
		    documentation 	"возвращение на уровень вверх"
		    stereotype 	"chg"
		    result     	"StaticNode"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0
		    quidu      	"4501367B01C5")
		(object Operation "new_ctor_op"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*45C70C01004E_BASE_INIT*"
			    value      	"//#UC START# *45C70C01004E_BASE_INIT*¤//#UC END# *45C70C01004E_BASE_INIT*")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*45C70C01004E_BODY*"
			    value      	(value Text 
|//#UC START# *45C70C01004E_BODY*¤	this->init (root);¤	//#UC END# *45C70C01004E_BODY*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657714977"))
		    quid       	"45C70C01004E"
		    documentation 	"root - нода с которой начнется поиск"
		    stereotype 	"ctor"
		    parameters 	(list Parameters
			(object Parameter "inout root"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4501367B01C5")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657715273"))
			    quid       	"45C71B2701A5"
			    type       	"StaticNode"
			    quidu      	"4501367B01C5"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "init"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*45D473430242*"
			    value      	(value Text 
|//#UC START# *45D473430242*¤	m_current = GCL::StaticNode::_duplicate (root);¤	m_is_first = true;¤	//#UC END# *45D473430242*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657715715"))
		    quid       	"45D473430242"
		    documentation 	"инициализация итератора"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "inout root"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4501367B01C5")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657716022"))
			    quid       	"466A53DE0196"
			    type       	"StaticNode"
			    quidu      	"4501367B01C5"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "current"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"4501367B01C5")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657713493"))
		    quid       	"45C70B65030D"
		    documentation 	"текущая нода, на которую указывает итератор"
		    type       	"StaticNode"
		    quidu      	"4501367B01C5"
		    Containment 	"By Reference")
		(object ClassAttribute "is_first"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"3DBFFE100240")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657713888"))
		    quid       	"45C70C34038A"
		    documentation 	"флаг показывает первый ли раз спросили get_next"
		    type       	"boolean"
		    quidu      	"3DBFFE100240"
		    Containment 	"By Value"))
	    language   	"MDA Generator")
	(object Association "$UNNAMED$0"
	    quid       	"44FEBE230262"
	    roles      	(list role_list
		(object Role "$UNNAMED$1"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657699072"))
		    quid       	"44FEBE23039B"
		    supplier   	"Logical View::Primitives::a-string"
		    quidu      	"452257A0036F"
		    Containment 	"By Value"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$2"
		    quid       	"44FEBE23039D"
		    supplier   	"Logical View::shared::GCL::data::std_defs::StrSet"
		    quidu      	"44FEBE140197"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$3"
	    quid       	"44FEBE380020"
	    roles      	(list role_list
		(object Role "$UNNAMED$4"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657700287"))
		    quid       	"44FEBE380214"
		    supplier   	"Logical View::Primitives::a-string"
		    quidu      	"452257A0036F"
		    Containment 	"By Value"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$5"
		    quid       	"44FEBE380224"
		    supplier   	"Logical View::shared::GCL::data::std_defs::StrVector"
		    quidu      	"44FEBE2F034D"
		    is_aggregate 	TRUE))))
    logical_presentations 	(list unit_reference_list
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ColorizeFor"
		    value      	"44FEAD4A0272"))
	    quid       	"44FEBDAB03BA"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	1797
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::shared::GCL::data::std_defs" @1
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1643")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"372")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"318")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1643, 372)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@1
			location   	(1493, 342)
			fill_color 	13434879
			nlines     	1
			max_width  	300
			justify    	0
			label      	"std_defs")
		    stereotype 	(object ItemLabel
			Parent_View 	@1
			location   	(1493, 292)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	297
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"44FEBDF3039B"
		    width      	318
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::std_defs::StrSet" @2
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"720")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"138")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"234")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(720, 138)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	6572835
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@2
			location   	(612, 110)
			nlines     	1
			max_width  	216
			justify    	0
			label      	"• StrSet")
		    stereotype 	(object ItemLabel
			Parent_View 	@2
			location   	(612, 60)
			anchor     	10
			nlines     	1
			max_width  	216
			justify    	0
			label      	"<<Set>>")
		    icon_style 	"Label"
		    line_color 	6572835
		    fill_color 	16777215
		    quidu      	"44FEBE140197"
		    width      	234
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::Primitives::a-string" @3
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1239")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"249")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"194")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"116"))
		    location   	(1239, 249)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	TRUE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@3
			location   	(1132, 203)
			fill_color 	13434879
			nlines     	1
			max_width  	214
			justify    	0
			label      	"a-string")
		    icon_style 	"None"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"452257A0036F"
		    width      	232
		    height     	117
		    autoResize 	TRUE)
		(object AssociationViewNew "$UNNAMED$0" @4
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"837,162;1141,228"))
		    location   	(979, 192)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"44FEBE230262"
		    roleview_list 	(list RoleViews
			(object RoleView "$UNNAMED$1" @5
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"989,195;1141,228"))
			    Parent_View 	@4
			    location   	(259, 54)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"44FEBE23039B"
			    client     	@4
			    supplier   	@3
			    vertices   	(list Points
				(979, 192)
				(1122, 222))
			    line_style 	0)
			(object RoleView "$UNNAMED$2" @6
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"989,195;837,162"))
			    Parent_View 	@4
			    location   	(259, 54)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"44FEBE23039D"
			    client     	@4
			    supplier   	@2
			    vertices   	(list Points
				(979, 192)
				(837, 162))
			    line_style 	0)))
		(object ClassView "Class" "Logical View::shared::GCL::data::std_defs::StrVector" @7
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"729")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"381")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"240")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(729, 381)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	6572835
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@7
			location   	(618, 353)
			nlines     	1
			max_width  	222
			justify    	0
			label      	"• StrVector")
		    stereotype 	(object ItemLabel
			Parent_View 	@7
			location   	(618, 303)
			anchor     	10
			nlines     	1
			max_width  	219
			justify    	0
			label      	"<<Vector>>")
		    icon_style 	"Label"
		    line_color 	6572835
		    fill_color 	16777215
		    quidu      	"44FEBE2F034D"
		    width      	240
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object AssociationViewNew "$UNNAMED$3" @8
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"849,349;1141,273"))
		    location   	(985, 313)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"44FEBE380020"
		    roleview_list 	(list RoleViews
			(object RoleView "$UNNAMED$4" @9
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"995,311;1141,273"))
			    Parent_View 	@8
			    location   	(265, -167)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"44FEBE380214"
			    client     	@8
			    supplier   	@3
			    vertices   	(list Points
				(985, 313)
				(1122, 278))
			    line_style 	0)
			(object RoleView "$UNNAMED$5" @10
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"995,311;849,349"))
			    Parent_View 	@8
			    location   	(265, -167)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"44FEBE380224"
			    client     	@8
			    supplier   	@7
			    vertices   	(list Points
				(985, 313)
				(849, 349))
			    line_style 	0)))
		(object ClassView "ParameterizedClass" "Logical View::shared::GCL::data::DirectMap" @11
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"303")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1227")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"350")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"216"))
		    location   	(303, 1227)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@11
			location   	(137, 1219)
			fill_color 	13434879
			nlines     	1
			max_width  	332
			justify    	0
			label      	"• DirectMap")
		    stereotype 	(object ItemLabel
			Parent_View 	@11
			location   	(137, 1169)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	332
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"44FEC13E0149"
		    width      	350
		    height     	216
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::std_defs::FILE" @12
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1161")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"624")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"262")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(1161, 624)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@12
			location   	(1039, 596)
			fill_color 	13434879
			nlines     	1
			max_width  	244
			justify    	0
			label      	"• FILE")
		    stereotype 	(object ItemLabel
			Parent_View 	@12
			location   	(1039, 546)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	241
			justify    	0
			label      	"<<Typedef>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"44FEBEBC0030"
		    width      	262
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::std_defs::File_box" @13
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"708")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"618")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"234")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(708, 618)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	7874680
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@13
			location   	(600, 590)
			nlines     	1
			max_width  	216
			justify    	0
			label      	"• File_box")
		    stereotype 	(object ItemLabel
			Parent_View 	@13
			location   	(600, 540)
			anchor     	10
			nlines     	1
			max_width  	216
			justify    	0
			label      	"<<Box>>")
		    icon_style 	"Label"
		    line_color 	7874680
		    fill_color 	16777215
		    quidu      	"44FEBE6E005F"
		    width      	234
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object InheritView "" @14
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"825,619;1029,621"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"44FED78F02EF"
		    client     	@13
		    supplier   	@12
		    vertices   	(list Points
			(825, 619)
			(1029, 621))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::GCL::data::Buffer" @15
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"900")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"930")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"318")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(900, 930)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@15
			location   	(750, 900)
			fill_color 	13434879
			nlines     	1
			max_width  	300
			justify    	0
			label      	"• Buffer")
		    stereotype 	(object ItemLabel
			Parent_View 	@15
			location   	(750, 850)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	297
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"450135270167"
		    width      	318
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::OnDemandFile" @16
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"900")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1290")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"320")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(900, 1290)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@16
			location   	(749, 1260)
			fill_color 	13434879
			nlines     	1
			max_width  	302
			justify    	0
			label      	"• OnDemandFile")
		    stereotype 	(object ItemLabel
			Parent_View 	@16
			location   	(749, 1210)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	302
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"450135840290"
		    width      	320
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::OrphanStr" @17
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1620")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"120")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"318")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1620, 120)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@17
			location   	(1470, 90)
			fill_color 	13434879
			nlines     	1
			max_width  	300
			justify    	0
			label      	"• OrphanStr")
		    stereotype 	(object ItemLabel
			Parent_View 	@17
			location   	(1470, 40)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	297
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"450135E90109"
		    width      	318
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::PackedStrStream" @18
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1788")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"930")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"384")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1788, 930)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@18
			location   	(1605, 900)
			fill_color 	13434879
			nlines     	1
			max_width  	366
			justify    	0
			label      	"• PackedStrStream")
		    stereotype 	(object ItemLabel
			Parent_View 	@18
			location   	(1605, 850)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	366
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"4501364F0290"
		    width      	384
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::StaticNode" @19
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"270")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1560")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"350")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(270, 1560)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@19
			location   	(104, 1530)
			fill_color 	13434879
			nlines     	1
			max_width  	332
			justify    	0
			label      	"• StaticNode")
		    stereotype 	(object ItemLabel
			Parent_View 	@19
			location   	(104, 1480)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	332
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4501367B01C5"
		    width      	350
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::data::StaticNodeStubBase" @20
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"288")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1902")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"434")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(288, 1902)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@20
			location   	(80, 1872)
			fill_color 	13434879
			nlines     	1
			max_width  	416
			justify    	0
			label      	"• StaticNodeStubBase")
		    stereotype 	(object ItemLabel
			Parent_View 	@20
			location   	(80, 1822)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	416
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"450136B500FA"
		    width      	434
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object InheritView "" @21
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"282,1809;274,1652"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"450136BC008C"
		    client     	@20
		    supplier   	@19
		    vertices   	(list Points
			(282, 1809)
			(274, 1652))
		    line_style 	0)
		(object ClassView "ParameterizedClass" "Logical View::shared::GCL::data::StaticNodeStub" @22
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"285")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"2283")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"350")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"216"))
		    location   	(285, 2283)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@22
			location   	(119, 2275)
			fill_color 	13434879
			nlines     	1
			max_width  	332
			justify    	0
			label      	"• StaticNodeStub")
		    stereotype 	(object ItemLabel
			Parent_View 	@22
			location   	(119, 2225)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	332
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"450136CE01F4"
		    width      	350
		    height     	216
		    annotation 	8
		    autoResize 	TRUE)
		(object InheritView "" @23
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"285,2174;287,1994"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"450136E30290"
		    client     	@22
		    supplier   	@20
		    vertices   	(list Points
			(285, 2174)
			(287, 1994))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::GCL::data::StaticNodeMng" @24
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1426")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"2759")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"2492")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"292"))
		    location   	(1426, 2759)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	TRUE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@24
			location   	(176, 2675)
			fill_color 	13434879
			nlines     	1
			max_width  	2500
			justify    	0
			label      	"• StaticNodeMng")
		    stereotype 	(object ItemLabel
			Parent_View 	@24
			location   	(176, 2625)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	2500
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"450137530213"
		    width      	2518
		    height     	292
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @25
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"460,2356;1076,2612"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	(object SegLabel @26
			Parent_View 	@25
			location   	(746, 2523)
			font       	(object Font
			    size       	10
			    face       	"Arial"
			    charSet    	204
			    bold       	FALSE
			    italics    	FALSE
			    underline  	FALSE
			    strike     	FALSE
			    color      	0
			    default_color 	TRUE)
			anchor     	10
			anchor_loc 	1
			nlines     	1
			max_width  	450
			justify    	0
			label      	"<<uses>>"
			pctDist    	0.490636
			height     	45
			orientation 	1)
		    line_color 	3947680
		    quidu      	"4501376001B5"
		    client     	@22
		    supplier   	@24
		    vertices   	(list Points
			(460, 2356)
			(1076, 2612))
		    line_style 	0)
		(object ClassView "ParameterizedClass" "Logical View::shared::GCL::data::Tree" @27
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1653")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1284")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"350")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"216"))
		    location   	(1653, 1284)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@27
			location   	(1487, 1276)
			fill_color 	13434879
			nlines     	1
			max_width  	332
			justify    	0
			label      	"• Tree")
		    stereotype 	(object ItemLabel
			Parent_View 	@27
			location   	(1487, 1226)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	332
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"450138270399"
		    width      	350
		    height     	216
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @28
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"366,1651;366,1809"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	(object SegLabel @29
			Parent_View 	@28
			location   	(486, 1730)
			font       	(object Font
			    size       	10
			    face       	"Arial"
			    charSet    	204
			    bold       	FALSE
			    italics    	FALSE
			    underline  	FALSE
			    strike     	FALSE
			    color      	0
			    default_color 	TRUE)
			anchor     	10
			anchor_loc 	1
			nlines     	1
			max_width  	450
			justify    	0
			label      	"<<uses>>"
			pctDist    	0.500000
			height     	120
			orientation 	0)
		    line_color 	3947680
		    quidu      	"45018B6503D8"
		    client     	@19
		    supplier   	@20
		    vertices   	(list Points
			(366, 1651)
			(366, 1809))
		    line_style 	3
		    origin_attachment 	(366, 1651)
		    terminal_attachment 	(366, 1809))
		(object ClassView "Class" "Logical View::shared::GCL::data::StaticNodeIterator" @30
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1341")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1821")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"912")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"492"))
		    location   	(1341, 1821)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@30
			location   	(894, 1637)
			fill_color 	13434879
			nlines     	1
			max_width  	894
			justify    	0
			label      	"• StaticNodeIterator")
		    stereotype 	(object ItemLabel
			Parent_View 	@30
			location   	(894, 1587)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	894
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"45C70B45008C"
		    width      	912
		    height     	492
		    annotation 	8
		    autoResize 	TRUE)))))
