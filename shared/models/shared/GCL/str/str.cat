
(object Petal
    version    	50
    _written   	"Rose 2006.0.0.061205"
    charSet    	204)

(object Class_Category "str"
    is_unit    	TRUE
    is_loaded  	TRUE
    attributes 	(list Attribute_Set
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"AbstarctOperation"
	    value      	"regular")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"IsNative"
	    value      	"false")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (i.h)"
	    value      	"w:/shared/GCL/str/str_conv.i.h::4503DFAE006D,w:/shared/GCL/str/str_op.i.h::4503E01500CB")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (h)"
	    value      	"w:/shared/GCL/str/str_conv.h::4503DFAE006D,w:/shared/GCL/str/str_op.h::4503E01500CB")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (cpp)"
	    value      	"w:/shared/GCL/str/str_conv.cpp::4503DFAE006D")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED WikiPageID (wiki)"
	    value      	(value Text 
|Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_conv|4503DFAE006D::4503DFAE006D;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_op|4503E01500CB::4503E01500CB;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/Модель проекта "shared"/GCL/str/str_conv|4503DFAE006D::4503DFAE006D;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/Модель проекта "shared"/GCL/str/str_op|4503E01500CB::4503E01500CB;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_conv|4503DFAE006D::4503DFAE006D;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_op|4503E01500CB::4503E01500CB;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_conv|4503DFAE006D::4503DFAE006D;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_op|4503E01500CB::4503E01500CB
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"WikiPageID (wiki)"
	    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str|4503DF990167
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ApplyedGens"
	    value      	"C++ интерфейсы и реализация|Документация")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SourceType (wiki)"
	    value      	"wiki")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ElementCreationOrder"
	    value      	"16663717276"))
    quid       	"4503DF990167"
    documentation 	"методы работы со строками"
    stereotype 	"Unit"
    visible_categories 	(list visibility_relationship_list
	(object Visibility_Relationship
	    quid       	"450422870399"
	    supplier   	"Logical View::shared::GCL::data"
	    quidu      	"44FEB6B3010B"))
    exportControl 	"Public"
    logical_models 	(list unit_reference_list
	(object Class "str_conv"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4503DFAE006D_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4503DFAE006D_CUSTOM_INCLUDES*¤#include "ace/Basic_Types.h"¤¤namespace GCL {¤	const std::string utf8_to_win1251 (const std::string& src) {¤		return utf8_to_win1251 (src.c_str ());¤	}¤}¤//#UC END# *4503DFAE006D_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4503DFAE006D*"
		    value      	(value Text 
|//#UC START# *4503DFAE006D*¤namespace {¤¤static const unsigned char s_dos2koi [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0xE1, 0xE2, 0xF7, 0xE7, 0xE4, 0xE5, 0xF6, 0xFA, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,¤	0xF2, 0xF3, 0xF4, 0xF5, 0xE6, 0xE8, 0xE3, 0xFE, 0xFB, 0xFD, 0xFF, 0xF9, 0xF8, 0xFC, 0xE0, 0xF1,¤	0xC1, 0xC2, 0xD7, 0xC7, 0xC4, 0xC5, 0xD6, 0xDA, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,¤	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,¤	0xC0, 0xC1, 0xC2, 0xC3, 0x2D, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,¤	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0xD2, 0xD3, 0xD4, 0xD5, 0xC6, 0xC8, 0xC3, 0xDE, 0xDB, 0xDD, 0xDF, 0xD9, 0xD8, 0xDC, 0xC0, 0xD1,¤	0xB3, 0xA3, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF¤};¤¤static const unsigned char s_dos2mac [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x20, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0xB0, 0xB1, 0xB2, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,¤	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,¤	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF¤};¤¤static const unsigned char s_dos2win [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xA4,¤	0x10, 0x11, 0x12, 0x13, 0xB6, 0xA7, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,¤	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0x87, 0x87, 0x87, 0x80, 0x81, 0x81, 0x81, 0x82, 0x82, 0x81, 0x80, 0x82, 0x8A, 0x8A, 0x8A, 0x82,¤	0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x86, 0x86, 0x83, 0x89, 0x84, 0x85, 0x86, 0x87, 0x88, 0x84,¤	0x84, 0x85, 0x85, 0x83, 0x83, 0x89, 0x89, 0x88, 0x88, 0x8A, 0x89, 0x87, 0x87, 0x80, 0x87, 0x87,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,¤/*240*/ 0xA8, 0xB8,  170,  186,  175,  191, 0x5F, 0x5F, 0xB0, 0xB7, 0xB7, 0x5F, 0xB9, 0xB1, 0xA8, 0xA0¤};¤¤static const unsigned char s_dos2win_pseudo [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xA4,¤	0x10, 0x11, 0x12, 0x13, 0xB6, 0xA7, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,¤	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0x87, 0x87, 0x87,  '|',  '|', 0x81, 0x81, 0x82, 0x82, 0x81, 0x80, 0x82, 0x8A, 0x8A, 0x8A, '\\',¤	'\\',  '-',  '-',  '|',  '-',  '+', 0x86, 0x86, 0x83, 0x89, 0x84, 0x85, 0x86, 0x87, 0x88, 0x84,¤	0x84, 0x85, 0x85, 0x83, 0x83, 0x89, 0x89, 0x88, 0x88,  '/',  '/', 0x87, 0x87, 0x80, 0x87, 0x87,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,¤	0xA8, 0xB8,  170,  186,  175,  191, 0x5F, 0x5F, 0xB0, 0xB7, 0xB7, 0x5F, 0x6E, 0xB2, 0xA8, 0xA0¤};¤¤static const unsigned char s_koi2dos [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xA0, 0xA1, 0xA2, 0xF1, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,¤	0xB0, 0xB1, 0xB2, 0xF0, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,¤	0xEE, 0xA0, 0xA1, 0xE6, 0xA4, 0xA5, 0xE4, 0xA3, 0xE5, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE,¤	0xAF, 0xEF, 0xE0, 0xE1, 0xE2, 0xE3, 0xA6, 0xA2, 0xEC, 0xEB, 0xA7, 0xE8, 0xED, 0xE9, 0xE7, 0xEA,¤	0x9E, 0x80, 0x81, 0x96, 0x84, 0x85, 0x94, 0x83, 0x95, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,¤	0x8F, 0x9F, 0x90, 0x91, 0x92, 0x93, 0x86, 0x82, 0x9C, 0x9B, 0x87, 0x98, 0x9D, 0x99, 0x97, 0x9A¤};¤¤static const unsigned char s_koi2mac [256] ={¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x20,¤	0x21, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0xB0, 0xB1, 0xB2, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,¤	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xFF, 0x20, 0x20, 0x20, 0x20,¤	0x20, 0x20, 0x20, 0xF1, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0x20, 0xF3, 0xF2, 0xF0, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20,¤	0xFE, 0xE0, 0xE1, 0xF6, 0xE4, 0xE5, 0xF4, 0xE3, 0xF5, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE,¤	0xEF, 0xDF, 0xF0, 0xF1, 0xF2, 0xF3, 0xE6, 0xE2, 0xFC, 0xFB, 0xE7, 0xF8, 0xFD, 0xF9, 0xF7, 0xFA,¤	0x9E, 0x80, 0x81, 0x96, 0x84, 0x85, 0x94, 0x83, 0x95, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,¤	0x8F, 0x9F, 0x90, 0x91, 0x92, 0x93, 0x86, 0x82, 0x9C, 0x9B, 0x87, 0x98, 0x9D, 0x99, 0x97, 0x9A¤};¤¤static const unsigned char s_koi2win [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xA0, 0xA1, 0xA2, 0xB8, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,¤	0xB0, 0xB1, 0xB2, 0xA8, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,¤	0xFE, 0xE0, 0xE1, 0xF6, 0xE4, 0xE5, 0xF4, 0xE3, 0xF5, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE,¤	0xEF, 0xFF, 0xF0, 0xF1, 0xF2, 0xF3, 0xE6, 0xE2, 0xFC, 0xFB, 0xE7, 0xF8, 0xFD, 0xF9, 0xF7, 0xFA,¤	0xDE, 0xC0, 0xC1, 0xD6, 0xC4, 0xC5, 0xD4, 0xC3, 0xD5, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE,¤	0xCF, 0xDF, 0xD0, 0xD1, 0xD2, 0xD3, 0xC6, 0xC2, 0xDC, 0xDB, 0xC7, 0xD8, 0xDD, 0xD9, 0xD7, 0xDA ¤};¤¤static const unsigned char s_mac2dos [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,¤	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,¤	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,¤	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF¤};¤¤static const unsigned char s_mac2koi [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0xE1, 0xE2, 0xF7, 0xE7, 0xE4, 0xE5, 0xF6, 0xFA, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,¤	0xF2, 0xF3, 0xF4, 0xF5, 0xE6, 0xE8, 0xE3, 0xFE, 0xFB, 0xFD, 0xFF, 0xF9, 0xF8, 0xFC, 0xE0, 0xF1,¤	0xC1, 0xC2, 0xD7, 0xC7, 0xC4, 0xC5, 0xD6, 0xDA, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xBF, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xA0, 0xA1, 0xA2, 0xB0, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xD1,¤	0xC1, 0xC2, 0xD7, 0xC7, 0xC4, 0xC5, 0xD6, 0xDA, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,¤	0xD2, 0xD3, 0xD4, 0xD5, 0xC6, 0xC8, 0xC3, 0xDE, 0xDB, 0xDD, 0xDF, 0xD9, 0xD8, 0xDC, 0xC0, 0x9B ¤};¤¤static const unsigned char s_mac2win [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xA4,¤	0x10, 0x11, 0x12, 0x13, 0xB6, 0xA7, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,¤	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0x5F, 0x5F, 0x5F, 0xA6, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F,¤	0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F,¤	0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0xA6, 0x5F, 0xFF,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x5F ¤};¤¤static const unsigned char s_win2dos [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0x20, 0xAD, 0x9B, 0x9C, 0x0F, 0x9D, 0xDD, 0x15, 0xF0, 0x63, 0xA6, 0xAE, 0xAA, 0x2D, 0x72, 0x5F,¤	0xF8, 0xF1, 0xFD, 0x33, 0x27, 0xE6, 0x14, 0xFA, 0xF1, 0xFC, 0xA7, 0xAF, 0xAC, 0xAB, 0x5F, 0xA8,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF¤};¤¤static const unsigned char s_win2koi [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xB3, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,¤	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xA3, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,¤	0xE1, 0xE2, 0xF7, 0xE7, 0xE4, 0xE5, 0xF6, 0xFA, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,¤	0xF2, 0xF3, 0xF4, 0xF5, 0xE6, 0xE8, 0xE3, 0xFE, 0xFB, 0xFD, 0xFF, 0xF9, 0xF8, 0xFC, 0xE0, 0xF1,¤	0xC1, 0xC2, 0xD7, 0xC7, 0xC4, 0xC5, 0xD6, 0xDA, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,¤	0xD2, 0xD3, 0xD4, 0xD5, 0xC6, 0xC8, 0xC3, 0xDE, 0xDB, 0xDD, 0xDF, 0xD9, 0xD8, 0xDC, 0xC0, 0xD1¤};¤¤static const unsigned char s_win2mac [256] = {¤	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x20, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,¤	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,¤	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,¤	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,¤	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,¤	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,¤	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,¤	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0x20, 0xED, 0x9B, 0x9C, 0x0F, 0x9D, 0xDD, 0x15, 0x22, 0x63, 0xE6, 0xEE, 0xEA, 0x2D, 0x72, 0x5F,¤	0xF8, 0xF1, 0xFD, 0x33, 0x27, 0xF6, 0x14, 0xFA, 0x2C, 0x31, 0xE7, 0xEF, 0xEC, 0xEB, 0x5F, 0xE8,¤	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,¤	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,¤	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,¤	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF ¤};¤¤static const unsigned char* s_code_tables [5] [5] = {¤	{ 0, s_win2dos, s_win2koi, s_win2mac, 0 },¤	{ s_dos2win, 0, s_dos2koi, s_dos2mac, s_dos2win_pseudo },¤	{ s_koi2win, s_koi2dos, 0, s_koi2mac, 0 },¤	{ s_mac2win, s_mac2dos, s_mac2koi, 0, 0 },¤	{ 0, 0, 0, 0, 0 }¤};¤¤static const ACE_UINT16 s_win12512utf8 [256] = {¤    0x0    ,0x1    ,0x2    ,0x3    ,0x4    ,0x5    ,0x6    ,0x7    ,0x8    ,0x9    ,0xa    ,0xb    ,0xc    ,0xd    ,0xe    ,0xf    ,¤    0x10   ,0x11   ,0x12   ,0x13   ,0x14   ,0x15   ,0x16   ,0x17   ,0x18   ,0x19   ,0x1a   ,0x1b   ,0x1c   ,0x1d   ,0x1e   ,0x1f   ,¤    0x20   ,0x21   ,0x22   ,0x23   ,0x24   ,0x25   ,0x26   ,0x27   ,0x28   ,0x29   ,0x2a   ,0x2b   ,0x2c   ,0x2d   ,0x2e   ,0x2f   ,¤    0x30   ,0x31   ,0x32   ,0x33   ,0x34   ,0x35   ,0x36   ,0x37   ,0x38   ,0x39   ,0x3a   ,0x3b   ,0x3c   ,0x3d   ,0x3e   ,0x3f   ,¤    0x40   ,0x41   ,0x42   ,0x43   ,0x44   ,0x45   ,0x46   ,0x47   ,0x48   ,0x49   ,0x4a   ,0x4b   ,0x4c   ,0x4d   ,0x4e   ,0x4f   ,¤    0x50   ,0x51   ,0x52   ,0x53   ,0x54   ,0x55   ,0x56   ,0x57   ,0x58   ,0x59   ,0x5a   ,0x5b   ,0x5c   ,0x5d   ,0x5e   ,0x5f   ,¤    0x60   ,0x61   ,0x62   ,0x63   ,0x64   ,0x65   ,0x66   ,0x67   ,0x68   ,0x69   ,0x6a   ,0x6b   ,0x6c   ,0x6d   ,0x6e   ,0x6f   ,¤    0x70   ,0x71   ,0x72   ,0x73   ,0x74   ,0x75   ,0x76   ,0x77   ,0x78   ,0x79   ,0x7a   ,0x7b   ,0x7c   ,0x7d   ,0x7e   ,0x7f   ,¤    0x402  ,0x403  ,0x201a ,0x453  ,0x201e ,0x2026 ,0x2020 ,0x2021 ,0x20ac ,0x2030 ,0x409  ,0x2039 ,0x40a  ,0x40c  ,0x40b  ,0x40f  ,¤    0x452  ,0x2018 ,0x2019 ,0x201c ,0x201d ,0x2022 ,0x2013 ,0x2014 ,0      ,0x2122 ,0x459  ,0x203a ,0x45a  ,0x45c  ,0x45b  ,0x45f  ,¤    0xa0   ,0x40e  ,0x45e  ,0x408  ,0xa4   ,0x490  ,0xa6   ,0xa7   ,0x401  ,0xa9   ,0x404  ,0xab   ,0xac   ,0xad   ,0xae   ,0x407  ,¤    0xb0   ,0xb1   ,0x406  ,0x456  ,0x491  ,0xb5   ,0xb6   ,0xb7   ,0x451  ,0x2116 ,0x454  ,0xbb   ,0x458  ,0x405  ,0x455  ,0x457  ,¤    0x410  ,0x411  ,0x412  ,0x413  ,0x414  ,0x415  ,0x416  ,0x417  ,0x418  ,0x419  ,0x41a  ,0x41b  ,0x41c  ,0x41d  ,0x41e  ,0x41f  ,¤    0x420  ,0x421  ,0x422  ,0x423  ,0x424  ,0x425  ,0x426  ,0x427  ,0x428  ,0x429  ,0x42a  ,0x42b  ,0x42c  ,0x42d  ,0x42e  ,0x42f  ,¤    0x430  ,0x431  ,0x432  ,0x433  ,0x434  ,0x435  ,0x436  ,0x437  ,0x438  ,0x439  ,0x43a  ,0x43b  ,0x43c  ,0x43d  ,0x43e  ,0x43f  ,¤    0x440  ,0x441  ,0x442  ,0x443  ,0x444  ,0x445  ,0x446  ,0x447  ,0x448  ,0x449  ,0x44a  ,0x44b  ,0x44c  ,0x44d  ,0x44e  ,0x44f¤};¤¤} // namespace ""¤¤char* buffer_recoding (code_t code_in, code_t code_out, size_t len, char* dest, const char* src) {¤	if ((dest != 0) && (len != 0)) {¤		if (src == 0) {¤			src = dest;¤		}¤¤		const unsigned char* current_code_table = s_code_tables [code_in] [code_out];¤		if (current_code_table != 0) {¤			for (size_t i = 0; i < len; ++i) {¤				dest [i] = current_code_table [(unsigned char)src [i]];¤			}¤		} else {¤			if (dest != src) {¤				memmove (dest, src, len);¤			}¤		}¤¤	}¤¤	return dest;¤}¤¤const std::string win1251_to_utf8_i (const unsigned char* src, size_t src_len) {¤	std::string result;¤	result.reserve (3*src_len);¤¤	for (size_t i = 0; i < src_len; ++i) {¤		ACE_UINT16 next = s_win12512utf8[src[i]];¤¤		if (next < 0x80) {¤			result +=  static_cast<const char> (next);¤		} else if (next < 0x800) {¤			result += static_cast<const char> (next >> 6 | 0xc0);¤			result += static_cast<const char> (next & 0x3f | 0x80);¤		} else if (next < 0x10000) {¤			result += static_cast<const char> (next >> 12 | 0xe0);¤			result += static_cast<const char> (next >> 6 & 0x3f | 0x80);¤			result += static_cast<const char> (next & 0x3f | 0x80);¤		} else {¤			GDS_ASSERT (false);¤		}¤	}¤¤	return result;¤}¤¤//#UC END# *4503DFAE006D*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4503DFAE006D_USER_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4503DFAE006D_USER_INCLUDES*¤#include <iterator>¤#include <cctype>¤¤namespace GCL {¤	const std::string utf8_to_win1251 (const std::string& src);¤}¤//#UC END# *4503DFAE006D_USER_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4503DFAE006D_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *4503DFAE006D_USER_DEFINITION*	¤	// определение по умолчанию системной кодировки¤	#if defined (CODETYPE_DOS)¤		static const code_t cd_sys = cd_dos;¤	#elif defined (CODETYPE_WIN)¤		static const code_t cd_sys = cd_win;¤	#elif defined (CODETYPE_KOI)¤		static const code_t cd_sys = cd_koi;¤	#elif defined (_WIN32) && !defined (_CONSOLE)¤		static const code_t cd_sys = cd_win;¤	#elif defined (unix) && !defined (__GO32__) && !defined (__CYGWIN32__)¤		static const code_t cd_sys = cd_koi;¤	#elif defined (__GO32__) || defined (__CYGWIN32__) || (defined (_WIN32) && defined (_CONSOLE))¤		static const code_t cd_sys = cd_dos;¤	#else¤		static const code_t cd_sys = cd_mac;¤	#endif¤	¤	// конвертация буфера из одной кодировки в другую¤	char* buffer_recoding (code_t code_in, code_t code_out, size_t len, char* dest, const char* src = 0);¤	¤	// конвертация строки из одной кодировки в другую¤	inline char* string_recoding (code_t code_in, code_t code_out, char* dest, const char* src = 0);¤		¤	// конвертит обычную струку в строку wide-кодов, с залданным префиксом ¤	// и возможностью сохранять english-сиволы¤	inline std::string multibyte_to_str (¤		const std::string& in¤		, char prefix = 0¤		, bool keep_eng = false¤		, char open_quot = 0¤		, char close_quot = 0¤	);¤¤	// преобразует строку с именем согласно стилю OMG IDL¤	enum CodeItem {¤		 CI_FUNCTION¤		, CI_PARAMTER¤		, CI_CLASS_MEMBER¤		, CI_VARIBLE¤		, CI_CONST¤		, CI_ENUM¤		, CI_CLASS¤		, CI_TYPEDEF¤		, CI_STRUCT¤		, CI_EXCEPTION¤		, CI_ENUM_ITEM¤	};¤	¤	inline std::string convert_to_omg_style (const std::string& str, CodeItem ci);¤¤	// преобразует строку с именем согласно стилю Borland VCL¤	inline std::string convert_to_borland_style (const std::string& str, CodeItem ci );¤	¤	// преобразует строку с именем согласно стилю Java¤	inline std::string convert_to_java_style (const std::string& str, CodeItem ci );¤	¤	inline void to_upper (std::string& str);¤¤	inline void to_lower (std::string& str);¤¤	// пересобирает строку из входного  формата в выходной ¤	// (в качестве составных элементов поддерживаются только подстроки, общим кол-вом не более 32)¤	inline std::string string_converter (¤		const std::string& str¤		, const std::string& in_format¤		, const std::string& out_format¤		, unsigned out_size_multiplicator = 10¤	);¤	¤	inline void convert_to_scanf_format (std::string& str);¤¤	// конвертация символа в нижний регистр (маленькие буквы)¤	inline char char_lower (const char chr, code_t code = cd_win);¤	¤	// конвертация символа в верхний регистр (большие буквы)¤	inline char char_upper (const char chr, code_t code = cd_win);¤	¤	// конвертация строки в нижний регистр (маленькие буквы)¤	inline void string_lower (char* src, code_t code = cd_win);¤	¤	// конвертация строки в верхний регистр (большие буквы)¤	inline void string_upper (char* src, code_t code = cd_win);¤//#UC END# *4503DFAE006D_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*4503DFAE006D_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4503DFAE006D_CUSTOM_INCLUDES*¤//#UC END# *4503DFAE006D_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*4503DFAE006D*"
		    value      	(value Text 
|//#UC START# *4503DFAE006D*¤// конвертация строки из одной кодировки в другую¤inline char* string_recoding (code_t code_in, code_t code_out, char* dest, const char* src) {¤	return GCL::buffer_recoding (code_in, code_out, (dest != 0) ? (strlen (dest)) : (0), dest, src);¤}¤¤// конвертит обычную струку в строку wide-кодов, с залданным префиксом ¤// и возможностью сохранять english-сиволы¤¤inline std::string multibyte_to_str (¤	const std::string& in¤	, char prefix¤	, bool keep_eng¤	, char open_quot¤	, char close_quot¤) {¤	std::string ret;¤#ifdef WIN32¤	bool first_eng = true;¤	for (std::string::const_iterator it = in.begin(); it != in.end(); it++) {			¤		if (*it < 0 || !keep_eng) {¤			if (!first_eng && close_quot) {¤				ret += close_quot;¤				first_eng = true;¤			}¤			WCHAR wch[2];¤			MultiByteToWideChar(CP_ACP, 0, &(*it), 1, wch, 1);¤			if (prefix) ret += prefix;¤			char buf[8];¤			itoa (wch[0], buf, 10);¤			ret += buf;¤		} else {¤			if (first_eng && open_quot) {¤				ret += open_quot;¤				first_eng = false;¤			}¤			ret += *it;¤		}¤	}¤	if (!first_eng && close_quot) {¤		ret += close_quot;¤		first_eng = true;¤	}¤#else¤	GDS_ASSERT_MSG (false, ("need to implement"));¤#endif¤	return ret;¤}¤¤// преобразует строку с именем согласно стилю OMG IDL¤inline std::string convert_to_omg_style (const std::string& str, CodeItem ci) {¤	std::string ret;¤	// need setlocale;¤	¤	std::string::const_iterator it_begin = str.begin();¤	std::string::const_iterator it_end = str.end();¤	for (std::string::const_iterator it = it_begin; it != it_end; it++) {¤		switch (ci) {¤			case CI_FUNCTION:¤			case CI_PARAMTER:¤			case CI_CLASS_MEMBER:¤			case CI_VARIBLE: {¤				if (it != it_begin) {¤					std::string::const_iterator it_1 = it - 1;¤					std::string::const_iterator it1 = it + 1;¤					if (¤						it1 != it_end¤						&& std::isupper (*it)¤						&& (¤							(¤								//предыдущий и следующий символы не должны быть¤								//одновременно заглавными буквами¤								std::isupper (*it_1) ^ std::isupper (*it1)¤							)¤							|| (¤								//предыдущий и следующий символы должны быть¤								//одновременно маленькими буквами¤								!std::isupper (*it_1) && !std::isupper (*it1)¤							)¤						)¤					) {¤						ret += "_";¤					}¤				}¤				ret += std::tolower (*it);¤				break;¤			} ¤			case CI_CLASS:¤			case CI_TYPEDEF:¤			case CI_STRUCT:¤			case CI_EXCEPTION: ¤			case CI_ENUM: {¤				ret += *it;¤				break;¤			}¤			case CI_CONST:¤			case CI_ENUM_ITEM: {¤				ret += *it;¤				break;¤			}¤		}¤	}¤	return ret;¤}¤¤// преобразует строку с именем согласно стилю Borland VCL¤inline std::string convert_to_borland_style (const std::string& str, CodeItem ci ) {¤	std::string ret;¤	// need setlocale;¤¤	for (std::string::const_iterator it = str.begin(); it != str.end(); it++) {¤		switch (ci) {¤			case CI_FUNCTION:¤			case CI_CLASS:¤			case CI_TYPEDEF:¤			case CI_STRUCT:¤			case CI_EXCEPTION: ¤			case CI_ENUM: {¤				if (*it == '_') {¤					it++;¤					ret += toupper(static_cast<unsigned char> (*it));¤				} else if (it == str.begin()) {¤					ret += toupper(static_cast<unsigned char> (*it));¤				} else {¤					ret += *it;¤				}¤				break;¤			}	 			¤			case CI_PARAMTER:¤			case CI_CLASS_MEMBER:¤			case CI_VARIBLE: {¤				ret += *it;¤				break;¤			}¤			case CI_CONST: {¤				ret += *it;¤				break;¤			}¤			case CI_ENUM_ITEM: {¤				ret += *it;¤				break;¤			}¤		}¤	}¤	¤	return ret;¤}¤¤// преобразует строку с именем согласно стилю Java¤inline std::string convert_to_java_style (const std::string& str, CodeItem ci ) {¤	std::string ret;¤	// need setlocale;¤	std::string::const_iterator it_begin = str.begin ();¤	std::string::const_iterator it_end = str.end ();¤	for (std::string::const_iterator it = it_begin; it != it_end; it++) {¤		switch (ci) {¤			case CI_FUNCTION:¤			case CI_CLASS:¤			case CI_TYPEDEF:¤			case CI_STRUCT:¤			case CI_EXCEPTION: ¤			case CI_ENUM: {¤				if (*it == '_' && (it + 1) != it_end) {¤					it++;¤					ret += toupper(static_cast<unsigned char> (*it));¤				} else {¤					ret += *it;¤				}¤				break;¤			}	 			¤			case CI_PARAMTER:¤			case CI_CLASS_MEMBER:¤			case CI_VARIBLE: {¤				ret += *it;¤				break;¤			}¤			case CI_CONST: {¤				ret += *it;¤				break;¤			}¤			case CI_ENUM_ITEM: {¤				ret += *it;¤				break;¤			}¤		}¤	}¤	¤	return ret;¤}¤¤inline void to_upper (std::string& str) {¤	for (std::string::iterator it = str.begin(); it != str.end(); it++) {¤#if !defined(__APPLE__)¤		*it = toupper(static_cast<unsigned char> (*it));¤#else¤        *it = char_upper(static_cast<unsigned char> (*it), cd_win);¤#endif¤	}¤}¤¤inline void to_lower (std::string& str) {¤	for (std::string::iterator it = str.begin(); it != str.end(); it++) {¤#if !defined(__APPLE__)¤		*it = tolower(static_cast<unsigned char> (*it));¤#else¤        *it = char_lower(static_cast<unsigned char> (*it), cd_win);¤#endif¤	}¤}¤¤// пересобирает строку из входного  формата в выходной ¤// (в качестве составных элементов поддерживаются только подстроки, общим кол-вом не более 32)¤inline std::string string_converter (¤	const std::string& str¤	, const std::string& in_format¤	, const std::string& out_format¤	, unsigned out_size_multiplicator¤) {¤	std::string ret;¤	if (!str.empty ()) {¤		ret.resize(str.size()*out_size_multiplicator);¤		char s1[1024]; ¤		char s2[1024]; ¤		char s3[1024]; ¤		char s4[64];¤		char s5[64];¤		char s6[64];¤		char s7[64];¤		char s8[64];¤		char s9[64];¤		char s10[64];¤		char s11[64];¤		char s12[64];¤		char s13[64];¤		char s14[64];¤		char s15[64];¤		char s16[64];¤		char s17[64];¤		char s18[64];¤		char s19[64];¤		char s20[64];¤		char s21[64];¤		char s22[64];¤		char s23[64];¤		char s24[64];¤		char s25[64];¤		char s26[64];¤		char s27[64];¤		char s28[64];¤		char s29[64];¤		char s30[64];¤		char s31[64];¤		char s32[64];¤		¤		s1[0] ¤			= s2[0] ¤			= s3[0] ¤			= s4[0] ¤			= s5[0] ¤			= s6[0] ¤			= s7[0] ¤			= s8[0] ¤			= s9[0] ¤			= s10[0] ¤			= s11[0] ¤			= s12[0]¤			= s13[0]¤			= s14[0]¤			= s15[0]¤			= s16[0] ¤			= s17[0] ¤			= s18[0]¤			= s19[0]¤			= s20[0]¤			= s21[0] ¤			= s22[0]¤			= s23[0]¤			= s24[0]¤			= s25[0]¤			= s26[0] ¤			= s27[0] ¤			= s28[0]¤			= s29[0]¤			= s30[0]¤			= s31[0]¤			= s32[0]¤			= 0;¤¤		sscanf (str.data()¤			, in_format.data()¤			, s1¤			, s2¤			, s3¤			, s4¤			, s5¤			, s6¤			, s7¤			, s8¤			, s9¤			, s10¤			, s11¤			, s12¤			, s13¤			, s14¤			, s15¤			, s16¤			, s17¤			, s18¤			, s19¤			, s20¤			, s21¤			, s22¤			, s23¤			, s24¤			, s25¤			, s26¤			, s27¤			, s28¤			, s29¤			, s30¤			, s31¤			, s32¤		);¤		sprintf (const_cast<char*>(ret.c_str())¤			, out_format.data()¤			, s1¤			, s2¤			, s3¤			, s4¤			, s5¤			, s6¤			, s7¤			, s8¤			, s9¤			, s10¤			, s11¤			, s12¤			, s13¤			, s14¤			, s15¤			, s16¤			, s17¤			, s18¤			, s19¤			, s20¤			, s21¤			, s22¤			, s23¤			, s24¤			, s25¤			, s26¤			, s27¤			, s28¤			, s29¤			, s30¤			, s31¤			, s32¤		);¤		ret.resize(strlen(ret.data()));¤	}¤	return ret;¤}¤¤inline void convert_to_scanf_format (std::string& str) {¤	std::string res;¤	for (std::string::iterator it = str.begin(); it != str.end(); it++) {¤		if (*it == '\\') {¤			it++;¤			switch (*it) {¤			case 'n':¤				res += '\n';¤				break;¤			case 't':¤				res += '\t';¤				break;¤			case '0':¤				res += '\0';¤				break;¤			case '\\':¤				res += '\\';¤				break;¤			default:¤				res += *it;¤			}¤		} else {¤			res += *it;¤		}¤	}¤	str = res;¤}¤¤// конвертация символа в нижний регистр (маленькие буквы)¤inline char char_lower (const char chr, code_t code) {¤	char result;¤¤	switch (code) {¤		case cd_win_pseudo:¤		case cd_win: {¤			if (¤				((chr >= 'A') && (chr <= 'Z')) ¤				|| ((chr >= 'А') && (chr <= 'Я'))¤			) {¤				result = chr+0x20;¤			} else {¤				if (chr == 'Ё') {¤					result = 'ё';¤				} else {¤					result = chr;¤				}¤			}¤			break;¤		}¤¤		default: {¤			GDS_ASSERT (false); // неподдерживаямая кодировка¤			result = chr;¤		}¤	}¤¤	return result;¤}¤¤// конвертация символа в верхний регистр (большие буквы)¤inline char char_upper (const char chr, code_t code) {¤	char result;¤¤	switch (code) {¤		case cd_win_pseudo:¤		case cd_win: {¤			if (¤				((chr >= 'a') && (chr <= 'z'))¤				|| ((chr >= 'а') && (chr <= 'я'))¤			) {¤				result = chr-0x20;¤			} else {¤				if (chr == 'ё') {¤					result = 'Ё';¤				} else {¤					result = chr;¤				}¤			}¤			break;¤		}¤¤		default: {¤			assert (false); // неподдерживаямая кодировка¤			result = chr;¤		}¤	}¤¤	return result;¤}¤¤// конвертация строки в нижний регистр (маленькие буквы)¤inline void string_lower (char* src, code_t code) {¤	if (src != 0) {¤		for (; *src != '\0'; ++src) {¤			*src = char_lower (*src, code);¤		}¤	}¤}¤¤// конвертация строки в верхний регистр (большие буквы)¤inline void string_upper (char* src, code_t code) {¤	if (src != 0) {¤		for (; *src != '\0'; ++src) {¤			*src = char_upper (*src, code);¤		}¤	}¤}¤//#UC END# *4503DFAE006D*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/GCL/str/str_conv.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/str/str_conv.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (i.h)"
		    value      	"w:/shared/GCL/str/str_conv.i.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_conv|4503DFAE006D
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (i.h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16663017466")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local helper"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"weak"
		    value      	"false"))
	    quid       	"4503DFAE006D"
	    documentation 	"операции различной конвертации строк (кодировка, кейс, представление и т.д.)"
	    stereotype 	"UtilityPack"
	    operations 	(list Operations
		(object Operation "convert"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"TargetStereotype"
			    value      	"const")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46F9DFD601C5*"
			    value      	(value Text 
|//#UC START# *46F9DFD601C5*¤	if (code_in == code_out) {¤		return src;¤	}¤	std::string result;¤	if (code_in != cd_utf && code_out != cd_utf) {¤		std::vector<char> converted_str (ACE_OS::strlen (src));¤		GCL::buffer_recoding (¤			code_in¤			, code_out¤			, converted_str.size ()¤			, &converted_str[0]¤			, src¤		);¤		result.assign (converted_str.begin (), converted_str.end ());¤	} else {¤		if (code_in == cd_utf) {¤			//конвертируем из utf в code_out¤			switch (code_out) {¤				case cd_win: {					¤					result = utf8_to_win1251 (src);¤					break;¤				}¤				default:¤					GDS_ASSERT_MSG (0, ("Unsupported output coding (%d)", code_out));¤					result = src;¤					break;¤			}¤		} else if (code_out == cd_utf) {¤			switch (code_in) {¤				case cd_win: {¤					result = win1251_to_utf8 (src);					¤					break;¤				}¤				default:¤					GDS_ASSERT_MSG (0, ("Unsupported input coding (%d)", code_in));¤					result = src;¤					break;¤			}¤		}¤	}¤	return result;¤	//#UC END# *46F9DFD601C5*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"452257A0036F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657839026"))
		    quid       	"46F9DFD601C5"
		    documentation 	"конвертирует переданную строку из кодировки code_in в строку с кодировкой code_out"
		    parameters 	(list Parameters
			(object Parameter "src"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFE240068")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657839347"))
			    quid       	"46F9E01901C5"
			    type       	"string"
			    quidu      	"3DBFFE240068")
			(object Parameter "code_in"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"46F9DF0F00EA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657839729"))
			    quid       	"46F9E0190222"
			    type       	"code_t"
			    quidu      	"46F9DF0F00EA")
			(object Parameter "code_out"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"46F9DF0F00EA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657840104"))
			    quid       	"46F9E0190280"
			    type       	"code_t"
			    quidu      	"46F9DF0F00EA"))
		    result     	"a-string"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"452257A0036F")
		(object Operation "utf8_to_win1251"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"TargetStereotype"
			    value      	"const")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46F9E04103C8*"
			    value      	(value Text 
|//#UC START# *46F9E04103C8*¤	static const std::basic_string<unsigned char> utf (reinterpret_cast<const unsigned char*> ("\xD0\xB0\xD0\xB1\xD0\xB2\xD0\xB3\xD0\xB4\xD0\xB5\xD1\x91\xD0\xB6\xD0\xB7\xD0\xB8\xD0\xB9\xD0\xBA\xD0\xBB\xD0\xBC\xD0\xBD\xD0\xBE\xD0\xBF\xD1\x80\xD1\x81\xD1\x82\xD1\x83\xD1\x84\xD1\x85\xD1\x86\xD1\x87\xD1\x88\xD1\x89\xD1\x8A\xD1\x8B\xD1\x8C\xD1\x8D\xD1\x8E\xD1\x8F\xD0\x90\xD0\x91\xD0\x92\xD0\x93\xD0\x94\xD0\x95\xD0\x81\xD0\x96\xD0\x97\xD0\x98\xD0\x99\xD0\x9A\xD0\x9B\xD0\x9C\xD0\x9D\xD0\x9E\xD0\x9F\xD0\xA0\xD0\xA1\xD0\xA2\xD0\xA3\xD0\xA4\xD0\xA5\xD0\xA6\xD0\xA7\xD0\xA8\xD0\xA9\xD0\xAA\xD0\xAB\xD0\xAC\xD0\xAD\xD0\xAE\xD0\xAF"));¤	static const std::string win ("абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ");¤¤	const unsigned char* src_ = reinterpret_cast<const unsigned char*>(src);¤	size_t utf_string_len = ACE_OS::strlen (src);¤	¤	std::string result;¤	for (size_t i = 0; i < utf_string_len; ++i) {¤		if (src_[i] < '\x7F') {¤			result += static_cast<const char> (src_[i]);¤			continue;¤		}¤		if ((src_[i] & 0xF0) == 0xF0) { // четырёхбайтовый символ, пропускаем¤			result += ' ';¤			i += 3;¤			continue;¤		}¤		if ((src_[i] & 0xE0) == 0xE0) { // трёхбайтовый символ, пропускаем, если не №¤			GDS_ASSERT ((i + 2) < utf_string_len);¤			if ((src_[i] == 0xE2) && (src_[i+1] == 0x84) && (src_[i+2] == 0x96)) {¤				result += '№';¤			} else {¤				result += ' ';¤			}¤			i += 2;¤			continue;¤		}¤		GDS_ASSERT ((i + 1) < utf_string_len);¤		for (size_t j = 0, k = 0; j < 132; j += 2, ++k) {					¤			if (src_[i] == utf[j] && src_[i+1] == utf[j+1]) {¤				result += win [k];¤				break;¤			}¤		}¤		++i;¤	}¤	return result;¤	//#UC END# *46F9E04103C8*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"452257A0036F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657840523"))
		    quid       	"46F9E04103C8"
		    documentation 	"конвертирует строку из UTF8 в win1251"
		    parameters 	(list Parameters
			(object Parameter "src"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFE240068")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657840861"))
			    quid       	"46F9E0C2004E"
			    type       	"string"
			    quidu      	"3DBFFE240068"))
		    result     	"a-string"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"452257A0036F")
		(object Operation "win1251_to_utf8"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"TargetStereotype"
			    value      	"const")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46F9E0900148*"
			    value      	(value Text 
|//#UC START# *46F9E0900148*¤	return win1251_to_utf8_i (reinterpret_cast<const unsigned char*> (src), ACE_OS::strlen (src));¤	//#UC END# *46F9E0900148*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"452257A0036F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657841274"))
		    quid       	"46F9E0900148"
		    documentation 	"конвертирует строку из win1251 в UTF8"
		    parameters 	(list Parameters
			(object Parameter "src"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFE240068")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657841583"))
			    quid       	"46F9E0B7032C"
			    type       	"string"
			    quidu      	"3DBFFE240068"))
		    result     	"a-string"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"452257A0036F")
		(object Operation "win1251_to_utf8"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"1369905677871420")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"452257A0036F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"TargetStereotype"
			    value      	"const")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*51A71A0D0359*"
			    value      	(value Text 
|//#UC START# *51A71A0D0359*¤	return win1251_to_utf8_i (reinterpret_cast<const unsigned char*> (src.data ()), src.length ());¤	//#UC END# *51A71A0D0359*
			    )))
		    quid       	"51A71A0D0359"
		    documentation 	"конвертирует строку из win1251 в UTF8"
		    parameters 	(list Parameters
			(object Parameter "src"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"1369905685669972")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F"))
			    quid       	"51A71A150295"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    result     	"a-string"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"452257A0036F"))
	    language   	"MDA Generator"
	    nestedClasses 	(list nestedClasses
		(object Class "code_t"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657836008"))
		    quid       	"46F9DF0F00EA"
		    documentation 	"идентификаторы кодировок"
		    stereotype 	"Enum"
		    class_attributes 	(list class_attribute_list
			(object ClassAttribute "cd_win"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657836317"))
			    quid       	"46F9DF4C001F"
			    documentation 	"кодировка cp1251"
			    initv      	"0"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "cd_dos"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657836723"))
			    quid       	"46F9DF5B038A"
			    documentation 	"кодировка cp866"
			    initv      	"1"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "cd_koi"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657837115"))
			    quid       	"46F9DF72003E"
			    documentation 	"кодировка KOI8-R"
			    initv      	"2"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "cd_mac"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657837521"))
			    quid       	"46F9DF8703B9"
			    documentation 	"кодировка используемая в MacOS"
			    initv      	"3"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "cd_win_pseudo"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657837950"))
			    quid       	"46F9DFA20261"
			    documentation 	"????"
			    initv      	"4"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "cd_utf"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16657838375"))
			    quid       	"46F9DFA703D8"
			    documentation 	"кодировка UTF8"
			    initv      	"5"
			    exportControl 	"Public"
			    Containment 	"By Value")))))
	(object Class "str_op"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4503E01500CB_USER_INCLUDES*"
		    value      	"//#UC START# *4503E01500CB_USER_INCLUDES*¤#include <iterator>¤#include <stack>¤#include <ctype.h>¤#include <algorithm>¤#include <functional>¤#include <locale>¤#include <string.h>¤¤//#UC END# *4503E01500CB_USER_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4503E01500CB_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *4503E01500CB_USER_DEFINITION*¤	inline std::string& str_replace (std::string& in, const char* what, const char* to);¤¤	inline std::string& str_replace (std::string& in, const std::string& what, const std::string& to);¤	¤	// заменяет в переданной строке (str) указанный символ (from) на подстроку (to), на ВСЕЙ длинне стрки,¤	// результат пишеться d lheue. cnhjre (result)¤	inline void replace_char (const std::string& str, std::string& result, char from, const std::string& to);¤	¤	// заменяет в переданной строке (str) указанный символ (from) на подстроку (to), на ВСЕЙ длинне стрки¤	inline std::string& replace_char (std::string& str, char from, char to);¤¤	// удаляет все обрамляющие строку (in) вайт-спейсы¤	inline std::string trim_ws (const char* in);¤¤	// удаляет все обрамляющие строку (in) вайт-спейсы¤	inline std::string trim_ws (const std::string& in);¤¤	// смещает указатель (in) на первый не вайт-спейс символ¤	inline const char* skip_whitespaces (const char* in);¤¤	// обнуляет все финальные символы (chsrs) из переданной последовательности (str)¤	inline void kill_final_char (char* str, const char* chars);¤	¤	// обнуляет все финальные символы (chars) из переданной последовательности (str)¤	inline void kill_final_char (std::string& str, const char* chars);¤¤	// разбивает строку (input) на фрагменты указанной длинны (len), с учетом \n и разбиения на слова¤	inline GCL::StrVector split_string_format (const char* input, unsigned len);¤	¤	¤	// разбивает строку (input)на фрагменты по заданному символу (split_char)¤	template <typename ResultT>¤	inline ResultT& split_string_by (ResultT& res, const char* input, char split_char);¤¤	inline GCL::StrVector split_string_by (const char* input, char split_char);¤	¤	// разбивает строку ([it, it_end]) на фрагменты по заданному символу (split_char),¤	// c учетом вложенных фрагментов-исключений ([open, close]), и эскейп-символов (exclude_symb)¤	inline GCL::StrVector split_string_by (¤		std::string::const_iterator it¤		, const std::string::const_iterator& it_end¤		, char split_char¤		, char open = 0¤		, char exclude_symb = 0¤		, char close = 0¤	);¤¤	// разбивает строку ([it, it_end]) на фрагменты по заданному символу (split_char),¤	// c учетом вложенных фрагментов-исключений ([open, close]) если разделитель встречается внутри¤	// такого блока, то он пропускается¤	// exclude_symb - эскейп-символ¤	// пример:¤	// для строки: fff,zzzz,x{xx,xx}x\,X¤	// split_string (..., ',',"{",'\',"}")¤	// даст¤	//   fff¤	//   zzzz¤	//   x{xx,xx}x,X ¤¤	inline GCL::StrVector split_string_by (¤		std::string::const_iterator it¤		, const std::string::const_iterator& it_end¤		, char split_char¤		, const std::string& open_chars¤		, char exclude_symb¤		, const std::string& close_chars¤	);¤¤	// разбивает строку ([it, it_end]) на фрагменты по заданному символу (split_char),¤	// c учетом вложенных фрагментов-исключений ([open, close]) если разделитель встречается внутри¤	// такого блока, то он пропускается¤	// exclude_symb - эскейп-символ¤	// пример:¤	// для строки: fff,zzzz,x{xx,xx}x\,X¤	// split_string (..., ',',"{",'\',"}")¤	// даст¤	//   fff¤	//   zzzz¤	//   x{xx,xx}x,X ¤	//¤	// функция имеет ограничение на 64 вложенных фрагмента ([open, close])¤	inline void split_string_by (¤		std::string::const_iterator it¤		, const std::string::const_iterator& it_end¤		, char split_char¤		, const std::string& open_chars¤		, char exclude_symb¤		, const std::string& close_chars¤		, GCL::StrVector& result¤	);¤¤	// разбивает строку (str) на фрагменты по заданной подстроке (split_str), разделителем является целая строка¤	template <typename ResultT>¤	inline ResultT& split_string_by_sub_string (ResultT& result, const char* str, const char* split_str);¤¤	inline GCL::StrVector split_string_by_sub_string (const char* str, const char* split_str);¤	inline GCL::StrVector split_string_by_sub_string (const std::string& str, const std::string& split_str);¤¤	// разбивает строку (str) на УНИКАЛЬНЫЕ фрагменты по заданной подстроке (split_str),¤	// разделителем является целая строка¤	inline GCL::StrSet split_string_by_sub_string_uniq (const char* str, const char* split_str);¤¤	// объединяет фрагменты (strs) в единую строку, разделяя их указанной подстрокой (separator)¤	// аналог boost::join, но работает чуть быстрее (что странно :()¤	template <typename InputT, typename SeparatorT>¤	inline std::string join (const InputT& strs, const SeparatorT& separator);¤	¤	// проверяет наличие указанного символа (ch) в строке (str)¤	inline bool contains (char ch, const char* str);¤¤	// разбивает строку (input) на фрагменты по заданноve массиву символов (split_chars),¤	// разделителем является любой символ, в зависимости от флага (remove_empty) пустые фрагменты удаляються или нет¤	inline GCL::StrVector split_string_by_chars (const char* input, const char* split_chars, bool remove_empty = true);¤¤	// возвращает фрагмент строки ([it, it_end]) ограниченный заданными символами (close), ¤	// с учетом вложенных фрагментов ([open, close])  с возможностью задания символа-исключения (exclude_symb)¤	// пример:¤	//		std::string str "text1 text2 {sub fragment} text3 \} text4} text5";¤	//		cout << part (str.begin(), str.end(), '}', '\\', '{');¤	// out:¤	//		text1 text2 {sub fragment} text3 \} text4¤	template <typename Iterator>¤	inline std::string part (¤		Iterator& it¤		, const Iterator& it_end¤		, const char close¤		, const char exclude_symb = 0¤		, const char open = 0¤	);¤¤	// поиск конца фрагмента в массиве [start, end], аналогично part(...)¤	inline char* find_part_end (¤		const char* start¤		, const char* end¤		, const char close¤		, const char exclude_symb = 0¤		, const char open = 0¤	);¤¤	// разбивает строку (input) на фрагменты ограниченные переданными символами (fragment_begin, fragment_end)¤	// пример:¤	//		split_string_by_fragment ("{text1}, {text2}  {text3}{text4}", '{', '}')¤	// вернет массив:¤	//		text1¤	//		text2¤	//		text3¤	//		text4¤	inline GCL::StrVector split_string_by_fragment (const char* input, char fragment_begin, char fragment_end);¤¤	// поиск конца сегмента, НЕ аналогично part(...)¤	inline bool find_char_ex (¤		std::string::const_iterator& it¤		, const std::string::const_iterator& it_end¤		, const char symb¤		, const char open = 0¤		, const char close = 0¤		, const char exclude_symb = 0¤	);¤¤	// разбивает строку ([it, it_end]) на фрагменты ограниченные символами (open, close), c учетом эскейп-символа (exclude_symb)¤	inline GCL::StrVector extract_fragments (¤		std::string::const_iterator& it¤		, const std::string::const_iterator& it_end¤		, const char open¤		, const char close = 0¤		, const char exclude_symb = 0		¤	);¤¤	// возвращает полную строку из тестового потока ([start, end]), к которой пренадлежит позиция указателя (at)¤	inline std::string get_line (¤		const std::string::const_iterator& at¤		, const std::string::const_iterator& start¤		, const std::string::const_iterator& end¤	);¤¤¤	// str начинается с prefix¤	//  Если prefix = 0 то возвращает true¤	inline bool start_with (const char* str, const char* prefix);¤¤	inline bool start_with (const std::string& str, const std::string& prefix);¤¤	// str начинается с prefix без учета регистра¤	//   Если prefix = 0 то возвращает true¤	inline bool starti_with (const char* str, const char* prefix, const std::locale& loc);¤¤	// str заканчивается с sufix¤	//   Если sufix = 0 то возвращает true¤	inline bool end_with (const char* str, const char* sufix);¤¤	// str заканчивается с sufix юез учета регистра¤	//   Если sufix = 0 то возвращает true¤	inline bool endi_with (const char* str, const char* sufix, const std::locale& loc);¤¤	// str начинается и заканчивается border¤	//   Если border = 0 то возвращает true¤	inline bool border_with (const char* str, const char* border);¤¤	// str начинается и заканчивается border без учета регистра¤	//   Если border = 0 то возвращает true¤	inline bool borderi_with (const char* str, const char* border, const std::locale& loc);¤¤	// str начинается с prefix_char¤	inline bool start_with (const char* str, const char prefix_char);¤¤	// str заканчивается с sufix_char¤	inline bool end_with (const char* str, const char sufix_char);¤	¤	// str начинается и заканчивается border_char¤	inline bool border_with (const char* str, const char border_char);¤¤	// поиск подстроки с использованием языковой кодировки, без учета регистра c использованием STL¤	// (порддерживаются - s_ru_win, s_ru_dos, s_ru_koi, s_eng)¤	// возвращается указатель найденной подстроки, в противном случае возвращается указатель на конец строки¤	inline const char* strstr (const char* str1, const char* str2, const std::locale& loc);¤¤	inline int to_upper_win (int ch );¤¤	inline int str_compare_strong (const char * s1, const char * s2);¤	inline ssize_t str_compare_strong_with_len (const char * s1, const char * s2);¤¤	// проверка символа на то, что он является буквой¤	inline bool is_alpha (const char chr, code_t code = cd_win);¤	¤	// проверка символа на то, что он является цифрой¤	inline bool is_digit (const char chr, code_t code = cd_win);¤	¤	// проверка символа на то, что он является цифрой или буквой¤	inline bool is_alnum (const char chr, code_t code = cd_win);¤	¤	// проверка символа на то, что он является символом разделителем¤	inline bool is_delimiter (const char chr);¤¤	// проверка символа на то, что он является символом таблицы (псевдографика)¤	inline bool is_table (const char chr);¤	¤	// проверка символа на нижний регистр (маленькие буквы)¤	inline bool is_lower (const char chr, code_t code = cd_win);¤	¤	// проверка символа на верхний регистр (большие буквы)¤	inline bool is_upper (const char chr, code_t code = cd_win);¤	¤	// поиск подстроки в строке с учетом регистра¤	// возвращается указатель найденной подстроки, в противном случае возвращается 0¤	inline const char* find_sub_string (const char* string, const char* sub_string);¤¤	// поиск подстроки в строке без учетом регистра¤	// возвращается указатель найденной подстроки, в противном случае возвращается 0¤	inline const char* find_sub_string_nocase (const char* string, const char* sub_string, code_t code = cd_win);¤¤	// возвращает позицию первого пробела или знака препинания после заданной¤	// если до конца строки такой позиции не встретилось, возвращает 0¤	inline size_t find_end_of_word_after_position (const char* string, size_t position);¤	¤	template <typename ContainerT>¤	struct ContainerTraits;¤//#UC END# *4503E01500CB_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*4503E01500CB_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4503E01500CB_CUSTOM_INCLUDES*¤#include "shared/Core/data/unsorted_containers.h"¤//#UC END# *4503E01500CB_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"i.h:*4503E01500CB*"
		    value      	(value Text 
|//#UC START# *4503E01500CB*¤// заменяет в переданной строке (in) указанную подстроку (what) другой (to), на ВСЕЙ длинне стрки¤inline std::string& str_replace (std::string& in, const char* what, const char* to) {¤	size_t what_size = strlen (what);¤	size_t to_size = strlen (to);¤	¤	size_t offset = 0;¤	size_t p;¤	while ((p = in.find(what, offset)) != std::string::npos) {¤		in.replace(p, what_size, to);¤		offset = p + to_size;¤	}	¤¤	return in;¤}¤¤inline std::string& str_replace (std::string& in, const std::string& what, const std::string& to) {¤	return str_replace (in, what.c_str (), to.c_str ());¤}¤¤// заменяет в переданной строке (str) указанный символ (from) на подстроку (to), на ВСЕЙ длинне стрки,¤// результат пишеться в result¤inline void replace_char (const std::string& str, std::string& result, char from, const std::string& to) {¤	result.erase();¤	for (std::string::const_iterator it = str.begin(); it != str.end(); it++) {¤		if (*it == from) {¤			result += to;¤		} else {¤			result += *it;¤		}¤	}		¤}¤¤// заменяет в переданной строке (str) указанный символ (from) на символ (to), на ВСЕЙ длинне стрки¤inline std::string& replace_char (std::string& str, char from, char to) {¤	for (std::string::iterator it = str.begin(); it != str.end(); it++) {¤		if (*it == from) {¤			*it = to;¤		}¤	}¤	return str;¤}¤¤// удаляет все обрамляющие строку (in) вайт-спейсы¤inline std::string trim_ws (const char* in) {¤	while (*in && (*in > 0 && (isspace ((unsigned char)*in) || *in == 9))) {¤		in++;¤	}¤	std::string ret = in;¤¤	size_t i = ret.size ();¤	while (i && (ret [i-1] > 0 && (isspace (ret [i-1]) || ret [i-1] == 9))) {¤		i--;¤	}¤	ret.resize (i);¤	return ret;¤}¤¤// удаляет все обрамляющие строку (in) вайт-спейсы¤inline std::string trim_ws (const std::string& in) {¤	return trim_ws (in.c_str ());¤}¤¤// смещает указатель (in) на первый не вайт-спейс символ¤inline const char* skip_whitespaces (const char* in) {¤	while (*in && (isspace ((unsigned char)*in) || *in == 9)) {¤		in++;¤	}¤	return in;¤}¤¤// обнуляет все финальные символы (chsrs) из переданной последовательности (str)¤inline void kill_final_char (char* str, const char* chars) {¤	size_t ch_len = strlen (chars);¤	for (size_t i = strlen (str) - 1; i > 0; i--) {¤		bool find = false;¤		for (size_t ii = 0; ii < ch_len && !find; ii++) {¤			find = (str[i] == chars[ii]);¤		}¤¤		if (find) {¤			str[i] = 0;¤		} else {¤			return;¤		}¤	}¤}¤¤// обнуляет все финальные символы (chars) из переданной последовательности (str)¤inline void kill_final_char (std::string& str, const char* chars) {¤	size_t ch_len = strlen (chars);¤	for (size_t i = str.size () - 1; i > 0; i--) {¤		bool find = false;¤		for (size_t ii = 0; ii < ch_len && !find; ii++) {¤			find = (str[i] == chars[ii]);¤		}¤¤		if (find) {¤			str.erase (i);¤		} else {¤			return;¤		}¤	}¤}¤¤// разбивает строку (input) на фрагменты указанной длинны (n), с учетом \n и разбиения на слова¤inline GCL::StrVector split_string_format (const char* input, size_t n) {¤	std::vector<std::string> strs;¤¤	size_t str_len = strlen (input);¤	size_t start_pos = 0; //начальная позиция в строке, с которой можно копировать подстроку	¤	for (size_t pos = 0, delim_pos = std::string::npos; pos < str_len; ++pos) {¤		const char ch = input[pos];¤		if (pos >= (start_pos + n) || ch == '\n') {¤			size_t count = ch == '\n' ¤				? pos - start_pos ¤				: delim_pos != std::string::npos ¤					? delim_pos - start_pos + 1 ¤					: pos - start_pos + 1;¤			strs.push_back (std::string (input + start_pos, count));¤			start_pos += count + ((ch == '\n') ? 1 : 0);¤			delim_pos = std::string::npos; //сбрасываем позицию разделителя¤		} else if (ch == ' ' || ch == '-') {¤			//запоминаем разделитель¤			delim_pos = pos;¤		}¤	}¤	if (start_pos < str_len) {¤		strs.push_back (std::string (input + start_pos, str_len - start_pos));¤	}¤	return strs;¤}¤¤template <typename ContainerT>¤struct ContainerTraits {¤	static void append (ContainerT& cont, const typename ContainerT::value_type& value) {¤		cont.push_back (value);¤	}¤};¤¤template <typename key, typename compare, typename allocator>¤struct ContainerTraits<std::set<key, compare, allocator> > {¤	typedef std::set<key, compare, allocator> ContainerT;¤	static void append (ContainerT& cont, const typename ContainerT::value_type& value) {¤		cont.insert (value);¤	}¤};¤¤template <¤	class Value¤	, class Hash¤	, class Pred¤	, class Alloc¤>¤struct ContainerTraits<boost::unordered_set<Value, Hash, Pred, Alloc> > {¤	typedef boost::unordered_set<Value, Hash, Pred, Alloc> ContainerT;¤	static void append (ContainerT& cont, const typename ContainerT::value_type& value) {¤		cont.insert (value);¤	}¤};¤¤// разбивает строку (input)на фрагменты по заданному символу (split_char)¤template <typename ResultT>¤inline ResultT& split_string_by (ResultT& res, const char* input, char split_char) {¤	const char* str = input;¤	size_t total_count = 0; ¤¤	// Пропускаем символ-разделитель¤	while (*str && *str == split_char) {¤		total_count++;¤		str++;¤	}¤	while (total_count < strlen (input)) {¤		size_t pos = 0;¤		// find split char¤		while ( str[pos+1] && str[pos] != split_char ) pos++;¤¤		if ( pos ) { ¤			std::string s (str, str[pos] == split_char ? pos : pos+1);¤			ContainerTraits<ResultT>::append (res, s);¤		} else if ( str[0] ) {				¤			//res.push_back(str);¤			ContainerTraits<ResultT>::append (res, str);¤		}¤		total_count += pos + 1;¤		str += pos + 1;¤		// пропускаем все символы-разделители, если их вдруг несколько¤		while (*str && *str == split_char) {¤			str++;¤			total_count++;¤		}¤	}¤¤	return res;¤}¤¤inline GCL::StrVector split_string_by (const char* input, char split_char) {¤	GCL::StrVector strs;¤	split_string_by (strs, input, split_char);¤	return strs;¤}¤¤// разбивает строку ([it, it_end]) на фрагменты по заданному символу (split_char),¤// c учетом вложенных фрагментов-исключений ([open, close]), и эскейп-символов (exclude_symb)¤inline GCL::StrVector split_string_by (¤	std::string::const_iterator it¤	, const std::string::const_iterator& it_end¤	, char split_char¤	, char open¤	, char exclude_symb¤	, char close¤) {¤	if (!close) {¤		close = open;¤	}¤	GCL::StrVector strs;¤	size_t sub_part_count = 0;¤¤	while (it != it_end) {¤		std::string::const_iterator it_begin = it;¤		while (it != it_end) {				¤			if (*it == open && (open != close || !sub_part_count)) {¤				sub_part_count++;				¤			} else if (*it == close) {¤				sub_part_count--;				¤			} else if (*it == split_char && !sub_part_count) {¤				break;¤			}¤			if (*it == exclude_symb) {¤				it++;¤			} 				¤			it++;¤		}¤		¤		strs.push_back(std::string (it_begin, it));¤		if (it != it_end) it++;¤	}		¤	return strs;¤}¤¤// разбивает строку ([it, it_end]) на фрагменты по заданному символу (split_char),¤// c учетом вложенных фрагментов-исключений ([open, close]) если разделитель встречается внутри¤// такого блока, то он пропускается¤// exclude_symb - эскейп-символ¤// пример:¤// для строки: fff,zzzz,x{xx,xx}x\,X¤// split_string (..., ',',"{",'\',"}")¤// даст¤//   fff¤//   zzzz¤//   x{xx,xx}x,X ¤//¤// функция имеет ограничение на 64 вложенных фрагмента ([open, close])¤¤inline void split_string_by (¤	std::string::const_iterator it¤	, const std::string::const_iterator& it_end¤	, char split_char¤	, const std::string& open_chars¤	, char exclude_symb¤	, const std::string& close_chars¤	, GCL::StrVector& result¤) {	¤	std::string temp (it, it_end);¤	if (GCL::contains (split_char, temp.c_str ())) {¤		char fragment_close_stack[64] = {};¤		long current_level = -1;¤		while (it != it_end) {¤			std::string::const_iterator it_begin = it;¤			while (it != it_end) {				¤				if (current_level >= 0 && *it == fragment_close_stack[current_level]) {					¤					// close opened fragment¤					--current_level;					¤				} else {¤					std::string::size_type open_fnd = open_chars.find (*it);¤					if (open_fnd != std::string::npos) {¤						// open new fragments¤						fragment_close_stack[++current_level] = close_chars[open_fnd];¤					} else if (*it == split_char && current_level < 0) {¤						break;						¤					}¤				}												¤				if (*it == exclude_symb) {¤					it++;¤				} 				¤				it++;¤			}¤			¤			result.push_back(std::string (it_begin, it));¤			if (it != it_end) it++;¤		}	¤	} else {¤		result.push_back (temp);¤	}¤}¤// разбивает строку ([it, it_end]) на фрагменты по заданному символу (split_char),¤// c учетом вложенных фрагментов-исключений ([open, close]) если разделитель встречается внутри¤// такого блока, то он пропускается¤// exclude_symb - эскейп-символ¤// пример:¤// для строки: fff,zzzz,x{xx,xx}x\,X¤// split_string (..., ',',"{",'\',"}")¤// даст¤//   fff¤//   zzzz¤//   x{xx,xx}x,X ¤¤inline GCL::StrVector split_string_by (¤	std::string::const_iterator it¤	, const std::string::const_iterator& it_end¤	, char split_char¤	, const std::string& open_chars¤	, char exclude_symb¤	, const std::string& close_chars¤) {¤	GCL::StrVector strs;			¤	std::string temp (it, it_end);¤	if (GCL::contains (split_char, temp.c_str ())) {¤		std::stack<char> fragment_close_stack;¤		while (it != it_end) {¤			std::string::const_iterator it_begin = it;¤			while (it != it_end) {				¤				if (fragment_close_stack.size() && *it == fragment_close_stack.top()) {					¤					// close opened fragment¤					fragment_close_stack.pop();					¤				} else {¤					std::string::size_type open_fnd = open_chars.find (*it);¤					if (open_fnd != std::string::npos) {¤						// open new fragments¤						fragment_close_stack.push(close_chars[open_fnd]);¤					} else if (*it == split_char && !fragment_close_stack.size()) {¤						break;						¤					}¤				}												¤				if (*it == exclude_symb) {¤					it++;¤				} 				¤				it++;¤			}¤			¤			strs.push_back(std::string (it_begin, it));¤			if (it != it_end) it++;¤		}	¤	} else {¤		strs.push_back(temp);¤	}¤	return strs;¤}¤¤// разбивает строку (str) на фрагменты по заданной подстроке (split_str), разделителем является целая строка¤template <class ResultT>¤ResultT& split_string_by_sub_string (ResultT& result, const char* str, const char* split_str) {¤	size_t split_size = strlen(split_str);¤	while (str) {¤		const char* pstr = ::strstr (str, split_str);¤¤		std::string s (str, pstr ? pstr-str : strlen(str));¤		if (!s.empty ()) {¤			ContainerTraits<ResultT>::append (result, s);¤		}¤		¤		str = pstr ? pstr + split_size: 0;¤	}¤	return result;¤}¤¤inline GCL::StrVector split_string_by_sub_string (const char* str, const char* split_str) {¤	GCL::StrVector strs;	¤	split_string_by_sub_string (strs, str, split_str);¤	return strs;¤}¤¤inline GCL::StrVector split_string_by_sub_string (const std::string& str, const std::string& split_str) {¤	return split_string_by_sub_string (str.c_str (), split_str.c_str ());¤}¤// разбивает строку (str) на УНИКАЛЬНЫЕ фрагменты по заданной подстроке (split_str),¤// разделителем является целая строка¤inline GCL::StrSet split_string_by_sub_string_uniq (const char* str, const char* split_str) {¤	GCL::StrSet strs;	¤	split_string_by_sub_string (strs, str, split_str);¤	return strs;¤}¤¤// объединяет фрагменты (strs) в единую строку, разделяя их указанной подстрокой (merge_str)¤template <typename InputT, typename SeparatorT>¤inline std::string join (const InputT& strs, const SeparatorT& separator) {¤	std::string ret;¤	typedef typename InputT::const_iterator const_iterator;¤	const_iterator it = strs.begin ();¤	const_iterator it_end = strs.end ();¤¤	for (; it != it_end; it++) {¤		ret += *it;¤		if (std::distance (it, it_end) > 1 ) {¤			ret += separator;¤		}¤	}¤	return ret;¤}¤¤// проверяет наличие указанного символа (ch) в строке (str)¤inline bool contains (char ch, const char* str) {¤	while (*str) {¤		if (*str == ch) {¤			return true;¤		}¤		str++;¤	}¤	return false;¤}¤¤// разбивает строку (input) на фрагменты по заданноve массиву символов (split_chars),¤// разделителем является любой символ, в зависимости от флага (remove_empty) пустые фрагменты удаляються или нет¤inline GCL::StrVector split_string_by_chars (const char* input, const char* split_chars, bool remove_empty) {¤	GCL::StrVector strs;¤	¤	const char* str = input;¤	while (*str) {¤		size_t f_pos = strcspn (str, split_chars);			¤¤		if (f_pos) {				¤			strs.push_back(std::string (str, str + f_pos));¤		} else {¤			if (!remove_empty) {¤				strs.push_back ("");¤			}¤		}¤		¤		str += f_pos;			¤		if (*str) {¤			str++;¤		}¤	}¤	return strs;¤}¤¤// возвращает фрагмент строки ([it, it_end]) ограниченный заданными символами (close), ¤// с учетом вложенных фрагментов ([open, close])  с возможностью задания символа-исключения (exclude_symb)¤// пример:¤//		std::string str "text1 text2 {sub fragment} text3 \} text4} text5";¤//		cout << part (str.begin(), str.end(), '}', '\\', '{');¤// out:¤//		text1 text2 {sub fragment} text3 \} text4¤template <typename Iterator>¤inline std::string part (¤	Iterator& it¤	, const Iterator& it_end¤	, const char close¤	, const char exclude_symb¤	, const char open¤) {¤	if (it == it_end) {¤		return std::string ();¤	}¤¤	Iterator it_begin = it;¤	it_begin++;¤	size_t sub_part_count = 1;¤	¤	while (it != it_end && sub_part_count) {¤		it++;¤		if (it == it_end) {¤			break;¤		}¤¤		if (*it == open) {¤			sub_part_count++;¤		}¤¤		if (*it == close) {¤			sub_part_count--;¤		}¤¤		if (*it == exclude_symb) {¤			it++;¤		}¤	}¤	¤	std::string ret (it_begin, it);¤	return ret;¤}¤¤// поиск конца фрагмента в массиве [start, end], аналогично part(...)¤inline char* find_part_end (¤	const char* start¤	, const char* end¤	, const char close¤	, const char exclude_symb¤	, const char open¤) {¤	size_t sub_part_count = 1;¤	¤	while (start != end && sub_part_count) {¤		start++;¤		if (*start == open) sub_part_count++;¤		if (*start == close) sub_part_count--;¤		if (*start == exclude_symb) start++;¤	}¤	¤	return const_cast<char*>(start);¤}¤¤// разбивает строку (input) на фрагменты ограниченные переданными символами (fragment_begin, fragment_end)¤// пример:¤//		split_string_by_fragment ("{text1}, {text2}  {text3}{text4}", '{', '}')¤// вернет массив:¤//		text1¤//		text2¤//		text3¤//		text4¤inline GCL::StrVector split_string_by_fragment (const char* input, char fragment_begin, char fragment_end) {¤	GCL::StrVector strs;¤¤	const char* str = input;¤	size_t begin_pos = 0; ¤	size_t end_pos = 0; ¤¤	do {			¤		// find begin char¤		while (str[begin_pos] && str[begin_pos] != fragment_begin) begin_pos++;¤		¤		if (str[begin_pos]) {¤			if (fragment_begin == fragment_end) {¤				begin_pos++;¤				end_pos = begin_pos;¤				while (str[end_pos] && str[end_pos] != fragment_end) end_pos++;¤			} else {¤				end_pos = find_part_end (str + begin_pos, 0, fragment_end, '\\', fragment_begin) - input;¤				begin_pos++;¤			}				¤			¤			if ( str[end_pos] ) { ¤				std::string s (str+begin_pos, end_pos - begin_pos);¤				strs.push_back(s);¤				end_pos++;¤				begin_pos = end_pos;¤			}¤		}¤	} while (str[begin_pos] && str[end_pos]);¤	¤	return strs;¤}¤¤¤// поиск конца сегмента, НЕ аналогично part(...)¤inline bool find_char_ex (¤	std::string::const_iterator& it¤	, const std::string::const_iterator& it_end¤	, const char symb¤	, const char open¤	, const char close¤	, const char exclude_symb¤) {¤	bool ret = false;¤	size_t sub_part_count = 0;¤	bool is_open = false;¤¤	for ( ; it != it_end; it++) {			¤		if (*it == open) {¤			if (open == close) {¤				if (!is_open) {¤					is_open = true;¤					sub_part_count++;¤				} else {¤					is_open = false;¤					sub_part_count--;¤				}¤			} else {¤				sub_part_count++;¤			}¤		} else if (*it == close) {¤			sub_part_count--;¤		} else if (*it == exclude_symb) {¤			it++;¤		} else if (!sub_part_count && *it == symb) {¤			ret = true;¤			break;¤		}¤	}¤	¤	return ret;¤}¤¤// разбивает строку ([it, it_end]) на фрагменты ограниченные символами (open, close), c учетом эскейп-символа (exclude_symb)¤inline GCL::StrVector extract_fragments (¤	std::string::const_iterator& it¤	, const std::string::const_iterator& it_end¤	, const char open¤	, const char close¤	, const char exclude_symb¤) {¤	GCL::StrVector strs;¤	while ( it != it_end && *it == open) {¤		strs.push_back(part(it, it_end, close, exclude_symb, open));¤		it++;¤	}¤	return strs;¤}¤¤// возвращает полную строку из тестового потока ([start, end]), к которой пренадлежит позиция указателя (at)¤inline std::string get_line (¤	const std::string::const_iterator& at¤	, const std::string::const_iterator& start¤	, const std::string::const_iterator& end¤) {¤	std::string::const_iterator str_start = at;¤	std::string::const_iterator str_end = at;¤	for (; str_start != start; str_start--) {¤		if (*str_start == '\n') break;¤	}¤	for (; str_end != end; str_end++) {¤		if (*str_end == '\n') break;¤	}¤¤	return std::string (str_start, str_end);¤}¤¤// вспомагательный класс для сравнения символов без учета регистра¤struct no_case : std::binary_function <char, char, bool> {¤	std::locale m_locale;¤¤	no_case (const std::locale loc = std::locale::classic ())¤		: m_locale (loc) {¤	};¤	¤	bool operator () (char c1, char c2) const {¤		return std::toupper (c1, m_locale) == std::toupper (c2, m_locale);¤	};¤};¤¤// str начинается с prefix¤//   Если prefix = 0 то возвращает true¤inline bool start_with (const char* str, const char* prefix) {¤	bool retv;¤¤	retv = false;¤¤	if (prefix == 0) {¤		retv = true;¤	} else if (str) {¤		size_t str_len = strlen (str);¤		size_t prefix_len = strlen (prefix);¤¤		if (str_len >= prefix_len) {¤			retv = memcmp (str, prefix, prefix_len) == 0;¤		}¤	}¤¤	return retv;¤}¤¤inline bool start_with (const std::string& str, const std::string& prefix) {¤	return start_with (str.c_str (), prefix.c_str ());¤}¤¤// str заканчивается с sufix¤//   Если sufix = 0 то возвращает true¤inline bool end_with (const char* str, const char* sufix) {¤	bool retv;¤¤	retv = false;¤¤	if (sufix == 0) {¤		retv = true;¤	} else if (str) {¤		size_t str_len = strlen (str);¤		size_t sufix_len = strlen (sufix);¤¤		if (str_len >= sufix_len) {¤			retv = memcmp (str + (str_len - sufix_len), sufix, sufix_len) == 0;¤		}¤	}¤¤	return retv;¤}¤¤// str начинается и заканчивается border¤//   Если border = 0 то возвращает true¤inline bool border_with (const char* str, const char* border) {¤	bool retv;¤¤	retv = false;¤¤	if (border == 0) {¤		retv = true;¤	} else if (str) {¤		size_t str_len = strlen (str);¤		size_t border_len = strlen (border);¤¤		if (str_len >= border_len) {¤			retv = (memcmp (str, border, border_len) == 0)¤					&& (memcmp (str + (str_len - border_len), border, border_len) == 0);¤		}¤	}¤¤	return retv;¤}¤¤// str начинается с prefix_char¤inline bool start_with (const char* str, const char prefix_char) {¤	bool retv = false;¤¤	if (str) {¤		retv = str [0] == prefix_char;¤	}¤¤	return retv;¤}¤¤// str начинается с prefix_char без учета регистра¤inline bool starti_with (const char* str, const char prefix_char, const std::locale& loc) {¤	bool retv = false;¤¤	if (str) {¤		retv = std::toupper (str [0], loc) == std::toupper (prefix_char, loc);¤	}¤¤	return retv;¤}¤¤// str заканчивается с sufix_char¤inline bool end_with (const char* str, const char sufix_char) {¤	bool retv = false;¤¤	if (str) {¤		size_t str_len = strlen (str);¤¤		retv = str [str_len - 1] == sufix_char;¤	}¤¤	return retv;¤}¤¤// str заканчивается с sufix_char без учета регистра¤inline bool endi_with (const char* str, const char sufix_char, const std::locale& loc) {¤	bool retv = false;¤¤	if (str) {¤		size_t str_len = strlen (str);¤¤		retv = std::toupper (str [str_len - 1], loc) == std::toupper (sufix_char, loc);¤	}¤¤	return retv;¤}¤¤// str начинается и заканчивается border_char¤inline bool border_with (const char* str, const char border_char) {¤	bool retv;¤¤	retv = false;¤¤	if (str) {¤		size_t str_len = strlen (str);¤¤		retv = (str [0] == border_char) && (str [str_len - 1] == border_char);¤	}¤¤	return retv;¤}¤¤// str начинается и заканчивается border_char без учета регистра¤inline bool borderi_with (const char* str, const char border_char, const std::locale& loc) {¤	bool retv = false;¤¤	if (str) {¤		size_t str_len = strlen (str);¤¤		retv = (std::toupper (str [0], loc) == std::toupper (border_char, loc))¤				&& (std::toupper (str [str_len - 1], loc) == std::toupper (border_char, loc));¤	}¤¤	return retv;¤}¤¤// поиск подстроки с использованием языковой кодировки, без учета регистра¤//  c использованием STL¤//  (порддерживаются - s_ru_win, s_ru_dos, s_ru_koi, s_eng)¤//  возвращается указатель найденной подстроки, в противном случае возвращается указатель¤//  на конец строки¤inline const char* strstr (const char* str1, const char* str2, const std::locale& loc) {¤	if (str1 != 0 && str2 != 0) {¤		return std::search (str1, str1 + strlen (str1), str2, str2 + strlen (str2), no_case (loc));¤	} else {¤		return str1;¤	}¤};¤¤inline int to_upper_win ( int ch ) {¤	if ( ch >= 'a' && ch <= 'z' )¤		return ch + 'A' - 'a';¤	if ( ch >= 'а' && ch <= 'я' )¤		return ch + 'А' - 'а';¤	else¤		return ch;¤}¤¤inline int str_compare_strong ( const char * s1, const char * s2) {¤	register unsigned char c1, c2;¤	//	int	c1, c2;¤¤	if (s1==0 || s2==0) {¤		return 0;¤	}¤	if ( * s1 == '\"' )¤		s1++;¤¤	if ( * s2 == '\"' )¤		s2++;¤¤	for (register int i = 0; (s1 [i] != 0) && (s2 [i] != 0); i++) {¤		c1 = to_upper_win(s1 [i]);¤		c2 = to_upper_win(s2 [i]);¤		// skip masked characters¤		if ( c1 == '?' || c2 == '?' )¤			continue;¤¤		if ( c1 != c2 )¤			return c1 - c2;			¤	}¤¤	if ( c1 == 0 || c2 == 0 )¤		return c1 - c2;¤¤	return 0;		// strings matches in first n positions¤}¤¤inline ssize_t str_compare_strong_with_len (const char * s1, const char * s2) {¤	if (s1==0 || s2==0) {¤		return 0;¤	}¤	int result = str_compare_strong (s1, s2);¤	return result ? result : ACE_OS::strlen (s1) - ACE_OS::strlen (s2);¤}¤¤// проверка символа на то, что он является буквой¤inline bool is_alpha (const char chr, code_t code) {¤	bool result;¤¤	switch (code) {¤		case cd_win_pseudo:¤		case cd_win: {¤			if (¤				((chr >= 'A') && (chr <= 'Z'))¤				|| ((chr >= 'a') && (chr <= 'z'))¤				|| ((chr >= 'А') && (chr <= 'Я'))¤				|| ((chr >= 'а') && (chr <= 'я'))¤				|| ((chr == 'Ё') || (chr == 'ё'))¤			) {¤				result = true;¤			} else {¤				result = false;¤			}¤			break;¤		}¤¤		default: {¤			assert (false); // неподдерживаямая кодировка¤			result = false;¤		}¤	}¤¤	return result;¤}¤¤// проверка символа на то, что он является цифрой¤inline bool is_digit (const char chr, code_t code) {¤	bool result;¤¤	switch (code) {¤		case cd_win:¤		case cd_win_pseudo:¤		case cd_dos:¤		case cd_koi:¤		case cd_mac: {¤			if ((chr >= '0') && (chr <= '9')) {¤				result = true;¤			} else {¤				result = false;¤			}¤			break;¤		}¤¤		default: {¤			assert (false); // неподдерживаямая кодировка¤			result = false;¤		}¤	}¤¤	return result;¤}¤¤// проверка символа на то, что он является цифрой или буквой¤inline bool is_alnum (const char chr, code_t code) {¤	return is_alpha (chr, code) || is_digit (chr, code);¤}¤¤static const char* WORDS_DELIMETERS = " ,.\"\'(){}=-\\|/:;[]\r\n\t";¤¤// проверка символа на то, что он является символом разделителем¤inline bool is_delimiter (const char chr) {¤	return strchr (WORDS_DELIMETERS, chr) != 0;¤}¤¤static const char* TABLE_SYMBOL = "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a";¤// проверка символа на то, что он является символом таблицы (псевдографика)¤inline bool is_table (const char chr) {¤	return strchr (TABLE_SYMBOL, chr) != 0;¤}¤¤// проверка символа на нижний регистр (маленькие буквы)¤inline bool is_lower (const char chr, code_t code) {¤	bool result;¤¤	switch (code) {¤		case cd_win_pseudo:¤		case cd_win: {¤			if (¤				((chr >= 'a') && (chr <= 'z'))¤				|| ((chr >= 'а') && (chr <= 'я'))¤				|| (chr == 'ё')¤			) {¤				result = true;¤			} else {¤				result = false;¤			}¤			break;¤		}¤¤		default: {¤			assert (false); // неподдерживаямая кодировка¤			result = false;¤		}¤	}¤¤	return result;¤}¤¤// проверка символа на верхний регистр (большие буквы)¤inline bool is_upper (const char chr, code_t code) {¤	bool result;¤¤	switch (code) {¤		case cd_win_pseudo:¤		case cd_win: {¤			if (¤				((chr >= 'A') && (chr <= 'Z'))¤				|| ((chr >= 'А') && (chr <= 'Я'))¤				|| (chr == 'Ё')¤			) {¤				result = true;¤			} else {¤				result = false;¤			}¤			break;¤		}¤¤		default: {¤			assert (false); // неподдерживаямая кодировка¤			result = false;¤		}¤	}¤¤	return result;¤}¤¤// поиск подстроки в строке с учетом регистра¤// возвращается указатель найденной подстроки, в противном случае возвращается 0¤inline const char* find_sub_string (const char* string, const char* sub_string) {¤	if ((string == 0) || (sub_string == 0) || (*sub_string == '\0')) {¤		return string;¤	}¤¤	char* string_head = (char*)string;¤	while (*string_head != '\0') {¤		char* s1 = string_head;¤		char* s2 = (char*)sub_string;¤¤		while ((*s1 != '\0') && (*s2 != '\0') && !(*s1-*s2)) {¤			++s1;¤			++s2;¤		}¤¤		if (*s2 == '\0') {¤			break;¤		}¤¤		++string_head;¤	}¤¤	return *string_head != 0 ? string_head : 0;¤}¤¤// поиск подстроки в строке без учетом регистра¤// возвращается указатель найденной подстроки, в противном случае возвращается 0¤inline const char* find_sub_string_nocase (const char* string, const char* sub_string, code_t code) {¤	if ((string == 0) || (sub_string == 0) || (*sub_string == '\0')) {¤		return string;¤	}¤¤	char* string_head = (char*)string;¤	while (*string_head != '\0') {¤		char* s1 = string_head;¤		char* s2 = (char*)sub_string;¤¤		while ((*s1 != '\0') && (*s2 != '\0') && !(char_upper (*s1, code)-char_upper (*s2, code))) {¤			++s1;¤			++s2;¤		}¤¤		if (*s2 == '\0') {¤			break;¤		}¤¤		++string_head;¤	}¤¤	return *string_head != 0 ? string_head : 0;¤}¤¤// возвращает позицию первого пробела или знака препинания после заданной¤// если до конца строки такой позиции не встретилось, возвращает 0¤inline size_t find_end_of_word_after_position (const char* line, size_t position) {¤	if (!line || (ACE_OS::strlen (line) <= position - 1)) {¤		return 0; ¤	}¤¤	for (size_t i = position - 1; i < ACE_OS::strlen (line); ++i) {¤		if (ACE_OS::ace_isspace (line[i]) || ACE_OS::ace_ispunct (line[i])) {¤			return i + 1;¤		}¤	}¤¤	return 0;¤}¤//#UC END# *4503E01500CB*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"ifdef"
		    value      	"")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/str/str_op.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (i.h)"
		    value      	"w:/shared/GCL/str/str_op.i.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/str_op|4503E01500CB
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (i.h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16663737823"))
	    quid       	"4503E01500CB"
	    documentation 	"различные операции преобразования строк, поиска в строке, замены подстрок слияние фрагментов и т.д."
	    stereotype 	"UtilityPack"
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657842736"))
		    quid       	"4504225A031C"
		    supplier   	"Logical View::shared::GCL::str::str_conv"
		    quidu      	"4503DFAE006D")
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16657843110"))
		    quid       	"450422640109"
		    supplier   	"Logical View::shared::GCL::data::std_defs"
		    quidu      	"44FEBDF3039B"))
	    language   	"MDA Generator")
	(object Class "base64_encoder"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local helper"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"weak"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/GCL/str/base64_encoder.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*48FDB9CE0275_USER_INCLUDES*"
		    value      	"//#UC START# *48FDB9CE0275_USER_INCLUDES*¤#include <boost/iostreams/filter/aggregate.hpp>¤//#UC END# *48FDB9CE0275_USER_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*48FDB9CE0275_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *48FDB9CE0275_USER_DEFINITION*¤template<¤	/// The character base of the base64 encoder. Usually this is char or¤	/// wchar_t.¤	typename C,¤	/// The allocator type of the base64 encoder. Usually this is¤	/// std::allocator<C>.¤	typename A = std::allocator<C> >¤	/// A base64 encoder filter that can be used with boost::iostreams.¤class base64_encoder_base : public boost::iostreams::aggregate_filter<C, A> {¤private:¤	/// Base class of this filter.¤	typedef boost::iostreams::aggregate_filter<C, A> base_type;¤¤public:¤	/// The character type of this filter.¤	typedef typename base_type::char_type char_type;¤	/// The category of this filter.¤	typedef typename base_type::category category;¤	/// The vector type used by this filter.¤	typedef typename base_type::vector_type vector_type;¤¤private:¤	/// Encode a block of three 8bit characters and return 4 base64 characters.¤	void encode_base64_block(¤		/// The block of three 8bit characters.¤		std::vector<unsigned char> const& buf,¤		/// Vector of 4 base64 characters to receive decoded result.¤		std::vector<unsigned char> & encoded,¤		/// The number of 8bit characters in the block.¤		size_t character_count¤	) {¤		const char base64_code[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"};¤¤		encoded[0] = base64_code [buf[0] >> 2];¤		encoded[1] = base64_code [((buf[0] & 0x03) << 4) | ((buf[1] & 0xf0) >> 4)];¤		encoded[2] = character_count > 1 ? base64_code [((buf[1] & 0x0f) << 2) | ((buf[2] & 0xc0) >> 6)] : '=';¤		encoded[3] = character_count > 2 ? base64_code [buf[2] & 0x3f] : '=';¤	}¤¤	/// The function that performs the actual base64 encoding.¤	virtual void do_filter (¤		/// The source data.¤		vector_type const& src,¤		/// The destination data.¤		vector_type & dest¤	) {¤		size_t nblocks = 0;¤		for (typename vector_type::const_iterator si=src.begin (); si!=src.end ();) {¤			std::vector<unsigned char> block(3, '\0');¤			size_t i = 0;¤			for ( i = 0; i < 3 && si != src.end (); ++i) {¤				block[i] = (unsigned char)*si++;¤			}¤¤			std::vector<unsigned char> encoded(4, '\0');¤			encode_base64_block (block, encoded, i);¤			dest.insert(dest.end (), encoded.begin (), encoded.end ());¤			++nblocks;¤¤			if (nblocks >= 76/4 - 1) {¤				dest.push_back('\n');¤				nblocks = 0;¤			}¤		}¤	}¤};¤¤BOOST_IOSTREAMS_PIPABLE (base64_encoder_base, 2)¤¤/// A base64 encoder for a char type.¤typedef base64_encoder_base<char> base64_encoder;¤¤/// A base64 encoder for a wchar_t type.¤typedef base64_encoder_base<wchar_t> wbase64_encoder;¤¤std::string encode_base64_string (const std::string& to_encode);¤std::string encode_base64_string (const std::vector<char>& to_encode);¤//#UC END# *48FDB9CE0275_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/GCL/str/base64_encoder|48FDB9CE0275
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/GCL/str/base64_encoder.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*48FDB9CE0275_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *48FDB9CE0275_CUSTOM_INCLUDES*¤#include <boost/iostreams/filtering_stream.hpp>¤#include <boost/iostreams/device/back_inserter.hpp>¤//#UC END# *48FDB9CE0275_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*48FDB9CE0275*"
		    value      	(value Text 
|//#UC START# *48FDB9CE0275*¤template<class Container>¤const char* get_buffer (const Container& container) {¤	GDS_ASSERT (false);¤	return 0;¤}¤¤template<>¤const char* get_buffer<std::string> (const std::string& container) {¤	return container.c_str ();¤}¤¤template<>¤const char* get_buffer<std::vector<char> > (const std::vector<char>& container) {¤	if (container.empty ()) {¤		const static char* empty_string = "";¤¤		return empty_string;¤	}¤¤	return &container[0];¤}¤¤template<class Container>¤std::string encode_base64_string_i (const Container& to_encode) {	¤	boost::iostreams::filtering_ostream encode;¤	std::string encoded;¤¤	encode.push (GCL::base64_encoder ());¤	encode.push (boost::iostreams::back_inserter (encoded));¤¤	encode.write (get_buffer (to_encode), to_encode.size ());¤¤	encode.pop ();	// this makes the stream run to completion¤¤	return encoded;¤}¤¤std::string encode_base64_string (const std::string& to_encode) {¤	return encode_base64_string_i (to_encode);¤}¤¤std::string encode_base64_string (const std::vector<char>& to_encode) {	¤	return encode_base64_string_i (to_encode);¤}¤//#UC END# *48FDB9CE0275*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16657843694"))
	    quid       	"48FDB9CE0275"
	    documentation 	"реализация base64 кодирования, которая может выступать фильтром для потока. Стыбрена из ngi-central.org."
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator"))
    logical_presentations 	(list unit_reference_list
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ColorizeFor"
		    value      	"44FEAD4A0272"))
	    quid       	"4503DFA903D8"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	0
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::shared::GCL::str::str_conv" @1
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"951")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"201")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"1264")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"342"))
		    location   	(951, 201)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@1
			location   	(318, 67)
			fill_color 	13434879
			nlines     	1
			max_width  	1266
			justify    	0
			label      	"• str_conv")
		    stereotype 	(object ItemLabel
			Parent_View 	@1
			location   	(318, 17)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1266
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    line_color 	7885055
		    fill_color 	14145535
		    quidu      	"4503DFAE006D"
		    width      	1284
		    height     	392
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::GCL::str::str_op" @2
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"951")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1206")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"318")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(948, 1206)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@2
			location   	(798, 1176)
			fill_color 	13434879
			nlines     	1
			max_width  	300
			justify    	0
			label      	"• str_op")
		    stereotype 	(object ItemLabel
			Parent_View 	@2
			location   	(798, 1126)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	297
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"4503E01500CB"
		    width      	318
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @3
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"951,1113;951,293"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"4504225A031C"
		    client     	@2
		    supplier   	@1
		    vertices   	(list Points
			(948, 1113)
			(950, 397))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::GCL::data::std_defs" @4
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"279")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1170")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"346")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"178"))
		    location   	(279, 1170)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658175
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@4
			location   	(129, 1142)
			nlines     	1
			max_width  	300
			justify    	0
			label      	"std_defs")
		    stereotype 	(object ItemLabel
			Parent_View 	@4
			location   	(129, 1092)
			anchor     	10
			nlines     	1
			max_width  	297
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    line_color 	658175
		    fill_color 	16777215
		    quidu      	"44FEBDF3039B"
		    width      	318
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @5
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"830,1197;605,1179"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"450422640109"
		    client     	@2
		    supplier   	@4
		    vertices   	(list Points
			(788, 1197)
			(438, 1178))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::GCL::str::base64_encoder" @6
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(1524, 1206)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@6
			location   	(1322, 1177)
			fill_color 	13434879
			nlines     	1
			max_width  	404
			justify    	0
			label      	"• base64_encoder")
		    stereotype 	(object ItemLabel
			Parent_View 	@6
			location   	(1322, 1127)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	404
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"48FDB9CE0275"
		    width      	422
		    height     	182
		    annotation 	8
		    autoResize 	TRUE)))
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ClassUID"
		    value      	"4503DFAE006D"))
	    quid       	"46F9DF6A00DA"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	0
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::shared::GCL::str::str_conv::code_t" @7
		    ShowCompartmentStereotypes 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"345")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"279")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"456")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"494"))
		    location   	(345, 279)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@7
			location   	(126, 94)
			fill_color 	13434879
			nlines     	1
			max_width  	438
			justify    	0
			label      	"code_t")
		    stereotype 	(object ItemLabel
			Parent_View 	@7
			location   	(126, 44)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	438
			justify    	0
			label      	"<<Enum>>")
		    icon_style 	"Label"
		    fill_color 	13821680
		    quidu      	"46F9DF0F00EA"
		    width      	456
		    height     	494
		    annotation 	8
		    autoResize 	TRUE)))))
