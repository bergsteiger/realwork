
(object Petal
    version    	50
    _written   	"Rose 2006.0.0.061205"
    charSet    	204)

(object Class_Category "Controls"
    is_unit    	TRUE
    is_loaded  	TRUE
    attributes 	(list Attribute_Set
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"AbstarctOperation"
	    value      	"regular")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"IsNative"
	    value      	"false")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (h)"
	    value      	"w:/shared/WinGUI/Controls/CCeXDib.h::4700B8F90119,w:/shared/WinGUI/Controls/CImageListEx.h::46960B1401F4,w:/shared/WinGUI/Controls/CPPDrawManager.h::4700B8C80280,w:/shared/WinGUI/Controls/CPPHtmlDrawer.h::4700B81F006D,w:/shared/WinGUI/Controls/CPPToolTip.h::4700B6AC00CB,w:/shared/WinGUI/Controls/ETSLayout.h::46A88BDA035B")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (cpp)"
	    value      	"w:/shared/WinGUI/Controls/CCeXDib.cpp::4700B8F90119,w:/shared/WinGUI/Controls/CImageListEx.cpp::46960B1401F4,w:/shared/WinGUI/Controls/CPPDrawManager.cpp::4700B8C80280,w:/shared/WinGUI/Controls/CPPHtmlDrawer.cpp::4700B81F006D,w:/shared/WinGUI/Controls/CPPToolTip.cpp::4700B6AC00CB,w:/shared/WinGUI/Controls/ETSLayout.cpp::46A88BDA035B")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED WikiPageID (wiki)"
	    value      	(value Text 
|Shared (c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CCeXDib|4700B8F90119::4700B8F90119;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPDrawManager|4700B8C80280::4700B8C80280;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPHtmlDrawer|4700B81F006D::4700B81F006D;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB::4700B6AC00CB;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B::46A88BDA035B;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB::4700B6AC00CB;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CCeXDib|4700B8F90119::4700B8F90119;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPDrawManager|4700B8C80280::4700B8C80280;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPHtmlDrawer|4700B81F006D::4700B81F006D;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB::4700B6AC00CB;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B::46A88BDA035B;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B::46A88BDA035B
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"WikiPageID (wiki)"
	    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls|46960AAE0251
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SourceType (wiki)"
	    value      	"wiki")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SELF GENERATED FILE (h)"
	    value      	"w:/shared/WinGUI/Controls/Controls.h")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SourceType (h)"
	    value      	"file")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ElementCreationOrder"
	    value      	"16659753046"))
    quid       	"46960AAE0251"
    documentation 	"Ô‡ÍÂÚ ÍÓÌÚÓÎÓ‚"
    stereotype 	"Views"
    visible_categories 	(list visibility_relationship_list
	(object Visibility_Relationship
	    quid       	"46960ACC01B5"
	    supplier   	"Logical View::external::MFCTypes::Types"
	    quidu      	"4652B4FB036B")
	(object Visibility_Relationship
	    quid       	"4696104001B5"
	    supplier   	"Logical View::external::cximage::CxImageUnit"
	    quidu      	"4649B9200222"))
    exportControl 	"Public"
    logical_models 	(list unit_reference_list
	(object Class "CImageListEx"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CImageListEx.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CImageListEx.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*46960B1401F4_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *46960B1401F4_DESTR_BODY*§	//#UC END# *46960B1401F4_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ImplementSelectType"
		    value      	"all")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"OverloadSelectType"
		    value      	"include")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CImageListEx|46960B1401F4
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659767117"))
	    quid       	"46960B1401F4"
	    documentation 	"–‡Ò¯ËÂÌÌ˚È ImageList, ÔÓÁ‚ÓÎˇÂÚ ÙÓÏËÓ‚‡Ú¸ ÒÔËÒÓÍ ËÁÓ·‡ÊÂÌËÈ ËÁ ÓÚ‰ÂÎ¸Ì˚ı Ù‡ÈÎÓ‚-Í‡ÚËÌÓÍ"
	    stereotype 	"SimpleClass"
	    superclasses 	(list inheritance_relationship_list
		(object Inheritance_Relationship
		    quid       	"46960C560119"
		    supplier   	"Logical View::external::MFCTypes::Types::CImageList"
		    quidu      	"46960AE00157"))
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659775854"))
		    quid       	"469610550167"
		    stereotype 	"uses"
		    supplier   	"Logical View::external::cximage::CxImageUnit::CxImage"
		    quidu      	"4649B9520148"))
	    operations 	(list Operations
		(object Operation "add"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46960C7C0138*"
			    value      	(value Text 
|//#UC START# *46960C7C0138*§	§	ImagePathToIndex::const_iterator it = m_image_path_to_index.find (path);§	if (it != m_image_path_to_index.end ()) {§		return it->second;§	} else if (ACE_OS::access(path.c_str (), F_OK) != -1) { //file exists		§		CxImage image;§		if (§			image.Load (path.c_str ())§			&& image.IsValid ()§		) {§			int idx = -1;§			/*RGBQUAD rgbquad_mask = image.GetPixelColor (0, 0, false);§			COLORREF rgb_mask = RGB (§				rgbquad_mask.rgbRed, rgbquad_mask.rgbGreen, rgbquad_mask.rgbBlue§			);*/§			HBITMAP bitmap = image.MakeBitmap ();§			if (bitmap != NULL) {§				idx = this->add_image (bitmap, 1);§				if (idx != -1) {§					m_image_path_to_index.insert (ImagePathToIndex::value_type (path, idx));§				}				§				DeleteObject (bitmap);§			}§			return idx;§		}§	}§	return -1;§	//#UC END# *46960C7C0138*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659770117"))
		    quid       	"46960C7C0138"
		    documentation 	
|ƒÓ·‡‚ÎˇÂÚ ËÁÓ·‡ÊÂÌËÂ ‚ ÒÔËÒÓÍ.
|path - ÔÛÚ¸ Í Ù‡ÈÎÛ Ò ËÁÓ·‡ÊÂÌËÂÏ
|‚ ÒÎÛ˜‡Â ÛÒÔÂ¯ÌÓ„Ó ‰Ó·‡‚ÎÂÌËˇ ‚ÓÁ‚‡˘‡ÂÚ ËÌ‰ÂÍÒ ËÁÓ·‡ÊÂÌËˇ ‚ ÒÔËÒÍÂ, ËÌ‡˜Â ‚ÓÁ‚˘‡ÂÚ -1
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "path"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659770417"))
			    quid       	"4696156F034B"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    result     	"integer"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"450A61050251")
		(object Operation "get_image_index"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46960D0B034B*"
			    value      	(value Text 
|//#UC START# *46960D0B034B*§	ImagePathToIndex::const_iterator it = m_image_path_to_index.find (path);§	if (it != m_image_path_to_index.end ()) {§		return it->second;§	} else {§		return this->add (path);§	}§	return -1;§	//#UC END# *46960D0B034B*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659770834"))
		    quid       	"46960D0B034B"
		    documentation 	"‚ÓÁ‚‡˘‡ÂÚ ËÌ‰ÂÍÒ ËÁÓ·‡ÊÂÌËˇ, ÒÓÓÚ‚ÂÚÒÚ‚Û˛˘Â„Ó ÔÛÚË (path)"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "path"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659771135"))
			    quid       	"46976C12004E"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    result     	"integer"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"450A61050251")
		(object Operation "delete_list"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4696256F031C*"
			    value      	(value Text 
|//#UC START# *4696256F031C*§	m_cx = -1;§	m_cy = -1;§	m_image_path_to_index.clear ();§	this->DeleteImageList();§	//#UC END# *4696256F031C*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659771537"))
		    quid       	"4696256F031C"
		    documentation 	"Û‰‡ÎˇÂÚ ImageList, Ó˜Ë˘‡ÂÚ Ï‡ÔÛ"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "remove_images"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46976C1800DA*"
			    value      	(value Text 
|//#UC START# *46976C1800DA*§	for (int i = 0; i < this->GetImageCount (); ++i) {§		this->Remove (i);§	}§	m_image_path_to_index.clear ();§	//#UC END# *46976C1800DA*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659771893"))
		    quid       	"46976C1800DA"
		    documentation 	"Û‰‡ÎˇÂÚ ËÁÓ·‡ÊÂÌËˇ ËÁ ÒÔËÒÍ‡"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "create"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C88D80109*"
			    value      	(value Text 
|//#UC START# *469C88D80109*§	m_cx = cx;§	m_cy = cy;§	this->Create (cx, cy, flags, initial, grow);§	//#UC END# *469C88D80109*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659772237"))
		    quid       	"469C88D80109"
		    documentation 	
|‡Ì‡ÎÓ„ Create ËÁ MSDN:
|cx - ‡ÁÏÂ Í‡Ê‰Ó„Ó ËÁÓ·‡ÊÂÌËˇ
|cy - ‡ÁÏÂ Í‡Ê‰Ó„Ó ËÁÓ·‡ÊÂÌËˇ
|flags - ÙÎ‡„Ë, Á‡‰‡˛˘ËÂ ÚËÔ
|initial - ÒÍÓÎ¸ÍÓ ËÁÓ·‡ÊÂÌËÈ ÎËÒÚ ı‡ÌËÚ ÒÌ‡˜‡Î‡
|grow - Ì‡ ÒÍÓÎ¸ÍÓ ‡ÒÚÂÚ ÒÔËÒÓÍ ÔË ‰Ó·‡‚ÎÂÌËË ËÁÓ·‡ÊÂÌËˇ
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "cx"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659772532"))
			    quid       	"469C89C5003E"
			    type       	"integer"
			    quidu      	"450A61050251")
			(object Parameter "cy"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659772906"))
			    quid       	"469C89C5008C"
			    type       	"integer"
			    quidu      	"450A61050251")
			(object Parameter "flags"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A6117003E")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659773260"))
			    quid       	"469C89C500EA"
			    type       	"unsigned integer"
			    quidu      	"450A6117003E")
			(object Parameter "initial"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659773611"))
			    quid       	"469C89C50148"
			    type       	"integer"
			    quidu      	"450A61050251")
			(object Parameter "grow"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659773991"))
			    quid       	"469C89C50196"
			    type       	"integer"
			    quidu      	"450A61050251"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "new_ctor_op"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C8A0F03D8_BASE_INIT*"
			    value      	"//#UC START# *469C8A0F03D8_BASE_INIT*§: m_cx (-1), m_cy (-1)§//#UC END# *469C8A0F03D8_BASE_INIT*")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C8A0F03D8_BODY*"
			    value      	(value Text 
|//#UC START# *469C8A0F03D8_BODY*§	//#UC END# *469C8A0F03D8_BODY*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659774401"))
		    quid       	"469C8A0F03D8"
		    documentation 	"ÍÓÌÒÚÛÍÚÓ"
		    stereotype 	"ctor"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "add_image"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C8E2301C5*"
			    value      	(value Text 
|//#UC START# *469C8E2301C5*§	class _local {§	public:§		static void fill_dc (HDC dc, const COLORREF& row_color) {§			HBRUSH backBrush= (HBRUSH)(row_color);				§			// Save old brush§			HBRUSH pOldBrush = (HBRUSH)::SelectObject(dc, backBrush);§			§			RECT rect;§			::GetClipBox(dc, &rect);     // Erase the area needed§			§			//paint the given rectangle using the brush that is currently selected §			//into the specified device context§			::PatBlt(dc, rect.left, rect.top, abs(rect.left - rect.right),abs(rect.top-rect.bottom ),PATCOPY);§§			//Select back the old brush§			::SelectObject(dc,pOldBrush);§			DeleteObject (backBrush);§		}§		static HBITMAP add_rows (CBitmap* src, const long row_count,  const COLORREF& row_color) {	§			HBITMAP ret = NULL;§			if (src) {§				HDC dc = ::GetDC(NULL);§				BITMAP bmp = {0};§				src->GetBitmap (&bmp);§				const long width = bmp.bmWidth; §				const long height = bmp.bmHeight + row_count;§§				HDC src_dc = CreateCompatibleDC (dc);§				HGDIOBJ old_obj = SelectObject (src_dc, (HBITMAP)*src);§§				HDC dst_dc = CreateCompatibleDC(dc);§				HGDIOBJ objReserve;§				ret = CreateCompatibleBitmap(src_dc, width, height);§				objReserve = SelectObject(dst_dc, ret);§				fill_dc (dst_dc, row_color);§				BitBlt (dst_dc, 0, 0, bmp.bmWidth, bmp.bmHeight, src_dc, 0, 0, SRCCOPY);§				§				SelectObject (dst_dc, objReserve);§				SelectObject (src_dc, old_obj);§§				DeleteDC (dst_dc);§				DeleteDC (src_dc);§				ReleaseDC (NULL, dc);§			}§			return ret;§		}§	};§	int idx = -1;§	CBitmap* bmp = CBitmap::FromHandle (image);§	if (bmp) {					§		BITMAP bmBitmap;§		bmp->GetBitmap (&bmBitmap);§		RGBTRIPLE* rgb = (RGBTRIPLE*)(bmBitmap.bmBits);§		COLORREF rgb_mask = RGB(rgb[0].rgbtRed, rgb[0].rgbtGreen, rgb[0].rgbtBlue);§		HBITMAP new_bitmap = NULL;§		if (m_cy > 0 && bmBitmap.bmHeight < m_cy) {§			new_bitmap = _local::add_rows (bmp, m_cy - bmBitmap.bmHeight, rgb_mask);§			if (new_bitmap != NULL) {				§				if (count > 1) {§					//Ì‡ÂÁ‡ÂÏ Ì‡ ·ÓÎ¸¯Û˛ Í‡ÚËÌÍÛ Ì‡ Ï‡ÎÂÌ¸ÍËÂ§					CxImage full_img;§					if (full_img.CreateFromHBITMAP (new_bitmap)) {§						for (int i = 0; i < count; ++i) {§							long cx = m_cx != -1 ? m_cx : 16;§							long cy = m_cy != -1 ? m_cy : 16;§							CxImage one_image (m_cx, m_cy, full_img.GetBpp ());§							long left = i*cx;§							long right = left + cx;§							full_img.Crop (left, 0, right, cy, &one_image);§							HBITMAP bitmap = one_image.MakeBitmap ();§							if (bitmap != NULL) {§								CBitmap* bmp = CBitmap::FromHandle (bitmap);§								idx = this->Add (bmp, rgb_mask);			§								bmp->Detach ();§								DeleteObject (bitmap);§							}§						}§					}§				} else {§					CBitmap* new_bmp = CBitmap::FromHandle (new_bitmap);§					idx = this->Add (new_bmp, rgb_mask);§					new_bmp->Detach();§				}				§				DeleteObject (new_bitmap);§			}§		} else {§			idx = this->Add (bmp, rgb_mask);§		}§		§		bmp->Detach();				§	}§	return idx;§	//#UC END# *469C8E2301C5*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659774761"))
		    quid       	"469C8E2301C5"
		    documentation 	
|‰Ó·‡‚ÎˇÂÚ ‚ ÒÔËÒÓÍ Í‡ÚËÌÍÛ
|‚ÓÁ‚‡˘‡ÂÚ ËÌ‰ÂÍÒ ÔÂ‚ÓÈ ‰Ó·‡‚ÎÂÌÌÓÈ Í‡ÚËÌÍË ‚ ÒÔËÒÓÍ
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "image"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45D2F9890138")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659775055"))
			    quid       	"469C903A0251"
			    type       	"HBITMAP"
			    quidu      	"45D2F9890138")
			(object Parameter "count"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659775405"))
			    quid       	"469F61C00167"
			    type       	"integer"
			    quidu      	"450A61050251"))
		    result     	"integer"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"450A61050251"))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "cx"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659768995"))
		    quid       	"469C89D300BB"
		    documentation 	"‡ÁÏÂ ÔÓ ’ Í‡Ê‰Ó„Ó ËÁÓ·‡ÊÂÌËˇ ‚ ÒÔËÒÍÂ"
		    type       	"integer"
		    quidu      	"450A61050251"
		    Containment 	"By Value")
		(object ClassAttribute "cy"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659769353"))
		    quid       	"469C89EC0148"
		    documentation 	"‡ÁÏÂ ÔÓ Y Í‡Ê‰Ó„Ó ËÁÓ·‡ÊÂÌËˇ ‚ ÒÔËÒÍÂ"
		    type       	"integer"
		    quidu      	"450A61050251"
		    Containment 	"By Value"))
	    language   	"MDA Generator"
	    nestedClasses 	(list nestedClasses
		(object Class "ImagePathToIndex"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16663690238"))
		    quid       	"46960BC80119"
		    documentation 	
|Ï‡Ô‡: "ÔÛÚ¸ Í Ù‡ÈÎÛ Ò ËÁÓ·‡ÊÂÌËÂÏ" -> ËÌ‰ÂÍÒ ‚ ImageList'Â
		    
		    stereotype 	"Map")))
	(object Class "ETSLayout"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local helper"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/ETSLayout.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/ETSLayout.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*46A88BDA035B_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *46A88BDA035B_CUSTOM_INCLUDES*§//#UC END# *46A88BDA035B_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*46A88BDA035B*"
		    value      	(value Text 
|//#UC START# *46A88BDA035B*§////////////////////////////////////////////§//         ___ ____ _________________     //§//        / _/_  _// _______________/     //§//       / _/ / / / /  ___ ___ ____       //§//      /__/ /_/ / / /   // _/_  _/       //§//     _________/ / / / // _/ / /         //§// (c) 1998-2000_/ /___//_/  /_/          //§//                                        //§////////////////////////////////////////////§//          all rights reserved           //§////////////////////////////////////////////§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutDialog§//§// A class for smart layouting of Dialogs and such§//§// USAGE: See LayoutMgr.html§//§// AUTHOR: Erwin Tratar <tr@et-soft.de>§//§// DISCLAIMER:§//§// This Sourcecode and all accompaning material is È1998-1999 Erwin Tratar. §// All rights reserved.§//§// The source code may be used in compiled form in any way you desire §// (including usage in commercial applications), providing that your §// application adds essential code (i.e. it is not only a wrapper) to the §// functionality found here§//§// Redistribution of the sourcecode itself, publication in any media or §// inclusion in a library requires the authors expressed written consent.§// You may not sale this code for profit.§//§// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY. USE IT §// AT YOUR OWN RISK! THE AUTHOR ACCEPTS NO LIABILITY FOR ANY DAMAGE/LOSS OF §// BUSINESS THAT THIS PRODUCT MAY CAUSE.§//§//§// HISTORY: §// 1998/05/1	Initial Release§// 1998/05/13	Added ability to have a Pane with a control§// 1998/05/13	Added better support for TabControls§// 1998/05/14	automatically set Icon to IDR_MAINFRAME§// 1998/05/19	no flicker on restoring position in OnInitialUpdate§//				Changed procedure for load/save, see constructor§// 1998/10/02	Added support for Maximum (tracking) size§// 1998/10/02	Much improved handling regarding RELATIVE/GREEDY§//              /w critical minimum size§// 1998/10/02	turn on/off gripper at lower right corner§// 1998/10/05   Support for user defined minimum size for items§//              (was hardcoded 5 before)§// 1998/10/07   Fix for FormViews§// 1998/10/31	Support for SECDialogBar/CDialogBar§// 1998/10/31	simplified interface§// 1998/10/31	Advanced positioning options§// 1998/10/31	Added paneNull for empty Pane (former: NULL)§// 1998/11/20	Swapped ETSLayoutDialog constructor parameters§// 1998/11/20	Added Pane::addItemSpaceBetween §//				[Leo Zelevinsky]§// 1998/11/24	Added fixup for greedy panes§// 1998/11/24	addItemSpaceBetween now subtracts 2*nDefaultBorder§// 1998/11/24	addGrowing() added as a shortcut for a paneNull§// 1998/11/24	simplified interface: no more PaneBase:: / Pane:: §//				needed§// 1998/11/24	added FILL_* Modes§// 1998/11/24	improved maximum size handling for greedy panes§// 1998/11/25	Fixup of greedy panes caused infinite loop in some §//				cases§// 1999/01/07	addItemSpaceLike() added§// 1999/04/03   Fixed ETSLayoutFormView memory leak§// 1999/04/07   Fixed ALIGN_xCENTER§// 1999/04/08   New simple stream-interface added§// 1999/04/09   Added support for an empty Status-Bar for resizing §//              instead of a gripper in the lower right corner§//              [Andreas Kapust]§// 1999/04/11   New code for much less flickering, OnEraseBkgnd()§//              overidden for this task§// 1999/05/12   Split Layout code into understandable pieces and adding§//              a lot of comments§// 1999/06/20   ABSOLUTE_X + ALIGN_FILL_X expands item if there is any§//              left space (after all Abs/Rel/Greedy processing is done)§// 1999/10/06   Changed Load() and Save() to use WINDOWPLACEMENT§//              [Keith Bussell]§// 1999/11/18   Added possibility to add panes of the same orientation§//              to another pane. This merges both panes in one big§//              pane with the same orientation§// 1999/11/18   Added support for BCGDialogBar (only with BCG > 4.52!)§// 1999/11/25   Addes support for PropertyPages/Sheets. Uses some code§//              of a code submission from Anreas Kapust§// 1999/11/25   Renamed classes to ETSLayoutXXX§// 1999/11/25   Use CreateRoot() and Root() instead of m_pRootPane in§//              derived class.§// 1999/11/26   Added autopointer support. No need to use normal pointers§//              when defining layout anymore. Changed m_pRootPane to §//              m_RootPane§// 1999/11/26   Bug in Fixup Greedy II with multiple GREEDY panes and one§//              of them min/max limited§// 1999/11/28   Fixed PaneTab::getConstrainVert() for ABSOLUTE_VERT§// 1999/11/28   Fixed itemFixed()§// 1999/11/28   Changed DWORD modeResize Arguments to layModeResize for §//              better type safety. Added typesafe operator|§// 1999/12/04   Don't reposition window in UpdateLayout if it's a child§//              (as a child Dialog or PropertyPage)§// 1999/12/04   Erase Backgroung with GCL_HBRBACKGROUND (if available) §// 1999/12/04   itemSpaceXXX() adds a NORESIZE item instead of ABSOLUTE_XXX§//              this will fix unwanted growing in secondary direction§//§// Version: 1.0 [1999/12/04] Initial Article on CodeProject§//§// 1999/12/10   Erase Backgroung within TabCtrl was 'fixed' badly. Reverted to§//              old working code§// 2000/02/02   When the Dialog is child of a View the class works correctly§//              now [Didier BULTIAUW]§// 2000/02/15   Combo-Boxes were not working correctly (in all modes!)§// 2000/02/17   aligned SpinButton Controls (with buddy) now handled §//              automatically§//              !! do not add such a control to the layout !! it is always§//              reattached to its buddy.§// 2000/02/17   changed some cotrol class names to the defined constants§//§// Version: 1.1 [2000/02/17]§//§// 2000/02/25   Fixed auto alignment of SpinButton Controls to only affect §//              visible ones§// 2000/02/27   Put all the classes into the namespace 'ETSLayout'§// 2000/03/07   Fixed growing Dialog after minimizing and restoring§// 2000/05/22   Whole Statusbar (Gripper) is not excluded anymore in EraseBkgnd()§//              instead only the triangular Gripper is excluded§// 2000/05/31   Fix for PropertySheets with PSH_WIZARDHASFINISH [Th°mmi]§// 2000/05/31   Fix for UpDown-Controls with EditCtrl Buddy in PropertyPages.§//              These were not repositioned every time the page is being show§//              until the first resize§// 2000/07/28   Problems with resizing ActiveX Controls fixed [Micheal Chapman]§// 2000/07/28   Some strings were not properly wrapped with _T()§// 2000/08/03   Check for BS_GROUPBOX was not correct as BS_GROUPBOX is more than one Bit§// 2000/08/03   New override AddMainArea added to ETSLayoutPropertySheet in order to §//              have a hook for additional controls in a PropertySheet (besides the Tab)§// 2000/08/03   New override AddButtons added to ETSLayoutPropertySheet in order to §//              have a hook for additional controls in the bottem pane of a PropertySheet§// 2000/08/03   Removed the need for DECLARE_LAYOUT§//§// Version: 1.2 [2000/08/05]§§#define OEMRESOURCE§§using namespace WinGUI::ETSLayout;§#pragma warning(disable: 4097 4610 4510 4100)§§§#ifndef OBM_SIZE§#define	OBM_SIZE		32766§// taken from WinresRc.h§// if not used for any reason§#endif§§#ifdef _DEBUG§#define new DEBUG_NEW§#undef THIS_FILE§static char THIS_FILE[] = __FILE__;§#endif§§static UINT auIDStatusBar[] = §{ §  ID_SEPARATOR§};§§const int ERASE_GROUP_BORDER	= 10;§const int FIXUP_CUTOFF	= 5;§const int TAB_SPACE = 5;§§// the _NULL-Pane§CWnd* ETSLayoutMgr::paneNull = 0;§§void ETSLayoutMgr::Layout(CRect& rcClient)§{§	if(rcClient.Height() && rcClient.Width()  && m_RootPane.IsValid())	\§		m_RootPane->resizeTo(rcClient);									\§}§§§ETSLayoutMgr::CPane ETSLayoutMgr::pane( layOrientation orientation, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, §									   int sizeBorder /*=nDefaultBorder*/, int sizeExtraBorder /*=0*/, §									   int sizeSecondary /*=0*/)§{§	Pane* pPane = new Pane ( this, orientation, sizeBorder, sizeExtraBorder );§	pPane->m_sizeSecondary = sizeSecondary;§	pPane->m_modeResize    = modeResize;§§	return CPane(pPane);§}§§ETSLayoutMgr::CPane ETSLayoutMgr::paneTab( CTabCtrl* pTab, layOrientation orientation, §										  ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeBorder /*=nDefaultBorder*/, §										  int sizeExtraBorder /*=0*/, int sizeSecondary /*=0*/)§{§	Pane* pPane = new PaneTab ( pTab, this, orientation, sizeBorder, sizeExtraBorder );§	pPane->m_sizeSecondary = sizeSecondary;§	pPane->m_modeResize    = modeResize;§§	return CPane(pPane);§}§§§ETSLayoutMgr::CPane ETSLayoutMgr::paneCtrl( CWnd* pCtrl, layOrientation orientation, §										   ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeBorder /*=nDefaultBorder*/, §										   int sizeExtraBorder /*=0*/, int sizeTopExtra /*=0*/, §										   int sizeSecondary /*=0*/)§{§	Pane* pPane = new PaneCtrl ( pCtrl, this, orientation, sizeBorder, sizeExtraBorder, sizeTopExtra );§	pPane->m_sizeSecondary = sizeSecondary;§	pPane->m_modeResize    = modeResize;§§	return CPane(pPane);§}§§ETSLayoutMgr::CPane ETSLayoutMgr::paneCtrl( UINT nID, layOrientation orientation, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, §										   int sizeBorder /*=nDefaultBorder*/, int sizeExtraBorder /*=0*/,§										   int sizeTopExtra /*=0*/, int sizeSecondary /*=0*/)§{§	Pane* pPane = new PaneCtrl ( nID, this, orientation, sizeBorder, sizeExtraBorder, sizeTopExtra );§	pPane->m_sizeSecondary = sizeSecondary;§	pPane->m_modeResize    = modeResize;§§	return CPane(pPane);§}§§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::item(UINT nID, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeX /*=0*/, int sizeY /*=0*/, §										   int sizeXMin /*=-1*/, int sizeYMin /*=-1*/)§{§	return new PaneItem( nID, this, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);§}§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::item(CWnd* pWnd, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/,§										   int sizeX /*=0*/, int sizeY /*=0*/, int sizeXMin /*=-1*/, §										   int sizeYMin /*=-1*/)§{§	return new PaneItem( pWnd, this, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);§}§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemFixed(layOrientation orientation, int sizePrimary)§{§	CPaneBase p = new PaneItem(paneNull, this, NORESIZE, (orientation==HORIZONTAL)?sizePrimary:0, (orientation==VERTICAL)?sizePrimary:0);§	return p;§}§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemGrowing(layOrientation orientation)§{§	return new PaneItem(paneNull, this, (orientation==HORIZONTAL)?ABSOLUTE_VERT:ABSOLUTE_HORZ, 0, 0, -nDefaultBorder, -nDefaultBorder);§}§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceBetween( layOrientation orientation, CWnd* pWndFirst, CWnd* pWndSecond )§{§	if( orientation == HORIZONTAL ) {§		// I'm interested in horizontal spacing§§		CRect rLeft, rRight;§		pWndFirst->GetWindowRect(&rLeft);§		pWndSecond->GetWindowRect(&rRight);§§		int sizeX = rRight.left - rLeft.right;§	§		if( sizeX < 0 ) {§			// compare top to top§			sizeX = rRight.left - rLeft.left;§		}§		else {§			sizeX -= 2*nDefaultBorder;§		}§§		return new PaneItem(paneNull, this, NORESIZE, sizeX, 0);§	}§	else {§		// I'm interested in vertical spacing§		CRect rTop, rBot;§		pWndFirst->GetWindowRect(&rTop);§		pWndSecond->GetWindowRect(&rBot);§§		int sizeY = rBot.top - rTop.bottom;§§		if( sizeY < 0 ) {§			// compare top to top§			sizeY = sizeY = rBot.top - rTop.top;§		}§		else {§			sizeY -= 2*nDefaultBorder;§		}§§		return new PaneItem(paneNull, this, NORESIZE, 0, sizeY);§	}§}§§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceBetween( layOrientation orientation, UINT nIDFirst, UINT nIDSecond )§{§	CWnd *pFirst	= GetWnd()->GetDlgItem(nIDFirst);§	CWnd *pSecond	= GetWnd()->GetDlgItem(nIDSecond);§§	ASSERT( pFirst && pSecond );§§	return itemSpaceBetween( orientation, pFirst, pSecond );§}§§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceLike( layOrientation orientation, CWnd* pWnd )§{§	CRect rRect;§	pWnd->GetWindowRect(&rRect);§§	if( orientation == HORIZONTAL ) {§		// I'm interested in horizontal spacing§		return new PaneItem(paneNull, this, NORESIZE, rRect.Width(), 0);§	}§	else {§		// I'm interested in vertical spacing§		return new PaneItem(paneNull, this, NORESIZE, 0, rRect.Height() );§	}§§}§§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceLike( layOrientation orientation, UINT nID )§{§	CWnd *pWnd	= GetWnd()->GetDlgItem(nID);§	ASSERT( pWnd );§§	return itemSpaceLike( orientation, pWnd );§}§§§§ETSLayoutMgr::~ETSLayoutMgr()§{§}§§void ETSLayoutMgr::UpdateLayout()§{§	if(!m_RootPane)§		return;§§	// Check constraints§	CRect rcClient = GetRect();§§	if( m_pWnd->IsKindOf( RUNTIME_CLASS( CDialog ) ) && !(m_pWnd->GetStyle()&WS_CHILD) ) {§		CRect rcWindow;§		m_pWnd->GetWindowRect(rcWindow);§§		// Added by Didier BULTIAUW§        CWnd* parentWnd = m_pWnd->GetParent();§        if( (parentWnd != 0) && parentWnd->IsKindOf(RUNTIME_CLASS(CView)) )§        {§			CRect rcParent;§            parentWnd->GetWindowRect(rcParent);§            rcWindow.OffsetRect(-rcParent.left,-rcParent.top);§        }§		// end add§§		CRect rcBorder = rcWindow;§		rcBorder -= rcClient;§§		// Min and Max info§		int minWidth	= m_RootPane->getMinConstrainHorz() + rcBorder.Width()  + 2*m_sizeRootBorders.cx;§		int minHeight	= m_RootPane->getMinConstrainVert() + rcBorder.Height() + 2*m_sizeRootBorders.cy;§		int maxWidth	= m_RootPane->getMaxConstrainHorz();§		if(maxWidth != -1) {§			maxWidth += rcBorder.Width()  + 2*m_sizeRootBorders.cx;§			maxWidth = std::max(maxWidth, minWidth);§		}§		int maxHeight	= m_RootPane->getMaxConstrainVert();§		if(maxHeight != -1) {§			maxHeight += rcBorder.Height() + 2*m_sizeRootBorders.cy;§			maxHeight = std::max(maxHeight, minHeight);§		}§§		if(rcWindow.Width() < minWidth)§			rcWindow.right = rcWindow.left + minWidth;§		if(rcWindow.Height() < minHeight)§			rcWindow.bottom = rcWindow.top + minHeight;§§		if(maxWidth != -1  && rcWindow.Width() > maxWidth)§			rcWindow.right = rcWindow.left + maxWidth;§		if(maxHeight != -1 && rcWindow.Height() > maxHeight)§			rcWindow.bottom = rcWindow.top + maxHeight;§§		m_pWnd->MoveWindow(rcWindow);§	}§	// Do the Layout§	rcClient = GetRect();§§	// Add a Border around the rootPane§	rcClient.top	+= m_sizeRootBorders.cy;§	rcClient.bottom -= m_sizeRootBorders.cy;§	rcClient.left	+= m_sizeRootBorders.cx;§	rcClient.right	-= m_sizeRootBorders.cx;§§	if(GetWnd()->IsWindowVisible()) {§		// Avoid ugly artifacts§		//GetWnd()->SetRedraw(FALSE);§		Layout(rcClient);§		//GetWnd()->SetRedraw(TRUE);§	}§	else§		Layout(rcClient);§§	// Take special care of SpinButtons (Up-Down Controls) with Buddy set, enumerate§	// all childs:§	CWnd* pWndChild = GetWnd()->GetWindow(GW_CHILD);§	TCHAR szClassName[ MAX_PATH ];§	while(pWndChild)§	{§		::GetClassName( pWndChild->GetSafeHwnd(), szClassName, MAX_PATH );§		DWORD dwStyle = pWndChild->GetStyle();§§		// is it a SpinButton?§		if( _tcscmp(szClassName, UPDOWN_CLASS)==0 && ::IsWindowVisible(pWndChild->GetSafeHwnd()) ) {§			HWND hwndBuddy = (HWND)::SendMessage( pWndChild->GetSafeHwnd(), UDM_GETBUDDY, 0, 0);§			if( hwndBuddy != 0 && (dwStyle&(UDS_ALIGNRIGHT|UDS_ALIGNLEFT)) != 0 )§			{§				// reset Buddy§				::SendMessage( pWndChild->GetSafeHwnd(), UDM_SETBUDDY, (WPARAM)hwndBuddy, 0);§			}§		}§		§§		pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);§	}§§§	GetWnd()->Invalidate();§}§§§bool ETSLayoutMgr::Save(LPCTSTR lpstrRegKey)§{§    CRect rcWnd;§§    if(IsWindow(GetWnd()->m_hWnd))§    {§        WINDOWPLACEMENT wp;§        if(GetWnd()->GetWindowPlacement(&wp))§        {§            // Make sure we don't pop up §            // minimized the next time§            if(wp.showCmd != SW_SHOWMAXIMIZED)§                wp.showCmd = SW_SHOWNORMAL;§§            AfxGetApp()->WriteProfileBinary(lpstrRegKey, §                _T("WindowPlacement"), §                reinterpret_cast<LPBYTE>(&wp), sizeof(wp));§        }§    }§    return true;§}§§bool ETSLayoutMgr::Load(LPCTSTR lpstrRegKey)§{§    LPBYTE pbtData = 0;§    UINT nSize = 0;§    if(AfxGetApp()->GetProfileBinary(lpstrRegKey,§        _T("WindowPlacement"), &pbtData, &nSize))§    {§        WINDOWPLACEMENT* pwp = §            reinterpret_cast<WINDOWPLACEMENT*>(pbtData);§		§        ASSERT(nSize == sizeof(WINDOWPLACEMENT));§        if(nSize == sizeof(WINDOWPLACEMENT))§            GetWnd()->SetWindowPlacement(reinterpret_cast<WINDOWPLACEMENT*>(pbtData));§§        delete [] pbtData;§    }§    return true;§}§§§void ETSLayoutMgr::EraseBkgnd(CDC* pDC)§{§	CRect	rcClient;§	GetWnd()->GetClientRect( rcClient );§§	CRgn	rgn;§	rgn.CreateRectRgnIndirect(rcClient);§    TRACE("CreateRgn (%d,%d,%d,%d)\n", rcClient.left, rcClient.top, rcClient.right, rcClient.bottom );§§	CRgn    rgnRect;§	rgnRect.CreateRectRgn(0,0,0,0);§§	CRect	rcChild;§	CWnd* pWndChild = GetWnd()->GetWindow( GW_CHILD );§§	TCHAR szClassName[ MAX_PATH ];§§    pDC->SelectClipRgn(NULL);§    §	while( pWndChild ) {§		§		pWndChild->GetWindowRect(rcChild);§		GetWnd()->ScreenToClient( rcChild );§§		rgnRect.SetRectRgn( rcChild );§	§		::GetClassName( pWndChild->GetSafeHwnd(), szClassName, MAX_PATH );§		DWORD dwStyle = pWndChild->GetStyle();§§		// doesn't make sense for hidden children§		if( dwStyle & WS_VISIBLE ) {§§            // Fix: BS_GROUPBOX is more than one Bit, extend check to (dwStyle & BS_GROUPBOX)==BS_GROUPBOX [ET]§			if( _tcscmp(szClassName,_T("Button"))==0 && (dwStyle & BS_GROUPBOX)==BS_GROUPBOX ) {§				// it is a group-box, ignore completely§			}§			else if( _tcscmp(szClassName,WC_TABCONTROL )==0 ) {§				// ignore Tab-Control's inside rect§				static_cast<CTabCtrl*>(pWndChild)->AdjustRect(FALSE,rcChild);§§				CRgn rgnContent;§				rgnContent.CreateRectRgnIndirect(rcChild);§§				rgnRect.CombineRgn( &rgnRect, &rgnContent, RGN_DIFF );§				rgn.CombineRgn( &rgn, &rgnRect, RGN_DIFF );§			}§			else if( _tcscmp(szClassName,STATUSCLASSNAME)==0 ) {§§				CPoint ptTriangleGrip[3];§				ptTriangleGrip[0] = CPoint(rcChild.right,rcChild.top);§				ptTriangleGrip[1] = CPoint(rcChild.right,rcChild.bottom);§				ptTriangleGrip[2] = CPoint(rcChild.right-rcChild.Height(),rcChild.bottom);§§				CRgn rgnGripper;§				rgnGripper.CreatePolygonRgn(ptTriangleGrip,3, WINDING);§§				rgn.CombineRgn( &rgn, &rgnGripper, RGN_DIFF );§§			}§			else {§				rgn.CombineRgn( &rgn, &rgnRect, RGN_DIFF );§			}§		}§§		pWndChild = pWndChild->GetNextWindow();§	}§§§	HBRUSH hBrBack = (HBRUSH) ::GetClassLong(GetWnd()->GetSafeHwnd(), GCL_HBRBACKGROUND) ;§	if( hBrBack == 0 )§		hBrBack = ::GetSysColorBrush(COLOR_BTNFACE);§§	pDC->FillRgn( &rgn, §		CBrush::FromHandle( hBrBack )§		);§	§}§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutMgr::PaneItem implementation§§§ETSLayoutMgr::PaneItem::PaneItem(CWnd* pWnd, ETSLayoutMgr* pMgr, ETSLayoutMgr::layResizeMode modeResize/*=GREEDY*/§								 , int sizeX/*=0*/, int sizeY/*=0*/§								 , int sizeXMin/*=-1*/, int sizeYMin/*=-1*/ ) : PaneBase( pMgr )§{§	m_modeResize	= modeResize;§	m_hwndCtrl		= pWnd->GetSafeHwnd();§§	m_sizeX			= 0;§	m_sizeY			= 0;§§	m_bComboSpecial = false;§§	m_sizeXMin		= sizeXMin;§	m_sizeYMin		= sizeYMin;§§	if(!m_hwndCtrl) {			// only Dummy!§		m_sizeX = sizeX;§		m_sizeY = sizeY;§	}§	else {§		CRect rcControl;§		::GetWindowRect(m_hwndCtrl, &rcControl);§§		if(sizeX == 0) {§			m_sizeX			= rcControl.Width();§		}§		else {§			m_sizeX = sizeX;§		}§		if( m_sizeXMin == -1 ) {§			// do not make smaller than current size§			m_sizeXMin		= rcControl.Width();§		}§§		if(sizeY == 0) {§			m_sizeY			= rcControl.Height();§		}§		else {§			m_sizeY = sizeY;§		}§		if( m_sizeYMin == -1 ) {§			// do not make smaller than current size§			m_sizeYMin		= rcControl.Height();§		}§§		TCHAR szClassName[ MAX_PATH ];§		::GetClassName( m_hwndCtrl, szClassName, MAX_PATH );§§		// special treatment for combo-boxes§		if( _tcscmp(szClassName,_T("ComboBox"))==0 || _tcscmp(szClassName,WC_COMBOBOXEX)==0) {§			m_bComboSpecial = true;§		}§	}§}§§ETSLayoutMgr::PaneItem::PaneItem( UINT nID, ETSLayoutMgr* pMgr, ETSLayoutMgr::layResizeMode modeResize/*=GREEDY*/§								 , int sizeX/*=0*/, int sizeY/*=0*/§								 , int sizeXMin/*=-1*/, int sizeYMin/*=-1*/ ) : PaneBase( pMgr )§{§	CWnd* pWnd		= pMgr->GetWnd()->GetDlgItem(nID);§	m_hwndCtrl		= pWnd->GetSafeHwnd();§§	m_sizeX			= 0;§	m_sizeY			= 0;§§	m_bComboSpecial = false;§§	m_modeResize	= modeResize;§§	m_sizeXMin = sizeXMin;§	m_sizeYMin = sizeYMin;§§	if(!m_hwndCtrl) {			// only Dummy!§		m_sizeX = sizeX;§		m_sizeY = sizeY;§	}§	else {§		CRect rcControl;§		::GetWindowRect(m_hwndCtrl, &rcControl);§§		if(sizeX == 0) {§			m_sizeX			= rcControl.Width();§		}§		else {§			m_sizeX = sizeX;§		}§		if( m_sizeXMin == -1 ) {§			// do not make smaller than current size§			m_sizeXMin		= rcControl.Width();§		}§§		if(sizeY == 0) {§			m_sizeY			= rcControl.Height();§		}§		else {§			m_sizeY = sizeY;§		}§		if( m_sizeYMin == -1 ) {§			// do not make smaller than current size§			m_sizeYMin		= rcControl.Height();§		}§§		TCHAR szClassName[ MAX_PATH ];§		::GetClassName( m_hwndCtrl, szClassName, MAX_PATH );§§		// special treatment for combo-boxes§		if( _tcscmp(szClassName,_T("ComboBox"))==0 || _tcscmp(szClassName,WC_COMBOBOXEX)==0) {§			m_bComboSpecial = true;§		}§	}§}§§int ETSLayoutMgr::PaneItem::getConstrainHorz(int sizeParent) §{§	if( m_modeResize & ABSOLUTE_HORZ) {§		return m_sizeX;	§	}§	if(m_modeResize & RELATIVE_HORZ) {§		return (sizeParent * m_sizeX) / 100;	§	}§	return -1;§}§§int ETSLayoutMgr::PaneItem::getConstrainVert(int sizeParent) §{§	if(m_modeResize & ABSOLUTE_VERT) {§		return m_sizeY;	§	}§	if(m_modeResize & RELATIVE_VERT) {§		return (sizeParent * m_sizeY) / 100;	§	}§	return -1;§}§§int ETSLayoutMgr::PaneItem::getMinConstrainHorz() §{§	if(m_modeResize & ABSOLUTE_HORZ) {§		return m_sizeX;	§	}§	return std::max(nMinConstrain,m_sizeXMin);§}§§int ETSLayoutMgr::PaneItem::getMinConstrainVert() §{§	if(m_modeResize & ABSOLUTE_VERT) {§		return m_sizeY;	§	}§	return std::max(nMinConstrain,m_sizeYMin);§}§§int ETSLayoutMgr::PaneItem::getMaxConstrainHorz() §{§	if(m_modeResize & ABSOLUTE_HORZ) {§		return m_sizeX;	§	}§	return -1;§}§§int ETSLayoutMgr::PaneItem::getMaxConstrainVert() §{§	if(m_modeResize & ABSOLUTE_VERT) {§		return m_sizeY;	§	}§	return -1;	§}§§bool ETSLayoutMgr::PaneItem::resizeTo(CRect& rcNewArea) §{§	if(m_hwndCtrl) {§§		CRect rcWnd;§		::GetWindowRect( m_hwndCtrl, rcWnd );§§		if( !(m_modeResize & ALIGN_FILL_HORZ) && m_modeResize & ABSOLUTE_HORZ ) {§§§			if( (m_modeResize & ALIGN_HCENTER) == ALIGN_HCENTER ) {§				rcNewArea.OffsetRect( (rcNewArea.Width() - rcWnd.Width())/2, 0 ); §			}§			else if( m_modeResize & ALIGN_RIGHT ) {§				rcNewArea.OffsetRect( rcNewArea.Width() - rcWnd.Width(), 0 ); §			}§§			rcNewArea.right = rcNewArea.left + rcWnd.Width();§		}§		if( !(m_modeResize & ALIGN_FILL_VERT) && m_modeResize & ABSOLUTE_VERT ) {§§§			if( (m_modeResize & ALIGN_VCENTER) == ALIGN_VCENTER ) {§				rcNewArea.OffsetRect( 0, (rcNewArea.Height()-rcWnd.Height())/2 ); §			}§			else if( m_modeResize & ALIGN_BOTTOM ) {§				rcNewArea.OffsetRect( 0, rcNewArea.Height() - rcWnd.Height()); §			}§§			rcNewArea.bottom = rcNewArea.top + rcWnd.Height();§§		}§§		DWORD dwStyle = ::GetWindowLong( m_hwndCtrl, GWL_STYLE );§§		// special treatment for combo-boxes§		if( m_bComboSpecial && (dwStyle & CBS_DROPDOWN) ) {§			// keep height (though only fully visible when dropped down)§			rcNewArea.bottom = rcNewArea.top + rcWnd.Height();§		}§§    // FIX: ::MoveWindow would case problems with some ActiveX Controls [Micheal Chapman]§    CWnd* pTempWnd = CWnd::FromHandle( m_hwndCtrl );§    pTempWnd->MoveWindow( rcNewArea.left, rcNewArea.top, rcNewArea.Width(), rcNewArea.Height() );§§		if( m_bComboSpecial && !(dwStyle & CBS_DROPDOWN) && !(dwStyle & CBS_NOINTEGRALHEIGHT) ) {§§			// Keep CB Size = Edit + LB ( if not CBS_NOINTEGRALHEIGHT)§§			::GetWindowRect( m_hwndCtrl, rcWnd );§§			CRect rcListBox;§			HWND hwndListBox = ::GetDlgItem(m_hwndCtrl, 1000); // ListBox of CB§			if( hwndListBox != 0 )§			{§				::GetWindowRect( hwndListBox, rcListBox );§				rcWnd.bottom = rcListBox.bottom;§§				rcNewArea.bottom = rcNewArea.top + rcWnd.Height();§§        // FIX: ::MoveWindow would case problems with some ActiveX Controls [Micheal Chapman]§        CWnd* pTempWnd = CWnd::FromHandle( m_hwndCtrl );§        pTempWnd->MoveWindow( rcNewArea.left, rcNewArea.top, rcNewArea.Width(), rcNewArea.Height(), true );§			}§		}§§		::RedrawWindow(m_hwndCtrl,0,0, RDW_INVALIDATE | RDW_UPDATENOW ); §§	}§	return true;§}§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutMgr::PaneTab implementation§§§ETSLayoutMgr::PaneTab::PaneTab( CTabCtrl* pTab, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /*= nDefaultBorder*/, int sizeExtraBorder /*= 0*/ )§: ETSLayoutMgr::Pane(pMgr, orientation, sizeBorder, sizeExtraBorder) §{§	ASSERT(pTab);§	m_pTab = pTab;§}§§int ETSLayoutMgr::PaneTab::getConstrainHorz(int sizeParent)§{§	CRect rcTab;§	m_pTab->AdjustRect(TRUE, &rcTab);§§	if(rcTab.Width() > sizeParent)§		return rcTab.Width();§§	return Pane::getConstrainHorz(sizeParent /*- rcTab.Width()*/);§}§§int ETSLayoutMgr::PaneTab::getConstrainVert(int sizeParent)§{§	CRect rcTab;§	m_pTab->AdjustRect(TRUE, &rcTab);§§	if( m_modeResize & ABSOLUTE_VERT ) {§		return m_sizeSecondary + rcTab.Height();§	}§§	if(rcTab.Height() > sizeParent)§		return rcTab.Height();§§	return Pane::getConstrainVert(sizeParent /*- rcTab.Height()*/);§}§§int ETSLayoutMgr::PaneTab::getMinConstrainHorz()§{§	CRect rcTab(0,0,0,0);§	m_pTab->AdjustRect(TRUE, &rcTab);§§	return Pane::getMinConstrainHorz() + rcTab.Width() ;§}§§int ETSLayoutMgr::PaneTab::getMinConstrainVert()§{§	CRect rcTab(0,0,0,0);§	m_pTab->AdjustRect(TRUE, &rcTab);§§	return Pane::getMinConstrainVert() + rcTab.Height();§}§§int ETSLayoutMgr::PaneTab::getMaxConstrainHorz()§{§	CRect rcTab(0,0,0,0);§	m_pTab->AdjustRect(TRUE, &rcTab);§§	int paneMax = Pane::getMaxConstrainHorz();§	return (paneMax != -1) ? paneMax + rcTab.Width() : -1;§}§§int ETSLayoutMgr::PaneTab::getMaxConstrainVert()§{§	CRect rcTab(0,0,0,0);§	m_pTab->AdjustRect(TRUE, &rcTab);§§	int paneMax = Pane::getMaxConstrainVert();§	return (paneMax != -1) ? paneMax + rcTab.Height() : -1;§}§§bool ETSLayoutMgr::PaneTab::resizeTo(CRect& rcNewArea)§{§	m_pTab->MoveWindow(rcNewArea);§	m_pTab->AdjustRect(FALSE,rcNewArea);§§	return Pane::resizeTo(rcNewArea);§}§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutMgr::PaneCtrl implementation§§§ETSLayoutMgr::PaneCtrl::PaneCtrl( CWnd* pCtrl, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /*= nDefaultBorder*/, int sizeExtraBorder /*= 0*/, int sizeTopExtra /*= 0*/ )§: ETSLayoutMgr::Pane(pMgr, orientation, sizeBorder, sizeExtraBorder)§{§	m_sizeTopExtra = sizeTopExtra;§§	ASSERT(pCtrl);§	m_hwndCtrl = pCtrl->GetSafeHwnd();§}§§ETSLayoutMgr::PaneCtrl::PaneCtrl( UINT nID, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /*= nDefaultBorder*/, int sizeExtraBorder /*= 0*/, int sizeTopExtra /*= 0*/ )§: ETSLayoutMgr::Pane(pMgr, orientation, sizeBorder, sizeExtraBorder)§{§	m_sizeTopExtra = sizeTopExtra;§§	m_hwndCtrl = ::GetDlgItem(pMgr->GetWnd()->GetSafeHwnd(), nID);§	ASSERT(m_hwndCtrl);§}§§int ETSLayoutMgr::PaneCtrl::getConstrainHorz(int sizeParent)§{§	return Pane::getConstrainHorz(sizeParent) ;§}§§int ETSLayoutMgr::PaneCtrl::getConstrainVert(int sizeParent)§{§	return Pane::getConstrainVert(sizeParent);§}§§int ETSLayoutMgr::PaneCtrl::getMinConstrainHorz()§{§	return Pane::getMinConstrainHorz();§}§§int ETSLayoutMgr::PaneCtrl::getMinConstrainVert()§{§	return Pane::getMinConstrainVert() + m_sizeTopExtra;§}§§int ETSLayoutMgr::PaneCtrl::getMaxConstrainHorz()§{§	int paneMax = Pane::getMaxConstrainHorz();§	return ( paneMax == -1) ? -1 : paneMax ;§}§§int ETSLayoutMgr::PaneCtrl::getMaxConstrainVert()§{§	int paneMax = Pane::getMaxConstrainVert();§	return ( paneMax == -1) ? -1 : paneMax + m_sizeTopExtra;§}§§bool ETSLayoutMgr::PaneCtrl::resizeTo(CRect& rcNewArea)§{§  // FIX: ::MoveWindow would case problems with some ActiveX Controls [Micheal Chapman]§  CWnd* pTempWnd = CWnd::FromHandle( m_hwndCtrl );§  pTempWnd->MoveWindow( rcNewArea.left, rcNewArea.top, rcNewArea.Width(), rcNewArea.Height(), true );§§  ::RedrawWindow(m_hwndCtrl,0,0, RDW_INVALIDATE | RDW_UPDATENOW |RDW_ERASE); §	rcNewArea.top	+= m_sizeTopExtra;§	return Pane::resizeTo(rcNewArea);§}§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutMgr::Pane implementation§§ETSLayoutMgr::Pane::Pane( ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /* = nDefaultBorder */, int sizeExtraBorder /*= 0*/) §: PaneBase(pMgr)§{§	m_Orientation	= orientation;§	m_sizeBorder	= sizeBorder;§	m_sizeSecondary	= 0;§	m_modeResize	= 0;§	m_sizeExtraBorder= sizeExtraBorder;§}§§§ETSLayoutMgr::Pane::~Pane() §{§}§§§bool ETSLayoutMgr::Pane::addItem( CWnd* pWnd, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeX /*=0*/, int sizeY /*=0*/, int sizeXMin /*=0*/, int sizeYMin /*=0*/)§{§	CPaneBase pItem = new PaneItem( pWnd, m_pMgr, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);§	return addPane( pItem );§}§§bool ETSLayoutMgr::Pane::addItem( UINT nID, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeX /*=0*/, int sizeY /*=0*/, int sizeXMin /*=0*/, int sizeYMin /*=0*/)§{§	CPaneBase pItem = new PaneItem( nID, m_pMgr, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);§	return addPane( pItem );§}§§bool ETSLayoutMgr::Pane::addItemFixed(int size)§{§	CPaneBase pNewItem = m_pMgr->itemFixed(m_Orientation, size);§	return addPane( pNewItem );§}§§bool ETSLayoutMgr::Pane::addItemGrowing()§{§	CPaneBase pNewItem = m_pMgr->itemGrowing(m_Orientation);§	return addPane( pNewItem );§}§§bool ETSLayoutMgr::Pane::addItemSpaceBetween( CWnd* pWndFirst, CWnd* pWndSecond )§{§	CPaneBase pNewItem = m_pMgr->itemSpaceBetween(m_Orientation, pWndFirst, pWndSecond);§	return addPane( pNewItem );§}§§bool ETSLayoutMgr::Pane::addItemSpaceBetween( UINT nIDFirst, UINT nIDSecond )§{§	CPaneBase pNewItem = m_pMgr->itemSpaceBetween(m_Orientation, nIDFirst, nIDSecond);§	return addPane( pNewItem );§}§§bool ETSLayoutMgr::Pane::addItemSpaceLike( CWnd* pWnd )§{§	CPaneBase pNewItem = m_pMgr->itemSpaceLike(m_Orientation, pWnd);§	return addPane( pNewItem );§}§§bool ETSLayoutMgr::Pane::addItemSpaceLike( UINT nID )§{§	CPaneBase pNewItem = m_pMgr->itemSpaceLike(m_Orientation, nID);§	return addPane( pNewItem );§}§§bool ETSLayoutMgr::Pane::addPane( CPane pSubpane, ETSLayoutMgr::layResizeMode modeResize, int sizeSecondary /* = 0 */) §{§	if( pSubpane->getOrientation() == m_Orientation)§	{§		// wrap in subpane of opposite orientation§		CPane pPaneWrap = new Pane(m_pMgr, m_Orientation==HORIZONTAL?VERTICAL:HORIZONTAL,0,0);§		pPaneWrap->addPane( pSubpane  );§§		addPane( pPaneWrap, modeResize, sizeSecondary );§	}§	else§	{§		pSubpane->m_modeResize = modeResize;§§		if(m_Orientation==HORIZONTAL && (modeResize & ABSOLUTE_HORZ) ) {§			if(sizeSecondary == 0) {§				pSubpane->m_sizeSecondary = pSubpane->getMinConstrainHorz();§			}§		}§		else if(m_Orientation==HORIZONTAL && (modeResize & RELATIVE_HORZ) ) {§			pSubpane->m_sizeSecondary = sizeSecondary;§		}§		else if(m_Orientation==VERTICAL && (modeResize & ABSOLUTE_VERT) ) {§			if(sizeSecondary == 0) {§				pSubpane->m_sizeSecondary = pSubpane->getMinConstrainVert();§			}§		}§		else if(m_Orientation==VERTICAL && (modeResize & RELATIVE_VERT) ) {§			pSubpane->m_sizeSecondary = sizeSecondary;§		}§§		m_paneItems.Add(pSubpane);§	}§§	return true;§}§§bool ETSLayoutMgr::Pane::addPane( CPaneBase pItem ) §{§	m_paneItems.Add(pItem);§	return true;§}§§int ETSLayoutMgr::Pane::getConstrainHorz(int sizeParent) §{§	ASSERT( m_Orientation == VERTICAL);§§	if( m_modeResize & RELATIVE_HORZ ) {§		return (sizeParent * m_sizeSecondary) / 100;§	}§	else if( m_modeResize & ABSOLUTE_HORZ ){§		return m_sizeSecondary;§	}§	else§		return 0;§}§§§int ETSLayoutMgr::Pane::getConstrainVert(int sizeParent) §{§	ASSERT( m_Orientation == HORIZONTAL);§§	if( m_modeResize & RELATIVE_VERT ) {§		return (sizeParent * m_sizeSecondary) / 100;§	}§	else if( m_modeResize & ABSOLUTE_VERT ) {§		return m_sizeSecondary;§	}§	else {§		return 0;§	}§}§§int ETSLayoutMgr::Pane::getMaxConstrainHorz() §{§	if(m_Orientation == HORIZONTAL) {§		int nMaxConstr = -1;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§§			int nConstrain = pItem->getMaxConstrainHorz();§			if(nConstrain == -1)§				return -1;§§			nMaxConstr += nConstrain;§		}§		return (nMaxConstr == -1) ? -1 : nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;§	}§	else if( m_modeResize & ABSOLUTE_HORZ && m_sizeSecondary!=0) {§		return m_sizeSecondary; // + 2*m_sizeExtraBorder;§	}§	else {§		int nMaxConstr = -1;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§§			int nConstrain = pItem->getMaxConstrainHorz();§§			if( nConstrain == -1)§				return -1;§			else§				nMaxConstr = std::max(nMaxConstr, nConstrain);§§		}§		return (nMaxConstr == -1) ? -1 : nMaxConstr + 2*m_sizeExtraBorder;§	}§}§§int ETSLayoutMgr::Pane::getMaxConstrainVert() §{§	if(m_Orientation == VERTICAL) {§		int nMaxConstr = -1;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§§			int nConstrain = pItem->getMaxConstrainVert();§			if(nConstrain == -1)§				return -1;§§			nMaxConstr += nConstrain;§		}§		return (nMaxConstr == -1) ? -1 : nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;§	}§	else if( m_modeResize & ABSOLUTE_VERT && m_sizeSecondary!=0) {§		return m_sizeSecondary; // + 2*m_sizeExtraBorder;§	}§	else {§		int nMaxConstr = -1;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§§			int nConstrain = pItem->getMaxConstrainVert();§§			if( nConstrain == -1)§				return -1;§			else§				nMaxConstr = std::max(nMaxConstr, nConstrain);§§		}§		return (nMaxConstr == -1) ? -1 : nMaxConstr + 2*m_sizeExtraBorder;§	}§}§§int ETSLayoutMgr::Pane::getMinConstrainHorz() §{§	if(m_Orientation == HORIZONTAL) {§		int nMaxConstr = 0;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§			nMaxConstr += std::max(nMinConstrain, pItem->getMinConstrainHorz());§		}§		return nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;§	}§	else if( m_modeResize & ABSOLUTE_HORZ && m_sizeSecondary!=0) {§		return m_sizeSecondary; // + 2*m_sizeExtraBorder;§	}§	else {§		int nMaxConstr = 0;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§			int nConstrain = pItem->getMinConstrainHorz();§			nMaxConstr = std::max(nMaxConstr, nConstrain);§		}§		return nMaxConstr + 2*m_sizeExtraBorder;§	}§}§§int ETSLayoutMgr::Pane::getMinConstrainVert() §{§	if(m_Orientation == VERTICAL) {§		int nMaxConstr = 0;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§			nMaxConstr += std::max(nMinConstrain, pItem->getMinConstrainVert());§		}§		return nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;§	}§	else if( m_modeResize & ABSOLUTE_VERT && m_sizeSecondary!=0) {§		return m_sizeSecondary; // + 2*m_sizeExtraBorder;§	}§	else {§		int nMaxConstr = 0;§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§			int nConstrain = pItem->getMinConstrainVert();§			nMaxConstr = std::max(nMaxConstr, nConstrain);§		}§		return nMaxConstr + 2*m_sizeExtraBorder;§	}§}§§§int ETSLayoutMgr::Pane::resizeToAbsolute(int& availSpace, CArray<int,int>& sizePrimary, §										 CArray<int,int>& sizeMin, CArray<int,int>& sizeMax)§{§	// count all greedy items as returnvalue§	int nGreedy = 0;§§	// first, subtract all absoulute items from available space§	for(int i=0; i<m_paneItems.GetSize(); ++i) {§		CPaneBase pItem = m_paneItems[i];§§		if( m_Orientation == HORIZONTAL ) {§§			// for absolute items subtract their size from available space§			if(pItem->modeResize() & ABSOLUTE_HORZ) {§				availSpace -= (sizePrimary[i] = pItem->getConstrainHorz(0));§			}§§			// count Greedy items for later§			if(!(pItem->modeResize() & ABSOLUTE_HORZ) && !(pItem->modeResize() & RELATIVE_HORZ)) {§				nGreedy++;§			}§§			sizeMin[i] = pItem->getMinConstrainHorz();§			sizeMax[i] = pItem->getMaxConstrainHorz();§		}§		else {§§			// for absolute items subtract their size from available space§			if(pItem->modeResize() & ABSOLUTE_VERT) {§				availSpace -= (sizePrimary[i] = pItem->getConstrainVert(0));§			}§§			// count Greedy items for later§			if(!(pItem->modeResize() & ABSOLUTE_VERT) && !(pItem->modeResize() & RELATIVE_VERT)) {§				nGreedy++;§			}§§			sizeMin[i] = pItem->getMinConstrainVert();§			sizeMax[i] = pItem->getMaxConstrainVert();§		}§§	}§§	// Must not be negative !!§	availSpace = std::max(availSpace, 0);§§	return nGreedy;§}§§bool ETSLayoutMgr::Pane::resizeToRelative(int& availSpace, CArray<int,int>& sizePrimary,§										 CArray<int,int>& sizeMin, CArray<int,int>& sizeMax)§{§	// Then all relative items as percentage of left space (as of now after§	// all absolute items are subtracted§§	int availRel = availSpace;	// At the beginning all of remaining space is available. We want all§								// operation to be relative to the left space at this moment, so we§								// save this amount here. Then we safly can lower availSpace§§	int relDiff = 0;			// The cumulated difference between first proposed size and§								// eventual maximum/minimum size. This amount has to be§								// saved in some other place (i.e. where relativ items/subpane§								// are not limited by min/max§	§	int relLeft = 0;			// The cumulated amout of space that can be saved by§								// shrinking the items/panes up to the minimum§	§	int relCount = 0;			// Actually allocated item/subpane's cumulated primary sizes §								// of non-limited items/subpanes (these can be modified in fixup)§								// needed for equally distribution of differences amoung non-limited§								// relative items/subpanes§§	for(int i=0; i<m_paneItems.GetSize(); ++i) {§		CPaneBase pItem = m_paneItems[i];§§		// For all relative items in primary direction§		if( (m_Orientation==HORIZONTAL && pItem->modeResize() & RELATIVE_HORZ)§			||§			(m_Orientation==VERTICAL   && pItem->modeResize() & RELATIVE_VERT) )§		{§			// minimum item/subpane size in primary direction (pixels)§			int nSizeRelMin = sizeMin[i];§§			// maximum item/subpane size in primary direction (pixels)§			int nSizeRelMax = sizeMax[i];§§			// Relative size in primary direction (pixels)§			int nSizeRel	= (m_Orientation==HORIZONTAL) §									? §									(pItem->getConstrainHorz(availRel)) §									:§									(pItem->getConstrainVert(availRel));§§			if( nSizeRel < nSizeRelMin) {§				// The item/pane is shrinked too small!§				// We will grow it to it's minimum-size. In order not to modify§				// this item later when fixing up set the size to the negative§				// minimum size§				sizePrimary[i]	= -nSizeRelMin;§§				// As we grew one item/subpane we have to shrink another one.§				// We keep count on how much space we needed to grow the item§				// to it's minimum size§				relDiff += ( nSizeRelMin - nSizeRel );§			}§			else if(  nSizeRelMax != -1 && nSizeRel > nSizeRelMax) {§				// if there's a maximum size (nSizeRelMax != -1) and our item/subpane§				// is to be resized over that amount correct it.  In order not to modify§				// this item later when fixing up set the size to the negative§				// maximum size§				sizePrimary[i]	= -nSizeRelMax;§§				// As we shrinked one item/subpane we have to grow another one.§				// We keep count on how much space we needed to grow the item§				// to it's maximum size.§				relDiff += ( nSizeRelMax - nSizeRel );§			}§			else {§				// this is the normal case: neither are we minimum limited nor maximum§				// limited§§				// As this item/subpane is larger that it's minimum we could later (if§				// necessary for fixup) shrink it for the difference amount of pixels§				relLeft	+= ( nSizeRel - nSizeRelMin );§§				// Set the primary size of this item/pane. Can later be modified by fixup§				sizePrimary[i]	= nSizeRel;§§				// Add this item/subpane's primary size to the count of already allocated§				// cumulated size of non-limited items/subpanes (these can be modified in fixup)§				relCount	+= nSizeRel;§			}§§			// decrease available space by used space in this step§			availSpace	-= nSizeRel;§		}§	}§§	// We now have the situation that some items/subpanes had to be adjusted for cumulated§	// relDiff pixels (positive value means more space taken than indicated by percentage of§	// left space). On the other hand we have some items/subpanes which were not limited (in §	// their current dimensions) but could be if necessary up to relLeft pixels. §	if(relLeft < relDiff && availSpace >= (relDiff-relLeft) ){		§§		// If it's not possible to shrink other (relative) panes in order to distribute the§		// difference because the left for shrinking (relLeft) is too small we need to aquire§		// more space from the globally left space (if available at all)§		availSpace -= (relDiff-relLeft);§		relDiff = relLeft;§	}§§	// At this point we should have some space left (at least not be negative with the leftover§	// space) and on the other hand there's enough space for the limit-difference to be distributed§//	ASSERT( availSpace >= 0 && relLeft >= relDiff);§§	// Fixup Relative:§	// Distribute (if anecessary) relDiff on other (not limited) relative items/subpanes §	// (if available - if not later just grow the limited panes)§	while( relDiff != 0 && relCount >= 0 ) {§§		// in every iteration there must be some space distributed (of the difference) or it could §		// come to endless looping. Save the amount of space actually distributed in this iteration§		int relDist = 0;§§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			§			CPaneBase pItem = m_paneItems[i];§§§			// For all relative items in primary direction which were NOT limited§			if( (m_Orientation==HORIZONTAL && (pItem->modeResize() & RELATIVE_HORZ) && sizePrimary[i] > 0)§				||§				(m_Orientation==VERTICAL   && (pItem->modeResize() & RELATIVE_VERT) && sizePrimary[i] > 0) )§			{§				// keep a flag for termination of this iteration§				bool bLast = false;§§				// the difference should be distributed amoung all non-limited items/subpanes equally.§				// nDiff is the amount for the current item/subpane§				int nDiff = (relDiff * sizePrimary[i]) / relCount;§§				// if it's a too small value just add it to the current pane and break iteration§				if( abs(relDiff) <= FIXUP_CUTOFF ) {§					// take it all in this step§					nDiff = relDiff;§§					// set break flag§					bLast = true;§				}§§				// calculate the new size for the current item/subpane§				int nNewSize = sizePrimary[i] - nDiff;§			§				if( nNewSize < sizeMin[i] ) {§					// oh, we are limited here. Revise our plan:§§					// Not all of the space could be saved, add the actually possible space§					// to the sum§					relDist += ( sizePrimary[i] - sizeMin[i] );§§					// set it to the minimum possible size§					sizePrimary[i] = -sizeMin[i];§§					// as this item/subpane is now limited it's occupied space doesn't count§					// for relCount anymore§					relCount-= ( sizePrimary[i] );§				}§				else {§					// account the difference of the sizes in relDist and set new size§					relDist += ( sizePrimary[i] - nNewSize );§					sizePrimary[i] = nNewSize;§§					// if it's the last one break now§					if(bLast)§						break;§				}§			}§		}§		// Distributed some relDiff-space in every iteration§//		ASSERT(relDist != 0);	§		relDiff -= relDist;§§		if( relDist == 0 )§			break;§	}§§	// Fixup Relative: invert all negative (limited) sized to correct value§	for(int i=0; i<m_paneItems.GetSize(); ++i) {§		CPaneBase pItem = m_paneItems[i];§		if( (m_Orientation==HORIZONTAL && (pItem->modeResize() & RELATIVE_HORZ) && sizePrimary[i] < 0)§			||§			(m_Orientation==VERTICAL   && (pItem->modeResize() & RELATIVE_VERT) && sizePrimary[i] < 0) )§		{§			sizePrimary[i] *= -1;§		}§	}§§	return true;§}§§bool ETSLayoutMgr::Pane::resizeToGreedy(int& availSpace, int nGreedy, CArray<int,int>& sizePrimary, §									   CArray<int,int>& sizeMin, CArray<int,int>& sizeMax)§{§	// Now resize all Greedy items/subpanes equally among the remaining space§	int greedyDiff = 0;			// The cumulated difference between first proposed size and§								// eventual maximum/minimum size. This amount has to be§								// saved in some other place (i.e. where items/subpane§								// are not limited by min/max§	§	int greedyLeft = 0;			// The cumulated amount of space that can be saved by§								// shrinking the items/panes up to the minimum§	§	int greedyCount = 0;		// Actually allocated item/subpane's cumulated primary sizes §								// of non-limited items/subpanes (these can be modified in fixup)§								// needed for equally distribution of differences amoung non-limited§								// items/subpanes§§	for(int i=0; i<m_paneItems.GetSize(); ++i) {§		CPaneBase pItem = m_paneItems[i];§§§		if( (m_Orientation==HORIZONTAL §				&& !(pItem->modeResize()&ABSOLUTE_HORZ) §				&& !(pItem->modeResize()&RELATIVE_HORZ)§			)§			||§			(m_Orientation==VERTICAL   §				&& !(pItem->modeResize()&ABSOLUTE_VERT) §				&& !(pItem->modeResize()&RELATIVE_VERT)§			) §		)§		{§§			// All greedy items get an equal portion of the left space§			int nSize		= availSpace / nGreedy;§§			// minimum item/subpane size in primary direction (pixels)§			int nSizeMin	= sizeMin[i];§§			// maximum item/subpane size in primary direction (pixels)§			int nSizeMax	= sizeMax[i];§§§			// the last gets the all of the remaining space§			if( nGreedy == 1 )§				nSize = availSpace;						§§			if( nSize < nSizeMin) {§				// The item/pane is shrinked too small!§				// We will grow it to it's minimum-size. In order not to modify§				// this item later when fixing up set the size to the negative§				// minimum size§				sizePrimary[i]	= -nSizeMin;§§				// As we grew one item/subpane we have to shrink another one.§				// We keep count on how much space we needed to grow the item§				// to it's minimum size§				greedyDiff		+= ( nSizeMin - nSize );§			}§			else if( nSizeMax != -1 && nSize > nSizeMax) {§				// if there's a maximum size (nSizeRelMax != -1) and our item/subpane§				// is to be resized over that amount correct it.  In order not to modify§				// this item later when fixing up set the size to the negative§				// maximum size§				sizePrimary[i]	= -nSizeMax;§§				// As we shrinked one item/subpane we have to grow another one.§				// We keep count on how much space we needed to grow the item§				// to it's maximum size.§				greedyDiff		+= ( nSizeMax - nSize );§			}§			else {§§				// this is the normal case: neither are we minimum limited nor maximum§				// limited§§				// As this item/subpane is larger that it's minimum we could later (if§				// necessary for fixup) shrink it for the difference amount of pixels§				greedyLeft		+= ( nSize - nSizeMin );§§				// Set the primary size of this item/pane. Can later be modified by fixup§				sizePrimary[i]	= nSize;§§				// Add this item/subpane's primary size to the count of already allocated§				// cumulated size of non-limited items/subpanes (these can be modified in fixup)§				greedyCount		+= nSize;§			}§§			// decrease available space by used space in this step§			availSpace	-= nSize;§§			// one greedy item/subpane complete§			--nGreedy;§		}§	}§§§	// Fixup Greedy I§	// Distribute (if anecessary) greedyDiff on other (not limited) greedy items/subpanes §	// (if available - if not later just grow the limited panes)§§	// at least on not limited item present§	bool bAtLeastOne = true;§§	while( bAtLeastOne && greedyDiff != 0 && greedyCount > 0) {§§		// in every iteration there must be some space distributed (of the difference) or it could §		// come to endless looping. Save the amount of space actually distributed in this iteration§		int greedyDist = 0;§§		// at least on not limited item present§		bAtLeastOne = false;§§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§§§			if( (m_Orientation==HORIZONTAL §					&& !(pItem->modeResize()&ABSOLUTE_HORZ) §					&& !(pItem->modeResize()&RELATIVE_HORZ)§					&& sizePrimary[i] > 0§				)	§				||§				(m_Orientation==VERTICAL   §					&& !(pItem->modeResize()&ABSOLUTE_VERT) §					&& !(pItem->modeResize()&RELATIVE_VERT)§					&& sizePrimary[i] > 0 §				)§			)§			{§	 			// keep a flag for termination of this iteration§				bool bLast = false;§§				// the difference should be distributed among all non-limited items/subpanes equally.§				// nDiff is the amount for the current item/subpane§				int nDiff = (greedyDiff * sizePrimary[i]) / greedyCount;§§				// if it's a too small value just add it to the current pane and break iteration§				if( abs(greedyDiff) <= FIXUP_CUTOFF || nDiff == 0) {§					// take it all in this step§					nDiff = greedyDiff;§§					// set break flag§					bLast = true;§				}§§				// calculate the new size for the current item/subpane§				int nNewSize = sizePrimary[i] - nDiff;§			§				if( nNewSize < sizeMin[i] ) {§					// oh, we are limited here. Revise our plan:§§					if( sizePrimary[i] != sizeMin[i] )§						bAtLeastOne = true;§§					// Not all of the space could be saved, add the actually possible space§					// to the sum§					greedyDist += ( sizePrimary[i] - sizeMin[i] );§§					// set it to the minimum possible size§					sizePrimary[i] = sizeMin[i];§§					// as this item/subpane is now limited its occupied space doesn't count§					// for relCount anymore§					greedyCount -= ( sizePrimary[i] );§				}§				else {§					// yes, there is one§					bAtLeastOne = true;§§					// account the difference of the sizes in relDist and set new size§					greedyDist += ( sizePrimary[i] - nNewSize );§					sizePrimary[i] = nNewSize;§§					// if it's the last one break now§					if(bLast)§						break;§				}§			}§		}§		// Distributed some greedyDiff-space in every iteration§		ASSERT(!bAtLeastOne || greedyDist != 0 || greedyCount<=0);§		greedyDiff -= greedyDist;§	}§§§	// Fixup Greedy II§	if( greedyDiff < 0 ) {§		// still difference, some space left§§		// are there any items which are minimum-limited where we can give more space?§		for(int i=0; i<m_paneItems.GetSize() && greedyDiff!=0; ++i) {§			CPaneBase pItem = m_paneItems[i];§§			if( (m_Orientation==HORIZONTAL §					&& !(pItem->modeResize()&ABSOLUTE_HORZ) §					&& !(pItem->modeResize()&RELATIVE_HORZ)§				)	§				||§				(m_Orientation==VERTICAL   §					&& !(pItem->modeResize()&ABSOLUTE_VERT) §					&& !(pItem->modeResize()&RELATIVE_VERT)§				)§			)§			{§				if( sizePrimary[i] == -sizeMin[i] ) {§					// fill this one up as much as possible§					if( sizeMax[i] == -1) {§						// all fits in§						sizePrimary[i] += greedyDiff;§						greedyDiff = 0;§					}§					else {§						sizePrimary[i] += -std::min( -greedyDiff, sizeMax[i]-sizeMin[i]);§						greedyDiff     -= -std::min( -greedyDiff, sizeMax[i]-sizeMin[i]);§					}§				}§			}§		}§	}§§§	// Fixup Greedy III: invert all negative (limited) sized to correct value§	for(int i=0; i<m_paneItems.GetSize(); ++i) {§		CPaneBase pItem = m_paneItems[i];§§		if( (m_Orientation==HORIZONTAL §				&& !(pItem->modeResize() & ABSOLUTE_HORZ) §				&& !(pItem->modeResize() & RELATIVE_HORZ) §				&& sizePrimary[i] < 0§				&& sizeMin[i] >= 0§			)§			||§			(m_Orientation==VERTICAL   §				&& !(pItem->modeResize() & ABSOLUTE_VERT) §				&& !(pItem->modeResize() & RELATIVE_VERT) §				&& sizePrimary[i] < 0§				&& sizeMin[i] >= 0§			) §		)§		{§			if(sizePrimary[i] < 0)§				sizePrimary[i] *= -1;§		}§	}§§	return true;§}§§§bool ETSLayoutMgr::Pane::resizeTo(CRect& rcNewArea) §{§	// There must be some items or subpanes§	ASSERT(m_paneItems.GetSize());§§	// This Array holds the size in primary direction for each item/subpane§	CArray<int,int>	sizePrimary;§	sizePrimary.SetSize(m_paneItems.GetSize());§§	// This Array holds information about the minimum size in primary direction§	CArray<int,int>	sizeMin;§	sizeMin.SetSize(m_paneItems.GetSize());§§	// This Array holds information about the maximum size in primary direction§	CArray<int,int>	sizeMax;§	sizeMax.SetSize(m_paneItems.GetSize());§§§	// How much space is actually available, subtract all borders between items§	int availSpace = (m_Orientation == HORIZONTAL ? rcNewArea.Width() : rcNewArea.Height() ) - (m_paneItems.GetUpperBound()*m_sizeBorder);§	§	// If there is some Extra border (on top/bottem resp. left/right) subtract it too§	availSpace -= 2*m_sizeExtraBorder;§§	// Add the extra Border to top/bottem resp. left/right§	if(m_Orientation == HORIZONTAL) {§		rcNewArea.top		+= m_sizeExtraBorder;§		rcNewArea.bottom	-= m_sizeExtraBorder;§	}§	else {§		rcNewArea.left		+= m_sizeExtraBorder;§		rcNewArea.right		-= m_sizeExtraBorder;§	}§§	// Counts the number of greedy items/subpanes§	int nGreedy = resizeToAbsolute(availSpace, sizePrimary, sizeMin, sizeMax );§§	if(nGreedy == -1)§		return false;§§	if(! resizeToRelative(availSpace, sizePrimary, sizeMin, sizeMax ) )§		return false;§§	if(! resizeToGreedy(availSpace, nGreedy, sizePrimary, sizeMin, sizeMax ) )§		return false;§§§	// If there is any left space and there are ALIGN_FILL_* Items to assign it§	// equally among them§	if( availSpace > 0 ) {§		// Count possible Items§		int nFillItems = 0;§§		for(int i=0; i<m_paneItems.GetSize(); ++i) {§			CPaneBase pItem = m_paneItems[i];§			if( m_Orientation == HORIZONTAL §				&& (pItem->modeResize() & ABSOLUTE_HORZ ) §				&& (pItem->modeResize() & ALIGN_FILL_HORZ)§			§				||§				§				(pItem->modeResize() & ABSOLUTE_VERT ) §				&& (pItem->modeResize() & ALIGN_FILL_VERT) §			)§			{§				++nFillItems;§			}§		}§§		if( nFillItems > 0 ) {§			// okay, there are nFillItems, make them all availSpace/nFillItems bigger§			for(int i=0; i<m_paneItems.GetSize(); ++i) {§				CPaneBase pItem = m_paneItems[i];§§				if( m_Orientation == HORIZONTAL §					&& (pItem->modeResize() & ABSOLUTE_HORZ ) §					&& (pItem->modeResize() & ALIGN_FILL_HORZ)§				§					||§					§					(pItem->modeResize() & ABSOLUTE_VERT ) §					&& (pItem->modeResize() & ALIGN_FILL_VERT) §				)§				{§§					if( nFillItems == 1 ) {§						// the last one gets all the rest§						sizePrimary[i]	+= availSpace;§						availSpace		= 0;§						--nFillItems;§					}§					else {§						sizePrimary[i]	+= availSpace/nFillItems;§						availSpace		-= availSpace/nFillItems;§						--nFillItems;§					}§§				}§			}§		}§§	}§§	// Now reposition all items:§§	// starting offset§	int nOffset = (m_Orientation==HORIZONTAL ? rcNewArea.left : rcNewArea.top ) + m_sizeExtraBorder;§	for(int i=0; i<m_paneItems.GetSize(); ++i) {§		CPaneBase pItem = m_paneItems[i];§§		// Calculate rect of item/subpane§		CRect rcPane;§		§		if( m_Orientation==HORIZONTAL ) {§			rcPane.SetRect(nOffset, rcNewArea.top, nOffset+sizePrimary[i], rcNewArea.bottom);§		}§		else {§			rcPane.SetRect(rcNewArea.left, nOffset, rcNewArea.right, nOffset+sizePrimary[i]);§		}§§		// do the resizing!§		pItem->resizeTo( rcPane );§§		// go to the next position (old pos + size + border)§		ASSERT(sizePrimary[i] >= 0);§		nOffset += m_sizeBorder + sizePrimary[i];§	}				§§§	return true;			§}§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutDialog dialog§§#pragma warning(disable: 4355)§ETSLayoutDialog::ETSLayoutDialog(UINT nID, CWnd* pParent /*=NULL*/, LPCTSTR strName /*=NULL*/, bool bGripper /*=true*/)§	: CBaseDialog(nID, pParent), ETSLayoutMgr( this )§{§	//{{AFX_DATA_INIT(ETSLayoutDialog)§		// NOTE: the ClassWizard will add member initialization here§	//}}AFX_DATA_INIT§	m_bGripper	= bGripper;§§	if(strName)§		m_strRegStore = strName;§}§#pragma warning(default: 4355)§§BEGIN_MESSAGE_MAP(ETSLayoutDialog, CBaseDialog)§	//{{AFX_MSG_MAP(ETSLayoutDialog)§	ON_WM_SIZE()§	ON_WM_GETMINMAXINFO()§	ON_WM_ERASEBKGND()§	ON_WM_DESTROY()§	//}}AFX_MSG_MAP§END_MESSAGE_MAP()§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutDialog message handlers§§BOOL ETSLayoutDialog::OnEraseBkgnd(CDC* pDC) §{§	EraseBkgnd(pDC);§	return true;§}§§void ETSLayoutDialog::OnSize(UINT nType, int cx, int cy) §{§	CBaseDialog::OnSize(nType, cx, cy);§§	if( abs(cx) + abs(cy) > 0) §	{§		// Reposition Size Marker§		// Re-Layout all controls§		UpdateLayout();§		RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);§	}§§}§§void ETSLayoutDialog::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) §{§	if(m_RootPane.IsValid()) {§§		CRect rcClient = GetRect();§		if( rcClient.Height() > 0 || rcClient.Width() > 0 )§		{§§			CRect rcWnd;§			GetWindowRect(rcWnd);§			§			// How much do Window and Client differ§			int nDiffHorz = rcWnd.Width() - rcClient.Width();§			int nDiffVert = rcWnd.Height() - rcClient.Height();§§			// Take into account that there is a border around the rootPane§			lpMMI->ptMinTrackSize = CPoint(m_RootPane->getMinConstrainHorz() + nDiffHorz + 2*m_sizeRootBorders.cx,§				m_RootPane->getMinConstrainVert() + nDiffVert + 2*m_sizeRootBorders.cy);§§			int maxWidth = m_RootPane->getMaxConstrainHorz();§			int maxHeight = m_RootPane->getMaxConstrainVert();§§			if( maxWidth != -1 ) {§				lpMMI->ptMaxTrackSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;§				lpMMI->ptMaxSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;§			}§§			if( maxHeight != -1 ) {§				lpMMI->ptMaxTrackSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;§				lpMMI->ptMaxSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;§			}§		}§	}§}§§§CRect ETSLayoutDialog::GetRect() §{ §	CRect r; §	GetClientRect(r);§§	if( m_bGripper ) §	{§		if( ::IsWindow(m_StatusBar.GetSafeHwnd()) ) §		{§			CRect rcSizeIcon;§			m_StatusBar.GetWindowRect( rcSizeIcon);§			r.bottom -= (rcSizeIcon.Height() - m_sizeRootBorders.cy - 5);§		}§	}§§	return r; §}§§§BOOL ETSLayoutDialog::OnInitDialog() §{§	CBaseDialog::OnInitDialog();§§    // Ensure that the dialog is resizable§    this->ModifyStyle(0, WS_THICKFRAME);§§	if(!m_strRegStore.IsEmpty()) {§		Load(m_strRegStore);§	}	§§#ifdef _AUTO_SET_ICON§	POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition();§	if(pos) {§§		class ETSPseudoDocTemplate : public CDocTemplate§		{§			friend class ETSLayoutDialog;§		};§§		ETSPseudoDocTemplate* pDocT = (ETSPseudoDocTemplate*) AfxGetApp()->GetNextDocTemplate(pos);§		SetIcon( AfxGetApp()->LoadIcon(pDocT->m_nIDResource) ,FALSE);§	}§#endif§	§	// Sizing icon§	if(m_bGripper)§	{§		if(m_StatusBar.Create(m_pWnd))§		{                           §			m_StatusBar.SetIndicators(auIDStatusBar, sizeof(auIDStatusBar) / sizeof(UINT));§			m_StatusBar.SetWindowText(_T(""));		§			m_StatusBar.SetPaneStyle( 0, SBPS_STRETCH | SBPS_NOBORDERS );§			m_pWnd -> RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);§		}             §		else§			AfxMessageBox(_T("Error - Statusbar"));§§	}§	return TRUE;  // return TRUE unless you set the focus to a control§	              // EXCEPTION: OCX Property Pages should return FALSE§}§§void ETSLayoutDialog::OnDestroy() §{§	// Store size/position§	if(!m_strRegStore.IsEmpty()) {§		Save(m_strRegStore);§	}	§§	// manually delete layout definition if object is reused§	m_RootPane = 0;§§	CBaseDialog::OnDestroy();§}§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutDialog dialog§§#pragma warning(disable: 4355)§#ifdef CS_HELP§ETSLayoutDialogBar::ETSLayoutDialogBar(UINT nID )§	: CBaseDialogBar( nID ), ETSLayoutMgr( this )§#else§ETSLayoutDialogBar::ETSLayoutDialogBar()§	: ETSLayoutMgr( this )§#endif§{§	//{{AFX_DATA_INIT(ETSLayoutDialogBar)§		// NOTE: the ClassWizard will add member initialization here§	//}}AFX_DATA_INIT§	m_bInitialized = false;§	setRootBorders(0,0);§}§#pragma warning(default: 4355)§§BEGIN_MESSAGE_MAP(ETSLayoutDialogBar, CBaseDialogBar)§	//{{AFX_MSG_MAP(ETSLayoutDialogBar)§	ON_WM_SIZE()§	ON_WM_GETMINMAXINFO()§	ON_WM_DESTROY()§	ON_WM_ERASEBKGND()§	ON_MESSAGE(WM_INITDIALOG, OnInitDialog)§	//}}AFX_MSG_MAP§END_MESSAGE_MAP()§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutDialogBar message handlers§§LRESULT ETSLayoutDialogBar::OnInitDialog(WPARAM, LPARAM)§{§	Default();§	Initialize();§	return TRUE;§}§§void ETSLayoutDialogBar::UpdateLayout()§{§	ETSLayoutMgr::UpdateLayout();§§	if(m_RootPane.IsValid()) {§		CRect rcClient = GetRect();§§		CRect rcWnd;§		GetWindowRect(rcWnd);§			§		// How much do Window and Client differ§		CSize sizeDiff( rcWnd.Width() - rcClient.Width(), rcWnd.Height() - rcClient.Height());§§		// Take into account that there is a border around the rootPane§//		m_szMin = CSize(m_RootPane->getMinConstrainHorz() + sizeDiff.cx + 2*m_sizeRootBorders.cx,§//			m_RootPane->getMinConstrainVert() + sizeDiff.cy + 2*m_sizeRootBorders.cy);§	}§}§§CSize ETSLayoutDialogBar::CalcDynamicLayout(int nLength, DWORD dwMode)§{§	CSize sizeRet =  CBaseDialogBar::CalcDynamicLayout(nLength, dwMode);§§	CSize sizeMin = sizeRet;§	CSize sizeMax = sizeRet;§§	if(m_RootPane.IsValid()) {§		CRect rcClient = GetRect();§§		CRect rcWnd;§		GetWindowRect(rcWnd);§			§		// How much do Window and Client differ§		CSize sizeDiff( rcWnd.Width() - rcClient.Width(), rcWnd.Height() - rcClient.Height());§§		// Take into account that there is a border around the rootPane§//		sizeMin = CSize(m_RootPane->getMinConstrainHorz() + sizeDiff.cx + 2*m_sizeRootBorders.cx,§//			m_RootPane->getMinConstrainVert() + sizeDiff.cy + 2*m_sizeRootBorders.cy);§§§		int maxWidth = m_RootPane->getMaxConstrainHorz();§		int maxHeight = m_RootPane->getMaxConstrainVert();§§		if( maxWidth != -1 ) {§			sizeMax.cx = maxWidth + sizeDiff.cy + 2*m_sizeRootBorders.cx;§		}§§		if( maxHeight != -1 ) {§			sizeMax.cy = maxHeight + sizeDiff.cy + 2*m_sizeRootBorders.cy;§		}§	}§§	if( IsFloating() || !(dwMode&LM_HORZ))§	{§		sizeRet.cx = std::min( sizeRet.cx, sizeMax.cx );§	}§	if( IsFloating() || (dwMode&LM_HORZ))§	{§		sizeRet.cy = std::min( sizeRet.cy, sizeMax.cy );§	}§§	sizeRet.cx = std::max( sizeRet.cx, sizeMin.cx );§	sizeRet.cy = std::max( sizeRet.cy, sizeMin.cy );§§	return sizeRet;§}§§BOOL ETSLayoutDialogBar::OnEraseBkgnd(CDC* pDC) §{§	EraseBkgnd(pDC);§	return true;§}§§§void ETSLayoutDialogBar::OnSize(UINT nType, int cx, int cy) §{§	CBaseDialogBar::OnSize(nType, cx, cy);§§	if( abs(cx) + abs(cy) > 0)§	{§		// Re-Layout all controls§		UpdateLayout();§	}§	RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);§§}§§§CRect ETSLayoutDialogBar::GetRect() §{ §	CRect r; §	GetClientRect(r);§§	if( IsFloating() )§		r.DeflateRect(4,4);§§	return r; §}§§§void ETSLayoutDialogBar::OnDestroy() §{§	// Store size/position on your own!§	CBaseDialogBar::OnDestroy();§}§§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutFormView dialog§§IMPLEMENT_DYNAMIC(ETSLayoutFormView, CFormView)§§#pragma warning(disable: 4355)§ETSLayoutFormView::ETSLayoutFormView(UINT nID, LPCTSTR strName /*=NULL*/)§	: CBaseFormView(nID), ETSLayoutMgr( this )§{§	if(strName)§		m_strRegStore = strName;§}§#pragma warning(default: 4355)§§BEGIN_MESSAGE_MAP(ETSLayoutFormView, CBaseFormView)§	//{{AFX_MSG_MAP(ETSLayoutFormView)§	ON_WM_SIZE()§	ON_WM_GETMINMAXINFO()§	ON_WM_ERASEBKGND()§	//}}AFX_MSG_MAP§END_MESSAGE_MAP()§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutFormView message handlers§§BOOL ETSLayoutFormView::OnEraseBkgnd(CDC* pDC) §{§	EraseBkgnd(pDC);§	return true;§}§§§void ETSLayoutFormView::OnSize(UINT nType, int cx, int cy) §{§//	CBaseFormView::OnSize(nType, cx, cy);§	SetScrollSizes(MM_TEXT, CSize(cx,cy));§	if( abs(cx) + abs(cy) > 0) {§		// Re-Layout all controls§		UpdateLayout();§	}§//	MoveWindow(0,0,cx,cy);§}§§/*§void ETSLayoutFormView::UpdateLayout()§{§	ETSLayoutMgr::UpdateLayout();§§	if(m_RootPane.IsValid()) {§		// Force MainFrame to re-layout§		CFrameWnd* pFrame = static_cast<CFrameWnd*>(GetParent());§		if(pFrame) {§§			CRect rcWnd;§			pFrame->GetWindowRect(rcWnd);§			pFrame->MoveWindow(rcWnd);§			pFrame->RecalcLayout();§§		}§		return;§	}§}§*/§§void ETSLayoutFormView::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) §{§	// To use this you'll have to modify your CMainFrame:§	//§	// 1) Add a handler for WM_GETMINMAXINFO()§	// 2) Let this handler be:§	// void CMainFrame::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) §	// {§	// 	CFrameWnd::OnGetMinMaxInfo(lpMMI);§	// §	// 	if( GetActiveView() && GetActiveView()->IsKindOf( RUNTIME_CLASS(ETSLayoutFormView) ) ) {§	// 		GetActiveView()->SendMessage( WM_GETMINMAXINFO, 0, (LPARAM) lpMMI );§	// 	}§	// }§	// 3) Add "#include "dialogmgr.h" to MainFrm.cpp§§	if(m_RootPane.IsValid()) {§		CRect rcClient = GetRect();§§		CRect rcWnd;§		GetParent()->GetWindowRect(rcWnd);§	§		// How much do Window and Client differ§		rcWnd-=rcClient;§§		// Take into account that there is a border around the rootPane§		lpMMI->ptMinTrackSize = CPoint(m_RootPane->getMinConstrainHorz() + rcWnd.Width() + 2*m_sizeRootBorders.cx,§			m_RootPane->getMinConstrainVert() + rcWnd.Height() + 2*m_sizeRootBorders.cy);§§		int maxWidth = m_RootPane->getMaxConstrainHorz();§		int maxHeight = m_RootPane->getMaxConstrainVert();§§		if( maxWidth != -1 ) {§			lpMMI->ptMaxTrackSize.x = maxWidth + rcWnd.Width()+ 2*m_sizeRootBorders.cx;§			lpMMI->ptMaxSize.x = maxWidth + rcWnd.Width()+ 2*m_sizeRootBorders.cx;§		}§§		if( maxHeight != -1 ) {§			lpMMI->ptMaxTrackSize.y = maxHeight + rcWnd.Height() + 2*m_sizeRootBorders.cy;§			lpMMI->ptMaxSize.y = maxHeight + rcWnd.Height() + 2*m_sizeRootBorders.cy;§		}§	}§}§§ETSLayoutFormView::~ETSLayoutFormView() §{§	// Cleanup§}§§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutPropertyPage§§#ifdef CS_HELP§	IMPLEMENT_DYNCREATE(ETSLayoutPropertyPage, ETSCSHelpPropPage)§#else§	IMPLEMENT_DYNCREATE(ETSLayoutPropertyPage, CPropertyPage)§#endif§§#pragma warning(disable: 4355)§ETSLayoutPropertyPage::ETSLayoutPropertyPage( ) : ETSLayoutMgr( this )§{§	m_bLockMove = false;§	m_bResetBuddyOnNextTimeVisible = true;§}§§ETSLayoutPropertyPage::ETSLayoutPropertyPage( UINT nIDTemplate, UINT nIDCaption /*= 0*/ )§	: CBasePropertyPage(nIDTemplate, nIDCaption), ETSLayoutMgr( this )§{§	m_bLockMove = false;§	m_bResetBuddyOnNextTimeVisible = true;§}§§ETSLayoutPropertyPage::ETSLayoutPropertyPage( LPCTSTR lpszTemplateName, UINT nIDCaption /*= 0*/ )§	: CBasePropertyPage(lpszTemplateName, nIDCaption), ETSLayoutMgr( this )§{§	m_bLockMove = false;§	m_bResetBuddyOnNextTimeVisible = true;§}§#pragma warning(default: 4355)§§ETSLayoutPropertyPage::~ETSLayoutPropertyPage()§{§}§§§BEGIN_MESSAGE_MAP(ETSLayoutPropertyPage, CBasePropertyPage)§	//{{AFX_MSG_MAP(ETSLayoutPropertyPage)§	ON_WM_SIZE()§	ON_WM_GETMINMAXINFO()§	ON_WM_ERASEBKGND()§	ON_WM_WINDOWPOSCHANGING()§	ON_WM_DESTROY()§	ON_WM_WINDOWPOSCHANGED()§	//}}AFX_MSG_MAP§END_MESSAGE_MAP()§§§/////////////////////////////////////////////////////////////////////////////§// Behandlungsroutinen fπr Nachrichten ETSLayoutPropertyPage §§§§void ETSLayoutPropertyPage::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) §{§	CBasePropertyPage::OnWindowPosChanged(lpwndpos);§	§	// This code is needed in order to reset the buddy after this page has§	// been activated. At least on Win2k this is not done thru normal resizing,§	// as the page is not visible when first layouted. And without the page§	// being visible it's not possible to tell if the attached buddy is visible§	// or not (at least I don't know any way to do so)§§	if( ::IsWindowVisible( GetWnd()->GetSafeHwnd() ) )§	{§		if( m_bResetBuddyOnNextTimeVisible ) §		{§			// Take special care of SpinButtons (Up-Down Controls) with Buddy set, enumerate§			// all childs:§			CWnd* pWndChild = GetWnd()->GetWindow(GW_CHILD);§			TCHAR szClassName[ MAX_PATH ];§			while(pWndChild)§			{§				::GetClassName( pWndChild->GetSafeHwnd(), szClassName, MAX_PATH );§				DWORD dwStyle = pWndChild->GetStyle();§§				// is it a SpinButton?§				if( _tcscmp(szClassName, UPDOWN_CLASS)==0 && ::IsWindowVisible(pWndChild->GetSafeHwnd()) ) {§					HWND hwndBuddy = (HWND)::SendMessage( pWndChild->GetSafeHwnd(), UDM_GETBUDDY, 0, 0);§					if( hwndBuddy != 0 && (dwStyle&(UDS_ALIGNRIGHT|UDS_ALIGNLEFT)) != 0 )§					{§						// reset Buddy§						::SendMessage( pWndChild->GetSafeHwnd(), UDM_SETBUDDY, (WPARAM)hwndBuddy, 0);§					}§				}§				§§				pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);§			}§§			m_bResetBuddyOnNextTimeVisible = false;§		}§	}	§	else§	{§		// has been hidden again§		m_bResetBuddyOnNextTimeVisible = true;§	}§}§§void ETSLayoutPropertyPage::OnWindowPosChanging( WINDOWPOS* lpwndpos )§{§	// In WizardMode the System calls SetWindowPos with the §	// original size at every activation. This could cause§	// some flicker in certain circumstances. Therefore we lock§	// moving the page and unlock it only if _we_ move the page§	if( m_bLockMove)§	{§		lpwndpos->flags |= SWP_NOMOVE | SWP_NOSIZE;§	}§	CBasePropertyPage::OnWindowPosChanging( lpwndpos );§}§§BOOL ETSLayoutPropertyPage::OnEraseBkgnd(CDC* pDC) §{§	EraseBkgnd(pDC);§	return true;§}§§void ETSLayoutPropertyPage::OnDestroy() §{§	// manually delete layout definition if object is reused§	m_RootPane = 0;§§	CBasePropertyPage::OnDestroy();§}§§void ETSLayoutPropertyPage::OnSize(UINT nType, int cx, int cy) §{§	CBasePropertyPage::OnSize(nType, cx, cy);§	§	if( abs(cx) + abs(cy) > 0) §	{§		// Re-Layout all controls§		UpdateLayout();§	}	§}§§void ETSLayoutPropertyPage::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) §{§	if(m_RootPane.IsValid()) {§		CRect rcClient = GetRect();§§		CRect rcWnd;§		GetWindowRect(rcWnd);§		§		// How much do Window and Client differ§		int nDiffHorz = rcWnd.Width() - rcClient.Width();§		int nDiffVert = rcWnd.Height() - rcClient.Height();§§		// Take into account that there is a border around the rootPane§		lpMMI->ptMinTrackSize = CPoint(m_RootPane->getMinConstrainHorz() + nDiffHorz + 2*m_sizeRootBorders.cx,§			m_RootPane->getMinConstrainVert() + nDiffVert + 2*m_sizeRootBorders.cy);§§		int maxWidth = m_RootPane->getMaxConstrainHorz();§		int maxHeight = m_RootPane->getMaxConstrainVert();§§		if( maxWidth != -1 ) {§			lpMMI->ptMaxTrackSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;§			lpMMI->ptMaxSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;§		}§§		if( maxHeight != -1 ) {§			lpMMI->ptMaxTrackSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;§			lpMMI->ptMaxSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;§		}§	}§}§§§CRect ETSLayoutPropertyPage::GetRect() §{ §	CRect r; §	GetClientRect(r);§	return r; §}§§§BOOL ETSLayoutPropertyPage::OnInitDialog() §{§	CBasePropertyPage::OnInitDialog();§	UpdateLayout();§§	ETSLayoutPropertySheet* pSheet = (ETSLayoutPropertySheet*) GetParent();§§	//ASSERT_KINDOF( ETSLayoutPropertySheet, pSheet);§	if(pSheet)§	{§		if(pSheet->IsWizard())§		{§			m_bLockMove = true;§		}§	}§§	return TRUE;§}§§BOOL ETSLayoutPropertyPage::OnSetActive() §{§	ETSLayoutPropertySheet* pSheet = (ETSLayoutPropertySheet*) GetParent();§§	//ASSERT_KINDOF( ETSLayoutPropertySheet, pSheet);§	if(pSheet)§	{§		if(pSheet->IsWizard())§		{§			// In WizardMode the System calls SetWindowPos with the §			// original size on Page Activation. This will position the§			// page at the correct position§			m_bLockMove = false;§			MoveWindow(pSheet->m_rcPage);§			m_bLockMove = true;§		}§	}§§	UpdateLayout();	§§	return CBasePropertyPage::OnSetActive();§}§§/////////////////////////////////////////////////////////////////////////////§// ETSLayoutPropertySheet§§IMPLEMENT_DYNAMIC(ETSLayoutPropertySheet, CPropertySheet)§§#pragma warning(disable: 4355)§ETSLayoutPropertySheet::ETSLayoutPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage, §											   LPCTSTR strName /*=NULL*/, bool bGripper/*=true*/)§	: CPropertySheet(nIDCaption, pParentWnd, iSelectPage), ETSLayoutMgr( this )§{§	Init(strName, bGripper);§}§§ETSLayoutPropertySheet::ETSLayoutPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage, §											   LPCTSTR strName /*=NULL*/, bool bGripper/*=true*/)§	: CPropertySheet(pszCaption, pParentWnd, iSelectPage), ETSLayoutMgr( this )§{§	Init(strName, bGripper);§}§#pragma warning(default: 4355)§§void ETSLayoutPropertySheet::Init(LPCTSTR strName, bool bGripper)§{§	m_bGripper	= bGripper;§	if(strName)§		m_strRegStore = strName;§§	m_bAutoDestroy	= false;§	m_bAutoDestroyPages	= false;§	m_bModelessButtons = false;§}§§ETSLayoutPropertySheet::~ETSLayoutPropertySheet()§{§}§§§BEGIN_MESSAGE_MAP(ETSLayoutPropertySheet, CPropertySheet)§	//{{AFX_MSG_MAP(ETSLayoutPropertySheet)§	ON_WM_CREATE()§	ON_WM_SIZE()§	ON_WM_GETMINMAXINFO()§	ON_WM_DESTROY()§	ON_WM_ERASEBKGND()§	//}}AFX_MSG_MAP§END_MESSAGE_MAP()§§/////////////////////////////////////////////////////////////////////////////§// Behandlungsroutinen fπr Nachrichten ETSLayoutPropertySheet §§BOOL ETSLayoutPropertySheet::OnEraseBkgnd(CDC* pDC) §{§	EraseBkgnd(pDC);§	return true;§}§§§int ETSLayoutPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct) §{§	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)§		return -1;§§	ModifyStyle(0,WS_THICKFRAME| WS_SYSMENU);§	return 0;§}§§§void ETSLayoutPropertySheet::Resize(int cx, int cy)§{§	if( abs(cx) + abs(cy) > 0 && m_RootPane.IsValid() ) §	{§		UpdateLayout();§§		// Fix for PSH_WIZARDHASFINISH [Th°mmi]§		if (IsWizard() && !(m_psh.dwFlags & PSH_WIZARDHASFINISH) )§		{§			// manual reposition of the FINISH button§			// can not be done with normaly layouting because it§			// shares position with the NEXT button§			CWnd *pWndFinish;§			pWndFinish=GetDlgItem(ID_WIZFINISH);§§			if(pWndFinish)§			{§				CRect rcWnd;§				GetDlgItem(ID_WIZNEXT)->GetWindowRect(&rcWnd);§				ScreenToClient(&rcWnd);§				pWndFinish->MoveWindow(rcWnd);§				pWndFinish->RedrawWindow(0,0, RDW_INVALIDATE | RDW_UPDATENOW );§			}§		}§§		// reposition Gripper§		if(m_bGripper)§			RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);§§		CPropertyPage* pPage = (CPropertyPage*)GetActivePage();§§		if(pPage)§		{§			CRect rcWnd;§			GetTabControl()->GetWindowRect(&rcWnd);§			ScreenToClient(&rcWnd);§§			if(!IsWizard()) {§				// get inside of tab§				GetTabControl()->AdjustRect(FALSE, &rcWnd);§			}§			else§			{§				rcWnd.bottom += 5;§			}§§			// we need this size in WizardMode in order to §			// reposition newly activated page correctly§			m_rcPage = rcWnd;§			§			if( IsWizard() && pPage->IsKindOf(RUNTIME_CLASS(ETSLayoutPropertyPage)) )§			{§				ETSLayoutPropertyPage* pEtsPage = reinterpret_cast<ETSLayoutPropertyPage*>(pPage);§§				pEtsPage->m_bLockMove = false;§				pEtsPage->MoveWindow(m_rcPage);§				pEtsPage->m_bLockMove = true;§			}§			else §			{§				pPage->MoveWindow(m_rcPage);§			}§			§		}§§		if(IsWindowVisible())§		{§			RedrawWindow(0,0, RDW_INVALIDATE|RDW_UPDATENOW );§§			if(!IsWizard())§				GetTabControl()->RedrawWindow(0,0, RDW_INVALIDATE|RDW_UPDATENOW );§		}§	}§}§§void ETSLayoutPropertySheet::OnSize(UINT nType, int cx, int cy) §{§	CPropertySheet::OnSize(nType, cx, cy);§	Resize(cx,cy);§}§§// IDs of all PropertySheet controls§long _PropertySheetIDs[] =§{§	ID_WIZBACK,§	ID_WIZNEXT, §	ID_WIZFINISH,§	IDOK, §	IDCANCEL,§	ID_APPLY_NOW, §	IDHELP§};§§void ETSLayoutPropertySheet::AddMainArea(CPane paneRoot, CPaneBase itemTab)§{§    // the default is: Whole main Area is covered by the TabCtrl§    paneRoot << itemTab;§}§§void ETSLayoutPropertySheet::AddButtons(CPane paneBottom)§{§	// first item greedy to keep others right§	paneBottom->addItem (paneNull, GREEDY);§§§	// add all Controls to the layouting§	bool bFirst = true;§	for(int i = 0; i < (sizeof(_PropertySheetIDs) / sizeof(long)) ; i++)§	{§		// Prevent movement of finish button, if it is not shown explicitly [Th°mmi]§		if( IsWizard() §			&& _PropertySheetIDs[i] == ID_WIZFINISH §			&& !(m_psh.dwFlags & PSH_WIZARDHASFINISH) ) §		{§			continue;§		}§§		CWnd* pWnd = GetDlgItem(_PropertySheetIDs[i]);§§		if(pWnd)§		{§§			if(!(m_psh.dwFlags & PSH_HASHELP) && _PropertySheetIDs[i] == IDHELP)§			{§				// don't insert§				continue;§			}§§			if((m_psh.dwFlags & PSH_NOAPPLYNOW) && _PropertySheetIDs[i] == ID_APPLY_NOW)§			{§				// don't insert§				continue;§			}§§			// space before first one and between BACK & NEXT§			if( IsWizard() )§			{§				if( !bFirst && !(_PropertySheetIDs[i]==ID_WIZNEXT) )§				{§					paneBottom->addItem(paneNull, NORESIZE,12,0,0,0);§				}§			}§§			pWnd->ShowWindow(true);§			paneBottom->addItem(_PropertySheetIDs[i], NORESIZE);			§			bFirst = false;§		}§	}§§}§§BOOL ETSLayoutPropertySheet::OnInitDialog() §{§	BOOL bRet = CPropertySheet::OnInitDialog();§§	//ASSERT(!m_RootPane);§§	// Save initial rect§	GetWindowRect(&m_rcStart);§§	CPropertyPage* pPage = CPropertySheet::GetActivePage();§	ASSERT(pPage);§§	CRect rcPage;§	pPage->GetClientRect(&rcPage);§§	CreateRoot(VERTICAL);§	//ASSERT(m_RootPane);§§	// Add Tabcontrol to root pane§	m_ItemTab = item( GetTabControl(), GREEDY, 0, 0, 0, 0);§    AddMainArea(m_RootPane, m_ItemTab);§§	// Tabcontrol is invisible in WizardMode§	if(IsWizard())§	{§		GetTabControl()->ShowWindow(false);§	}§§	// add horizontal line in WizardMode§	if(IsWizard() && GetDlgItem(ID_WIZFINISH+1))§	{§		m_RootPane << item(ID_WIZFINISH+1, ABSOLUTE_VERT, 0, 0, 0, 0);§	}§§	if( IsWizard() || !m_bModeless || m_bModelessButtons )§	{§		// No spaces in WizardMode in order to keep BACK & NEXT together§		CPane bottomPane = pane(HORIZONTAL, ABSOLUTE_VERT, IsWizard() ? 0 : 5);§§        AddButtons(bottomPane);§		// add bottom (button) pane if any controls were added§        if(bottomPane->m_paneItems.GetSize() > 0) {§    		m_RootPane << bottomPane;§        }§	}§§§§	// some Space between Buttons und Gripper§	if(m_bGripper)§	{§		m_RootPane->addItem(paneNull, ABSOLUTE_VERT,0,2);§§		if(m_StatusBar.Create(m_pWnd))§		{                           §			m_StatusBar.SetIndicators(auIDStatusBar,§				sizeof(auIDStatusBar) / sizeof(UINT));§			m_StatusBar.SetWindowText(_T(""));		§			RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);§		}             §		else§		{§			AfxMessageBox(_T("Error - Statusbar"));§		}§	}§§	if(!m_strRegStore.IsEmpty())§	{§		Load(m_strRegStore);§	}	§§	Resize(1,1); // Fix. for 95/98/NT difference§§	CRect rcWnd;§	GetWindowRect( & rcWnd );§	MoveWindow( rcWnd );§§	return bRet;§}§§§void ETSLayoutPropertySheet::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) §{§	if(m_RootPane.IsValid() && GetTabControl() != 0 ) §	{§		CRect rcWnd;§		GetWindowRect(rcWnd);		§§		CRect rcClient = GetRect();§		rcWnd-=rcClient;§§		// ask for MinMax of all pages§		CSize sizePageMax(0,0);§		CSize sizePageMin(0,0);§		for( int nPage=0; nPage<GetPageCount(); ++nPage)§		{§			CPropertyPage* pPage = GetPage(nPage);§			ASSERT(pPage);§			if( pPage )§			{§				MINMAXINFO mmi;§				memset(&mmi, 0, sizeof(mmi));§§				if( IsWindow(pPage->GetSafeHwnd()) )§				{§					pPage->SendMessage(WM_GETMINMAXINFO, 0, (LPARAM) &mmi);§§					if(mmi.ptMaxTrackSize.x != 0)§					{§						sizePageMax.cx = std::min(sizePageMax.cx, mmi.ptMaxTrackSize.x);§					}§					if(mmi.ptMaxTrackSize.y != 0)§					{§						sizePageMax.cy = std::min(sizePageMax.cy, mmi.ptMaxTrackSize.y);§					}§					if(mmi.ptMinTrackSize.x != 0)§					{§						sizePageMin.cx = std::max(sizePageMin.cx, mmi.ptMinTrackSize.x);§					}§					if(mmi.ptMinTrackSize.y != 0)§					{§						sizePageMin.cy = std::max(sizePageMin.cy, mmi.ptMinTrackSize.y);§					}§				}§			}§		}§		static_cast<PaneItem*>( m_ItemTab.GetPaneBase() )->m_sizeXMin = sizePageMin.cx;§		static_cast<PaneItem*>( m_ItemTab.GetPaneBase() )->m_sizeYMin = sizePageMin.cy;§§		// calculate the needed size of the tabctrl in non-wizard-mode§		CRect rcItem(0,0,0,0);§		if(!IsWizard())§		{§			GetTabControl()->AdjustRect( TRUE, rcItem );§		}§§		lpMMI->ptMinTrackSize.x = m_RootPane->getMinConstrainHorz() + rcWnd.Width() + 2*m_sizeRootBorders.cx§					+ rcItem.Width();§§		lpMMI->ptMinTrackSize.y = m_RootPane->getMinConstrainVert() + rcWnd.Height() + 2*m_sizeRootBorders.cy §				+ rcItem.Height();§§		// never smaller than inital size!§		lpMMI->ptMinTrackSize.x = std::max((long)lpMMI->ptMinTrackSize.x, (long)m_rcStart.Width() );§		lpMMI->ptMinTrackSize.y = std::max((long)lpMMI->ptMinTrackSize.y, (long)m_rcStart.Height() );§§		// Rest like ETSLayoutMgr§§		int maxWidth = m_RootPane->getMaxConstrainHorz();§		int maxHeight = m_RootPane->getMaxConstrainVert();§§		if( maxWidth != -1 ) §		{§			lpMMI->ptMaxSize.x = sizePageMax.cx + rcWnd.Width()+ 2*m_sizeRootBorders.cx + rcItem.Width() ;§		}§§		if( maxHeight != -1 ) §		{§			lpMMI->ptMaxSize.y = sizePageMax.cy + rcWnd.Height() + 2*m_sizeRootBorders.cy + rcItem.Width() ;§		}§§		lpMMI->ptMaxTrackSize = lpMMI->ptMaxSize;§§	}§}§§§void ETSLayoutPropertySheet::OnDestroy() §{§	// Store size/position§	if(!m_strRegStore.IsEmpty()) §	{§		Save(m_strRegStore);§	}	§	m_RootPane = 0;§§	CPropertySheet::OnDestroy();§}§§void ETSLayoutPropertySheet::PostNcDestroy()§{§	if(m_bAutoDestroyPages)§	{§		// walk all pages and destry them§		for( int nPage=0; nPage<GetPageCount(); ++nPage)§		{§			CPropertyPage* pPage = GetPage(nPage);§			ASSERT(pPage);§			if( pPage )§			{§				delete pPage;§			}§		}§	}§§	if(m_bAutoDestroy)§		delete this;§}§§§§/**§ * CPane represents an autopointer to a PaneBase. Use this and you won't have to worry§ * about cleaning up any Panes. Also this autopointer lets you return Pane objects§ * from function without using pointers (at least you won't see them :) )§ */§ETSLayoutMgr::PaneHolder::PaneHolder(PaneBase* pPane )§{§§	ASSERT( pPane );§	m_pPane = pPane;§§	// Implicitly AddRef()§	m_nRefCount = 1;§}§§ETSLayoutMgr::PaneHolder::~PaneHolder()§{§	ASSERT( m_pPane );§	ASSERT( m_nRefCount == 0 );§§	delete m_pPane;§}§§void ETSLayoutMgr::PaneHolder::AddRef()§{§	InterlockedIncrement( &m_nRefCount );§}§§void ETSLayoutMgr::PaneHolder::Release()§{§	if( InterlockedDecrement( &m_nRefCount ) <= 0 )§	{§		// no more references on me, so destroy myself§		delete this;§	}§}§§ETSLayoutMgr::CPaneBase::CPaneBase( )§{§	// MUST be initialized later§	m_pPaneHolder = 0;§}§§ETSLayoutMgr::CPaneBase::CPaneBase( PaneBase* pPane )§{§	m_pPaneHolder = 0;§	§	if( pPane != 0)§		operator=( pPane );§}§§ETSLayoutMgr::CPaneBase::CPaneBase( const CPaneBase& other )§{§	m_pPaneHolder = 0;§	operator=(other);§}§§ETSLayoutMgr::CPaneBase::~CPaneBase()§{§	if(m_pPaneHolder)§		m_pPaneHolder->Release();§}§§void ETSLayoutMgr::CPaneBase::operator=( PaneBase* pPane )§{§	if(m_pPaneHolder)§	{§		m_pPaneHolder->Release();§		m_pPaneHolder = 0;§	}§§	if( pPane != 0 )§		m_pPaneHolder = new PaneHolder( pPane );§}§§void ETSLayoutMgr::CPaneBase::operator=( const CPaneBase& other )§{§	ASSERT( other.m_pPaneHolder );§§	if(m_pPaneHolder)§	{§		m_pPaneHolder->Release();§		m_pPaneHolder = 0;§	}§§	other.m_pPaneHolder->AddRef();§	m_pPaneHolder = other.m_pPaneHolder;§}§§ETSLayoutMgr::PaneBase* ETSLayoutMgr::CPaneBase::operator->() const§{§	ASSERT(m_pPaneHolder);§§	if(!m_pPaneHolder)§		return 0;§§	return (m_pPaneHolder->m_pPane);§}§§§§ETSLayoutMgr::CPane::CPane( )§{§}§§ETSLayoutMgr::CPane::CPane( Pane* pPane ) : ETSLayoutMgr::CPaneBase( static_cast<PaneBase*>(pPane) )§{§}§§ETSLayoutMgr::CPane::CPane( const CPane& other )§{§	operator=(other);§}§§ETSLayoutMgr::CPane::~CPane()§{§}§§void ETSLayoutMgr::CPane::operator=( Pane* pPane )§{§	CPaneBase::operator=(pPane);§}§§void ETSLayoutMgr::CPane::operator=( const ETSLayoutMgr::CPane& other )§{§	ASSERT( other.m_pPaneHolder );§§	if(m_pPaneHolder)§	{§		m_pPaneHolder->Release();§		m_pPaneHolder = 0;§	}§§	other.m_pPaneHolder->AddRef();§	m_pPaneHolder = other.m_pPaneHolder;§}§§ETSLayoutMgr::Pane* ETSLayoutMgr::CPane::operator->() const§{§	ASSERT(m_pPaneHolder);§§	if(!m_pPaneHolder)§		return 0;§§	return reinterpret_cast<Pane*>(m_pPaneHolder->m_pPane);§}§§ETSLayoutMgr::CPaneBase ETSLayoutMgr::CPane::ConvertBase() const§{§	ASSERT(m_pPaneHolder);§	return CPaneBase( m_pPaneHolder->m_pPane );§}§§ETSLayoutMgr::CPane& ETSLayoutMgr::CPane::operator<< ( const ETSLayoutMgr::CPane pPane )§{§	GetPane()->addPane( pPane, (ETSLayoutMgr::layResizeMode)pPane->m_modeResize, pPane->m_sizeSecondary);§	return (*this);§}§§ETSLayoutMgr::CPane& ETSLayoutMgr::CPane::operator<< ( const ETSLayoutMgr::CPaneBase pItem )§{§	GetPane()->addPane( pItem );§	return (*this);§}§§//#UC END# *46A88BDA035B*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*46A88BDA035B_USER_INCLUDES*"
		    value      	(value Text 
|//#UC START# *46A88BDA035B_USER_INCLUDES*§#include <afxtempl.h>§#include <windows.h>§#include <afxwin.h>         // MFC-Kern- und -Standardkomponenten§#include <afxext.h>         // MFC-Erweiterungen§#include <afxdisp.h>        // MFC Automatisierungsklassen§#ifndef _AFX_NO_AFXCMN_SUPPORT§#include <afxcmn.h>			// MFC-Unterstπtzung fπr gÙngige Windows-Steuerelemente§#endif // _AFX_NO_AFXCMN_SUPPORT§//#UC END# *46A88BDA035B_USER_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*46A88BDA035B_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *46A88BDA035B_USER_DEFINITION*§namespace ETSLayout§{§§#ifdef CS_HELP§	typedef ETSCSHelpDialog		CBaseDialog;§	typedef ETSCSHelpFormView	CBaseFormView;§	typedef ETSCSHelpDlgBar		CBaseDialogBar;§	typedef ETSCSHelpPropPage	CBasePropertyPage;§#else§	typedef CDialog CBaseDialog;§	typedef CFormView CBaseFormView;§	typedef CDialogBar CBaseDialogBar;§	typedef CPropertyPage CBasePropertyPage;§#endif§}§§// Support for CBCGDialogBar instead of CDialogBar available:§// you just have to change the typedef to CBaseDialogBar§§#ifndef ETSGUI_EXT_CLASS§#define ETSGUI_EXT_CLASS§#endif§§§// Support for CBCGDialogBar instead of CDialogBar§§/**§ * Controls whether the Icon is automatically set to IDR_MAINFRAME§ */§#define _AUTO_SET_ICON§§/**§ * Forward class declarations§ */§class ETSLayoutDialog;§class ETSLayoutDialogBar;§class ETSLayoutFormView;§class ETSLayoutMgr;§class ETSLayoutPropertyPage;§class ETSLayoutPropertySheet;§§§/**§ * These are NOOPs now§ */§#define DECLARE_LAYOUT()§#define IMPLEMENT_LAYOUT()§§/**§ * This is the default border size between the panes. You§ * may override it in Pane constructor, but it is the§ * fixed border around the root pane§ */§const int nDefaultBorder	= 5;§§/**§ * The minimum size for not ABSOLUTE_XXX items§ */§const int nMinConstrain = 5;§§class ETSGUI_EXT_CLASS ETSLayoutMgr§{§public:§	§	enum layResizeMode {§		GREEDY				= 0,		// Will eat up as much as it can§		ABSOLUTE_HORZ		= 1 << 0,	// Horizontal size is absolute§		RELATIVE_HORZ		= 1 << 1,	// Horizontal size in percent§		ABSOLUTE_VERT		= 1 << 2,	// Vertical size is absolute§		RELATIVE_VERT		= 1 << 3,	// Vertical size in percent§§		NORESIZE			= ABSOLUTE_HORZ | ABSOLUTE_VERT,§§		SIZE_MASK			= NORESIZE,§§		ALIGN_LEFT			= 1 << 4,   // following only for NORESIZE§		ALIGN_RIGHT			= 1 << 5,§		ALIGN_TOP			= 1 << 6,§		ALIGN_BOTTOM		= 1 << 7,§§		ALIGN_HCENTER		= ALIGN_LEFT    | ALIGN_RIGHT,	§		ALIGN_VCENTER		= ALIGN_TOP     | ALIGN_BOTTOM,§§		ALIGN_CENTER		= ALIGN_HCENTER | ALIGN_VCENTER,§§		ALIGN_FILL_HORZ		= 1 << 8,§		ALIGN_FILL_VERT		= 1 << 9,§		ALIGN_FILL			= ALIGN_FILL_HORZ | ALIGN_FILL_VERT,§	§/*		TRACKER_LEFT		= 1 << 10,	// not yet. May allow tracking of borders§		TRACKER_RIGHT		= 1 << 11,  // between items in the future§		TRACKER_TOP			= 1 << 12,§		TRACKER_BOTTOM		= 1 << 13,§*/§	};§§	enum layOrientation {§		HORIZONTAL,§		VERTICAL§	};§§	/**§	 * This is the base class for all kind of panes. §	 */§	class ETSGUI_EXT_CLASS PaneBase {§		friend class ETSLayoutMgr;§		friend class CPaneBase;§		friend class CPane;§§	public:§§		/**§		 * Informs the caller how much of the given space this pane would§		 * like to receive in horizontal direction§		 */§		virtual int		getConstrainHorz(int sizeParent) = 0;§§§		/**§		 * Informs the caller how much of the given space this pane would§		 * like to receive in vertical direction§		 */§		virtual int		getConstrainVert(int sizeParent) = 0;§§		/**§		 * Informs the caller how much of the given space this pane§		 * minimally need. This would be an absolute Value if §		 * the mode contains ABSOLUTE_HORZ or an explicit minimum§		 * value, else nMinConstrain§		 */§		virtual int		getMinConstrainHorz() = 0;§		/**§		 * Informs the caller if there is an restriction for maximum§		 * space this pane needs. Return -1 for unrestricted (GREEDY§		 * or RELATIVE)§		 */§		virtual int		getMaxConstrainHorz() = 0;§§		/**§		 * Informs the caller how much of the given space this pane§		 * minimally need. This would be an absolute Value if §		 * the mode contains ABSOLUTE_VERT or an explicit minimum§		 * value, else nMinConstrain§		 */§		virtual int		getMinConstrainVert() = 0;§§		/**§		 * Informs the caller if there is an restriction for maximum§		 * space this pane needs. Return -1 for unrestricted (GREEDY§		 * or RELATIVE)§		 */§		virtual int		getMaxConstrainVert() = 0;§§		/**§		 * This will do the actual resize operation after the§		 * caller computed a new area for this pane§		 */§		virtual bool	resizeTo(CRect& rcNewArea) = 0;§§		/**§		 * Constructor needed pointer to LayoutManager§		 */§		PaneBase( ETSLayoutMgr* pMgr )		{ m_pMgr = pMgr; };§§		/**§		 * Virtual destructor needed in Container operations§		 */§		virtual ~PaneBase() {};§§		/**§		 * Returs the Resize Mode of this pane§		 */§		DWORD	modeResize() { return m_modeResize; };§§	protected:§		/**§		 * How this Item will be resized, a combination of the flags above§		 */§		DWORD	m_modeResize;§§		/**§		 * A pointer to the holding LayoutManager derivate§		 */§		ETSLayoutMgr*		m_pMgr;§	};§§	/**§	 * CPaneBase represents an autopointer to a PaneBase. Use this and you won't have to worry§	 * about cleaning up any Panes. Also this autopointer lets you return Pane objects§	 * from function without using pointers (at least you won't see them :) )§	 */§	struct ETSGUI_EXT_CLASS PaneHolder§	{§		PaneHolder(PaneBase* pPane );§		~PaneHolder();§§		void	AddRef();§		void	Release();§§		PaneBase*	m_pPane;§		long		m_nRefCount;§	};§§	class ETSGUI_EXT_CLASS CPaneBase§	{§	protected:§		PaneHolder*		m_pPaneHolder;§§	public:§		// Standardconstructor§		CPaneBase( );§		CPaneBase( PaneBase* pPane );§		CPaneBase( const CPaneBase& other );§§		~CPaneBase();§§		void operator=( PaneBase* pPane );§		void operator=( const CPaneBase& other );§		PaneBase* operator->() const;§		PaneBase* GetPaneBase()	{ return operator->(); }§§		bool IsValid()			{ return (m_pPaneHolder != 0); }§		bool operator !()			{ return (m_pPaneHolder == 0); }§§	};§§	class Pane;§	class ETSGUI_EXT_CLASS CPane : public CPaneBase§	{§	public:§		// Standardconstructor§		CPane( );§		CPane( Pane* pPane );§		CPane( const CPane& other );§§		~CPane();§§		void operator=( Pane* pPane );§		void operator=( const CPane& other );§		Pane* operator->() const;§		Pane* GetPane()			{ return operator->(); }§§		CPaneBase ConvertBase() const;§§		CPane& operator<< ( const CPane pPane );§		CPane& operator<< ( const CPaneBase pItem );§	};§§§§	/**§	 * PaneItem represents a single control§	 */§	class ETSGUI_EXT_CLASS PaneItem : public PaneBase {§		friend class ETSLayoutMgr;§		friend class Pane;§	protected:§		/**§		 * Creates a new PaneItem from an Control. If sizeX or sizeY are 0§		 * and modeResize is ABSOLUTE will copy the current dimensions of§		 * the control to m_sizeX/Y. So the appearance does not change§		 * from the Dialog Editor§		 */§		PaneItem( CWnd* pWnd, ETSLayoutMgr* pMgr, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=0, int sizeYMin=0);§§		/**§		 * If your control is not mapped you can name it by its ChildID. Pass§		 * the pMgr to receive the CWnd* of nID. §		 * The rest as stated above§		 */§		PaneItem( UINT nID, ETSLayoutMgr* pMgr, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=0, int sizeYMin=0);§§§	public:§		/**§		 * see PaneBase§		 */§		virtual int getConstrainHorz(int sizeParent);§		virtual int getConstrainVert(int sizeParent);§		virtual int getMinConstrainHorz();§		virtual int getMinConstrainVert();§		virtual int	getMaxConstrainHorz();§		virtual int	getMaxConstrainVert();§		virtual bool resizeTo(CRect& rcNewArea);§§		bool	isDummy()				{ return (m_hwndCtrl == 0);	}§§	protected:§		friend class ETSLayoutPropertySheet;§§		/**§		 * The horizontal size of the control (see m_modeResize)§		 */§		int				m_sizeX;§		int				m_sizeXMin;§§		/**§		 * The vertical size of the control (see m_modeResize)§		 */§		int				m_sizeY;§		int				m_sizeYMin;§§		/**§		 * Child Control pointer§		 */§		HWND			m_hwndCtrl;§§		/**§		 * Combo box needs special treatment§		 */§		bool			m_bComboSpecial;§	};§§§	/**§	 * This class encapsulates a Subpane (and indeed the root Pane too)§	 * it is a container of PaneBase* which it will recursivly resize§	 */§	class ETSGUI_EXT_CLASS Pane : public PaneBase {§		friend class ETSLayoutMgr;§		friend class CPaneBase;§		friend class CPane;§        friend class ETSLayoutPropertySheet;§        §	protected:§		/**§		 * Tell the pane in which direction it is positioned. A HORIZONTAL pane§		 * arranges it's subpanes from left to right, a VERTICAL from top to bottom§		 */§		Pane( ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0 );§§	public:§		/**§		 * If your control is not mapped you can name it by its ChildID. Pass§		 * the pMgr to receive the CWnd* of nID. §		 * The rest as stated above§		 */§		bool addItem( UINT nID, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=-1, int sizeYMin=-1);§§		/**§		 * Creates a new PaneItem from an Control. If sizeX or sizeY are 0§		 * and modeResize is ABSOLUTE will copy the current dimensions of§		 * the control to m_sizeX/Y. So the appearance does not change§		 * from the Dialog Editor§		 */§		bool addItem( CWnd* pWnd, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=-1, int sizeYMin=-1);§§§		/**§		 * Add a whitespace Item (paneNull) of variable size with§		 * a minimum size of 0§		 */§		bool addItemGrowing();§§		/**§		 * Add a whitespace Item (paneNull) with fixed size§		 */§		bool addItemFixed(int size);§§		/**§		 * Add a whitespace Item (paneNull) of fixed size based on the§		 * current layout (as in the dialog template). Based on the layout§		 * of the pane vertical or horizontal spacing is considered§		 *§		 * First argument is the left (top) item for a HORIZONTAL (VERTICAL) pane§		 */§		bool addItemSpaceBetween( CWnd* pWndFirst, CWnd* pWndSecond );§		bool addItemSpaceBetween( UINT nIDFirst, UINT nIDSecond );§§§		/**§		 * Add a whitespace Item (paneNull) of fixed size based on the§		 * size of another item§		 */§		bool addItemSpaceLike( CWnd* pWnd );§		bool addItemSpaceLike( UINT nID );§§§		/**§		 * Add an item to the pane, appending at the end. This may be either obtained§		 * by a call to ETSLayoutMgr::item() or one of the ETSLayoutMgr::paneXXX() calls§		 */§		bool addPane( CPaneBase pItem );§		bool addPane( CPane pSubpane, layResizeMode modeResize, int sizeSecondary /* = 0 */);§§		virtual int		getConstrainHorz(int sizeParent);§		virtual int		getConstrainVert(int sizeParent);§		virtual int		getMinConstrainHorz();§		virtual int		getMinConstrainVert();§		virtual int		getMaxConstrainHorz();§		virtual int		getMaxConstrainVert();§		virtual bool	resizeTo(CRect& rcNewArea);§§		/**§		 * The destructor takes care of destroying all Subpanes and items§		 */§		virtual ~Pane();§§		/**§		 * Access to the orientation of this pane§		 */§		layOrientation	getOrientation() { return m_Orientation; };§§§	protected:§§		int		resizeToAbsolute(int& availSpace, CArray<int,int>& sizePrimary, §									CArray<int,int>& sizeMin, CArray<int,int>& sizeMax);§		§		bool	resizeToRelative(int& availSpace, CArray<int,int>& sizePrimary, §									CArray<int,int>& sizeMin, CArray<int,int>& sizeMax);§§		bool	resizeToGreedy(  int& availSpace, int nGreedy, CArray<int,int>& sizePrimary, §									CArray<int,int>& sizeMin, CArray<int,int>& sizeMax);§§		/**§		 * The orientation of the pane. Keep in mind that all subpanes§		 * must have the complementary orientation, i.e. a VERTICAL§		 * pane must have all HORIZONTAL SubPanes (or normal Items§		 * of course)§		 */§		layOrientation					m_Orientation;§§		/**§		 * This array holds the pointers to the Items/SubPanes§		 */§		CArray<CPaneBase, CPaneBase>	m_paneItems;§§		/**§		 * The secondary constrain§		 */§		int				m_sizeSecondary;§§		/** §		 * Size of gap between childs§		 */§		int				m_sizeBorder;§		int				m_sizeExtraBorder;§	};§§§	/**§	 * This class encapsulates a Subpane which is a Tab§	 * it will use calls to AdjustRect to position it's§	 * childs§	 */§	class ETSGUI_EXT_CLASS PaneTab : public Pane§	{§		friend class ETSLayoutMgr;§§	protected:§		/**§		 * Tell the pane in which direction it is positioned. A HORIZONTAL pane§		 * arranges it's subpanes from left to right, a VERTICAL from top to bottom§		 */§		PaneTab( CTabCtrl* pTab, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0 );§§	public:§		virtual int		getConstrainHorz(int sizeParent);§		virtual int		getConstrainVert(int sizeParent);§		virtual int		getMinConstrainHorz();§		virtual int		getMinConstrainVert();§		virtual int		getMaxConstrainHorz();§		virtual int		getMaxConstrainVert();§		virtual bool	resizeTo(CRect& rcNewArea);§§	private:§		CTabCtrl* m_pTab;§	};§§	/**§	 * This class encapsulates a Subpane which is a Static§	 * it will use calls to AdjustRect to position it's§	 * childs§	 */§	class ETSGUI_EXT_CLASS PaneCtrl : public Pane§	{§		friend class ETSLayoutMgr;§	protected:§		/**§		 * Tell the pane in which direction it is positioned. A HORIZONTAL pane§		 * arranges it's subpanes from left to right, a VERTICAL from top to bottom§		 */§		PaneCtrl( CWnd* pCtrl, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0);§		PaneCtrl( UINT nID, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0 );§§	public:§§		virtual int		getConstrainHorz(int sizeParent);§		virtual int		getConstrainVert(int sizeParent);§		virtual int		getMinConstrainHorz();§		virtual int		getMinConstrainVert();§		virtual int		getMaxConstrainHorz();§		virtual int		getMaxConstrainVert();§		virtual bool	resizeTo(CRect& rcNewArea);§§	private:§		HWND			m_hwndCtrl;§		int				m_sizeTopExtra;§	};§§§§§	ETSLayoutMgr(CWnd* pWnd)	{ m_pWnd = pWnd; m_sizeRootBorders = CSize(5,5); };§	virtual ~ETSLayoutMgr();§§	virtual CRect GetRect() { CRect r; m_pWnd->GetClientRect(r); return r; };§	CWnd*	m_pWnd;§	CWnd*	GetWnd()		{ return m_pWnd; };§	void	setRootBorders(int cx, int cy)	{ m_sizeRootBorders = CSize(cx,cy); };§§	/**§	 * Pass this for a pseudo Pane with no content§	 */§	static CWnd*	paneNull;§§	/**§	 * Loads the current position and size from the registry using a supplied§	 * key. Will be loaded with AfxGetApp()->WriteProfileXXX(). You may§	 * specify a subfolder (e.g. Load( _T("MyDialog\\Layout") ); ). Will§	 * load the following keys:§	 *§	 * - lpstrRegKey+"SizeX";§	 * - lpstrRegKey+"SizeY";§	 * - lpstrRegKey+"PosX";§	 * - lpstrRegKey+"PosY";§	 *§	 * Is automatically called during OnActivate() if key specified in§	 * constructor.§	 */§	bool Load(LPCTSTR lpstrRegKey);§§	/**§	 * Store the current position and size to the registry using a supplied§	 * key. Will be stored with AfxGetApp()->WriteProfileXXX(). You may§	 * specify a subfolder (e.g. Save( _T("MyDialog\\Layout") ); ). Will§	 * create the following keys:§	 *§	 * - lpstrRegKey+"SizeX";§	 * - lpstrRegKey+"SizeY";§	 * - lpstrRegKey+"PosX";§	 * - lpstrRegKey+"PosY";§	 *§	 * Is automatically called during DestroyWindow() if key specified in§	 * constructor.§	 */§	bool Save(LPCTSTR lpstrRegKey);§§	/**§	 * Updates the layout after you specify the new§	 * layout§	 */§	virtual void UpdateLayout();§	virtual void UpdateLayout(CPane p) {§		if(m_RootPane.IsValid())§		{§			// free old root§			m_RootPane = 0;§		}§		m_RootPane = p;§		UpdateLayout();§	}§§	/**§	 * Does the actual Layout, called from OnSize()§	 * Default implementation does nothing, use§	 * IMPLEMENT_LAYOUT in your derived class (see above)§	 */§	virtual void Layout(CRect& rcClient);§§§	/**§	 * Erasing only the these parts of the client area where§	 * there is no child window. Extra-code for group-boxes §	 * included!§	 */§	void EraseBkgnd(CDC* pDC);§§	/**§	 * Helperfunctions for the stream-interface. For usage see sample Application§	 * and/or documentation.§ 	 */§§	/**§	 * Create a new Pane. You may specify the resize§	 * mode for both directions. If you add modes for the secondary direction§	 * (i.e. *_VERT for a HORIZONTAL pane) then sizeSecondary is used as it's§	 * size. If you do not specify sizeSecondary and the mode is ABSOLUTE_VERT§	 * it will be computed as the maximum Height of all SubPanes (the same is§	 * true for VERTICAL panes and subpanes with *_HORZ)§	 */§	CPane pane( layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeSecondary = 0);§§	/**§	 * Create one of the special control panes. Parameter are like pane(). For§	 * additional information see documentation§	 */§	CPane paneTab( CTabCtrl* pTab, layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeSecondary = 0);§	CPane paneCtrl( UINT nID, layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0, int sizeSecondary = 0);§	CPane paneCtrl( CWnd* pCtrl, layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0, int sizeSecondary = 0);§§	/**§	 * Creates a new PaneItem for an Control. If sizeX or sizeY are 0§	 * and modeResize is ABSOLUTE will copy the current dimensions of§	 * the control to m_sizeX/Y. So the appearance does not change§	 * from the Dialog Editor. size*Min = -1 means: do not make smaller§	 * than in Dialog Template.§	 */§	CPaneBase item(UINT nID, layResizeMode modeResize = GREEDY, int sizeX =0, int sizeY =0, int sizeXMin =-1, int sizeYMin =-1);§	CPaneBase item(CWnd* pWnd, layResizeMode modeResize = GREEDY, int sizeX =0, int sizeY =0, int sizeXMin =-1, int sizeYMin =-1);§§§	/**§	 * Add a whitespace Item (paneNull) of variable size with§	 * a minimum size of 0§	 */§	CPaneBase itemGrowing(layOrientation orientation);§§	/**§	 * Add a whitespace Item (paneNull) with fixed size§	 */§	CPaneBase itemFixed(layOrientation orientation, int sizePrimary);§§	/**§	 * Add a whitespace Item (paneNull) of fixed size based on the§	 * current layout (as in the dialog template). Based on the layout§	 * of the pane vertical or horizontal spacing is considered§	 *§	 * First argument is the left (top) item for a HORIZONTAL (VERTICAL) pane§	 */§	CPaneBase itemSpaceBetween( layOrientation orientation, CWnd* pWndFirst, CWnd* pWndSecond );§	CPaneBase itemSpaceBetween( layOrientation orientation, UINT nIDFirst, UINT nIDSecond );§§	/**§	 * Add a whitespace Item (paneNull) of fixed size based on the§	 * size of another item§	 */§	CPaneBase itemSpaceLike( layOrientation orientation, CWnd* pWnd );§	CPaneBase itemSpaceLike( layOrientation orientation, UINT nID );§§protected:§	/**§	 * This holds the root pane. Fill in InitDialog()§	 */§	CPane m_RootPane;§§	/**§ 	 * Create a root pane§	 */§	CPane CreateRoot(layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0 )§	{§		if(m_RootPane.IsValid())§		{§			// free old root§			m_RootPane = 0;§		}§		m_RootPane = new Pane( this, orientation, sizeBorder, sizeExtraBorder);§		return m_RootPane;§	}§§	/**§	 * Key in Registry where to store Size§	 */§	CString m_strRegStore;§§	/**§	 * Borders around root§	 */§	CSize	m_sizeRootBorders;§};§§inline ETSLayoutMgr::layResizeMode operator|(const ETSLayoutMgr::layResizeMode m1, §											 const ETSLayoutMgr::layResizeMode m2)§	{ return (ETSLayoutMgr::layResizeMode)( (DWORD)m1|(DWORD)m2); }§§§/**§ * Base class for the Layout function. Derive your own class§ * from this or derive it from CDialog and modify _all_§ * references to CDialog to ETSLayoutDialog§ */§class ETSGUI_EXT_CLASS ETSLayoutDialog : public ETSLayout::CBaseDialog, protected ETSLayoutMgr§{§// Construction§public:§	ETSLayoutDialog(UINT nID, CWnd* pParent = NULL, LPCTSTR strName = NULL, bool bGripper = true);   // standard constructor§§// Dialog Data§	//{{AFX_DATA(ETSLayoutDialog)§	//}}AFX_DATA§§§// Overrides§	// ClassWizard generated virtual function overrides§	//{{AFX_VIRTUAL(ETSLayoutDialog)§	//}}AFX_VIRTUAL§§// Implementation§protected:§	// Generated message map functions§	//{{AFX_MSG(ETSLayoutDialog)§	afx_msg void OnSize(UINT nType, int cx, int cy);§	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);§	afx_msg BOOL OnEraseBkgnd(CDC* pDC);§	virtual BOOL OnInitDialog();§	afx_msg void OnDestroy();§	//}}AFX_MSG§	DECLARE_MESSAGE_MAP()§§	virtual CRect GetRect();§§	bool		m_bGripper;§	CStatusBar	m_StatusBar;§};§§§/**§ * Base class for the Layout function. Derive your own class§ * from this or derive it from CDialog and modify _all_§ * references to CFormView to ETSLayoutFormView§ */§class ETSGUI_EXT_CLASS ETSLayoutFormView : public ETSLayout::CBaseFormView, public ETSLayoutMgr§{§// Construction§	DECLARE_DYNAMIC(ETSLayoutFormView)§public:§	ETSLayoutFormView(UINT nID, LPCTSTR strName = NULL);   // standard constructor§	virtual ~ETSLayoutFormView();§§//	virtual void UpdateLayout();§§§// Overrides§	// ClassWizard generated virtual function overrides§	//{{AFX_VIRTUAL(ETSLayoutDialog)§	//}}AFX_VIRTUAL§§// Implementation§protected:§§	// Generated message map functions§	//{{AFX_MSG(ETSLayoutDialog)§	afx_msg void OnSize(UINT nType, int cx, int cy);§	afx_msg BOOL OnEraseBkgnd(CDC* pDC);§	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);§	//}}AFX_MSG§	DECLARE_MESSAGE_MAP()§};§§§/**§ * Base class for the Layout function. Derive your own class§ * from this or derive it from CBCGDialogBar/CDialogBar and § * modify _all_  references to CBCGDialogBar/CDialogBar to § * ETSLayoutDialogBar§ */§class ETSGUI_EXT_CLASS ETSLayoutDialogBar : public ETSLayout::CBaseDialogBar, protected ETSLayoutMgr§{§// Construction§public:§#ifdef CS_HELP§	ETSLayoutDialogBar(UINT nID);§#else§	ETSLayoutDialogBar();§#endif§§§// Overrides§	// ClassWizard generated virtual function overrides§	//{{AFX_VIRTUAL(ETSLayoutDialogBar)§	virtual CSize CalcDynamicLayout(int nLength, DWORD dwMode);§	//}}AFX_VIRTUAL§§	/**§	 * Override this to define Layout§	 */§	virtual BOOL Initialize() { return false; };§	virtual void UpdateLayout();§§// Implementation§protected:§	// Generated message map functions§	//{{AFX_MSG(ETSLayoutDialogBar)§	afx_msg void OnSize(UINT nType, int cx, int cy);§	afx_msg void OnDestroy();§	afx_msg BOOL OnEraseBkgnd(CDC* pDC);§	//}}AFX_MSG§	LRESULT OnInitDialog(WPARAM, LPARAM);§	DECLARE_MESSAGE_MAP()§§	virtual CRect GetRect();§	bool	m_bInitialized;§};§§§§/**************************************************§ ** ! the code is only tested for modal sheets ! **§ **************************************************/§§§/**§ * Resizable PropertySheet. Use this class standalone§ * or as your base class (instead CProptertySheet)§ */§class ETSGUI_EXT_CLASS ETSLayoutPropertySheet : public CPropertySheet, protected ETSLayoutMgr§{§	DECLARE_DYNAMIC(ETSLayoutPropertySheet)§§// Construction§public:§	ETSLayoutPropertySheet(UINT nIDCaption, CWnd *pParentWnd = NULL, UINT iSelectPage = 0, LPCTSTR strName=NULL, bool bGripper=true);§	ETSLayoutPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd = NULL, UINT iSelectPage = 0, LPCTSTR strName=NULL, bool bGripper=true);§§// Operationen§public:§	void	SetAutoDestroy()		{ m_bAutoDestroy = true; }§	void	SetAutoDestroyPages()	{ m_bAutoDestroyPages = true; }§	void	ModelessWithButtons()	{ m_bModelessButtons = true; }§// Overrides§    virtual void AddMainArea(CPane paneRoot, CPaneBase itemTab);§    virtual void AddButtons(CPane paneBottom);§    §	// ClassWizard generated virtual function overrides§	//{{AFX_VIRTUAL(ETSLayoutPropertySheet)§	public:§	virtual BOOL OnInitDialog();§	virtual void PostNcDestroy();§	//}}AFX_VIRTUAL§§// Implementation§public:§	virtual ~ETSLayoutPropertySheet();§§	// Generated message map functions§protected:§	//{{AFX_MSG(ETSLayoutPropertySheet)§	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);§	afx_msg void OnSize(UINT nType, int cx, int cy);§	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);§	afx_msg void OnDestroy();§	afx_msg BOOL OnEraseBkgnd(CDC* pDC);§	//}}AFX_MSG§	DECLARE_MESSAGE_MAP()§§	void Resize(int cx, int cy);§§friend class ETSLayoutPropertyPage;§§	void		Init(LPCTSTR strName, bool bGripper);§	CRect		m_rcStart;§	CRect		m_rcPage;§	bool		m_bGripper;§	CStatusBar	m_StatusBar;§	CPaneBase	m_ItemTab;§	bool		m_bAutoDestroy;§	bool		m_bAutoDestroyPages;§	bool		m_bModelessButtons;§};§§/**§ * Base class for the Layout function. Derive your own class§ * from this or derive it from CPropertyPage and § * modify _all_  references to CPropertyPage to § * ETSLayoutPropertyPage§ */§class ETSGUI_EXT_CLASS ETSLayoutPropertyPage : public ETSLayout::CBasePropertyPage, protected ETSLayoutMgr§{§friend class ETSLayoutPropertySheet;§§	DECLARE_DYNCREATE(ETSLayoutPropertyPage)§§// Konstruktion§public:§	ETSLayoutPropertyPage( );§	ETSLayoutPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0 );§	ETSLayoutPropertyPage( LPCTSTR lpszTemplateName, UINT nIDCaption = 0 );§§	~ETSLayoutPropertyPage();§§§// Overrides§	// ClassWizard generated virtual function overrides§	//{{AFX_VIRTUAL(ETSLayoutPropertyPage)§	public:§	virtual BOOL OnSetActive();§	//}}AFX_VIRTUAL§§// Implementation§protected:§	// Generated message map functions§	//{{AFX_MSG(ETSLayoutPropertyPage)§	afx_msg void OnSize(UINT nType, int cx, int cy);§	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);§	virtual BOOL OnInitDialog();§	afx_msg BOOL OnEraseBkgnd(CDC* pDC);§	afx_msg void OnWindowPosChanging( WINDOWPOS* lpwndpos );§	afx_msg void OnDestroy();§	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);§	//}}AFX_MSG§	DECLARE_MESSAGE_MAP()§§	virtual CRect GetRect();§	bool m_bLockMove;§	bool m_bResetBuddyOnNextTimeVisible;§};§//#UC END# *46A88BDA035B_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659776435"))
	    quid       	"46A88BDA035B"
	    documentation 	"Ì‡·Ó ÍÎ‡ÒÒÓ‚ Ë ÍÓÌÚÓÎÓ‚ ‰Îˇ ÔÓ‰‰ÂÊÍË ÂÒ‡ÈÁ‡"
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator")
	(object Class "CPPToolTip"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CPPToolTip.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CPPToolTip.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B6AC00CB_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB_CUSTOM_INCLUDES*§#define TIMER_HIDE		0x101 //the identifier of the timer for hide the tooltip§#define TIMER_SHOWING	0x102 //the identifier of the timer for tooltip's fade in§#define TIMER_SHOW		0x100 //the identifier of the timer for show the tooltip§#define TIMER_HIDING	0x103 //the identifier of the timer for tooltip's fade out§#define TIMER_ANIMATION 0x104 //the identifier of the timer for animation§§#define PERCENT_STEP_FADEIN		20 //How mush percent will adding during fade in§#define PERCENT_STEP_FADEOUT	20 //How mush percent will adding during fade out§#define PERCENT_MAX_TRANSPARENCY 100 //How mush percent by maximum transparency§#define PERCENT_MIN_TRANSPARENCY 0 //How mush percent by minimum transparency§§#define MAX_LENGTH_DEBUG_STRING 25 //§//#UC END# *4700B6AC00CB_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B6AC00CB*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB*§//////////////////§// Note that windows are enumerated in top-down Z-order, so the menu§// window should always be the first one found.§//§static BOOL CALLBACK MyEnumProc(HWND hwnd, LPARAM lParam)§{§	TCHAR buf[16];§	GetClassName(hwnd, buf, sizeof(buf) / sizeof(TCHAR));§	if (_tcscmp(buf, _T("#32768")) == 0)  // special classname for menus§	{§		*((HWND*)lParam) = hwnd;	 // found it§		return FALSE;§	}§	return TRUE;§}§§/////////////////////////////////////////////////////////////////////////////§// CPPToolTip§§CPPToolTip::CPPToolTip()§{§	// Default values§	m_dwTimeAutoPop = 5000;§	m_dwTimeInitial = 500;§	m_dwTimeFadeIn = 500;§	m_dwTimeFadeOut = 500;§	m_dwBehaviour = 0; //PPTOOLTIP_CLOSE_LEAVEWND | PPTOOLTIP_NOCLOSE_OVER;	 //The tooltip's behaviour§	m_dwEffectBk = 0;§	m_dwDirection = 0;§	m_dwStyles = 0;§	m_nGranularity = 0;§	m_nTransparency = 0;§	m_bDelayNextTool = FALSE;§	m_dwShowEffect = SHOWEFFECT_FADEINOUT;§	m_dwHideEffect = SHOWEFFECT_FADEINOUT;§§	m_nTooltipState = PPTOOLTIP_STATE_HIDEN;§	m_nTooltipType = PPTOOLTIP_NORMAL;§	m_nNextTooltipType = PPTOOLTIP_NORMAL;§§	m_ptOriginal.x = m_ptOriginal.y = 0;§§	m_rcCurTool.SetRectEmpty();§§	m_hwndDisplayedTool = NULL;§	m_last_dynamic_tool = 0;§	m_next_dynamic_tool = 0;§§	m_hBitmapBk = NULL;§	m_hUnderTooltipBk = NULL;§§	m_hbrBorder = NULL;§	m_hrgnTooltip = NULL;§§	SetColorBk(::GetSysColor(COLOR_INFOBK));§	SetBorder(::GetSysColor(COLOR_INFOTEXT));§	EnableHyperlink();§	SetNotify(FALSE);§	SetDefaultSizes();§	SetDirection();§	SetBehaviour();§	SetDebugMode(FALSE);§	SetMaxTipWidth(0);§//	EnableTextWrap(FALSE);§	SetDelayTime(PPTOOLTIP_TIME_INITIAL, 500);§	SetDelayTime(PPTOOLTIP_TIME_AUTOPOP, 5000);§	SetDelayTime(PPTOOLTIP_TIME_FADEIN, 0);§	SetDelayTime(PPTOOLTIP_TIME_FADEOUT, 0);§	SetTooltipShadow(6, 6);§§#ifdef PPTOOLTIP_USE_MENU§	MenuToolPosition();§#endif //PPTOOLTIP_USE_MENU§	§	// Register the window class if it has not already been registered.§	WNDCLASS wndcls;§	HINSTANCE hInst = AfxGetInstanceHandle();§	if(!(::GetClassInfo(hInst, PPTOOLTIP_CLASSNAME, &wndcls)))§	{§		// otherwise we need to register a new class§		wndcls.style			= CS_SAVEBITS;§		wndcls.lpfnWndProc		= ::DefWindowProc;§		wndcls.cbClsExtra		= wndcls.cbWndExtra = 0;§		wndcls.hInstance		= hInst;§		wndcls.hIcon			= NULL;§		wndcls.hCursor			= LoadCursor(hInst, IDC_ARROW);§		wndcls.hbrBackground	= NULL;§		wndcls.lpszMenuName		= NULL;§		wndcls.lpszClassName	= PPTOOLTIP_CLASSNAME;§		§		if (!AfxRegisterClass(&wndcls))§			AfxThrowResourceException();§	} //if§}§§BEGIN_MESSAGE_MAP(CPPToolTip, CWnd)§	//{{AFX_MSG_MAP(CPPToolTip)§	ON_WM_PAINT()§	ON_WM_TIMER()§	ON_WM_SETCURSOR()§	ON_WM_ACTIVATEAPP()§	//}}AFX_MSG_MAP§	ON_MESSAGE(UDM_TOOLTIP_REPAINT, OnRepaintWindow)§END_MESSAGE_MAP()§§§/////////////////////////////////////////////////////////////////////////////§// CPPToolTip message handlers§BOOL CPPToolTip::Create(CWnd* pParentWnd, BOOL bBalloon /* = TRUE */) §{§	TRACE(_T("CPPToolTip::Create\n"));§	§	ASSERT_VALID(pParentWnd);§	§	DWORD dwStyle = WS_POPUP; §	DWORD dwExStyle = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;§	m_hParentWnd = pParentWnd->GetSafeHwnd();§	§	if (!CreateEx(dwExStyle, PPTOOLTIP_CLASSNAME, NULL, dwStyle, 0, 0, 0, 0, pParentWnd->GetSafeHwnd(), NULL, NULL))§		return FALSE;§§	//§	SetDefaultSizes(bBalloon);§	m_drawer.SetCallbackRepaint(this->GetSafeHwnd(), UDM_TOOLTIP_REPAINT);§	SetDelayTime(PPTOOLTIP_TIME_ANIMATION, 100);§§	return TRUE;§} //End of Create§§BOOL CPPToolTip::DestroyWindow() §{§	Pop();§	SetDelayTime(PPTOOLTIP_TIME_ANIMATION, 0);§	return CWnd::DestroyWindow();§} //End of DestroyWindow§§/////////////////////////////////////////////////////////////////////§//		A tooltip with PPTOOLTIP_DISABLE_AUTOPOP behaviour don't hide on §//	change active application§//-------------------------------------------------------------------§// Fixed by vanhoopy (July 10, 2003)§/////////////////////////////////////////////////////////////////////§#if _MSC_VER < 1300§void CPPToolTip::OnActivateApp(BOOL bActive, HTASK hTask)§#else§void CPPToolTip::OnActivateApp(BOOL bActive, DWORD hTask)§#endif //_MSC_VER§{§	CWnd::OnActivateApp(bActive, hTask);§	§	if (!bActive) §		Pop();§} //End of the WM_ACTIVATEAPP handler§§LRESULT CPPToolTip::SendNotify(LPPOINT pt, PPTOOLTIP_INFO & ti) §{ §	TRACE(_T("CPPToolTip::SendNotify()\n")); §	// Make sure this is a valid window  §	if (!IsWindow(GetSafeHwnd())) §		return 0L; §	// See if the user wants to be notified  §	if (!IsNotify()) §		return 0L; §	§	NM_PPTOOLTIP_DISPLAY lpnm; §	lpnm.hwndTool = m_hwndNextTool;§	lpnm.pt = pt;  §	lpnm.ti = &ti; §	lpnm.hdr.hwndFrom = m_hWnd; §	lpnm.hdr.idFrom   = GetDlgCtrlID(); §	lpnm.hdr.code     = UDM_TOOLTIP_DISPLAY; §	§	::SendMessage(m_hNotifyWnd, WM_NOTIFY, lpnm.hdr.idFrom, (LPARAM)&lpnm);  §§	return 0L;§} //End of SendNotify§§/////////////////////////////////////////////////////////////////////§// CPPToolTip::IsNotify()§//		This function determines will be send the notification messages from §//	the control or not before display.§//-------------------------------------------------------------------§// Return value:§//	TRUE if the control will be notified the specified window§///////////////////////////////////////////////////////////////////////§BOOL CPPToolTip::IsNotify()§{§	TRACE(_T("CPPToolTip::IsNotify\n"));§	§	return (BOOL)(m_hNotifyWnd != NULL);§}  //End of IsNotify§§BOOL CPPToolTip::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) §{§	CPoint ptClient;§	::GetCursorPos(&ptClient);§	ScreenToClient(&ptClient);§	TRACE (_T("CPPToolTip::OnSetCursor(x=%d, y=%d)\n"), ptClient.x, ptClient.y);§	if (m_drawer.OnSetCursor(&ptClient))§		return TRUE; //The cursor over the hyperlink§	§	::SetCursor(::LoadCursor(NULL, IDC_ARROW));§§//	return CWnd::OnSetCursor(pWnd, nHitTest, message);§	return TRUE;§} //End of the WM_SETCURSOR handler§§LRESULT CPPToolTip::OnRepaintWindow(WPARAM wParam, LPARAM lParam)§{§	TRACE (_T("CPPToolTip::OnRepaintWindow()\n"));§	if (m_bHyperlinkEnabled)§	{§		//Window's repaint enabled§		CDC * pDC = GetDC();§		OnRedrawTooltip(pDC->GetSafeHdc(), m_dwCurTransparency);§		ReleaseDC(pDC);§	}§    return TRUE;§} //End of the UDM_TOOLTIP_REPAINT handler§§void CPPToolTip::OnDrawBorder(HDC hDC, HRGN hRgn)§{§	ASSERT (hDC);§	ASSERT (hRgn);§§	::FrameRgn(hDC, hRgn, m_hbrBorder, m_szBorder.cx, m_szBorder.cy);§} //End OnDrawBorder§§////////////////////////////////////////////////////////////////////////§//§//      +-----------------+    +-------------------+   +-----------------+  §//   +->|     Screen      +--->| m_hUnderTooltipBk |   |   m_hBitmapBk   |§//   |  +--------+--------+    +-------------------+   +--------+--------+§//   |           |                                            |§//   |  +--------V--------+                          +--------V--------+§//   |  |                 |     +--------------+     |                 |§//   |  |                 |     |   DrawHTML   |---->|                 |§//   |  |                 |     +--------------+     |                 |§//   |  |                 |                          |     MemDC       |§//   |  |                 |     +--------------+     |                 |§//   |  |                 |     | OnDrawBorder |---->|                 |§//   |  |     TempDC      |     +--------------+     +--------+--------+§//   |  |                 |                                   |         §//   |  |                 |     +--------------+              |         §//   |  |                 |<----+  DrawShadow  |              |         §//   |  |                 |     +--------------+              |         §//   |  |                 |                                   |         §//   |  |                 |<--------ALPHA---------------------+         §//   |  |                 |§//   |  +--------+--------+§//   |           |          §//   +-----------+§//§////////////////////////////////////////////////////////////////////////§void CPPToolTip::OnRedrawTooltip(HDC hDC, BYTE nTransparency /* = 0 */)§{§	TRACE (_T("CPPToolTip::OnRedrawTooltip(Transparency = %d)\n"), nTransparency);§§	//ENG: If a transparency more then max value§	//RUS: ≈ÒÎË ÁÌ‡˜ÂÌËÂ ÔÓÁ‡˜ÌÓÒÚË ·ÓÎ¸¯Â Ï‡ÍÒËÏ‡Î¸ÌÓ ‰ÓÔÛÒÚËÏÓ„Ó§	if (nTransparency > PERCENT_MAX_TRANSPARENCY)§		nTransparency = PERCENT_MAX_TRANSPARENCY;§§	//ENG: If device context not passed§	//RUS: ≈ÒÎË ÍÓÌÚÂÍÒÚ ÛÒÚÓÈÒÚ‚‡ ÌÂ ÔÂÂ‰‡‚‡ÎÒˇ, ÚÓ ÔÓÎÛ˜‡ÂÏ Â„Ó Ë ÛÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÔËÁÌ‡Í ‡‚ÚÓÏ‡ÚË˜ÂÒÍÓ„Ó Û‰‡ÎÂÌËˇ§	BOOL bAutoReleaseDC = FALSE;§	if (NULL == hDC)§	{§		hDC = ::GetDC(this->GetSafeHwnd());§		bAutoReleaseDC = TRUE;§	} //if§§	//ENG: Creates memory context§	//RUS: —ÓÁ‰‡ÂÏ ÍÓÌÚÂÍÒÚ ÛÒÚÓÈÒÚ‚‡ ‚ Ô‡ÏˇÚË§	HDC hMemDC = ::CreateCompatibleDC(hDC);§	HDC hBkDC = ::CreateCompatibleDC(hDC);§	HDC hTempDC = ::CreateCompatibleDC(hDC);§	HBITMAP hOldBkBitmap = (HBITMAP)::SelectObject(hBkDC, m_hBitmapBk);§	HBITMAP hBitmap = ::CreateCompatibleBitmap(hDC, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());§	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hMemDC, hBitmap);§	HBITMAP hTempBitmap = ::CreateCompatibleBitmap(hDC, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());§	HBITMAP hOldTempBitmap = (HBITMAP)::SelectObject(hTempDC, hTempBitmap);§§	//ENG: Gets the rectangle of the tooltip without a shadow§	//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ ÚÛÎÚËÔ‡ ·ÂÁ ÚÂÌË§	CRect rect = m_rcBoundsTooltip;§	rect.DeflateRect(0, 0, m_szOffsetShadow.cx, m_szOffsetShadow.cy);§	§	//ENG: Copy background to the temporary bitmap§	//RUS:  ÓÔËÛÂÏ ÙÓÌ ÔÓ‰ ÚÛÎÚËÔÓÏ ‚ Ô‡ÏˇÚ¸§	::BitBlt(hMemDC, 0, 0, rect.Width(), rect.Height(),§		hBkDC, 0, 0, SRCCOPY);§	§	//ENG: Draw HTML string§	//RUS: ŒÚÓ·‡Ê‡ÂÏ HTML ÒÚÓÍÛ§	m_drawer.DrawPreparedOutput(hMemDC, &m_rcTipArea);§§	//ENG: Gets a region of a window§	//RUS: œÓÎÛ˜‡ÂÏ Â„ËÓÌ ÓÍÌ‡§//	HRGN hrgn = ::CreateRectRgn(0, 0, 0, 0);§//	GetWindowRgn(hrgn);§§	//ENG: Draw border of the tooltip§	//RUS: ŒÚÓ·‡Ê‡ÂÏ ÍÓÌÚÛ ÚÛÎÚËÔ‡§	if ((NULL != m_hbrBorder) && (m_szBorder.cx) && (m_szBorder.cy))§		OnDrawBorder(hMemDC, m_hrgnTooltip);§§	if (NULL == m_hUnderTooltipBk)§	{§		//ENG: Stores a background under the tooltip to a bitmap§		//RUS: —Óı‡ÌˇÂÏ ÙÓÌ ÔÓ‰ ÚÛÎÚËÔÓÏ ‚ ·ËÚÏ‡Ô§		m_hUnderTooltipBk = ::CreateCompatibleBitmap(hDC, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());§		::SelectObject(hBkDC, m_hUnderTooltipBk);§		::BitBlt(hBkDC, 0, 0, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height(),§				 hDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, SRCCOPY);§	}§	else§	{§		//ENG: Restores a background from a bitmap§		//RUS: ¬ÓÒÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÙÓÌ ËÁ ·ËÚÏ‡Ô‡§		::SelectObject(hBkDC, m_hUnderTooltipBk);§	} //if§§	//ENG: Copy a original background bitmap to the temporary DC§	//RUS:  ÓÔËÛÂÏ ÓË„ËÌ‡Î¸Ì˚È ·ËÚÏ‡Ô ‚Ó ‚ÂÏÂÌÌ˚È ÍÓÌÚÂÍÒÚ Ô‡ÏˇÚË§	::BitBlt(hTempDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height(),§		hBkDC, 0, 0, SRCCOPY);§§	//ENG: Draws a shadow§	//RUS: ¬˚‚Ó‰ËÏ ÚÂÌ¸§	if (m_szOffsetShadow.cx || m_szOffsetShadow.cy)§	{§		//ENG: Creates a mask of the tooltip for shadow§		//RUS: —ÓÁ‰‡ÂÏ Ï‡ÒÍÛ ÚÛÎÚËÔ‡ ‰Îˇ ‚˚‚Ó‰‡ ÚÂÌË§		HBITMAP hMask = ::CreateCompatibleBitmap(hDC, rect.Width(), rect.Height());§		HDC hMaskDC = ::CreateCompatibleDC(hDC);§		//ENG: Creates a mask of the tooltip§		//RUS: —ÓÁ‰‡ÌËÂ Ï‡ÒÍË ÚÛÎÚËÔ‡§		BYTE nColor = LOBYTE(::MulDiv(255, 100 - m_nDarkenShadow, 100));§		nColor += ((255 - nColor) * nTransparency) / 100;§		HBRUSH hBrush = ::CreateSolidBrush(RGB(nColor, nColor, nColor));§		HBITMAP hOldMask = (HBITMAP)::SelectObject(hMaskDC, hMask);§		::BitBlt(hMaskDC, 0, 0, rect.Width(), rect.Height(), NULL, 0, 0, WHITENESS);§		::FillRgn(hMaskDC, m_hrgnTooltip, hBrush);§		::DeleteObject(hBrush);§		::SelectObject(hMaskDC, hOldMask);§		::DeleteDC(hMaskDC);§		§		//HBITMAP hTempBmp = m_drawer.GetDrawManager()->CreateImageEffect(m_hTooltipMask, rect.Width(), rect.Height(), IMAGE_EFFECT_LIGHTEN, )§		m_drawer.GetDrawManager()->DrawShadow(hTempDC, §											  m_szOffsetShadow.cx, §											  m_szOffsetShadow.cy,§										      rect.Width(), rect.Height(), hMask,§			   							      m_bGradientShadow, §											  m_szDepthShadow.cx, m_szDepthShadow.cy);§		::DeleteObject(hMask);§	} //if§§	//ENG: Merges a tooltip on with the client area §	//RUS: Õ‡ÍÎ‡‰˚‚‡ÂÏ ÚÛÎÚËÔ Ì‡ ÍÎËÂÌÚÒÍÛ˛ ˜‡ÒÚ¸ Ò ‡Î¸Ù‡-Ì‡ÎÓÊÂÌËÂÏ§	::SelectClipRgn(hTempDC, m_hrgnTooltip);§	m_drawer.GetDrawManager()->AlphaBitBlt(hTempDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top,§											rect.Width(), rect.Height(),§											hMemDC, 0, 0, 100 - nTransparency);§	::SelectClipRgn(hTempDC, NULL);§§	//ENG: Output a tooltip to the screen§	//RUS: ¬˚‚Ó‰ËÏ ÚÛÎÚËÔ Ì‡ ˝Í‡Ì§	::BitBlt(hDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top,§		m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height(),§		hTempDC, 0, 0, SRCCOPY);§	§	//ENG: Free resources§	//RUS: ŒÒ‚Ó·ÓÊ‰‡ÂÏ Á‡‰ÂÈÒÚ‚Ó‚‡ÌÌ˚Â ÂÒÛÒ˚§	::SelectObject(hBkDC, hOldBkBitmap);§	::SelectObject(hMemDC, hOldBitmap);§	::SelectObject(hTempDC, hOldTempBitmap);§	::DeleteObject(hBitmap);§	::DeleteObject(hTempBitmap);§	::DeleteDC(hBkDC);§	::DeleteDC(hMemDC);§	::DeleteDC(hTempDC);§§	//ENG: Releases device context if needed§	//RUS: ŒÒ‚Ó·ÓÊ‰‡ÂÏ ÍÓÌÚÂÍÒÚ ÛÒÚÓÈÒÚ‚‡ ÂÒÎË ˝ÚÓ ÌÂÓ·ıÓ‰ËÏÓ§	if (bAutoReleaseDC)§		::ReleaseDC(this->GetSafeHwnd(), hDC);§} //End of OnRedrawWindow§§void CPPToolTip::OnPaint() §{§	TRACE(_T("CPPToolTip::OnPaint()\n"));§	CPaintDC dc(this); // device context for painting§	§	//Copying info about current tool to displayed§	m_hwndDisplayedTool = m_hwndNextTool;§	m_last_dynamic_tool = m_next_dynamic_tool;§	m_tiDisplayed = m_tiNextTool;§	m_nTooltipType = m_nNextTooltipType;§§	OnRedrawTooltip(dc.GetSafeHdc(), m_dwCurTransparency);§} //End of the WM_PAINT handler§§BOOL CPPToolTip::PreTranslateMessage(MSG* pMsg) §{§	RelayEvent(pMsg);§	§	return CWnd::PreTranslateMessage(pMsg);§}§§BOOL CPPToolTip::RelayEvent(MSG* pMsg)§{§	//ENG: Disables a message translation if object was't created (thanks to Stoil Todorov)§	//RUS: «‡ÔÂÚ Ó·‡·ÓÚÍË ÒÓÓ·˘ÂÌËÈ ÂÒÎË Ó·˙ÂÍÚ ÌÂ ÒÓÁ‰‡Ì§	if (NULL == GetSafeHwnd())  §		return FALSE;§§	ASSERT(m_hParentWnd);§§	HWND hWnd = NULL;§	POINT pt;§	CRect rect;§	PPTOOLTIP_INFO ti;§	CString strTemp;§§	switch(pMsg->message)§	{§	case WM_SETFOCUS:§		rect.left = 0;§		break;§	case WM_LBUTTONDOWN:§		TRACE(_T("CPPToolTip::WM_LBUTTONDOWN\n"));§		if (IsCursorOverTooltip())§		{§			//Left Button was pressed over the tooltip§			pt = pMsg->pt;§			ScreenToClient(&pt);§			m_drawer.OnLButtonDown(&pt); //§		} //if§	case WM_LBUTTONDBLCLK:§	case WM_RBUTTONDOWN:§	case WM_RBUTTONDBLCLK:§	case WM_MBUTTONDOWN:§	case WM_MBUTTONDBLCLK:§	case WM_NCLBUTTONDOWN:§	case WM_NCLBUTTONDBLCLK:§	case WM_NCRBUTTONDOWN:§	case WM_NCRBUTTONDBLCLK:§	case WM_NCMBUTTONDOWN:§	case WM_NCMBUTTONDBLCLK:§	case WM_KEYDOWN:§	case WM_SYSKEYDOWN:§	case WM_MOUSEWHEEL:§//		// The user has interrupted the current tool - dismiss it§//		if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_NOCLOSE_MOUSEDOWN))§		Pop();§		break;§	case WM_MOUSEMOVE:§		if ((PPTOOLTIP_HELP == m_nTooltipType) || (PPTOOLTIP_HELP == m_nNextTooltipType))§			return FALSE;§		if ((m_ptOriginal.x != pMsg->pt.x) || (m_ptOriginal.y != pMsg->pt.y))§		{§			// The mouse pointer's position was changed§§			//Initialize values§			rect.SetRectEmpty();§			m_ptOriginal = pt = pMsg->pt;§			::ScreenToClient(m_hParentWnd, &pt);§			if (m_bDebugMode)§			{§				//Debug mode§				ti.sTooltip = GetDebugInfoTool(&pt);§				ti.nMask = 0;§				m_hwndDisplayedTool = NULL;§				SetNewTooltip(this->GetSafeHwnd(), 0, ti);§			}§			else if (IsCursorOverTooltip() && !(m_tiDisplayed.nBehaviour & PPTOOLTIP_TRACKING_MOUSE)) §			{§				OnSetCursor (this, 0, 0);§				//ENG: Mouse over a tooltip and tracking mode was disabled§				//RUS:  ÛÒÓ Ì‡‰ ÚÛÎÚËÔÓÏ ÔË ‚˚ÍÎ˛˜ÂÌÌÓÏ ÂÊËÏÂ "Ú‡ÍËÌ„‡"§				if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_NOCLOSE_OVER))§				{§					//ENG: A tooltip don't hides when mouse over him§					//RUS: ≈ÒÎË ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ ÒÚËÎ¸ ÌÂ Á‡Í˚‚‡ÌËˇ ÚÛÎÚËÔ‡ ÂÒÎË ÍÛÒÓ Ì‡‰ ÌËÏ§					HideTooltip();§				}§				else§				{§					//ENG: Resetup autopop timer§					//RUS: œÂÂÛÒÚ‡Ì‡‚ÎË‚‡ÂÏ Ú‡ÈÏÂ ‡‚ÚÓÁ‡Í˚ÚËˇ ÚÛÎÚËÔ‡§					SetAutoPopTimer();§				} //if§			}§			else§			{§				//ENG: Searching a toolbar's item§				//RUS: »˘ÂÏ ˝ÎÂÏÂÌÚ Ì‡ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§				hWnd = FindToolBarItem(pMsg->pt, ti);§				if (NULL == hWnd)§				{§					//ENG: Searching a hot area of the tooltip§					//RUS: »˘ÂÏ ÔÂ‰ÓÔÂ‰ÂÎÂÌÌÛ˛ „Óˇ˜Û˛ ÁÓÌÛ ÚÛÎÚËÔ‡§					hWnd = FindTool(&pt, ti);§				} //if§				TRACE ("¬ÂÏÂÌÌÓÂ ÓÍÌÓ = 0x%08X\n", hWnd);§				if (NULL == hWnd)§				{§					//Ë˘∏Ï ÒÂ‰Ë ‰ËÌ‡ÏË˜ÂÒÍËı ˝ÎÂÏÂÌÚÓ‚§					CallBackMap::iterator it = m_dynamic_tools.begin ();§					CallBackMap::iterator it_end = m_dynamic_tools.end ();§					DynamicToolID finded_tool = 0;§§					for (; it != it_end && finded_tool == 0; ++it) {§						if (it->second (ti)) {§							finded_tool = it->first;§						}§					}§§					if (finded_tool != 0) {§						if (§							(finded_tool != m_last_dynamic_tool) §							|| (ti.rectBounds != m_tiDisplayed.rectBounds/* m_rcDisplayedTool*/)§						) {§							//ÂÒÎË ÌÓ‚˚È ˝ÎÂÏÂÌÚ§							SetNewTooltip(hWnd, finded_tool, ti);§						} else {§							//˝ÎÂÏÂÌÚ ÌÂ ÔÓÏÂÌˇÎÒˇ§							if (m_tiDisplayed.nBehaviour & PPTOOLTIP_TRACKING_MOUSE) {§								//ENG: If sets tracking mode§								//RUS: ≈ÒÎË ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ "Ú‡ÍËÌ„‡"§								SetAutoPopTimer();§								OutputTooltipOnScreen(&pMsg->pt);§							} else if (§								(finded_tool == m_last_dynamic_tool) && §								!(m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)§							) {§								//ENG: A tooltip must hide at anything mouse move§								//RUS: ≈ÒÎË ‰ÓÎÊÂÌ ÔˇÚ‡Ú¸Òˇ ÔËÎ˛·ÓÏ ‰‚ËÊÂÌËË Ï˚¯Ë§								if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW))§								{§									//ENG: "Multiple show" mode was disabled§									//RUS: ≈ÒÎË ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÏÌÓÊÂÒÚ‚ÂÌÌÓ„Ó ÔÓÍ‡Á‡ ÚÛÎÚËÔ‡§									HideTooltip();§								}§								else§								{§									//ENG: "Multiple show" mode was enabled§									//RUS: ≈ÒÎË ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÏÌÓÊÂÒÚ‚ÂÌÌÓ„Ó ÔÓÍ‡Á‡ ÚÛÎÚËÔ‡§									SetNewTooltip(hWnd, finded_tool, ti);§								} //if§							}§							else§							{§								//ENG: A tooltip don't must when a mouse is over window§								//RUS: “ÛÎÚËÔ ÌÂ ‰ÓÎÊÂÌ ÔˇÚ‡Ú¸Òˇ ÔÓÍ‡ Ì‡ıÓ‰ËÚÒˇ Ì‡‰ ÓÍÌÓÏ§								SetAutoPopTimer();§							} //if§						}§§					} else {§						//ENG: An item with a tooltip wasn't found§						//RUS: ÕË Ó‰ËÌ ˝ÎÂÏÂÌÚ, ÓÚÓ·‡Ê‡˛˘ËÈ ÚÛÎÚËÔ, ÌÂ Ì‡È‰ÂÌ§						m_hwndDisplayedTool = NULL;§§						m_last_dynamic_tool = 0;§§						m_tiDisplayed.rectBounds.SetRectEmpty();§						KillTimer(TIMER_SHOW);§						HideTooltip();§					}§				}§				else §				{§					if ((hWnd != m_hwndDisplayedTool) || (ti.rectBounds != m_tiDisplayed.rectBounds/* m_rcDisplayedTool*/))§					{§						//ENG: Sets new tooltip for the new window or for the new window's item§						//RUS: ≈ÒÎË ÌÓ‚ÓÂ ÓÍÌÓ ËÎË ÌÓ‚˚È ˝ÎÂÏÂÌÚ ÓÍÌ‡, ÚÓ ÛÒÚ‡ÌÓ‚ËÚ¸ ÌÓ‚˚È ÚÛÎÚËÔ§						SetNewTooltip(hWnd, 0, ti);§					}§					else§					{§						//ENG: Nothing was changed§						//RUS: ≈ÒÎË ÌË ÓÍÌÓ, ÌË ˝ÎÂÏÂÌÚ ÓÍÌ‡ ÌÂ ËÁÏÂÌˇÎËÒ¸§						if (m_tiDisplayed.nBehaviour & PPTOOLTIP_TRACKING_MOUSE)§						{§							//ENG: If sets tracking mode§							//RUS: ≈ÒÎË ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ "Ú‡ÍËÌ„‡"§							SetAutoPopTimer();§							OutputTooltipOnScreen(&pMsg->pt);§						}§						else if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_CLOSE_LEAVEWND))§						{§							//ENG: A tooltip must hide at anything mouse move§							//RUS: ≈ÒÎË ‰ÓÎÊÂÌ ÔˇÚ‡Ú¸Òˇ ÔËÎ˛·ÓÏ ‰‚ËÊÂÌËË Ï˚¯Ë§							if ((hWnd == m_hwndDisplayedTool) && §								!(m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW))§							{§								//ENG: "Multiple show" mode was disabled§								//RUS: ≈ÒÎË ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÏÌÓÊÂÒÚ‚ÂÌÌÓ„Ó ÔÓÍ‡Á‡ ÚÛÎÚËÔ‡§								HideTooltip();§							}§							else§							{§								//ENG: "Multiple show" mode was enabled§								//RUS: ≈ÒÎË ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÏÌÓÊÂÒÚ‚ÂÌÌÓ„Ó ÔÓÍ‡Á‡ ÚÛÎÚËÔ‡§								SetNewTooltip(hWnd, 0, ti);§							} //if§						}§						else§						{§							//ENG: A tooltip don't must when a mouse is over window§							//RUS: “ÛÎÚËÔ ÌÂ ‰ÓÎÊÂÌ ÔˇÚ‡Ú¸Òˇ ÔÓÍ‡ Ì‡ıÓ‰ËÚÒˇ Ì‡‰ ÓÍÌÓÏ§							SetAutoPopTimer();§						} //if§					} //if§				} //if§			} //if§		} //if§		break;§	} //switch§§	return FALSE;§} //End RelayEvent§§void CPPToolTip::SetNewTooltip(HWND hWnd, DynamicToolID toolID, const PPTOOLTIP_INFO & ti, BOOL bDisplayWithDelay /* = TRUE */, TooltipType type /* = PPTOOLTIP_NORMAL */)§{§	TRACE (_T("CPPToolTip::SetNewTooltip(hWnd=0x%08X, CRect(left=%d, top=%d, right=%d, bottom=%d), nID=%d)\n"), §		hWnd, ti.rectBounds.left, ti.rectBounds.top, ti.rectBounds.right, ti.rectBounds.bottom, ti.nIDTool);§	§	m_bNextToolExist = FALSE;§§	//ENG: Hides a tooltip§	//RUS: œˇ˜ÂÏ ÚÛÎÚËÔ ÂÒÎË ÓÌ ÔÓÍ‡Á‡Ì ËÎË ÔÓÍ‡Á˚‚‡ÂÚÒˇ§	if ((PPTOOLTIP_STATE_SHOWING == m_nTooltipState) || §		(PPTOOLTIP_STATE_SHOWN == m_nTooltipState))§		HideTooltip();§§	//ENG: If a tooltip wasn't hidden§	//RUS: ≈ÒÎË ÚÛÎÚËÔ Â˘Â ÌÂ ÒÔˇÚ‡Ì, Ê‰ÂÏ ...§	m_nNextTooltipType = type;§	m_hwndNextTool = hWnd;§	m_next_dynamic_tool = toolID;§	m_tiNextTool = ti;§	if (PPTOOLTIP_STATE_HIDEN != m_nTooltipState)§	{§		TRACE(_T("SetNewTooltip2(%d)\n"), m_nNextTooltipType);§		m_bNextToolExist = TRUE;§		if (bDisplayWithDelay && m_dwTimeInitial)§			m_bDelayNextTool = TRUE;§		else §			m_bDelayNextTool = FALSE;§		return;§	} //if§§	//ENG: Start the show timer§	//RUS: Õ‡˜ËÌ‡ÂÏ ÔÓÍ‡Á ÌÓ‚Ó„Ó ÚÛÎÚËÔ‡§	if (bDisplayWithDelay && m_dwTimeInitial)§		SetTimer(TIMER_SHOW, m_dwTimeInitial, NULL);§	else§		OnTimer(TIMER_SHOW);§} //End of SetNewTooltip§§void CPPToolTip::OnTimer(UINT nIDEvent) §{§	POINT pt;§	switch (nIDEvent)§	{§	case TIMER_SHOW:§		TRACE(_T("OnTimerShow(%d)\n"), m_nNextTooltipType);§		//ENG: Kill SHOW timer §		//RUS: ”·ËÚ¸ Ú‡ÈÏÂ ÓÊË‰‡ÌËˇ ÔÓÍ‡Á‡ ÚÛÎÚËÔ‡§		KillTimer(TIMER_SHOW);§		//ENG: Get current mouse coordinates§		//RUS: œÓÎÛ˜ËÚ¸ ÚÂÍÛ˘ÂÂ ÔÓÎÓÊÂÌËÂ ÚÛÎÚËÔ‡§		if ((PPTOOLTIP_HELP == m_nNextTooltipType) || §			(PPTOOLTIP_MENU == m_nNextTooltipType))§			pt = m_ptOriginal;§		else GetCursorPos(&pt);§§		if ((pt.x != m_ptOriginal.x) || (pt.y != m_ptOriginal.y))§		{§			//ENG: If mouse coordinates was changed§			//RUS: ≈ÒÎË ÍÛÒÓ Ò‰‚ËÌÛÎÒˇ, ÚÓ ÛÌË˜ÚÓÊËÚ¸ ÚÛÎÚËÔ§			TRACE(_T("OnTimerShow(HideTooltip)\n"));§			HideTooltip();§		}§		else if (PPTOOLTIP_STATE_HIDEN == m_nTooltipState)§		{§			TRACE(_T("OnTimerShow(Showing)\n"));§			m_nTooltipState = PPTOOLTIP_STATE_SHOWING;§			//Display first step§			PrepareDisplayTooltip(&m_ptOriginal);§			§			//Fade In effect§			if ((SHOWEFFECT_FADEINOUT == m_dwShowEffect) && m_dwTimeFadeIn)§			{§				TRACE(_T("OnTimerShow(FadeIn)\n"));§				SetTimer(TIMER_SHOWING, m_dwTimeFadeIn, NULL); //Fade in showing was enabled§			}§			else§			{§				TRACE(_T("OnTimerShow(Shown)\n"));§				m_nTooltipState = PPTOOLTIP_STATE_SHOWN; //Tooltip is already show§				if (m_dwTimeAutoPop && !(m_tiNextTool.nBehaviour & PPTOOLTIP_DISABLE_AUTOPOP))§					SetTimer(TIMER_HIDE, m_dwTimeAutoPop, NULL); //Hiding by timer was enabled§			} //if§		} //if§		break;§	case TIMER_SHOWING:§		TRACE(_T("OnTimerFadeIn(Current Transparency=%d )\n"), m_dwCurTransparency);§		//ENG: If fade-in effect was finished then sets minimum transparency§		//RUS: ≈ÒÎË ¯‡„Ë ˝ÙÙÂÍÚ‡ ÔÎ‡‚ÌÓ„Ó ÔÓÍ‡Á‡ ËÒ˜ÂÔ‡Ì˚, ÚÓ ÛÒÚ‡ÌÓ‚ËÚ¸ ÏËÌËÏ‡Î¸ÌÛ˛ ÔÓÁ‡˜ÌÓÒÚ¸§		if (m_dwCurTransparency > (PERCENT_MIN_TRANSPARENCY + PERCENT_STEP_FADEIN))§			m_dwCurTransparency -= PERCENT_STEP_FADEIN;§		else m_dwCurTransparency = PERCENT_MIN_TRANSPARENCY;§§		if (m_dwCurTransparency <= m_tiDisplayed.nTransparency)§		{§			//ENG: Kills showing timer and sets a tooltip's state as SHOWN§			//RUS: ”·Ë‚‡ÂÏ Ú‡ÈÏÂ ÔÎ‡‚ÌÓ„Ó ÔÓÍ‡Á‡ Ë ÛÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÒÓÒÚÓˇÌËÂ ÚÛÎÚËÔ‡ Í‡Í SHOWN§			m_dwCurTransparency = m_tiDisplayed.nTransparency;§			KillTimer(TIMER_SHOWING);§			m_nTooltipState = PPTOOLTIP_STATE_SHOWN;§			//ENG: Starts timer to auto pop of the tooltip§			//RUS: «‡ÔÛÒÍ Ú‡ÈÏÂ‡ Ì‡ ‡‚ÚÓÏ‡ÚË˜ÂÒÍÓÂ ÒÓÍ˚ÚËÂ ÚÛÎÚËÔ‡§			SetAutoPopTimer();§		} //if§		//ENG: Redraw tooltip with new transparency factor§		//RUS: œÂÂËÒÓ‚‡Ú¸ ÚÂÍÛ˘ËÈ ÚÛÎÚËÔ Ò ÌÓ‚˚Ï ÍÓ˝ÙÙËˆËÂÌÚÓÏ ÔÓÁ‡˜ÌÓÒÚË§		OnRedrawTooltip(NULL, m_dwCurTransparency);§		break;	§	case TIMER_HIDE:§		TRACE(_T("OnTimerHide()\n"));§		//ENG: Kill all timers except HIDING timer§		//RUS: ”·Ë‚‡ÂÏ ‚ÒÂ Ú‡ÈÏÂ˚ Á‡ ËÒÍÎ˛˜ÂÌËÂÏ Ú‡ÈÏÂ‡ HIDING§		KillTimer(TIMER_SHOW);§		KillTimer(TIMER_SHOWING);§		KillTimer(TIMER_HIDE);§		//ENG: If hiding timer don't start§		//RUS: œÓ‚ÂˇÂÏ Á‡ÔÛ˘ÂÌ ÎË Ú‡ÈÏÂ ÒÓÍ˚ÚËˇ ÚÛÎÚËÔ‡§		if (PPTOOLTIP_STATE_HIDING != m_nTooltipState)§		{§			m_nTooltipState = PPTOOLTIP_STATE_HIDING;§			if ((SHOWEFFECT_FADEINOUT == m_dwHideEffect) && m_dwTimeFadeOut)§			{§				//ENG: If fade-out effect enabled and setted fade-out timestep§				//RUS: ≈ÒÎË ˝ÙÙÂÍÚ ÔÎ‡‚ÌÓ„Ó ÒÓÍ˚ÚËˇ ‡ÁÂ¯ÂÌ Ë ÛÍ‡Á‡ÌÓ ‚ÂÏˇ ¯‡„‡ ÒÓÍ˚ÚËˇ§				SetTimer(TIMER_HIDING, m_dwTimeFadeOut, NULL);§			}§			else§			{§				//ENG: Sets a maximum transparency and to stops a hiding of a tooltip§				//RUS: ”ÒÚ‡Ì‡‚ÎË‚‡ÂÏ Ï‡ÍÒËÏ‡Î¸ÌÛ˛ ÔÓÁ‡˜ÌÓÒÚ¸ Ë ÓÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÒÓÍ˚ÚËÂ§				m_dwCurTransparency = PERCENT_MAX_TRANSPARENCY;§				OnTimer(TIMER_HIDING);§			} //if§		} //if§		break;§	case TIMER_HIDING:§		TRACE(_T("OnTimerFadeOut(Current Transparency=%d)\n"), m_dwCurTransparency);§		//ENG: If fade-out effect was finished then sets maximum transparency§		//RUS: ≈ÒÎË ¯‡„Ë ˝ÙÙÂÍÚ‡ ÔÎ‡‚ÌÓ„Ó ÒÓÍ˚ÚËˇ ËÒ˜ÂÔ‡Ì˚, ÚÓ ÛÒÚ‡ÌÓ‚ËÚ¸ Ï‡ÍÒËÏ‡Î¸ÌÛ˛ ÔÓÁ‡˜ÌÓÒÚ¸§		if (m_dwCurTransparency < (PERCENT_MAX_TRANSPARENCY - PERCENT_STEP_FADEOUT))§			m_dwCurTransparency += PERCENT_STEP_FADEOUT;§		else m_dwCurTransparency = PERCENT_MAX_TRANSPARENCY;§		§		if (PERCENT_MAX_TRANSPARENCY == m_dwCurTransparency)§		{§			//ENG: Kills hiding timer and hides a tooltip§			//RUS: ”·Ë‚‡ÂÏ Ú‡ÈÏÂ ÔÎ‡‚ÌÓ„Ó ÒÓÍ˚ÚËˇ Ë Ôˇ˜ÂÏ ÓÍÌÓ ÚÛÎÚËÔ‡§			KillTimer(TIMER_HIDING);§			if (m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)§			{§				//If for tool to set a multiple show then reset last window§				m_hwndDisplayedTool = NULL;§				m_last_dynamic_tool = 0;§§				m_tiDisplayed.rectBounds.SetRectEmpty();§			} //if§			ShowWindow(SW_HIDE);§			m_nTooltipState = PPTOOLTIP_STATE_HIDEN;§			if (m_bNextToolExist)§			{§				//ENG: If next tooltip is exist then starts show§				//RUS: ≈ÒÎË ÒÛ˘ÂÒÚ‚ÛÂÚ ÔÓ‰„ÓÚÓ‚ÎÂÌÌ˚È ÚÛÎÚËÔ, ÚÓ Ì‡˜‡Ú¸ Â„Ó ÓÚÓ·‡ÊÂÌËÂ§				m_bNextToolExist = FALSE;§//				m_nTooltipType = m_nNextTooltipType;§//				m_nNextTooltipType = PPTOOLTIP_NORMAL;§				if (m_bDelayNextTool) SetTimer(TIMER_SHOW, m_dwTimeInitial, NULL);§				else OnTimer(TIMER_SHOW);§			}§			else§			{§				//ENG: If next tooltip wasn't exist§				//RUS: ≈ÒÎË ÔÓ‰„ÓÚÓ‚ÎÂÌÌ˚È ÚÛÎÚËÔ ÌÂ ÒÛ˘ÂÒÚ‚ÛÂÚ§				m_nTooltipType = PPTOOLTIP_NORMAL;§				m_nNextTooltipType = PPTOOLTIP_NORMAL;§			} //if§		}§		else §		{§			//ENG: Redraw tooltip with new transparency factor§			//RUS: œÂÂËÒÓ‚‡Ú¸ ÚÂÍÛ˘ËÈ ÚÛÎÚËÔ Ò ÌÓ‚˚Ï ÍÓ˝ÙÙËˆËÂÌÚÓÏ ÔÓÁ‡˜ÌÓÒÚË§			OnRedrawTooltip(NULL, m_dwCurTransparency);§		} //if§		break;	§	case TIMER_ANIMATION:§		if (IsVisible() && (PPTOOLTIP_STATE_SHOWN == m_nTooltipState))§		{§			if(m_drawer.OnTimer())§				OnRedrawTooltip(NULL, m_dwCurTransparency);§		} //if§		break;§	default:§		CWnd::OnTimer(nIDEvent);§		break;§	} //switch§} //End of the WM_TIMER handler§§void CPPToolTip::HideTooltip()§{§	TRACE (_T("CPPToolTip::HideTooltip(CurState=%d)\n"), m_nTooltipState);§	switch(m_nTooltipState)§	{§	case PPTOOLTIP_STATE_SHOWING:§		//ENG: Kill showing tooltip§		//RUS: ≈ÒÎË ÚÛÎÚËÔ ÚÓÎ¸ÍÓ ÓÚ·‡Ê‡ÂÚÒˇ, ÚÓ ÔÂÍ‡˘‡ÂÏ Â„Ó ÓÚÓ·‡Ê‡Ú¸§		KillTimer(TIMER_SHOWING);§	case PPTOOLTIP_STATE_SHOWN:§		//ENG: Hiding a tooltip§		//RUS: œˇ˜ÂÏ ÚÛÎÚËÔ§		OnTimer(TIMER_HIDE);§		break;§	} //switch§} //End of HideTooltip§§void CPPToolTip::SetAutoPopTimer()§{§	TRACE (_T("CPPToolTip::SetAutoPopTimer()\n"));§	if (m_dwTimeAutoPop && !(m_tiDisplayed.nBehaviour & PPTOOLTIP_DISABLE_AUTOPOP))§		SetTimer(TIMER_HIDE, m_dwTimeAutoPop, NULL);§} //End of SetAutoPopTimer§§void CPPToolTip::KillTimers(DWORD dwIdTimer /* = NULL */)§{§	TRACE (_T("CPPToolTip::KillTimers()\n"));§	if (dwIdTimer == NULL)§	{§		KillTimer(TIMER_SHOW);§		KillTimer(TIMER_HIDE);§		KillTimer(TIMER_SHOWING);§		KillTimer(TIMER_HIDING);§	}§	else §	{§		KillTimer(dwIdTimer);§	} //if§} //End KillTimers§§void CPPToolTip::Pop()§{§	TRACE (_T("CPPToolTip::Pop()\n"));§	m_nTooltipState = PPTOOLTIP_STATE_HIDEN;§	m_nTooltipType = PPTOOLTIP_NORMAL;§	m_nNextTooltipType = PPTOOLTIP_NORMAL;§	KillTimers();§	if (IsVisible())§	{§		if (m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)§		{§			//If for tool to set a multiple show then reset last window§			m_hwndDisplayedTool = NULL;§			m_last_dynamic_tool = 0;§			m_tiDisplayed.rectBounds.SetRectEmpty();§		} //if§		ShowWindow(SW_HIDE);§	} //if§} //End of Pop§§void CPPToolTip::PrepareDisplayTooltip(LPPOINT lpPoint)§{§	TRACE (_T("CPPToolTip::PrepareDisplayTooltip()\n"));§	§	//Fills default members§	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_STYLES))§		m_tiNextTool.nStyles = m_dwStyles;§§	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_EFFECT))§	{§		m_tiNextTool.nEffect = m_dwEffectBk;§		m_tiNextTool.nGranularity = m_nGranularity;§	} //if§§	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_COLORS))§	{§		m_tiNextTool.crBegin = m_clrBeginBk;§		m_tiNextTool.crMid = m_clrMidBk;§		m_tiNextTool.crEnd = m_clrEndBk;§	} //if§§	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_DIRECTION))§		m_tiNextTool.nDirection = m_dwDirection;§§	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_BEHAVIOUR))§		m_tiNextTool.nBehaviour = m_dwBehaviour;§§	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_TRANSPARENCY))§		m_tiNextTool.nTransparency = m_nTransparency;§	§	//Send notify§	POINT pt = *lpPoint; //Pointer in screen coordinates§	SendNotify(&pt, m_tiNextTool);§	§	//If string and icon are not exist then exit§	if (m_tiNextTool.sTooltip.IsEmpty())§		return;§	§	//calculate the width and height of the box dynamically§	CDC * pDC = GetDC();§	ASSERT(pDC->GetSafeHdc());§	§	CSize sz (0, 0);§	m_drawer.PrepareOutput(pDC->GetSafeHdc(), m_tiNextTool.sTooltip, &sz);§§	m_rcTipArea.SetRect(0, 0, sz.cx, sz.cy);§	m_rcTooltip = m_rcTipArea;§§	//Inflates on MARGIN_CX and MARGIN_CY sizes§	m_rcTipArea.OffsetRect(m_nSizes[PPTTSZ_MARGIN_CX], m_nSizes[PPTTSZ_MARGIN_CY]);§	m_rcTooltip.InflateRect(0, 0, 2 * m_nSizes[PPTTSZ_MARGIN_CX], 2 * m_nSizes[PPTTSZ_MARGIN_CY]);§§	//Inflates on §	//Gets tooltip's rect with anchor§	CPoint ptAnchor;§	m_dwCurDirection = GetTooltipDirection(m_tiNextTool.nDirection, pt, ptAnchor, m_rcTooltip, m_rcBoundsTooltip, m_rcTipArea);§§	//ENG: Clears resources§	//RUS: Œ˜Ë˘‡ÂÏ ÂÒÛÒ˚§	FreeResources();§§	//ENG: Creates a new region of the window§	//RUS: —ÓÁ‰‡ÂÏ ÌÓ‚˚È Â„ËÓÌ ÓÍÌ‡§	m_hrgnTooltip = GetTooltipRgn(m_dwCurDirection, ptAnchor.x, ptAnchor.y, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());§§	CRect rect = m_rcBoundsTooltip;§	§	//ENG: Creates a background bitmap§	//RUS: —ÓÁ‰‡ÂÏ ·ËÚÏ‡Ô ÙÓÌ‡ ÚÛÎÚËÔ‡§	m_hBitmapBk = ::CreateCompatibleBitmap(pDC->GetSafeHdc(), rect.Width(), rect.Height());§	HDC hMemDC = ::CreateCompatibleDC(pDC->GetSafeHdc());§	§	//ENG: Creates a background of the tooltip's body§	//RUS: —ÓÁ‰‡ÌËÂ ÙÓÌ‡ ÚÂÎ‡ ÚÛÎÚËÔ‡§	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hMemDC, m_hBitmapBk);§	m_drawer.GetDrawManager()->FillEffect(hMemDC, §								m_tiNextTool.nEffect, §								m_rcTooltip,§								m_tiNextTool.crBegin,§								m_tiNextTool.crMid,§								m_tiNextTool.crEnd,§								m_tiNextTool.nGranularity,§								5);§	//ENG: Fills an anchor§	//RUS: «‡ÔÓÎÌˇÂÏ ˇÍÓ¸ ÚÛÎÚËÔ‡§	switch (m_dwCurDirection)§	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, m_rcTooltip.left - m_rcBoundsTooltip.left, m_rcBoundsTooltip.Height(),§					 hMemDC, m_rcTooltip.left + 1, m_rcBoundsTooltip.top, 1, m_rcBoundsTooltip.Height());§		break;§	case PPTOOLTIP_RIGHTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcTooltip.right, m_rcBoundsTooltip.top, m_rcBoundsTooltip.right - m_rcTooltip.right, m_rcBoundsTooltip.Height(),§					 hMemDC, m_rcTooltip.right - 1, m_rcBoundsTooltip.top, 1, m_rcBoundsTooltip.Height());§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcBoundsTooltip.left, m_rcTooltip.bottom, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.bottom - m_rcTooltip.bottom,§					 hMemDC, m_rcBoundsTooltip.left, m_rcTooltip.bottom - 1, m_rcBoundsTooltip.Width(), 1);§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, m_rcBoundsTooltip.Width(), m_rcTooltip.top - m_rcBoundsTooltip.top,§					 hMemDC, m_rcBoundsTooltip.left, m_rcTooltip.top + 1, m_rcBoundsTooltip.Width(), 1);§		break;§	} //switch§§	::SelectObject(hMemDC, hOldBitmap);§	::DeleteDC(hMemDC);§	§	ReleaseDC(pDC);§	§	//ENG: Calculate the tooltip's placement on the screen§	//RUS: ¬˚˜ËÒÎÂÌËÂ ÔÓÎÓÊÂÌËˇ ÚÛÎÚËÔ‡ Ì‡ ˝Í‡ÌÂ§	rect.left = pt.x - ptAnchor.x;§	rect.top = pt.y - ptAnchor.y;§	rect.right = rect.left + m_rcBoundsTooltip.Width();§	rect.bottom = rect.top + m_rcBoundsTooltip.Height();§§	//ENG: If fade-in effect ia available§	//RUS: ≈ÒÎË ÔÎ‡‚ÌÓÂ ÓÚÓ·‡ÊÂÌËÂ ‰ÓÒÚÛÔÌÓ§	if ((SHOWEFFECT_FADEINOUT == m_dwShowEffect) && m_dwTimeFadeIn)§		m_dwCurTransparency = 100;§	else§		m_dwCurTransparency = m_tiNextTool.nTransparency;§§	HRGN hrgnWindow = ::CreateRectRgn(0, 0, 0, 0);§	if (m_szOffsetShadow.cx || m_szOffsetShadow.cy)§	{§		//ENG: If shadow will drawn§		//RUS: ≈ÒÎË ÚÂÌ¸ ·Û‰ÂÚ ÓÚÓ·‡Ê‡Ú¸Òˇ§		HRGN hrgnShadow = ::CreateRectRgn(0, 0, 0, 0);§		::CombineRgn(hrgnShadow, m_hrgnTooltip, hrgnShadow, RGN_COPY);§		::OffsetRgn(hrgnShadow, m_szOffsetShadow.cx, m_szOffsetShadow.cy);§		::CombineRgn(hrgnWindow, m_hrgnTooltip, hrgnShadow, RGN_OR);§		::DeleteObject(hrgnShadow);§§		//ENG: Increments the sizes of tooltip to drawing a shadow§		//RUS: ”‚ÂÎË˜Ë‚‡ÂÏ ‡ÁÏÂ˚ ÚÛÎÚËÔ‡ ‰Îˇ ËÒÓ‚‡ÌËˇ ÚÂÌË§		m_rcBoundsTooltip.right += m_szOffsetShadow.cx;§		m_rcBoundsTooltip.bottom += m_szOffsetShadow.cy;§	}§	else§	{§		//ENG: The current window has not a shadow§		//RUS: “ÂÍÛ˘ÂÂ ÓÍÌÓ ÌÂ ËÏÂÂÚ ÚÂÌË§		::CombineRgn(hrgnWindow, m_hrgnTooltip, NULL, RGN_COPY);§	}//if§§	//ENG: Applies a region§	//RUS: œËÏÂÌˇÂÏ Â„ËÓÌ§	SetWindowRgn(hrgnWindow, FALSE);§	§	//ENG: Sets a tooltip on the screen§	//RUS: ”ÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÚÛÎÚËÔ Ì‡ ˝Í‡ÌÂ§	if (PPTOOLTIP_MENU == m_nTooltipType) §	{§		SetWindowPos(NULL, §			rect.left, rect.top,§			m_rcBoundsTooltip.Width(), §			m_rcBoundsTooltip.Height(),§			SWP_SHOWWINDOW|SWP_NOACTIVATE|SWP_NOZORDER/*|SWP_NOCOPYBITS*/);§	}§	else§	{§		SetWindowPos(NULL, §			rect.left, rect.top,§			m_rcBoundsTooltip.Width(), §			m_rcBoundsTooltip.Height(),§			SWP_SHOWWINDOW|SWP_NOACTIVATE/*|SWP_NOCOPYBITS*/);§	}§} //End of PrepareDisplayTooltip§§void CPPToolTip::FreeResources()§{§	if (NULL != m_hrgnTooltip)§	{§		::DeleteObject(m_hrgnTooltip);§		m_hrgnTooltip = NULL;§	} //if§§	if (NULL != m_hBitmapBk)§	{§		::DeleteObject(m_hBitmapBk);§		m_hBitmapBk = NULL;§	} //if§§	if (NULL != m_hUnderTooltipBk)§	{§		::DeleteObject(m_hUnderTooltipBk);§		m_hUnderTooltipBk = NULL;§	} //if§} //End of FreeResources§§void CPPToolTip::OutputTooltipOnScreen(LPPOINT lpPoint, HDC hDC /* = NULL */)§{§	TRACE(_T("OutputTooltipOnScreen()\n"));§	CRect rect = m_rcBoundsTooltip;§	rect.OffsetRect(*lpPoint);§	//m_dwCurDirection = GetTooltipDirection(m_tiNextTool.nDirection, &pt, &ptAnchor, m_rcTooltip, m_rcBoundsTooltip, m_rcTipArea);§	MoveWindow(rect);§} //End OutputTooltipOnScreen§§////////////////////////////////////////////////////////////////////§// CPPToolTip::GetTooltipDirection()§//		Gets a real direction of a tooltip.§//------------------------------------------------------------------§// Parameters:§//		dwDirection		- A default direction of a tooltip. §//		lpPoint			- A mouse position in the screen coordinates.§//		lpAnchor		- An anchor position in the client coordinates§//      rcBody			- A rectangle of a tooltip's body in the client coordinates§//		rcFull			- A rectangle of a full tooltip in the client coordinates§//		rcTipArea		- A rectangle of a tooltip's info area in the client coordinates§// Return values:§//		A real direction of a tooltip§//------------------------------------------------------------------§// Explanation:§//    0§//  0 +------------------------------------+§//    |                                    |§//    |             rcBody                 |§//    |                                    |§//    |  +------------------------------+  |§//    |  |                              |  |§//    |  |         rcTipArea            |  |§//    |  |                              |  |§//    |  +------------------------------+  |§//    |                                    |§//    +--+...------------------------------+§//    :  |  /                              :§//    :  | /        rcFull                 :§//    :..|/................................:§//       +- lpAnchor§//§////////////////////////////////////////////////////////////////////§DWORD CPPToolTip::GetTooltipDirection(DWORD dwDirection, const CPoint & ptPoint, CPoint & ptAnchor, CRect & rcBody, CRect & rcFull, CRect & rcTipArea)§{§	//ENG: Get Window's rectangle. The whole virtual desktop .... not only the primary screen.JFN§	//RUS: œÓÎÛ˜‡ÂÏ ÔÓÎÌ˚È ÔˇÏÓÛ„ÓÎ¸ÌËÍ ˝Í‡Ì‡ Windows§	CRect rWindow;§    rWindow.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);§    rWindow.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);§	rWindow.right   = rWindow.left + ::GetSystemMetrics(SM_CXVIRTUALSCREEN);§    rWindow.bottom  = rWindow.top + ::GetSystemMetrics(SM_CYVIRTUALSCREEN);§§	//-------------------------------------------§	//ENG: Initializing size of the bounds rect§	//RUS: »ÌËˆË‡ÎËÁ‡ˆËˇ ÔÓÎÌÓ„Ó ‡ÁÏÂ‡ Ó„‡ÌË˜Ë‚‡˛˘Â„Ó ÚÛÎÚËÔ ÔˇÏÓÛ„ÓÎ¸ÌËÍ‡§	rcFull = rcBody;§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§		rcFull.right += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		break;§	case PPTOOLTIP_RIGHTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		rcFull.right += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§		rcFull.bottom += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		rcFull.bottom += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		break;§	} //switch§	§	//---------------------------------------------------§	//ENG: If needed change a horizontal direction§	//RUS: œÓ‚ÂÍ‡ „ÓËÁÓÌÚ‡Î¸Ì˚ı ‡ÁÏÂÓ‚ Ì‡ ÔÓÔ‡‰‡ÌËÂ ‚ ˝Í‡Ì§	CPoint pt(ptPoint);§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§		pt.x += rcFull.right;§		if (pt.x > rWindow.right)§			dwDirection ^= 0x10;§		break;§	case PPTOOLTIP_RIGHTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		pt.x -= rcFull.right;§		if (pt.x < rWindow.left)§			dwDirection ^= 0x10;§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_LEFT:§		pt.x += rcFull.right;§		pt.x -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		if (pt.x > rWindow.right)§		{§			pt.x = ptPoint.x - rcFull.right;§			pt.x += m_nSizes [PPTTSZ_MARGIN_ANCHOR];§			if (pt.x < rWindow.left)§				dwDirection |= 0x02;§			else§				dwDirection ^= 0x01;§		} //if§		break;§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		pt.x -= rcFull.right;§		pt.x += m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		if (pt.x < rWindow.left)§		{§			pt.x = ptPoint.x + rcFull.right;§			pt.x -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];§			if (pt.x > rWindow.right)§				dwDirection ^= 0x03;§			else§				dwDirection ^= 0x01;§		} //if§		break;§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_CENTER:§		if ((ptPoint.x - rWindow.left) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])§			dwDirection ^= 0x02;§		else if ((rWindow.right - ptPoint.x) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])§			dwDirection ^= 0x03;§		break;§	} //switch§§	//---------------------------------------------------§	//ENG: If needed change a vertical direction§	//RUS: œÓ‚ÂÍ‡ ‚ÂÚËÍ‡Î¸Ì˚ı ‡ÁÏÂÓ‚ Ì‡ ÔÓÔ‡‰‡ÌËÂ ‚ ˝Í‡Ì§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_TOP:§		pt.y += rcFull.bottom;§		pt.y -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		if (pt.y > rWindow.bottom)§		{§			pt.y = ptPoint.y - rcFull.bottom;§			pt.y += m_nSizes [PPTTSZ_MARGIN_ANCHOR];§			if (pt.y < rWindow.top)§				dwDirection |= 0x02;§			else§				dwDirection ^= 0x01;§		} //if§		break;§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		pt.y -= rcFull.bottom;§		pt.y += m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		if (pt.y < rWindow.top)§		{§			pt.y = ptPoint.y + rcFull.bottom;§			pt.y -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];§			if (pt.y > rWindow.bottom)§				dwDirection ^= 0x03;§			else§				dwDirection ^= 0x01;§		} //if§		break;§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§		if ((ptPoint.y - rWindow.top) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])§			dwDirection ^= 0x02;§		else if ((rWindow.bottom - ptPoint.y) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])§			dwDirection ^= 0x03;§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§		pt.y -= rcFull.bottom;§		if (pt.y < rWindow.top)§			dwDirection ^= 0x10;§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		pt.y += rcFull.bottom;§		if (pt.y > rWindow.bottom)§			dwDirection ^= 0x10;§		break;§	} //switch§§	//---------------------------------------------------§	//ENG: Set the anchor's point§	//RUS: ”ÒÚ‡ÌÓ‚Í‡ ÍÓÓ‰ËÌ‡Ú˚ ÍÓÌ˜ËÍ‡§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§		ptAnchor.x = rcFull.left;§		break;§	case PPTOOLTIP_RIGHTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		ptAnchor.x = rcFull.right;§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§		ptAnchor.y = rcFull.bottom;§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		ptAnchor.y = rcFull.top;§		break;§	} //switch§	§	//§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_TOP:§		ptAnchor.y = rcFull.top + m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		break;§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		ptAnchor.y = rcFull.bottom - m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		break;§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§		ptAnchor.y = rcFull.bottom / 2;§		if ((ptPoint.y + rcFull.bottom / 2) <= rWindow.bottom)§		{§			if ((ptPoint.y - rcFull.bottom / 2) < rWindow.top)§				ptAnchor.y -= (rcFull.bottom / 2 - ptPoint.y + rWindow.top);§		}§		else if ((ptPoint.y - rcFull.bottom / 2) >= rWindow.top)§		{§			if ((ptPoint.y + rcFull.bottom / 2) > rWindow.bottom)§				ptAnchor.y += (ptPoint.y + rcFull.bottom / 2 - rWindow.bottom);§		} //if§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_LEFT:§		ptAnchor.x = rcFull.left + m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		break;§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		ptAnchor.x = rcFull.right - m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		break;§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_CENTER:§		ptAnchor.x = rcFull.right / 2;§		if ((ptPoint.x + rcFull.right / 2) <= rWindow.right)§		{§			if ((ptPoint.x - rcFull.right / 2) < rWindow.left)§				ptAnchor.x -= (rcFull.right / 2 - ptPoint.x + rWindow.left);§		}§		else if ((ptPoint.x - rcFull.right / 2) >= rWindow.left)§		{§			if ((ptPoint.x + rcFull.right / 2) > rWindow.right)§				ptAnchor.x += (ptPoint.x + rcFull.right / 2 - rWindow.right);§		} //if§		break;§	} //switch§§	//---------------------------------------------------§	//If needed offset anchor§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§		if ((ptPoint.y - ptAnchor.y) < rWindow.top)§			ptAnchor.y = ptPoint.y - rWindow.top;§		break;§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		if ((ptPoint.y + rcFull.bottom - ptAnchor.y) > rWindow.bottom)§			ptAnchor.y = rcFull.bottom - rWindow.bottom + ptPoint.y;§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_CENTER:§		if ((ptPoint.x - ptAnchor.x) < rWindow.left)§			ptAnchor.x = ptPoint.x - rWindow.left;§		break;§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		if ((ptPoint.x + rcFull.right - ptAnchor.x) > rWindow.right)§			ptAnchor.x = rcFull.right - rWindow.right + ptPoint.x;§		break;§	} //switch§§	//*!* I don't know why but without following lines application fails in Release mode!!!!§	CString str;§	str.Format("0x%08X", dwDirection);§§	//---------------------------------------------§	// Offset the body rectangle§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§		rcTipArea.OffsetRect(m_nSizes [PPTTSZ_HEIGHT_ANCHOR], 0);§		rcBody.OffsetRect(m_nSizes [PPTTSZ_HEIGHT_ANCHOR], 0);§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		rcTipArea.OffsetRect(0, m_nSizes [PPTTSZ_HEIGHT_ANCHOR]);§		rcBody.OffsetRect(0, m_nSizes [PPTTSZ_HEIGHT_ANCHOR]);§		break;§	} //switch§§	return dwDirection;§} //End of GetTooltipDirection§§HRGN CPPToolTip::GetTooltipRgn(DWORD dwDirection, int x, int y, int nWidth, int nHeight)§{§	HRGN hRgn = NULL;§	§	HRGN hrgnBody = NULL;§	CRect rcBody(0, 0, nWidth, nHeight);§§	HRGN hrgnAnchor = NULL;§	POINT ptAnchor [3];§	ptAnchor [0].x = x;§	ptAnchor [0].y = y;§	§	HRGN hrgnRect = NULL;§	§	//------------------------------§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§		rcBody.left += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		ptAnchor [1].x = ptAnchor [2].x = rcBody.left;§		break;§	case PPTOOLTIP_RIGHTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		rcBody.right -= m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		ptAnchor [1].x = ptAnchor [2].x = rcBody.right;§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_TOPEDGE_RIGHT:§		rcBody.top += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		ptAnchor [1].y = ptAnchor [2].y = rcBody.top;§		break;§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§		rcBody.bottom -= m_nSizes [PPTTSZ_HEIGHT_ANCHOR];§		ptAnchor [1].y = ptAnchor [2].y = rcBody.bottom;§		break;§	} //switch§§	//------------------------------§	switch(dwDirection) §	{§	case PPTOOLTIP_LEFTEDGE_TOP:§	case PPTOOLTIP_RIGHTEDGE_TOP:§		ptAnchor [1].y = rcBody.top + m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		ptAnchor [2].y = ptAnchor [1].y + m_nSizes [PPTTSZ_WIDTH_ANCHOR];§		break;§	case PPTOOLTIP_LEFTEDGE_BOTTOM:§	case PPTOOLTIP_RIGHTEDGE_BOTTOM:§		ptAnchor [1].y = rcBody.bottom - m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		ptAnchor [2].y = ptAnchor [1].y - m_nSizes [PPTTSZ_WIDTH_ANCHOR];§		break;§	case PPTOOLTIP_LEFTEDGE_VCENTER:§	case PPTOOLTIP_RIGHTEDGE_VCENTER:§		ptAnchor [1].y = ptAnchor [0].y - m_nSizes [PPTTSZ_WIDTH_ANCHOR] / 2;§//		ptAnchor [1].y = rcBody.top + (rcBody.Height() - m_nSizes [PPTTSZ_WIDTH_ANCHOR]) / 2;§		ptAnchor [2].y = ptAnchor [1].y + m_nSizes [PPTTSZ_WIDTH_ANCHOR];§		break;§	case PPTOOLTIP_TOPEDGE_LEFT:§	case PPTOOLTIP_BOTTOMEDGE_LEFT:§		ptAnchor [1].x = rcBody.left + m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		ptAnchor [2].x = ptAnchor [1].x + m_nSizes [PPTTSZ_WIDTH_ANCHOR];§		break;§	case PPTOOLTIP_TOPEDGE_RIGHT:§	case PPTOOLTIP_BOTTOMEDGE_RIGHT:§		ptAnchor [1].x = rcBody.right - m_nSizes [PPTTSZ_MARGIN_ANCHOR];§		ptAnchor [2].x = ptAnchor [1].x - m_nSizes [PPTTSZ_WIDTH_ANCHOR];§		break;§	case PPTOOLTIP_TOPEDGE_CENTER:§	case PPTOOLTIP_BOTTOMEDGE_CENTER:§		ptAnchor [1].x = ptAnchor [0].x - m_nSizes [PPTTSZ_WIDTH_ANCHOR] / 2;§//		ptAnchor [1].x = rcBody.left + (rcBody.Width() - m_nSizes [PPTTSZ_WIDTH_ANCHOR]) / 2;§		ptAnchor [2].x = ptAnchor [1].x + m_nSizes [PPTTSZ_WIDTH_ANCHOR];§		break;§	} //switch§§	//------------------------------§	//Gets the tooltip body's region§	hrgnBody = ::CreateRoundRectRgn(rcBody.left, rcBody.top, rcBody.right + 1, rcBody.bottom + 1, §			m_nSizes[PPTTSZ_ROUNDED_CX], m_nSizes[PPTTSZ_ROUNDED_CY]);§§	//Gets the tooltip anchor's region§	if (m_nSizes [PPTTSZ_HEIGHT_ANCHOR] && m_nSizes [PPTTSZ_WIDTH_ANCHOR])§		hrgnAnchor = ::CreatePolygonRgn(ptAnchor, 3, ALTERNATE);§	else§		hrgnAnchor = ::CreateRectRgn(0, 0, 0, 0);§§	hRgn = ::CreateRectRgn(0, 0, 0, 0);§	::CombineRgn(hRgn, hrgnBody, hrgnAnchor, RGN_OR);§§	if (NULL != hrgnBody)§		::DeleteObject(hrgnBody);§	if (NULL != hrgnAnchor)§		::DeleteObject(hrgnAnchor);§§	return hRgn;§} //End GetTooltipRgn§§BOOL CPPToolTip::IsCursorOverTooltip() const§{§    ASSERT(m_hParentWnd);§	§    // Is tooltip visible?§    if (!IsVisible() || !IsWindow(m_hWnd))§		return FALSE;§	§    POINT pt;§    GetCursorPos(&pt);§	§	CPPToolTip * pWnd = (CPPToolTip*)WindowFromPoint(pt);§	§	return (pWnd == this);§}§§HWND CPPToolTip::GetWndFromPoint(const LPPOINT lpPoint, PPTOOLTIP_INFO & ti, BOOL bCheckTool /* = TRUE */)§{§	// the default implementation of tooltips just calls WindowFromPoint§	// which does not work for certain kinds of combo boxes§	CPoint pt = *lpPoint;§	::ClientToScreen(m_hParentWnd, &pt);§	HWND hWnd = ::WindowFromPoint(pt);§	if (NULL != hWnd)§	{§		// try to hit combobox instead of edit control for CBS_DROPDOWN styles§		HWND hWndTemp = ::GetParent(hWnd);§		if (NULL != hWndTemp)§		{§			if (!IsComboBoxControl(hWndTemp, CBS_DROPDOWN))§			{§				// handle special case of disabled child windows§				::ScreenToClient(hWnd, &pt);§				hWndTemp = ::ChildWindowFromPoint(hWnd, pt);§				if (NULL == hWndTemp)§					return NULL;§				if ((!::IsWindowEnabled(hWndTemp)) && bCheckTool)§					return NULL;§			} //if§			§			if (FindTool(hWndTemp, &pt, ti) || !bCheckTool)§				return hWndTemp;§		} //if§	} //if§§	return NULL;§} //End GetWndFromPoint§§BOOL CPPToolTip::IsComboBoxControl(HWND hWnd, UINT nStyle)§{§	if (hWnd == NULL)§		return FALSE;§	// do cheap style compare first§	if ((UINT)(::GetWindowLong(hWnd, GWL_STYLE) & 0x0F) != nStyle)§		return FALSE;§§	// do expensive classname compare next§	TCHAR szCompare[9];§	::GetClassName(hWnd, szCompare, 9);§	return lstrcmpi(szCompare, _T("combobox")) == 0;§}§§CString CPPToolTip::GetDebugInfoTool(LPPOINT lpPoint)§{§	PPTOOLTIP_INFO ti;§	HWND hWnd = GetWndFromPoint(lpPoint, ti, FALSE);§	HWND hParent = ::GetParent (hWnd);§§	_TCHAR ch[128];§	CString str, strTemp;§	CString strOutput = _T("<table>");§	§	///////////////////////////////////////////////////////////////////§	//Table of a window§	strOutput += _T("<tr><td><font color=darkblue>Window</font><table border=1>");§§	//1. Window's class name and Window Owner's class name§	::GetClassName (hWnd, ch, 128);§	strOutput += CreateDebugCell(_T("Class name"), ch);§	§	//2. Window's title and Window Owner's title§	::GetWindowText (hWnd, ch, 128);§	strOutput += CreateDebugCell(_T("Title"), ch);§	§	//3. Window's handle and Window Owner's handle§	str.Format(_T("0x%08X"), hWnd);§	strOutput += CreateDebugCell(_T("Handle"), str);§	§	//4. Window's ID§	str.Format(_T("%d"), GetWindowLong(hWnd, GWL_ID));§	strOutput += CreateDebugCell(_T("Control ID"), str);§§	//5. Window's styles§	str.Format(_T("0x%08X"), (DWORD)::GetWindowLong (hWnd, GWL_STYLE));§	strOutput += CreateDebugCell(_T("Styles"), str);§	§	//6. Window's rect§	RECT rc; §	::GetWindowRect(hWnd, &rc);§	str.Format(_T("(%d, %d)-(%d, %d)"), rc.left, rc.top, rc.right, rc.bottom);§	strOutput += CreateDebugCell(_T("RECT"), str);§§	//7. Window's width§	str.Format(_T("%d"), rc.right - rc.left);§	strOutput += CreateDebugCell(_T("Width"), str);§	§	//8. Window's height§	str.Format(_T("%d"), rc.bottom - rc.top);§	strOutput += CreateDebugCell(_T("Height"), str);§§	//9. Window's has tooltip§	HWND hwndTool = FindTool(lpPoint, ti);§	str = (NULL != hwndTool) ? _T("Yes") : _T("No");§	strOutput += CreateDebugCell(_T("Has Tooltip"), str);§§	strOutput += _T("</table></td>");§§	///////////////////////////////////////////////////////////////////§	//Table of a window owner§	strOutput += _T("<td><font color=darkblue>Window Owner</font><table border=1>");§	§	//1. Window's class name and Window Owner's class name§	if (NULL != hParent)§	{§		::GetClassName (hParent, ch, 128);§		str = GetMaxDebugString((CString)ch);§	} //if§	else str = _T("N/A");§	strOutput += CreateDebugCell(_T("Class name"), str);§	§	//2. Window's title and Window Owner's title§	if (NULL != hParent)§	{§		::GetWindowText (hParent, ch, 128);§		str = GetMaxDebugString((CString)ch);§	} //if§	else str = _T("N/A");§	strOutput += CreateDebugCell(_T("Title"), str);§	§	//3. Window's handle and Window Owner's handle§	str.Format(_T("0x%08X"), hParent);§	strOutput += CreateDebugCell(_T("Handle"), str);§§	strOutput += _T("</table>");§	§	///////////////////////////////////////////////////////////////////§	//Table of a window owner§	strOutput += _T("<br><font color=darkblue>Mouse Cursor</font><table border=1>");§	§	//1.§	str.Format(_T("%d"), lpPoint->x);§	strOutput += CreateDebugCell(_T("X"), str);§	§	//2.§	str.Format(_T("%d"), lpPoint->y);§	strOutput += CreateDebugCell(_T("Y"), str);§§	strOutput += _T("</table></td></tr></table>");§§	///////////////////////////////////////////////////////////////////////////§	return strOutput;§}§§CString CPPToolTip::CreateDebugCell(CString sTitle, LPCTSTR lpszDescription)§{§	CString str;§	str.Format(_T("<tr><td width=70 bgcolor=buttonface>%s</td><td width=130 bgcolor=window>%s</td></tr>"), §		sTitle, GetMaxDebugString(lpszDescription));§	return str;§} //End of CreateDebugCell§§CString CPPToolTip::GetMaxDebugString(LPCTSTR lpszText)§{§	CString str = (CString)lpszText;§	str.Replace(_T("<"), _T("?")); //Replaces the begins of the tags§	if (str.GetLength() > MAX_LENGTH_DEBUG_STRING)§	{§		str = str.Left(MAX_LENGTH_DEBUG_STRING - 4);§		str += _T(" ...");§	} //if§§	return str;§} //End of GetMaxDebugString§§HWND CPPToolTip::FindTool(const LPPOINT lpPoint, PPTOOLTIP_INFO & ti)§{§	return GetWndFromPoint(lpPoint, ti, TRUE);§} //End of FindTool§§§BOOL CPPToolTip::FindTool(HWND hWnd, const LPPOINT lpPoint, PPTOOLTIP_INFO & ti)§{§	//ENG: Searching a specified HWND§	//RUS: »˘ÂÏ ÛÍ‡Á‡ÌÌ˚È HWND§	mapIter item = m_ToolMap.find(hWnd);§	if (item == m_ToolMap.end())§	{§		//ENG: Specified HWND wasn't found§		//RUS: ”Í‡Á‡ÌÌ˚È HWND ÌÂ Ì‡È‰ÂÌ§		return FALSE; §	} //if§	§	//ENG: Gets the array with the hotarea's parameters§	//RUS: œÓÎÛ˜‡ÂÏ Ï‡ÒÒË‚ Ò Ô‡‡ÏÂÚ‡ÏË „Óˇ˜Ëı ÁÓÌ ÛÍ‡Á‡ÌÓ„Ó ÓÍÌ‡§	arHotArea & hotarea = item->second;§	if ((hotarea.size() == 1) && hotarea[0].rectBounds.IsRectEmpty())§	{§		//ENG: If a bounding rectangle of a hotarea wasn't define§		//RUS: ≈ÒÎË Ó„‡ÌË˜Ë‚‡˛˘ËÈ ÔˇÏÓÛ„ÓÎ¸ÌËÍ „Óˇ˜ÂÈ ÁÓÌ˚ ÌÂ ÓÔÂ‰ÂÎÂÌ§		ti = hotarea[0];§		return TRUE;§	} //if§§	POINT ptClient = *lpPoint;§	if (hWnd != m_hParentWnd)§	{§		//ENG: If HWND specified window isn't a parent§		//RUS: ≈ÒÎË HWND ÌÂ ÓÚÌÓÒËÚÒˇ Í Ó‰ËÚÂÎ¸ÒÍÓÏÛ ÓÍÌÛ, ÚÓ ÔÂÓ·‡ÁÛÂÏ ÍÓÓ‰ËÌ‡Ú˚§		::ScreenToClient(hWnd, &ptClient);§	} //if§	§	CScrollView * pScroll = (CScrollView*)CScrollView::FromHandle(hWnd);§	if (pScroll->IsKindOf(RUNTIME_CLASS(CScrollView))) §	{§		//ENG: If HWND of CScrollView or derived class then corrects the coordinates§		//RUS: ≈ÒÎË HWND ÔËÌ‡‰ÎÂÊËÚ CScrollView ËÎË ÔÓËÁ‚Ó‰ÌÓÏÛ ÓÚ ÌÂ„Ó ÍÎ‡ÒÒÛ, ÚÓ ÍÓÂÍÚËÛÂÏ ÍÓÓ‰ËÌ‡Ú˚§		CPoint ptScroll = pScroll->GetScrollPosition();§		ptClient.x += ptScroll.x;§		ptClient.y += ptScroll.y;§	} //if§	§	//ENG: Search a hotarea under the mouse§	//RUS: »˘ÂÏ „Óˇ˜Û˛ ÁÓÌÛ ÔÓ‰ ÍÛÒÓÓÏ§	arHotArea::iterator iter;§	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)§	{§		ti = *iter;§		if (ti.rectBounds.PtInRect(ptClient))§		{§			//ENG: A hotarea was found§			//RUS: «ÓÌ‡ Ì‡È‰ÂÌ‡§			return TRUE;§		} //if§	} //for§	§	return FALSE;§} //End of FindTool§§HWND CPPToolTip::FindToolBarItem(POINT point, PPTOOLTIP_INFO & ti)§{§	//ENG: Toolbar control was disabled§	//RUS:  ÓÌÚÓÎ¸ Á‡ ÔÓ‰ÒÍ‡ÁÍ‡ÏË Í Ô‡ÌÂÎˇÏ ËÌÒÚÛÏÂÌÚÓ‚ ÓÚÍÎ˛˜ÂÌ§	if (!m_wndToolBars.size())§		return NULL;§§	//ENG: Gets a window under mouse§	//RUS: ŒÔÂ‰ÂÎˇÂÏ ÓÍÌÓ ÔÓ‰ ÍÛÒÓÓÏ§	HWND hWnd = ::WindowFromPoint(point);§	if (NULL != hWnd)§	{§		//ENG: A window was found. Searching a coincidence with toolbar windows§		//RUS: ŒÍÌÓ Ó·Ì‡ÛÊÂÌÓ. œÓËÒÍ ÒÓ‚Ô‡‰ÂÌËˇ Ò ÓÍÌ‡ÏË Ô‡ÌÂÎÂÈ ËÌÒÚÛÏÂÌÚÓ‚§		for (int i = 0; i < (int)m_wndToolBars.size(); i++)§		{§			if (m_wndToolBars[i] == hWnd)§			{§				//ENG: A toolbar under mouse§				//RUS: œ‡ÌÂÎ¸ ËÌÒÚÛÏÂÌÚÓ‚ ÔÓ‰ ÍÛÒÓÓÏ§				CToolBar * pBar = (CToolBar*)CToolBar::FromHandle(hWnd);§				pBar->ScreenToClient(&point);§				//ENG: Gets a item's count of the toolbar§				//RUS: œÓÎÛ˜‡ÂÏ ÍÓÎË˜ÂÒÚ‚Ó ˝ÎÂÏÂÌÚÓ‚ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§				int count = pBar->GetCount();§				CRect rect;§				//ENG: Searching an toolbar's item under mouse§				//RUS: œÓËÒÍ ˝ÎÂÏÂÌÚ‡ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚ Ì‡ıÓ‰ˇ˘Â„ÓÒˇ ÔÓ‰ ÍÛÒÓÓÏ§				for (int i = 0; i < count; i++)§				{§					pBar->GetItemRect(i, rect);§					if (rect.PtInRect(point))§					{§						//ENG: Toolbar's item was found§						//RUS: ›ÎÂÏÂÌÚ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚ Ó·Ì‡ÛÊÂÌ§						ti.nIDTool = pBar->GetItemID(i);§						ti.rectBounds = rect;§						ti.nMask = 0;§						ti.sTooltip = m_drawer.GetResCommandPrompt(ti.nIDTool, 1);§						return hWnd;§					} //if§				} //for§				return NULL;§			} //if§		} //for§	} //if§	return NULL;§} //End of FindToolBarItem§§§////////////////////////////////////////////////////////////////////////////////////////////§// *** public methods ***§////////////////////////////////////////////////////////////////////////////////////////////§§////////////////////////////////////////////////////////////////////§// CPPToolTip::AddTool()§// Registers a tool with the tooltip control.§//------------------------------------------------------------------§// Parameters:§//		pWnd			- Pointer to the window that contains the tool.  §//		lpszString		- Pointer to the text for the tool. §//      dwIdString		- ID of string resource§//		hIcon			- Handle of the icon§//		dwIdIcon		- ID of icon resource§//		szIcon			- Specifies the width and the height, in pixels, of the icon to load.§//		lpRectBounds	- Pointer to a RECT structure containing coordinates of the tool's bounding rectangle. §//						  The coordinates are relative to the upper-left corner of the client area of the window identified by pWnd. §//					      NULL if bounding rectangle don't uses for specified window§//		dwIdTool		- ID of the tool§//		ti				- Reference to PPTOOLTIP_INFO structure containing the parameters of the tooltip §//§// Remarks:§//		  A tooltip control can be associated with more than one tool. Call this function to register a tool §//		with the tooltip control, so that the information stored in the tooltip is displayed when the cursor is on the tool.§////////////////////////////////////////////////////////////////////§void CPPToolTip::AddTool(CWnd * pWnd, DWORD dwIdString, HICON hIcon, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)§{§	CString str;§	str.LoadString(dwIdString);§	AddTool(pWnd, (LPCTSTR)str, hIcon, lpRectBounds, dwIDTool);§}§§void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString, HICON hIcon, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)§{§	CString str;§	str.Format(_T("<table><tr><td><icon handle=0x%X></td><td>%s</td></tr></table>"), §		hIcon, lpszString);§	AddTool(pWnd, str, lpRectBounds, dwIDTool);§}§§void CPPToolTip::AddTool(CWnd * pWnd, DWORD dwIdString, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)§{§	CString str;§	str.LoadString(dwIdString);§	AddTool(pWnd, (LPCTSTR)str, dwIdIcon, szIcon, lpRectBounds, dwIDTool);§}§§void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)§{§	CString str;§	str.Format(_T("<table><tr><td><icon idres=%d width=%d height=%d></td><td>%s</td></tr></table>"), §		dwIdIcon, szIcon.cx, szIcon.cy, lpszString);§	AddTool(pWnd, str, lpRectBounds, dwIDTool);§}§§void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdBitmap, COLORREF crMask, CSize & szBitmap /*= CSize(0, 0)*/, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)§{§	CString str;§	str.Format(_T("<table><tr><td><bmp idres=%d mask=0x%X width=%d height=%d></td><td>%s</td></tr></table>"), §		dwIdBitmap, crMask, szBitmap.cx, szBitmap.cy, lpszString);§	AddTool(pWnd, str, lpRectBounds, dwIDTool);§}§§void CPPToolTip::AddTool(CWnd * pWnd, DWORD dwIdString, LPCRECT lpRectBounds /* = NULL */, DWORD dwIDTool /* = 0 */)§{§	CString str;§	str.LoadString(dwIdString);§	AddTool(pWnd, (LPCTSTR)str, lpRectBounds, dwIDTool);§}§§void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString /* = NULL */, LPCRECT lpRectBounds /* = NULL */, DWORD dwIDTool /* = 0 */)§{§	PPTOOLTIP_INFO ti;§§	ti.nIDTool = dwIDTool;§	if (NULL != lpRectBounds)§		ti.rectBounds = *lpRectBounds;§	else §		ti.rectBounds.SetRectEmpty();§	ti.sTooltip = (CString)lpszString;§	ti.nMask = 0;§	ti.nStyles = 0;§	ti.nDirection = 0;§	ti.nEffect = 0;§	ti.nBehaviour = 0;§	ti.nGranularity = 0;§	ti.crBegin = RGB(0, 0, 0);§	ti.crMid = RGB(0, 0, 0);§	ti.crEnd = RGB(0, 0, 0);§§	AddTool(pWnd, ti);§}§§void CPPToolTip::AddTool(CWnd * pWnd, PPTOOLTIP_INFO & ti)§{§	TRACE(_T("CPPToolTip::AddTool(hWnd=0x%08X)\n"), pWnd->GetSafeHwnd());§	ASSERT (pWnd);§§	//ENG: Gets HWND of a window§	//RUS: œÓÎÛ˜‡ÂÏ HWND ÓÍÌ‡§	HWND hWnd = pWnd->GetSafeHwnd();§	§	//ENG: Searching a specified HWND§	//RUS: »˘ÂÏ ÛÍ‡Á‡ÌÌ˚È HWND§	mapIter item = m_ToolMap.find(hWnd);§	§	if (item == m_ToolMap.end())§	{§		//ENG: A tooltip for a specified HWND wasn't found therefore create it§		//RUS: “ÛÎÚËÔ ‰Îˇ ÛÍ‡Á‡ÌÌÓ„Ó HWND ÌÂ Ó·Ì‡ÛÊÂÌ, ÔÓ˝ÚÓÏÛ ÒÓÁ‰‡ÂÏ Â„Ó§		arHotArea hotarea;§		hotarea.push_back(ti);§		m_ToolMap.insert(std::make_pair(hWnd, hotarea));§		return;§	} //if§§	//ENG: Gets parameters of the tooltip§	//RUS: œÓÎÛ˜‡ÂÏ Ô‡‡ÏÂÚ˚ ÚÛÎÚËÔ‡§	arHotArea & hotarea = item->second;§§	//ENG: A tooltip has more one rectangle areas. Check all theirs§	//RUS: “ÛÎÚËÔ ÒÓ‰ÂÊËÚ ·ÓÎÂÂ Ó‰ÌÓÈ ÔˇÏÓÛ„ÓÎ¸ÌÓÈ Ó·Î‡ÒÚË, ÔÓ‚ÂËÏ ‚ÒÂı Ëı§	arHotArea::iterator iter;§	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)§	{§		if (ti.rectBounds == (*iter).rectBounds)§		{§			//ENG: Specified window's rect already exist and so updates him§			//RUS: ”Í‡Á‡ÌÌ˚È ÔˇÏÓÛ„ÓÎ¸ÌËÍ ÓÍÌ‡ ÛÊÂ ÒÛ˘ÂÒÚ‚ÛÂÚ, ÔÓ˝ÚÓÏÛ ÔÓÒÚÓ Ó·ÌÓ‚ÎˇÂÏ Â„Ó Ô‡‡ÏÂÚ˚§			*iter = ti;§			return;§		} //if§	} //for§	§	//ENG: Adds a new tool §	//RUS: ƒÓ·‡‚ÎˇÂÏ ÌÓ‚˚È ËÌÒÚÛÏÂÌÚ§	hotarea.push_back(ti);§} //End of AddTool§§void CPPToolTip::AddDynamicTool (DynamicToolID tool, const ExternalFindCallback& callback) {§	m_dynamic_tools[tool] = callback;§}§§////////////////////////////////////////////////////////////////////§// CPPToolTip::RemoveTool()§//   Removes the tool specified by pWnd and lpRectBounds from the collection of §// tools supported by a tooltip control.§//------------------------------------------------------------------§// Parameters:§//		pWnd			- Pointer to the window that contains the tool.  §//		lpRectBounds	- Pointer to a RECT structure containing coordinates of the tool's bounding rectangle. §//						  The coordinates are relative to the upper-left corner of the client area of the window identified by pWnd. §//					      NULL if bounding rectangle don't uses for specified window§////////////////////////////////////////////////////////////////////§void CPPToolTip::RemoveTool(CWnd * pWnd, LPCRECT lpRectBounds /* = NULL */)§{§	TRACE (_T("CPPToolTip::RemoveTool(hWnd=0x%08X)\n"), pWnd->GetSafeHwnd());§	ASSERT(pWnd);§	§	//ENG: Gets HWND of a window§	//RUS: œÓÎÛ˜‡ÂÏ HWND ÓÍÌ‡§	HWND hWnd = pWnd->GetSafeHwnd();§§	//ENG: Searching a specified HWND§	//RUS: »˘ÂÏ ÛÍ‡Á‡ÌÌ˚È HWND§	mapIter item = m_ToolMap.find(hWnd);§§	if (item == m_ToolMap.end())§	{§		//ENG: Specified HWND wasn't found§		//RUS: ”Í‡Á‡ÌÌ˚È HWND ÌÂ Ì‡È‰ÂÌ§		return; §	} //if§§	if (NULL == lpRectBounds)§	{§		//ENG: Removes all tools for the specified window§		//RUS: ”‰‡Îˇ˛ÚÒˇ ‚ÒÂ ËÌÒÚÛÏÂÌÚ˚ ‰Îˇ ÛÍ‡Á‡ÌÌÓ„Ó ÓÍÌ‡§		m_ToolMap.erase(item);§	}§	else§	{§		//ENG: Search the tool to remove§		//RUS: œÓËÒÍ ËÌÒÚÛÏÂÌÚ‡ ‰Îˇ Û‰‡ÎÂÌËˇ§		arHotArea & hotarea = item->second;§		arHotArea::iterator iter;§		for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)§		{§			if ((*iter).rectBounds == *lpRectBounds)§			{§				//ENG: The tool was found§				//RUS: »ÌÒÚÛÏÂÌÚ Ì‡È‰ÂÌ§				if (hotarea.size() > 1)§				{§					//ENG: If the specified window has more one rectangle areas then removes the specified area only§					//RUS: ≈ÒÎË ÛÍ‡Á‡ÌÌÓÂ ÓÍÌÓ ÒÓ‰ÂÊËÚ ·ÓÎÂÂ Ó‰ÌÓÈ Ó·Î‡ÒÚË, ÚÓ Û‰‡ÎˇÂÏ ÚÓÎ¸ÍÓ ÛÍ‡Á‡ÌÌÛ˛ Ó·Î‡ÒÚ¸§					hotarea.erase(iter);§				}§				else§				{§					//ENG: If the specified window has one rectangle area only then removes the tool for specified window§					//RUS: ≈ÒÎË ÛÍ‡Á‡ÌÌÓÂ ÓÍÌÓ ËÏÂÂÚ ÚÓÎ¸ÍÓ Ó‰ÌÛ ÔˇÏÓÛ„ÓÎ¸ÌÛ˛ Ó·Î‡ÒÚ¸, ÚÓ Û‰‡ÎËÚ¸ ‚ÂÒ¸ ËÌÒÚÛÏÂÌÚ§					m_ToolMap.erase(item);§				} //if§				return;§			} //if§		} //for§	} //if§} //End of RemoveTool§§void CPPToolTip::RemoveDynamicTool(DynamicToolID tool) {§	CallBackMap::iterator it = m_dynamic_tools.find (tool);§	if (it != m_dynamic_tools.end ()) {§		m_dynamic_tools.erase (it);§	}§}§////////////////////////////////////////////////////////////////////§// CPPToolTip::RemoveAllTools()§//   Removes all tools from the collection of tools supported by a tooltip control.§////////////////////////////////////////////////////////////////////§void CPPToolTip::RemoveAllTools()§{§	TRACE (_T("CPPToolTip::RemoveAllTools()\n"));§§	//ENG: Removes all tools§	//RUS: ”‰‡ÎˇÂÏ ‚ÒÂ ËÌÒÚÛÏÂÌÚ˚§	if (m_ToolMap.size())§		m_ToolMap.clear();§§	//ENG: Removes all toolbars§	//RUS: ”‰‡ÎˇÂÏ ‚ÒÂ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§	if (m_wndToolBars.size())§		m_wndToolBars.clear();§§	m_dynamic_tools.clear ();§} //End of RemoveAllTools§§////////////////////////////////////////////////////////////////////§// CPPToolTip::AddToolBar()§// Registers a toolbar to the tooltip control.§//------------------------------------------------------------------§// Parameters:§//		pBar			- Pointer to the toolbar window.  §////////////////////////////////////////////////////////////////////§void CPPToolTip::AddToolBar(CToolBar * pBar)§{§	TRACE (_T("CPPToolTip::AddToolBar(hWnd=0x%08X)\n"), pBar->GetSafeHwnd());§	ASSERT(pBar);§§	//ENG: Gets HWND toolbar's window§	//RUS: œÓÎÛ˜‡ÂÏ HWND ÓÍÌ‡ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§	HWND hWnd = pBar->GetSafeHwnd();§§	//ENG: Searching a clone of a toolbar§	//RUS: œÓËÒÍ ‰Û·ÎËÍ‡Ú‡ ÛÍ‡Á‡ÌÌÓÈ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§	arToolBarWnd::iterator iter;§	for (iter = m_wndToolBars.begin(); iter != m_wndToolBars.end(); ++iter)§	{§		if (*iter == hWnd)§		{§			//ENG: A clone was found§			//RUS: ƒÛ·ÎËÍ‡Ú Ì‡È‰ÂÌ§			return;§		} //if§	} //for§§	//ENG: Stores HWND toolbar's window§	//RUS: «‡ÔÓÏËÌ‡ÂÏ HWND ÓÍÌ‡ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§	m_wndToolBars.push_back(hWnd);§§	//ENG: Disables a standard tooltip for the specified toolbar§	//RUS: «‡ÔÂ˘‡ÂÏ ÒÚ‡Ì‰‡ÚÌ˚Â ÔÓ‰ÒÍ‡ÁÍË ‰Îˇ ÛÍ‡Á‡ÌÓÈ Ô‡ÌÂÎË ËÌÒÚÛÏÂÌÚÓ‚§	DWORD dwStyles = pBar->GetBarStyle();§	dwStyles &= ~CBRS_TOOLTIPS;§	pBar->SetBarStyle(dwStyles);§} //End of AddToolBar§§§BOOL CPPToolTip::GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, LPCRECT lpRectBounds /* = NULL */)§{§	ASSERT(pWnd);§§	//ENG: Gets HWND of a window§	//RUS: œÓÎÛ˜‡ÂÏ HWND ÓÍÌ‡§	HWND hWnd = pWnd->GetSafeHwnd();	§	//ENG: Searching a specified HWND§	//RUS: »˘ÂÏ ÛÍ‡Á‡ÌÌ˚È HWND§	mapIter item = m_ToolMap.find(hWnd);	§	if (item == m_ToolMap.end())§	{§		//ENG: Specified HWND wasn't found§		//RUS: ”Í‡Á‡ÌÌ˚È HWND ÌÂ Ì‡È‰ÂÌ§		return FALSE; §	} //if§§	//ENG: Gets parameters of the tooltip§	//RUS: œÓÎÛ˜‡ÂÏ Ô‡‡ÏÂÚ˚ ÚÛÎÚËÔ‡§	arHotArea & hotarea = item->second;§§	//ENG: A tooltip has more one rectangle areas. Check all theirs§	//RUS: “ÛÎÚËÔ ÒÓ‰ÂÊËÚ ·ÓÎÂÂ Ó‰ÌÓÈ ÔˇÏÓÛ„ÓÎ¸ÌÓÈ Ó·Î‡ÒÚË, ÔÓ‚ÂËÏ ‚ÒÂı Ëı§	arHotArea::iterator iter;§	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)§	{§		if (lpRectBounds == (*iter).rectBounds)§		{§			//ENG: Specified window's rect already exist and so updates him§			//RUS: ”Í‡Á‡ÌÌ˚È ÔˇÏÓÛ„ÓÎ¸ÌËÍ ÓÍÌ‡ ÛÊÂ ÒÛ˘ÂÒÚ‚ÛÂÚ, ÔÓ˝ÚÓÏÛ ÔÓÒÚÓ Ó·ÌÓ‚ÎˇÂÏ Â„Ó Ô‡‡ÏÂÚ˚§			ti = *iter;§			return TRUE ;§		} //if§	} //for§	§	return FALSE;§}§§BOOL CPPToolTip::GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, DWORD dwIDTool /* = 0 */)§{§	ASSERT(pWnd);§§	//ENG: Gets HWND of a window§	//RUS: œÓÎÛ˜‡ÂÏ HWND ÓÍÌ‡§	HWND hWnd = pWnd->GetSafeHwnd();	§	//ENG: Searching a specified HWND§	//RUS: »˘ÂÏ ÛÍ‡Á‡ÌÌ˚È HWND§	mapIter item = m_ToolMap.find(hWnd);	§	if (item == m_ToolMap.end())§	{§		//ENG: Specified HWND wasn't found§		//RUS: ”Í‡Á‡ÌÌ˚È HWND ÌÂ Ì‡È‰ÂÌ§		return FALSE; §	} //if§§	//ENG: Gets parameters of the tooltip§	//RUS: œÓÎÛ˜‡ÂÏ Ô‡‡ÏÂÚ˚ ÚÛÎÚËÔ‡§	arHotArea & hotarea = item->second;§§	arHotArea::iterator iter;§	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)§	{§		if (dwIDTool == (*iter).nIDTool)§		{§			ti = *iter;§			return TRUE ;§		} //if§	} //for§	§	return FALSE;§}§§void CPPToolTip::UpdateTipText(LPCTSTR lpszText, CWnd * pWnd, DWORD dwIDTool /* = 0 */)§{§	PPTOOLTIP_INFO ti;§	if (GetToolInfo(ti, pWnd, dwIDTool))§	{§		ti.sTooltip = lpszText;§		AddTool(pWnd, ti);§	}§}§§void CPPToolTip::DelTool(CWnd * pWnd, DWORD dwIDTool)§{§	PPTOOLTIP_INFO ti;§	if (GetToolInfo(ti, pWnd, dwIDTool))§	{§		RemoveTool(pWnd, ti.rectBounds);§	}§}§§void CPPToolTip::SetToolRect(CWnd * pWnd, DWORD dwIDTool, LPCRECT lpRectBounds)§{§	PPTOOLTIP_INFO ti;§	if (GetToolInfo(ti, pWnd, dwIDTool))§	{§		ti.rectBounds = *lpRectBounds;§		AddTool(pWnd, ti);§	}§}§§////////////////////////////////////////////////////////////////////§// CPPToolTip::EnableHyperlink()§// Enables redrawing hyperlinks and hot areas.§////////////////////////////////////////////////////////////////////§void CPPToolTip::EnableHyperlink(BOOL bEnable /* = TRUE */)§{§	m_bHyperlinkEnabled = bEnable;§} //End of EnableHyperlink§§////////////////////////////////////////////////////////////////////§// CPPToolTip::SetCallbackHyperlink()§//   Sets the callback message that will be sent to the specified window §// if user clicks a hyperlink or hotareas with a msg parameter.§//------------------------------------------------------------------§// Parameters:§//		hWnd			- Handle of the window that will receive the callback message.§//						  Pass NULL to remove any previously specified callback message.§//		nMessage		- Callback message to send to window.§//		lParam			- A 32 bits user specified value that will be passed to the callback function.§//§// Remarks:§//    The callback function must be in the form:§//  LRESULT On_MenuCallback(WPARAM wParam, LPARAM lParam)§//		wParam			- Pointer to the string specified as parameter in <a msg=> tag.§//		lParam			- The 32 bits user specified value.§////////////////////////////////////////////////////////////////////§void CPPToolTip::SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam /* = 0 */)§{§	TRACE(_T("CPPToolTip::SetCallbackHyperlink()\n"));§	§	m_drawer.SetCallbackHyperlink(hWnd, nMessage, lParam);§} //End of SetCallbackHyperlink§§/////////////////////////////////////////////////////////////////////§// CPPToolTip::SetNotify()§// This function sets or removes the notification messages from the control before display.§//-------------------------------------------------------------------§// Parameters:§//		bParentNotify	- If TRUE the tooltip will be send the notification to parent window§//						  Else the notification will not send§//		hWnd			- If non-NULL the tooltip will be send the notification to specified window§//						  Else the notification will not send§///////////////////////////////////////////////////////////////////////§void CPPToolTip::SetNotify(BOOL bParentNotify /* = TRUE */)§{§	HWND hWnd = NULL;§	§	if (bParentNotify)§		hWnd = m_hParentWnd;§	§	SetNotify(hWnd);§} //End of SetNotify§§void CPPToolTip::SetNotify(HWND hWnd)§{§	TRACE(_T("CPPToolTip::SetNotify\n"));§	§	m_hNotifyWnd = hWnd;§} //End of SetNotify§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetSize()§//    Sets the specified size§//---------------------------------------------------------------------------§//  Parameters :§//		nSizeIndex		- index of the size. This parameter can be one §//						  of the following values:§//							PPTTSZ_ROUNDED_CX - The width of the ellipse used §//												to draw the rounded corners, in logical units.§//							PPTTSZ_ROUNDED_CY - The height of the ellipse used §//												to draw the rounded corners, in logical units.§//							PPTTSZ_MARGIN_CX  - The left and right margins of the tooltip's §//												text from the tooltip's edges. §//							PPTTSZ_MARGIN_CY  - The top and bottom margins of the tooltip's §//												text from the tooltip's edges.§//							PPTTSZ_WIDTH_ANCHOR - The width of the tooltip's anchor§//							PPTTSZ_HEIGHT_ANCHOR - The height of the tooltip's anchor §//							PPTTSZ_MARGIN_ANCHOR - The margin of the tooltip's anchor from §//												   his edge.§//							PPTTSZ_OFFSET_ANCHOR_CX - The horizontal offset of the tooltip's anchor§//													  from the hot spot of a cursor§//							PPTTSZ_OFFSET_ANCHOR_CY - The vertical offset of the tooltip's anchor§//													  from the hot spot of a cursor§//		nValue			- size's value§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetSize(int nSizeIndex, int nValue)§{§	TRACE(_T("CPPToolTip::SetSize(nSizeIndex = %d, nValue = %d)\n"), nSizeIndex, nValue);§	if (nSizeIndex >= PPTTSZ_MAX_SIZES)§		return;§§	m_nSizes [nSizeIndex] = nValue;§} //End of SetSize§§/////////////////////////////////////////////////////////////////////////////§//  CPPTootTip::GetSize()§//    Gets the specified size§//---------------------------------------------------------------------------§//  Parameters :§//		nSizeIndex		- An index of the sizes. See CPPToolTip::SetSize for a §//						  description of the valid values.§//  Returns :§//		size's value§//§/////////////////////////////////////////////////////////////////////////////§int CPPToolTip::GetSize(int nSizeIndex)§{§	TRACE(_T("CPPToolTip::GetSize(nSizeIndex = %d)\n"), nSizeIndex);§	if (nSizeIndex >= PPTTSZ_MAX_SIZES)§		return 0;§§	return m_nSizes [nSizeIndex];§} //End of GetSize§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetDefaultSizes()§//    Sets all sizes to default values§//---------------------------------------------------------------------------§//  Parameters:§//		bBalloonSize	- If TRUE all sizes will be sets for balloon tooltip§//						  otherwise tooltip will look as standard §/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetDefaultSizes(BOOL bBalloonSize /* = TRUE */)§{§	TRACE(_T("CPPToolTip::SetDefaultSizes()\n"));§§	if (bBalloonSize)§	{§		SetSize(PPTTSZ_ROUNDED_CX, 16);§		SetSize(PPTTSZ_ROUNDED_CY, 16);§		SetSize(PPTTSZ_MARGIN_CX, 12);§		SetSize(PPTTSZ_MARGIN_CY, 12);§		SetSize(PPTTSZ_WIDTH_ANCHOR, 12);§		SetSize(PPTTSZ_HEIGHT_ANCHOR, 16);§		SetSize(PPTTSZ_MARGIN_ANCHOR, 16);§		SetSize(PPTTSZ_OFFSET_ANCHOR_CX, 0);§		SetSize(PPTTSZ_OFFSET_ANCHOR_CY, 0);§	}§	else§	{§		SetSize(PPTTSZ_ROUNDED_CX, 0);§		SetSize(PPTTSZ_ROUNDED_CY, 0);§		SetSize(PPTTSZ_MARGIN_CX, 3);§		SetSize(PPTTSZ_MARGIN_CY, 1);§		SetSize(PPTTSZ_WIDTH_ANCHOR, 0);§		SetSize(PPTTSZ_HEIGHT_ANCHOR, 0);§		SetSize(PPTTSZ_MARGIN_ANCHOR, 0);§		SetSize(PPTTSZ_OFFSET_ANCHOR_CX, 0);§		SetSize(PPTTSZ_OFFSET_ANCHOR_CY, 0);§	} //if§} //End of SetDefaultSizes§§/////////////////////////////////////////////////////////////////////////////§// CPPToolTip::SetColorBk()§//   Sets background's colors §//---------------------------------------------------------------------------§//  Parameters:§//		color			- A solid color for background's effect §//		clrBegin		- A begin color for background's effect§//		clrMid			- A middle color for background's effect§//		clrEnd			- A end color for background's effect§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetColorBk(COLORREF color)§{§	SetColorBk(color, color, color);§} //End of SetColorBk§§void CPPToolTip::SetColorBk(COLORREF clrBegin, COLORREF clrEnd)§{§	SetColorBk(clrBegin, clrBegin, clrEnd);§} //End of SetColorBk§§void CPPToolTip::SetColorBk(COLORREF clrBegin, COLORREF clrMid, COLORREF clrEnd)§{§	m_clrBeginBk = clrBegin;§	m_clrMidBk = clrMid;§	m_clrEndBk = clrEnd;§} //End of SetColorBk§§/////////////////////////////////////////////////////////////////////////////§// CPPToolTip::SetEffectBk()§//   Sets a background's effect §//---------------------------------------------------------------------------§//  Parameters:§//		dwEffect		- A background's effect §//		nGranularity	- Adds an uniform noise to the effect. §//						  A good value is from 5 to 20; 0 to disable the effect. §//						  The noise has a positive effect because it hides the palette steps.§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetEffectBk(DWORD dwEffect, BYTE nGranularity /* = 5 */)§{§	m_dwEffectBk = dwEffect;§	m_nGranularity = nGranularity;§} //End of SetEffectBk§§/////////////////////////////////////////////////////////////////////////////§// CPPToolTip::SetBehaviour()§//   Sets a tooltip's behaviour §//---------------------------------------------------------------------------§//  Parameters:§//		dwBehaviour		- A tooltip's behaviour. 0 for normal tooltip without §//						  specific behaviours. This parameter can be any combination §//						  of CPPToolTip behaviours:§//							PPTOOLTIP_MULTIPLE_SHOW		- Multiple show for single control§//							PPTOOLTIP_TRACKING_MOUSE	- Tracking for mouse§//							PPTOOLTIP_CLOSE_LEAVEWND	- Close tooltip if mouse leave the control§//							PPTOOLTIP_NOCLOSE_OVER		- No close tooltip if mouse over him§//							PPTOOLTIP_DISABLE_AUTOPOP	- Disables autopop tooltip from timer§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetBehaviour(DWORD dwBehaviour /* = 0 */)§{§	m_dwBehaviour = dwBehaviour;§} //End of SetBehaviour§§/////////////////////////////////////////////////////////////////////////////§// CPPToolTip::GetBehaviour()§//   Gets a tooltip's behaviour §//---------------------------------------------------------------------------§// Return value:§//		A tooltip's behaviour. See CPPToolTip::SetBehaviour for a description of the §//	valid values.§/////////////////////////////////////////////////////////////////////////////§DWORD CPPToolTip::GetBehaviour()§{§	return m_dwBehaviour;§} //End of GetBehaviour§§/////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetDelayTime()§//   Call this function to set the delay time for a tooltip control. §// The delay time is the length of time the cursor must remain on a tool §// before the tooltip window appears. The default delay time is 500 milliseconds.§//-------------------------------------------------------------------§// Parameters:§//		dwDuration		- Flag that specifies which duration value will be retrieved. §//						  This parameter can be one of the following values:§//							PPTOOLTIP_TIME_AUTOPOP  - Retrieve the length of time the tooltip §//													  window remains visible if the pointer is §//													  stationary within a tool's bounding rectangle. §//							PPTOOLTIP_TIME_INITIAL  - Retrieve the length of time the pointer §//			 										  must remain stationary within a tool's bounding §//													  rectangle before the tool tip window appears. §//							PPTOOLTIP_TIME_FADEIN	- Retrieve the length of time for each step of§//													  fade-in effect§//							PPTOOLTIP_TIME_FADEOUT	- Retrieve the length of time for each step of§//													  fade-out effect§//							PPTOOLTIP_TIME_ANIMATION  Retrieve the speed for the animation§//						  For compatibility with 1.x versions of CPPToolTip a following values§//						  are available also:§//							TTDT_AUTOPOP			- Same PPTOOLTIP_TIME_AUTOPOP §//							TTDT_INITIAL			- Same PPTOOLTIP_TIME_INITIAL §//		nTime			- The specified delay time, in milliseconds.§/////////////////////////////////////////////////////////////////////§void CPPToolTip::SetDelayTime(DWORD dwDuration, DWORD dwTime)§{§	switch (dwDuration)§	{§	case PPTOOLTIP_TIME_AUTOPOP:§		m_dwTimeAutoPop = dwTime;§		break;§	case PPTOOLTIP_TIME_INITIAL:§		m_dwTimeInitial = dwTime;§		break;§	case PPTOOLTIP_TIME_FADEIN:§		m_dwTimeFadeIn = dwTime;§		break;§	case PPTOOLTIP_TIME_FADEOUT:§		m_dwTimeFadeOut = dwTime;§		break;§	case PPTOOLTIP_TIME_ANIMATION:§		KillTimer(TIMER_ANIMATION);§		if (dwTime)§			SetTimer(TIMER_ANIMATION, dwTime, NULL);§		break;§	}§} //End of SetDelayTime§§/////////////////////////////////////////////////////////////////////§// CPPToolTip::GetDelayTime()§// Retrieves the initial, pop-up, and reshow durations currently set §// for a CPPToolTip control§//-------------------------------------------------------------------§// Parameters:§//		dwDuration		- Flag that specifies which duration value will be retrieved. §//						  See CPPToolTip::SetDelayTime for a description of the valid values. §// Return value:§//	The specified delay time, in milliseconds§///////////////////////////////////////////////////////////////////////§DWORD CPPToolTip::GetDelayTime(DWORD dwDuration) const§{§	DWORD dwTime = 0;§	switch (dwDuration)§	{§	case PPTOOLTIP_TIME_AUTOPOP:§		dwTime = m_dwTimeAutoPop;§		break;§	case PPTOOLTIP_TIME_INITIAL:§		dwTime = m_dwTimeInitial;§		break;§	case PPTOOLTIP_TIME_FADEIN:§		dwTime = m_dwTimeFadeIn;§		break;§	case PPTOOLTIP_TIME_FADEOUT:§		dwTime = m_dwTimeFadeOut;§		break;§	}§§	return dwTime;§} //End of GetDelayTime§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetDirection()§//    Sets a placement of the tooltip's anchor§//---------------------------------------------------------------------------§//  Parameters :§//		dwDirection		- A placement of the tooltip's anchor. This parameter §//					      can be one of the following values:§//							PPTOOLTIP_TOPEDGE_LEFT			- A left corner of the top edge§//							PPTOOLTIP_TOPEDGE_RIGHT			- A right corner of the top edge§//							PPTOOLTIP_TOPEDGE_CENTER		- By center of the top edge§//							PPTOOLTIP_BOTTOMEDGE_LEFT		- A left corner of the bottom edge§//							PPTOOLTIP_BOTTOMEDGE_RIGHT		- A right corner of the bottom edge§//							PPTOOLTIP_BOTTOMEDGE_CENTER		- By center of the bottom edge§//							PPTOOLTIP_LEFTEDGE_TOP			- A top corner of the left edge§//							PPTOOLTIP_LEFTEDGE_BOTTOM		- A bottom corner of the left edge§//							PPTOOLTIP_LEFTEDGE_VCENTER		- By center of the left edge§//							PPTOOLTIP_RIGHTEDGE_TOP			- A top corner of the right edge§//							PPTOOLTIP_RIGHTEDGE_BOTTOM		- A bottom corner of the right edge§//							PPTOOLTIP_RIGHTEDGE_VCENTER		- By center of the right edge§//						  For compatibility with 1.x versions of CPPToolTip a following values§//						  are available also:§//							PPTOOLTIP_LEFT_TOP				- Same PPTOOLTIP_TOPEDGE_LEFT§//							PPTOOLTIP_RIGHT_TOP				- Same PPTOOLTIP_TOPEDGE_RIGHT§//							PPTOOLTIP_LEFT_BOTTOM			- Same PPTOOLTIP_BOTTOMEDGE_LEFT§//							PPTOOLTIP_RIGHT_BOTTOM			- Same PPTOOLTIP_BOTTOMEDGE_RIGHT§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetDirection(DWORD dwDirection /* = PPTOOLTIP_BOTTOMEDGE_LEFT */)§{§	TRACE(_T("CPPToolTip::SetDirection(nDirection = %d)\n"), dwDirection);§§	m_dwDirection = dwDirection;§} //End of SetDirection	§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::GetDirection()§//    Gets a placement of the tooltip's anchor§//---------------------------------------------------------------------------§//  Returns :§//	  A placement of the tooltip's anchor. See CPPToolTip::SetDirection for a description of §//	the valid values.§/////////////////////////////////////////////////////////////////////////////§DWORD CPPToolTip::GetDirection()§{§	TRACE(_T("CPPToolTip::GetDirection()\n"));§§	return m_dwDirection;§} //End of GetDirection§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetTextStyles()§//    Applies a CSS-like style for the tooltip's HTML§//---------------------------------------------------------------------------§//  Parameters:§//		lpszStyleName	- Pointer to a null-terminated string that specifies§//						  a name of CSS style§//		lpszStyleValue  - Pointer to a null-terminated string that specifies §//						  CSS-lite style for drawing a tooltip text.§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue)§{§	m_drawer.SetTextStyle(lpszStyleName, lpszStyleValue);§}§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetCssStyles()§//    Applies a CSS-like styles for the tooltip's HTML§//---------------------------------------------------------------------------§//  Parameters:§//		lpszCssStyles	- Pointer to a null-terminated string that specifies §//						  CSS-lite styles for drawing a tooltip text.§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetCssStyles(LPCTSTR lpszCssStyles /* = NULL */)§{§	m_drawer.SetCssStyles(lpszCssStyles);§} //End of SetCssStyles§§///////////////////////////////////////////////////////////////////////////// §//  CPPToolTip::SetCssStyles() §//    Applies a CSS-like styles for the tooltip's HTML §//--------------------------------------------------------------------------- §//  Parameters: §//      dwIdCssStyle    - ID of string resource §//      lpszPathDll		- §///////////////////////////////////////////////////////////////////////////// §void CPPToolTip::SetCssStyles(DWORD dwIdCssStyle, LPCTSTR lpszPathDll /* = NULL */) §{ §    m_drawer.SetCssStyles(dwIdCssStyle, lpszPathDll); §} //End of SetCssStyles§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::GetCssStyles()§//    Applies a CSS-like styles for the tooltip's HTML§//---------------------------------------------------------------------------§//  Return value:§//		Pointer to a null-terminated string that specifies CSS-lite styles §//  for drawing a tooltip text.§/////////////////////////////////////////////////////////////////////////////§LPCTSTR CPPToolTip::GetCssStyles()§{§	return m_drawer.GetCssStyles();§} //End of GetCssStyles§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetDebugMode()§//    Sets a debug mode. In this mode tooltip will display for any control§// and will contain debug info about control.§//---------------------------------------------------------------------------§//  Parameters:§//		bDebug			- TRUE set a debug mode.§/////////////////////////////////////////////////////////////////////////////§void CPPToolTip::SetDebugMode(BOOL bDebug /* = TRUE */)§{§	m_bDebugMode = bDebug;§} //End of SetDebugMode§§////////////////////////////////////////////////////////////////////§// CPPToolTip::ShowHelpTooltip()§// Shows the help tooltip in any place of screen.§//------------------------------------------------------------------§// Parameters:§//		pt				- Pointer to a POINT structure that receives the screen coordinates of the tooltip's anchor  §//		lpszString		- Pointer to the text for the help tooltip. §//      dwIdString		- ID of string resource§//		hIcon			- Handle of the icon§//		dwIdIcon		- ID of icon resource§//		szIcon			- Specifies the width and the height, in pixels, of the icon to load.§//		ti				- Reference to PPTOOLTIP_INFO structure containing the parameters of the tooltip §////////////////////////////////////////////////////////////////////§void CPPToolTip::ShowHelpTooltip(LPPOINT pt, DWORD dwIdText, HICON hIcon /* = NULL */)§{§	CString str;§	str.LoadString(dwIdText);§	ShowHelpTooltip(pt, (LPCTSTR)str, hIcon);§} //End ShowHelpTooltip§§void CPPToolTip::ShowHelpTooltip(LPPOINT pt, DWORD dwIdText, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */)§{§	CString str;§	str.LoadString(dwIdText);§	ShowHelpTooltip(pt, (LPCTSTR)str, dwIdIcon, szIcon);§} //End ShowHelpTooltip§§void CPPToolTip::ShowHelpTooltip(LPPOINT pt, LPCTSTR lpszString, HICON hIcon /* = NULL */)§{§	PPTOOLTIP_INFO ti;§	if (NULL == hIcon)§	{§		ti.sTooltip = (CString)lpszString;§	}§	else§	{§		ti.sTooltip.Format(_T("<table><tr><td><icon handle=0x%X></td><td>%s</td></tr></table>"), §							hIcon, lpszString);§	} //if§	§	ti.nMask = 0;§	ShowHelpTooltip(pt, ti);§} //End ShowHelpTooltip§§void CPPToolTip::ShowHelpTooltip(LPPOINT pt, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */)§{§	CString str;§	str.Format(_T("<table><tr><td><icon idres=%d width=%d height=%d></td><td>%s</td></tr></table>"), §		dwIdIcon, szIcon.cx, szIcon.cy, lpszString);§	ShowHelpTooltip(pt, (LPCTSTR)str);§} //End ShowHelpTooltip§§void CPPToolTip::ShowHelpTooltip(LPPOINT pt, PPTOOLTIP_INFO & ti)§{§	TRACE(_T("CPPToolTip::ShowHelpTooltip\n"));§§	m_ptOriginal = CPoint(pt->x, pt->y);§	ti.nBehaviour = m_dwBehaviour | PPTOOLTIP_DISABLE_AUTOPOP;§	ti.nMask = PPTOOLTIP_MASK_BEHAVIOUR;§	SetNewTooltip(NULL, 0, ti, FALSE, PPTOOLTIP_HELP);§} //End ShowHelpTooltip§§////////////////////////////////////////////////////////////////////§// CPPToolTip::SetBorder()§// Sets a border of the tooltip.§//------------------------------------------------------------------§// Parameters:§//		color			- Color of the tooltip's border§//		hbr				- Brush for drawing tooltip's border§//      nWidth			- A width of the brush§//		nHeight			- A height of the brush§////////////////////////////////////////////////////////////////////§void CPPToolTip::SetBorder(COLORREF color, int nWidth /* = 1 */, int nHeight /* = 1 */)§{§	HBRUSH hbr = ::CreateSolidBrush(color);§	SetBorder(hbr, nWidth, nHeight);§} //End of SetBorder§§void CPPToolTip::SetBorder(HBRUSH hbr, int nWidth /* = 1 */, int nHeight /* = 1 */)§{§	HideBorder();§	if (nWidth && nHeight && (NULL != hbr))§	{§		m_hbrBorder = hbr;§		m_szBorder.cx = nWidth;§		m_szBorder.cy = nHeight;§	} //if§} //End of SetBorder§§////////////////////////////////////////////////////////////////////§// CPPToolTip::HideBorder()§// Hides border of the tooltip.§////////////////////////////////////////////////////////////////////§void CPPToolTip::HideBorder()§{§	if (NULL != m_hbrBorder)§	{§		::DeleteObject(m_hbrBorder);§		m_hbrBorder = NULL;§	} //if§	m_szBorder.cx = 0;§	m_szBorder.cy = 0;§} //End of HideBorder§§////////////////////////////////////////////////////////////////////////////////§// Begin of the menu methods block. Build-in support for menu§#ifdef PPTOOLTIP_USE_MENU§//////////////////§// Need to handle WM_ENTERIDLE to cancel the tip if the user §// moved the mouse off the popup menu. For main menus, Windows §// will send a WM_MENUSELECT message for the parent menu when §// this happens, but for context menus there's no other way to §// know the user moved the mouse off the menu.§//§void CPPToolTip::OnEnterIdle(UINT nWhy, CWnd* pWho)§{§	if ((MSGF_MENU == nWhy))§	{§		if (m_nTooltipType == PPTOOLTIP_MENU)§		{§			if (PPTOOLTIP_STATE_SHOWN == m_nTooltipState)§			{§				CPoint pt;§				GetCursorPos(&pt);§				if (pWho->GetSafeHwnd() != ::WindowFromPoint(pt)) §				{§					HideTooltip();§				} //if§			} //if§		} //if§	} //if§} //End of OnEnterIdle§§void CPPToolTip::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSubMenu)§{§	if (((nFlags & 0xFFFF) == 0xFFFF) || (nFlags & MF_POPUP) || (nFlags & MF_SEPARATOR))§	{§		//HideTooltip();§		Pop();§	} §	else if (nItemID && hSubMenu) §	{§		HWND hwndMenu = GetRunningMenuWnd(); //CWnd::WindowFromPoint(pt);§		if (NULL != hwndMenu)§		{§			CRect rcMenu;§			::GetWindowRect(hwndMenu, rcMenu); // whole menu rect§			§			// find Item Rectangle and position§			int count = ::GetMenuItemCount(hSubMenu);§			int cy = rcMenu.top + GetSystemMetrics(SM_CYEDGE) + 1;§			for(int nItem = 0; nItem < count; nItem++) §			{§				CRect rect;§				::GetMenuItemRect(m_hParentWnd, hSubMenu, nItem, &rect);§				if(nItemID == ::GetMenuItemID(hSubMenu, nItem)) §				{§					UINT nState = GetMenuState(hSubMenu, nItemID, MF_BYCOMMAND);§					CString str;§					if (MF_DISABLED & nState)§						str = m_drawer.GetResCommandPrompt(nItemID, 2); //String for disabled item§					else§						str = m_drawer.GetResCommandPrompt(nItemID, 0);§§					CPoint pt;§					// found menu item: adjust rectangle to right and down§					pt.x = rcMenu.left;§					pt.y = cy;§					if (m_dwMenuToolPos & PPTOOLTIP_MENU_CENTER)§						pt.x += rect.Width() / 2;§					else if (m_dwMenuToolPos & PPTOOLTIP_MENU_RIGHT)§						pt.x += rect.Width();§					§					if (m_dwMenuToolPos & PPTOOLTIP_MENU_VCENTER)§						pt.y += rect.Height() / 2;§					else if (m_dwMenuToolPos & PPTOOLTIP_MENU_BOTTOM)§						pt.y += rect.Height();§§					PPTOOLTIP_INFO ti;§					ti.rectBounds = rect;§					ti.nMask = 0;§					ti.sTooltip = str;§					m_nNextTooltipType = PPTOOLTIP_MENU;§					m_ptOriginal = pt;§					SetNewTooltip(hwndMenu, 0, ti, TRUE, PPTOOLTIP_MENU);§§					return;§				} //if§				cy += rect.Height(); // add height§			} //for§		} //if§		//ENG: Menu item was not found§		//RUS: ›ÎÂÏÂÌÚ ÏÂÌ˛ ÌÂ Ì‡È‰ÂÌ.§		Pop();§	} //if§} //End of OnMenuSelect§§////////////////////////////////////////////////////////////////////§// CPPToolTip::GetRunningMenuWnd()§// Get running menu window.§////////////////////////////////////////////////////////////////////§HWND CPPToolTip::GetRunningMenuWnd()§{§	HWND hwnd = NULL;§	EnumWindows(MyEnumProc,(LPARAM)&hwnd);§	return hwnd;§} //End of GetRunningMenuWnd§§////////////////////////////////////////////////////////////////////§// CPPToolTip::MenuToolPosition()§// Sets a position of the tooltip's anchor about menu item.§//------------------------------------------------------------------§// Parameters:§//		nPos			- A tooltip's position. This parameter can be any combination §//						  of single horizontal value and single vertical value of CPPToolTip:§//							--- Horizontal position ---§//							PPTOOLTIP_MENU_LEFT		0x00§//							PPTOOLTIP_MENU_RIGHT	0x01§//							PPTOOLTIP_MENU_CENTER	0x02§//							--- Vertical position ---§//							PPTOOLTIP_MENU_TOP		0x00§//							PPTOOLTIP_MENU_BOTTOM	0x10§//							PPTOOLTIP_MENU_VCENTER  0x20§////////////////////////////////////////////////////////////////////§void CPPToolTip::MenuToolPosition(DWORD nPos /* = PPTOOLTIP_MENU_LEFT | PPTOOLTIP_MENU_TOP */)§{§	m_dwMenuToolPos = nPos;§} //End of MenuToolPosition§§// End of menu methods block§///////////////////////////////////////////////////////////§#endif //PPTOOLTIP_USE_MENU§§////////////////////////////////////////////////////////////////////§// CPPToolTip::EnableEscapeSequences()§//		Enables the escape sequences. If the escape sequences was disabled§//	HTML-lite compiler will ignore the codes less then 0x20 (such \n, \r, \t).§////////////////////////////////////////////////////////////////////§void CPPToolTip::EnableEscapeSequences(BOOL bEnable)§{§	m_drawer.EnableEscapeSequences(bEnable);§} //End of EnableEscapeSequences§§////////////////////////////////////////////////////////////////////§// CPPToolTip::SetImageList()§//		Sets an image list for using it into the HTML string with <ilst> tag.§//------------------------------------------------------------------§// Parameters:§//		nIdBitmap		- Resource IDs of the bitmap to be associated with the image list.§//		hBitmap			- Handle of the bitmap to be associated with the image list.§//      cx				- Dimensions of each image, in pixels.§//		cy				- Dimensions of each image, in pixels.§//		nCount			- The number of images in the image list§//		crMask			- Color used to generate a mask. Each pixel of this color in §//						  the specified bitmap is changed to transparent, and the §//						  corresponding bit in the mask is set to one.§////////////////////////////////////////////////////////////////////§void CPPToolTip::SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)§{§	m_drawer.SetImageList(nIdBitmap, cx, cy, nCount, crMask);§} //End of SetImageList§§void CPPToolTip::SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)§{§	m_drawer.SetImageList(hBitmap, cx, cy, nCount, crMask);§} //End of SetImageList§§////////////////////////////////////////////////////////////////////§// CPPToolTip::SetTransparency()§//		Sets a transparency of the tooltip.§//------------------------------------------------------------------§// Parameters:§//		nTransparency	- A transparency value to be used on the tooltip. §//						  The default 0 assumes that your tooltip is opaque and 0xFF (255) §//						  for full transparency of the tooltip.§////////////////////////////////////////////////////////////////////§void CPPToolTip::SetTransparency(BYTE nTransparency /* = 0 */) §{§	if (nTransparency <= PERCENT_MAX_TRANSPARENCY)§		m_nTransparency = nTransparency;§} //End of SetTransparency§§////////////////////////////////////////////////////////////////////§// CPPToolTip::SetTooltipShadow()§//		Sets a tooltip's shadow.§//------------------------------------------------------------------§// Parameters:§//		nOffsetX, §//		nOffsetY		- The offsets of the tooltip's shadow from the tooltip's window.§//		nDarkenPercent	- So far as colors under the shadow will be darken (0 - 100)§//      bGradient		- TRUE to use a gradient shadow.§//		nDepthX,§//		nDepthY			- The gradient depths of the tooltip's shadow.§////////////////////////////////////////////////////////////////////§void CPPToolTip::SetTooltipShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent /* = 50 */, §								  BOOL bGradient /* = TRUE */, int nDepthX /* = 7 */, int nDepthY /* = 7 */)§{§	m_szOffsetShadow.cx = nOffsetX;§	m_szOffsetShadow.cy = nOffsetY;§	m_szDepthShadow.cx = nDepthX;§	m_szDepthShadow.cy = nDepthY;§	m_nDarkenShadow = std::min(100, (int)nDarkenPercent);§	m_bGradientShadow = bGradient;§} //End of SetTooltipShadow§§void CPPToolTip::SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent /* = 50 */, §					BOOL bGradient /* = TRUE */, int nDepthX /* = 7 */, int nDepthY /* = 7 */)§{§	m_drawer.SetImageShadow(nOffsetX, nOffsetY, nDarkenPercent, bGradient, nDepthX, nDepthY);§} //End of SetImageShadow§§//#UC END# *4700B6AC00CB*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B6AC00CB_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB_DESTR_BODY*§	FreeResources();§	RemoveAllTools();§	HideBorder();§	//#UC END# *4700B6AC00CB_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B6AC00CB_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB_CUSTOM_INCLUDES*§#include "shared/WinGUI/Controls/CPPHtmlDrawer.h"§#include <vector>§#include <map>§#include <afxext.h>§#include "boost/function.hpp"§//ENG: Comments a next line if you never use a tooltip for a menu§//RUS: «‡ÍÓÏÂÌÚËÛÈÚÂ ÒÎÂ‰Û˛˘Û˛ ÒÚÓÍÛ, ÂÒÎË ‚˚ ÌÂ ÔÎ‡ÌËÛÂÚÂ ËÒÔÓÎ¸ÁÓ‚‡Ú¸ ÚÛÎÚËÔ ‰Îˇ ˝ÎÂÏÂÌÚÓ‚ ÏÂÌ˛§#define PPTOOLTIP_USE_MENU§§#define PPTOOLTIP_CLASSNAME    _T("CPPToolTip")  // Window class name§§//The §#define UDM_TOOLTIP_FIRST		   (WM_USER + 100)§#define UDM_TOOLTIP_DISPLAY		   (UDM_TOOLTIP_FIRST) //User was changed the data§#define UDM_TOOLTIP_REPAINT		   (UDM_TOOLTIP_FIRST + 1)§#define UDM_TOOLTIP_HIDING		   (UDM_TOOLTIP_FIRST + 2)§§//The behaviours§#define PPTOOLTIP_MULTIPLE_SHOW			0x00000001 //Multiple show for single control§#define PPTOOLTIP_TRACKING_MOUSE		0x00000002 //Tracking for mouse§#define PPTOOLTIP_CLOSE_LEAVEWND		0x00000004 //Close tooltip if mouse leave the control§#define PPTOOLTIP_NOCLOSE_OVER			0x00000008 //No close tooltip if mouse over him§#define PPTOOLTIP_DISABLE_AUTOPOP		0x00000010 //Disables autopop tooltip from timer§//#define PPTOOLTIP_NOCLOSE_MOUSEDOWN		0x00000020 //Disables autopop tooltip from timer§§//The masks§#define PPTOOLTIP_MASK_STYLES			0x0001	// The styles for the tooltip gets from the structures§#define PPTOOLTIP_MASK_EFFECT			0x0002	// The background's type for the tooltip gets from the structures§#define PPTOOLTIP_MASK_COLORS			0x0004	// The background's colors for the tooltip gets from the structures§#define PPTOOLTIP_MASK_DIRECTION		0x0008  // The align for the tooltip gets from the structures§#define PPTOOLTIP_MASK_BEHAVIOUR		0x0010  // The behaviour for the tooltip gets from the structures§#define PPTOOLTIP_MASK_TRANSPARENCY		0x0020  // §§//The constants of the timers§#define PPTOOLTIP_TIME_INITIAL			TTDT_INITIAL§#define PPTOOLTIP_TIME_AUTOPOP			TTDT_AUTOPOP§#define PPTOOLTIP_TIME_FADEIN			4§#define PPTOOLTIP_TIME_FADEOUT			5§#define PPTOOLTIP_TIME_ANIMATION		6§§//Tooltip's directions§#define PPTOOLTIP_TOPEDGE_LEFT			0x00§#define PPTOOLTIP_TOPEDGE_RIGHT			0x01§#define PPTOOLTIP_TOPEDGE_CENTER		0x02§#define PPTOOLTIP_BOTTOMEDGE_LEFT		0x10§#define PPTOOLTIP_BOTTOMEDGE_RIGHT		0x11§#define PPTOOLTIP_BOTTOMEDGE_CENTER		0x12§#define PPTOOLTIP_LEFTEDGE_TOP			0x20§#define PPTOOLTIP_LEFTEDGE_BOTTOM		0x21§#define PPTOOLTIP_LEFTEDGE_VCENTER		0x22§#define PPTOOLTIP_RIGHTEDGE_TOP			0x30§#define PPTOOLTIP_RIGHTEDGE_BOTTOM		0x31§#define PPTOOLTIP_RIGHTEDGE_VCENTER		0x32§//----- Old version (1.x) ---------§#define PPTOOLTIP_LEFT_TOP				PPTOOLTIP_TOPEDGE_LEFT§#define PPTOOLTIP_RIGHT_TOP				PPTOOLTIP_TOPEDGE_RIGHT§#define PPTOOLTIP_LEFT_BOTTOM			PPTOOLTIP_BOTTOMEDGE_LEFT§#define PPTOOLTIP_RIGHT_BOTTOM			PPTOOLTIP_BOTTOMEDGE_RIGHT§§#ifdef PPTOOLTIP_USE_MENU§//ENG: Anchor's position about a menu item§//RUS: ¬˚‡‚ÌË‚‡ÌËÂ ÍÓÌ˜ËÍ‡ ÚÛÎÚËÔ‡ ÓÚÌÓÒËÚÂÎ¸ÌÓ ˝ÎÂÏÂÌÚ‡ ÏÂÌ˛§#define PPTOOLTIP_MENU_LEFT		0x00§#define PPTOOLTIP_MENU_RIGHT	0x01§#define PPTOOLTIP_MENU_CENTER	0x02§#define PPTOOLTIP_MENU_TOP		0x00§#define PPTOOLTIP_MENU_BOTTOM	0x10§#define PPTOOLTIP_MENU_VCENTER  0x20§§#define PPTOOLTIP_MENU_HMASK	0x0F§#define PPTOOLTIP_MENU_VMASK	0xF0§#endif //PPTOOLTIP_USE_MENU§§// This info structure§typedef struct tagPPTOOLTIP_INFO§{§    UINT		nIDTool;		// ID of tool   §    CRect		rectBounds;		// Bounding rect for toolinfo to be displayed§	CString		sTooltip;		// The string of the tooltip§	UINT        nMask;			// The mask §	UINT		nStyles;		// The tooltip's styles§	UINT        nDirection;		// Direction display the tooltip relate cursor point§	UINT		nEffect;		// The color's type or effects§	UINT        nBehaviour;		// The tooltip's behaviour§	BYTE        nGranularity;	// The effect's granularity§	BYTE        nTransparency;	// The factor of the window's transparency (0-100)§	COLORREF	crBegin;		// Begin Color§	COLORREF    crMid;			// Mid Color§	COLORREF	crEnd;			// End Color§} PPTOOLTIP_INFO;§§// This structure sent to PPTooltip parent in a WM_NOTIFY message§typedef struct tagNM_PPTOOLTIP_DISPLAY {§    NMHDR hdr;§	HWND hwndTool;§	LPPOINT pt;§	PPTOOLTIP_INFO * ti;§} NM_PPTOOLTIP_DISPLAY;§//#UC END# *4700B6AC00CB_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B6AC00CB*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB*§public:§	BOOL Create(CWnd* pParentWnd, BOOL bBalloon = TRUE);§§	CPPToolTip();§§// Attributes§public:§	enum {	PPTTSZ_ROUNDED_CX = 0,§			PPTTSZ_ROUNDED_CY,§			PPTTSZ_MARGIN_CX,§			PPTTSZ_MARGIN_CY,§			PPTTSZ_WIDTH_ANCHOR,§			PPTTSZ_HEIGHT_ANCHOR,§			PPTTSZ_MARGIN_ANCHOR,§			PPTTSZ_OFFSET_ANCHOR_CX,§			PPTTSZ_OFFSET_ANCHOR_CY,§§			PPTTSZ_MAX_SIZES§		};§§	enum {	SHOWEFFECT_NONE = 0,§			SHOWEFFECT_FADEINOUT,§			§			SHOWEFFECT_MAX§		};§	§	typedef boost::function<bool (PPTOOLTIP_INFO & ti)> ExternalFindCallback;§	typedef void* DynamicToolID;§	// Operations§protected:§	enum TooltipState {  §			PPTOOLTIP_STATE_HIDEN = 0,§			PPTOOLTIP_STATE_SHOWING,§			PPTOOLTIP_STATE_SHOWN,§			PPTOOLTIP_STATE_HIDING§		};§§	enum TooltipType {§			PPTOOLTIP_NORMAL = 0,§			PPTOOLTIP_HELP,§			PPTOOLTIP_MENU§		};§§	CPPHtmlDrawer m_drawer; //HTML drawer object§	§	HWND m_hParentWnd; // The handle of the parent window§	HWND m_hNotifyWnd; // The handle of the notified window§§	BOOL m_bHyperlinkEnabled;§	BOOL m_bDebugMode;§§	POINT m_ptOriginal;§§	// Info about last displayed tool§	HWND  m_hwndDisplayedTool;§	DynamicToolID m_last_dynamic_tool;§§	TooltipType m_nTooltipType;§	PPTOOLTIP_INFO m_tiDisplayed; //Info about displayed tooltip§§	// Info about last displayed tool§	BOOL  m_bDelayNextTool;§	BOOL  m_bNextToolExist;§	HWND  m_hwndNextTool;§	DynamicToolID  m_next_dynamic_tool;§§	TooltipType m_nNextTooltipType;§	PPTOOLTIP_INFO m_tiNextTool; //Info about next tooltip§	§	// Info about current tool§	CRect m_rcCurTool;§	DWORD m_dwCurDirection;§	BYTE  m_dwCurTransparency;§	TooltipState  m_nTooltipState;§§	//Colors§	COLORREF m_clrBeginBk;§	COLORREF m_clrMidBk;§	COLORREF m_clrEndBk;§§	//Background§	HBITMAP m_hBitmapBk; //A bitmap with tooltip's background only§	HBITMAP m_hUnderTooltipBk;§§	//Border of the tooltip§	HBRUSH m_hbrBorder;§	SIZE m_szBorder;§§	//Shadow of the tooltip§	BOOL m_bGradientShadow;§	SIZE m_szOffsetShadow;§	SIZE m_szDepthShadow;§	BYTE m_nDarkenShadow;§§	HRGN m_hrgnTooltip;§§	//Default values for the window§	DWORD m_dwTimeAutoPop; //Retrieve the length of time the tool tip window remains visible if the pointer is stationary within a tool's bounding rectangle§	DWORD m_dwTimeInitial; //Retrieve the length of time the pointer must remain stationary within a tool's bounding rectangle before the tool tip window appears§	DWORD m_dwTimeFadeIn;§	DWORD m_dwTimeFadeOut;§§	DWORD m_dwBehaviour;   //The tooltip's behaviour§	DWORD m_dwEffectBk;§	DWORD m_dwDirection;   //The default tooltip's direction§	DWORD m_dwStyles;§	BYTE  m_nGranularity;§	BYTE  m_nTransparency; //The current value of transparency§	DWORD m_dwShowEffect; //§	DWORD m_dwHideEffect;§	int  m_nSizes [PPTTSZ_MAX_SIZES]; //All sizes §§#ifdef PPTOOLTIP_USE_MENU§	DWORD m_dwMenuToolPos;§#endif //PPTOOLTIP_USE_MENU§§	//§	CRect m_rcTipArea; //The bound rect around the tip's area in the client coordinates.§	CRect m_rcTooltip; //The bound rect around the body of the tooltip in the client coordinates.§	CRect m_rcBoundsTooltip; //The bound rect around a tooltip include an anchor§	CRect m_rcUnderTooltip;  //The bound rect of the window under the tooltip in the screen coordinates§§	//Initialize tools§	typedef std::vector<PPTOOLTIP_INFO>	arHotArea; // array of Tips rectangular spots§	typedef std::map<HWND, arHotArea>::iterator	mapIter;	// simplify reading§	std::map<HWND, arHotArea>	m_ToolMap;§§	//Initialize list of toolbars§	typedef std::vector<HWND>	arToolBarWnd;§	arToolBarWnd m_wndToolBars;  // array of HWND of the toolbars§§	//Initializes external tools§	typedef std::map<DynamicToolID, ExternalFindCallback> CallBackMap;§	CallBackMap m_dynamic_tools; //dynamic tools - ÓÔÂ‰ÂÎˇ˛Ú ‚ÓÁÏÓÊÌÓÒÚ¸ ÔÓÍ‡Á‡§								  //ÚÛÎÚËÔ‡ Ì‡ ÓÒÌÓ‚Â callback'‡§§// Overrides§	// ClassWizard generated virtual function overrides§	//{{AFX_VIRTUAL(CPPToolTip)§	public:§	virtual BOOL PreTranslateMessage(MSG* pMsg);§	virtual BOOL DestroyWindow();§	//}}AFX_VIRTUAL§§// Implementation§public:§	BOOL RelayEvent(MSG* pMsg);§§	//Tools§	void AddToolBar(CToolBar * pBar);§	void AddTool(CWnd * pWnd, DWORD dwIdString, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	void AddTool(CWnd * pWnd, LPCTSTR lpszString = NULL, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	void AddTool(CWnd * pWnd, PPTOOLTIP_INFO & ti);§	//To compatible with old version of CPPToolTip§	void AddTool(CWnd * pWnd, DWORD dwIdString, HICON hIcon, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	void AddTool(CWnd * pWnd, DWORD dwIdString, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0), LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	void AddTool(CWnd * pWnd, LPCTSTR lpszString, HICON hIcon, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	void AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0), LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	void AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdBitmap, COLORREF crMask, CSize & szBitmap = CSize(0, 0), LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);§	//add external tools§	void AddDynamicTool(DynamicToolID tool, const ExternalFindCallback& callback);§§	void RemoveTool(CWnd * pWnd, LPCRECT lpRectBounds = NULL);§	void RemoveDynamicTool(DynamicToolID tool);§	void RemoveAllTools();§§	BOOL GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, LPCRECT lpRectBounds = NULL);§	BOOL GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, DWORD dwIDTool = 0);§	void UpdateTipText(LPCTSTR lpszText, CWnd * pWnd, DWORD dwIDTool = 0);§	void DelTool(CWnd * pWnd, DWORD dwIDTool = 0);§	void SetToolRect(CWnd * pWnd, DWORD dwIDTool, LPCRECT lpRectBounds);§§	//Help tooltip§	void ShowHelpTooltip (LPPOINT pt, DWORD dwIdText, HICON hIcon = NULL);§	void ShowHelpTooltip (LPPOINT pt, DWORD dwIdText, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0));§	void ShowHelpTooltip (LPPOINT pt, LPCTSTR lpszString, HICON hIcon = NULL);§	void ShowHelpTooltip (LPPOINT pt, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0));§	void ShowHelpTooltip (LPPOINT pt, PPTOOLTIP_INFO & ti);§	void HideTooltip();§§	// color's functions§	void SetColorBk(COLORREF color);§	void SetColorBk(COLORREF clrBegin, COLORREF clrEnd);§	void SetColorBk(COLORREF clrBegin, COLORREF clrMid, COLORREF clrEnd);§	void SetEffectBk(DWORD dwEffect, BYTE nGranularity = 5);§§	//behaviour's methods§	void SetBehaviour(DWORD dwBehaviour = 0);§	DWORD GetBehaviour();§§	void SetDelayTime(DWORD dwDuration, DWORD dwTime);§	DWORD GetDelayTime(DWORD dwDuration) const;§§	void SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));§	void SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));§§	//functions for sizes§	void SetSize(int nSizeIndex, int nValue);§	int GetSize(int nSizeIndex);§	void SetDefaultSizes(BOOL bBalloonSize = TRUE);§§	//functions for direction§	void SetDirection (DWORD dwDirection = PPTOOLTIP_BOTTOMEDGE_LEFT);§	DWORD GetDirection();§§	void SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam = 0);§	§	void EnableHyperlink(BOOL bEnable = TRUE);§	void SetDebugMode(BOOL bDebug = TRUE);§§//	void EnableTextWrap(BOOL bEnable = TRUE){m_drawer.EnableTextWrap(bEnable);};§	void SetMaxTipWidth(int nWidth = 0){m_drawer.SetMaxWidth(nWidth);};§§	//functions for§	void  SetNotify(HWND hWnd);§	void  SetNotify(BOOL bParentNotify = TRUE);§§	void SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue);§	void SetCssStyles(LPCTSTR lpszCssStyles = NULL);§	void SetCssStyles(DWORD dwIdCssStyle, LPCTSTR lpszPathDll = NULL); //Sets the CSS styles§	LPCTSTR GetCssStyles();§§	void EnableEscapeSequences(BOOL bEnable);§§	void HideBorder();§	void SetBorder(COLORREF color, int nWidth = 1, int nHeight = 1);§	void SetBorder(HBRUSH hbr, int nWidth = 1, int nHeight = 1);§§	//Transparency of tooltip§	void SetTransparency(BYTE nTransparency = 0);§	inline BYTE GetTransparency() {return m_nTransparency;};§§	//Shadow of the tooltip§	void SetTooltipShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent = 50, BOOL bGradient = TRUE, int nDepthX = 7, int nDepthY = 7);§	void SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent = 50, BOOL bGradient = TRUE, int nDepthX = 7, int nDepthY = 7);§§#ifdef PPTOOLTIP_USE_MENU§	//Methods for the menu§	void MenuToolPosition(DWORD nPos = PPTOOLTIP_MENU_LEFT | PPTOOLTIP_MENU_TOP);§	inline DWORD GetMenuToolPosition() {return m_dwMenuToolPos;};§	void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSubMenu);§    void OnEnterIdle(UINT nWhy, CWnd* pWho);§	HWND GetRunningMenuWnd();§#endif //PPTOOLTIP_USE_MENU§§	static short GetVersionI()		{return 0x22;}§	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("2.2 beta");}§§private:§	virtual void OnDrawBorder(HDC hDC, HRGN hRgn);§§	// Generated message map functions§protected:§	void Pop();§	void KillTimers(DWORD dwIdTimer = NULL);§	void SetNewTooltip(HWND hWnd, DynamicToolID toolID, const PPTOOLTIP_INFO & ti, BOOL bDisplayWithDelay = TRUE, TooltipType type = PPTOOLTIP_NORMAL);§	HWND GetWndFromPoint(LPPOINT lpPoint, PPTOOLTIP_INFO & ti, BOOL bCheckTool = TRUE);§	LRESULT SendNotify(LPPOINT pt, PPTOOLTIP_INFO & ti);§§	BOOL IsCursorOverTooltip() const;§	inline BOOL IsVisible() const {return ((GetStyle() & WS_VISIBLE) == WS_VISIBLE);}§	BOOL  IsNotify(); //Is enabled notification§§	void PrepareDisplayTooltip(LPPOINT lpPoint);§	void OnRedrawTooltip(HDC hDC, BYTE nTransparency = 0);§§	void OutputTooltipOnScreen(LPPOINT lpPoint, HDC hDC = NULL);§	void SetAutoPopTimer(); //Sets autopop timer§§	void FreeResources();§	CString GetDebugInfoTool(LPPOINT lpPoint);§§	DWORD GetTooltipDirection(DWORD dwDirection, const CPoint & ptPoint, CPoint & ptAnchor, CRect & rcBody, CRect & rcFull, CRect & rcTipArea);§	HRGN GetTooltipRgn(DWORD dwDirection, int x, int y, int nWidth, int nHeight);§	§	CString GetMaxDebugString(LPCTSTR lpszText);§	CString CreateDebugCell(CString sTitle, LPCTSTR lpszDescription);§	§	BOOL FindTool(HWND hWnd, const LPPOINT lpPoint, PPTOOLTIP_INFO & ti);§	HWND FindTool(const LPPOINT lpPoint, PPTOOLTIP_INFO & ti);§	HWND FindToolBarItem(POINT point, PPTOOLTIP_INFO & ti);§	BOOL IsComboBoxControl(HWND hWnd, UINT nStyle);§§	//{{AFX_MSG(CPPToolTip)§	afx_msg void OnPaint();§	afx_msg void OnTimer(UINT nIDEvent);§	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);§	//}}AFX_MSG§#if _MSC_VER < 1300§    afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);§#else§    afx_msg void OnActivateApp(BOOL bActive, DWORD hTask);§#endif§    afx_msg LRESULT OnRepaintWindow(WPARAM wParam, LPARAM lParam);§	DECLARE_MESSAGE_MAP()§//#UC END# *4700B6AC00CB*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659776950"))
	    quid       	"4700B6AC00CB"
	    documentation 	"‡Ò¯ËÂÌÌ˚È ÍÓÌÚÓÎ ÚÛÎ-ÚËÔ"
	    stereotype 	"SimpleClass"
	    superclasses 	(list inheritance_relationship_list
		(object Inheritance_Relationship
		    quid       	"4700C599006D"
		    supplier   	"Logical View::external::MFCTypes::Controls::CWnd"
		    quidu      	"4652B53F01F4"))
	    language   	"MDA Generator")
	(object Class "CPPHtmlDrawer"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CPPHtmlDrawer.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CPPHtmlDrawer.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B81F006D_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B81F006D_CUSTOM_INCLUDES*§#include "atlconv.h"    // for Unicode conversion - requires #include <afxdisp.h> // MFC OLE automation classes§#include <shellapi.h>§#pragma comment(lib, "comctl32.lib")§§#define PPHTMLDRAWER_NO_HOVERLINK	-2	//A hot area is not exist under the cursor§#define PPHTMLDRAWER_BREAK_CHARS	_T(" -.,!:;)}]?") //A set of the chars to break line in the text wrap mode§§//#UC END# *4700B81F006D_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B81F006D*"
		    value      	(value Text 
|//#UC START# *4700B81F006D*§enum {§	MODE_DRAW = 0,§	MODE_FIRSTPASS,§	MODE_SECONDPASS§};§§/*§#define m_szOffsetShadow.cx		4 //§#define m_szOffsetShadow.cy		4 //§#define m_szDepthShadow.cx		7 //§#define m_szDepthShadow.cy		7 //§#define PPHTMLDRAWER_SHADOW_COLOR		RGB (64, 64, 64) //A gradient shadow's color§*/§§§/////////////////////////////////////////////////////////////////////////////§// CPPHtmlDrawer§§CPPHtmlDrawer::CPPHtmlDrawer()§{§	m_nNumPass = MODE_FIRSTPASS;§§	m_hInstDll = NULL;§	m_bFreeInstDll = FALSE;§	m_hDC = NULL;§	m_hImageList = NULL;§	§	m_csCallbackRepaint.hWnd = NULL;§	m_csCallbackRepaint.nMessage = 0;§	m_csCallbackRepaint.lParam = 0;§	m_csCallbackRepaint.wParam = 0;§	§	m_csCallbackLink.hWnd = NULL;§	m_csCallbackLink.nMessage = 0;§	m_csCallbackLink.lParam = 0;§	m_csCallbackLink.wParam = 0;§§//	m_clrShadow = PPHTMLDRAWER_SHADOW_COLOR;§§	m_hLinkCursor = NULL; // No cursor as yet§	m_nHoverIndexLink = PPHTMLDRAWER_NO_HOVERLINK;§§	SetListOfTags();§	SetListSpecChars();§    SetTableOfColors();§	SetDefaultCursor();§	EnableEscapeSequences();§	SetMaxWidth(0);§//	EnableTextWrap(FALSE); //A text warpping was disabled by default§//	EnableTextWrap(TRUE); //A text warpping was disabled by default§	SetImageShadow(4, 4);§	SetTabSize(32);§	SetDefaultCssStyles();§	EnableOutput();§	SetDisabledColor(::GetSysColor(COLOR_BTNSHADOW));§}§§void CPPHtmlDrawer::EnableOutput(BOOL bEnable /* = TRUE */)§{§	m_bIsEnable = bEnable;§} //End of EnableOutput§§void CPPHtmlDrawer::SetDisabledColor(COLORREF color)§{§	m_crDisabled = color;§}§§HICON CPPHtmlDrawer::GetIconFromResources(DWORD dwID, int nWidth /* = 0 */, int nHeight /* = 0 */) const§{§	if (0 == dwID) return NULL;§§	// Find correct resource handle§#ifdef _MFC_VER§	HINSTANCE hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(dwID), RT_GROUP_ICON);§#else§	HINSTANCE hInstResource = ::GetModuleHandle(NULL);§#endif§	// Set icon when the mouse is IN the button§	HICON hIcon = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(dwID), IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR);§	§	return hIcon;§}§§HICON CPPHtmlDrawer::GetIconFromFile(LPCTSTR lpszPath, int nWidth /* = 0 */, int nHeight /* = 0 */) const§{§	HICON hIcon = (HICON)::LoadImage(NULL, lpszPath, IMAGE_ICON, nWidth, nHeight, LR_LOADFROMFILE | LR_DEFAULTCOLOR);§	§	return hIcon;§}§§HICON CPPHtmlDrawer::GetIconFromDll(DWORD dwID, int nWidth /* = 0 */, int nHeight /* = 0 */, LPCTSTR lpszPathDll /* = NULL */) const§{§	if (0 == dwID) return NULL;§§	HICON hIcon = NULL;§§	HINSTANCE hInstDll = NULL;§	BOOL bNewDll = FALSE;§§	if (NULL == lpszPathDll)§	{§		if (NULL != m_hInstDll)§			hInstDll = m_hInstDll;§	}§	else§	{§		//Load New Library§		hInstDll = ::LoadLibraryEx(lpszPathDll, NULL, 0);§		if (NULL != hInstDll)§			bNewDll = TRUE;	§	}§§	if (NULL != hInstDll)§	{§		hIcon = (HICON)::LoadImage(hInstDll, MAKEINTRESOURCE(dwID), IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR);§§		if (bNewDll)§			::FreeLibrary(hInstDll);§	}§§	return hIcon;§}§§HBITMAP CPPHtmlDrawer::GetBitmapFromResources(DWORD dwID) const§{§	if (0 == dwID) return NULL;§§	// Find correct resource handle§#ifdef _MFC_VER§	HINSTANCE hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(dwID), RT_BITMAP);§#else§	HINSTANCE hInstResource = ::GetModuleHandle(NULL);§#endif§	// Load bitmap§	HBITMAP hBitmap = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(dwID), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);§	§	return hBitmap;§}§§HBITMAP CPPHtmlDrawer::GetBitmapFromFile(LPCTSTR lpszPath) const§{§	HBITMAP hBitmap = (HBITMAP)::LoadImage(NULL, lpszPath, IMAGE_BITMAP,§		0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE);§§	return hBitmap;§}§§HBITMAP CPPHtmlDrawer::GetBitmapFromDll(DWORD dwID, LPCTSTR lpszPathDll /* = NULL */) const§{§	if (0 == dwID) return NULL;§§	HBITMAP hBitmap = NULL;§§	HINSTANCE hInstDll = NULL;§	BOOL bNewDll = FALSE;§§	if (NULL == lpszPathDll)§	{§		if (NULL != m_hInstDll)§			hInstDll = m_hInstDll;§	}§	else§	{§		//Load New Library§		hInstDll = ::LoadLibraryEx(lpszPathDll, NULL, 0);§		if (NULL != hInstDll)§			bNewDll = TRUE;	§	}§§	if (NULL != hInstDll)§	{§		hBitmap = (HBITMAP)::LoadImage(hInstDll, MAKEINTRESOURCE(dwID), IMAGE_BITMAP,§			0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE);§§		if (bNewDll)§			::FreeLibrary(hInstDll);§	}§§	return hBitmap;§}§§CPPString CPPHtmlDrawer::GetStringFromResource(DWORD dwID) const§{§	if (0 == dwID) return _T("");§§	CPPString str;§	str.LoadString(dwID);§§	return str;§}§§CPPString CPPHtmlDrawer::GetStringFromDll(DWORD dwID, LPCTSTR lpszPathDll /* = NULL */) const§{§	if (0 == dwID) return _T("");§§	CPPString str = _T("");§§	HINSTANCE hInstDll = NULL;§	BOOL bNewDll = FALSE;§§	if (NULL == lpszPathDll)§	{§		if (NULL != m_hInstDll)§			hInstDll = m_hInstDll;§	}§	else§	{§		//Load New Library§		hInstDll = ::LoadLibraryEx(lpszPathDll, NULL, 0);§		if (NULL != hInstDll)§			bNewDll = TRUE;	§	}§§	if (NULL != hInstDll)§	{§#ifdef _UNICODE§#define CHAR_FUDGE 1    // one TCHAR unused is good enough§#else§#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char§#endif§		// try fixed buffer first (to avoid wasting space in the heap)§		TCHAR szTemp[256];§		§		DWORD dwLen = ::LoadString(hInstDll, dwID, szTemp, (sizeof(szTemp) * sizeof(TCHAR)));§		// If resource not found (or ::LoadString failure)§		if (0 != dwLen) §		{§			if ((sizeof(szTemp) * sizeof(TCHAR)) - dwLen > CHAR_FUDGE)§			{§				str = szTemp;§			} // if§			else§			{§				// try buffer size of 512, then larger size until entire string is retrieved§				int nSize = 256;§				do§				{§					nSize += 256;§					dwLen = ::LoadString(hInstDll, dwID, str.GetBuffer(nSize-1), nSize);§				} while (nSize - dwLen <= CHAR_FUDGE);§				str.ReleaseBuffer();§			}§#undef CHAR_FUDGE§		}§§		if (bNewDll)§			::FreeLibrary(hInstDll);§	}§	return str;§}§§///////////////////////////////////////////////////////////§// Get tooltip string for menu and toolbar items from the §// resources of the application.§// §// Parameters:§//		nID - Resource ID of the string§//		nNumParam - Which parameter will gets:§//					 0=long,§//					 1=short,§//					 2=disable§//§//§// Format prompt string:  long prompt \n short prompt \n disable prompt§////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::GetResCommandPrompt(UINT nID, UINT nNumParam /* = 0 */)§{§	CPPString str = GetStringFromResource(nID);§	if (!str.IsEmpty())§	{§		int nFirst = 0;§		int nLast = nFirst;§		UINT nCount = 0;§		while ((nCount <= nNumParam) && (nFirst < str.GetLength()))§		{§			nLast = str.Find(_T('\n'), nFirst);§			if (nLast < 0)§			{§				//Char wasn't found§				if (nCount == nNumParam)§					str = str.Mid(nFirst, str.GetLength() - nFirst);§				else§					str.Empty();§				§				return str;§			}§			else§			{§				//Char was found§				if (nCount == nNumParam)§				{§					str = str.Mid(nFirst, nLast - nFirst);§					return str;§				}§				else§				{§					nFirst = nLast + 1;§				} //if§			} //if§			nCount ++;§		} //while§	} //if§§	return _T("");§} //End of GetResCommandPrompt§§/////////////////////////////////////////////////////////////////////////////§// §void CPPHtmlDrawer::SetListSpecChars()§{§	AddSpecChar(_T("&amp;"), _T("&"));			// ampersand§	AddSpecChar(_T("&bull;"), _T("\x95\0"));	// bullet  NOT IN MS SANS SERIF§	AddSpecChar(_T("&copy;"), _T("\xA9\0"));	// copyright§//	AddSpecChar(_T("&euro;"), _T("\x80\0"));	// euro sign IN NOT CYRILLIC FONTS§	AddSpecChar(_T("&euro;"), _T("\x88\0"));	// euro sign IN CYRILLIC FONTS§	AddSpecChar(_T("&gt;"), _T(">"));			// greater than§	AddSpecChar(_T("&iquest;"), _T("\xBF\0"));	// inverted question mark§	AddSpecChar(_T("&lt;"), _T("<<"));			// less than§	AddSpecChar(_T("&nbsp;"), _T(" "));			// nonbreaking space§	AddSpecChar(_T("&para;"), _T("\xB6\0"));	// paragraph sign§	AddSpecChar(_T("&pound;"), _T("\xA3\0"));	// pound sign§	AddSpecChar(_T("&quot;"), _T("\""));		// quotation mark§	AddSpecChar(_T("&reg;"), _T("\xAE\0"));		// registered trademark§	AddSpecChar(_T("&trade;"), _T("\x99\0"));	// trademark NOT IN MS SANS SERIF§} //End of SetListSpecChars§§void CPPHtmlDrawer::AddSpecChar(LPCTSTR lpszAlias, LPCTSTR lpszValue)§{§	iter_mapStyles iter = m_mapSpecChars.find(lpszAlias);§	§	if (iter != m_mapSpecChars.end())§		iter->second = lpszValue;		//Modifies§	else§		m_mapSpecChars.insert(std::make_pair(lpszAlias, lpszValue)); //Add new§} //End of AddSpecialChar§§void CPPHtmlDrawer::ReplaceSpecChars()§{§	CPPString sAlias, sValue;§	for (iter_mapStyles iter = m_mapSpecChars.begin(); iter != m_mapSpecChars.end(); ++iter)§	{§		sAlias = iter->first;§		sValue = iter->second;§		m_csHtmlText.Replace(sAlias, sValue);§	} //for§§	m_csHtmlText.Remove(_T('\r'));§	if (!m_bEnableEscapeSequences)§	{§		//ENG: Remove escape sequences§		//RUS: ”‰‡ÎˇÂÏ ÒÔÂˆË‡Î¸Ì˚Â ÒËÏ‚ÓÎ˚§		m_csHtmlText.Remove(_T('\n'));§		m_csHtmlText.Remove(_T('\t'));§	}§	else§	{§		//ENG: Replace escape sequences to HTML tags§		//RUS: «‡ÏÂÌˇÂÏ ÒÔÂˆË‡Î¸Ì˚Â ÒËÏ‚ÓÎ˚ HTML Ú˝„‡ÏË§		m_csHtmlText.Replace(_T("\n"), _T("<br>"));§		m_csHtmlText.Replace(_T("\t"), _T("<t>"));§	} //if§} //End of ReplaceSpecChars§§/////////////////////////////////////////////////////////////////////////////§// §void CPPHtmlDrawer::SetListOfTags()§{§	AddTagToList(_T("b"), TAG_BOLD, _T("bold"));§	AddTagToList(_T("i"), TAG_ITALIC, _T("italic"));§	AddTagToList(_T("em"), TAG_ITALIC, _T("italic"));§	AddTagToList(_T("u"), TAG_UNDERLINE, _T("underline"));§	AddTagToList(_T("s"), TAG_STRIKEOUT, _T("strikeout"));§	AddTagToList(_T("strike"), TAG_STRIKEOUT, _T("strikeout"));§	AddTagToList(_T("font"), TAG_FONT, _T("font"));§	AddTagToList(_T("hr"), TAG_HLINE, _T(""));§	AddTagToList(_T("br"), TAG_NEWLINE, _T(""));§	AddTagToList(_T("\n"), TAG_NEWLINE, _T(""));§	AddTagToList(_T("t"), TAG_TABULATION, _T(""));§	AddTagToList(_T("\t"), TAG_TABULATION, _T(""));§	AddTagToList(_T("left"), TAG_LEFT, _T("left"));§	AddTagToList(_T("center"), TAG_CENTER, _T("center"));§	AddTagToList(_T("right"), TAG_RIGHT, _T("right"));§	AddTagToList(_T("justify"), TAG_JUSTIFY, _T("justify"));§	AddTagToList(_T("baseline"), TAG_BASELINE, _T("baseline"));§	AddTagToList(_T("top"), TAG_TOP, _T("top"));§	AddTagToList(_T("vcenter"), TAG_VCENTER, _T("vcenter"));§	AddTagToList(_T("middle"), TAG_VCENTER, _T("vcenter"));§	AddTagToList(_T("bottom"), TAG_BOTTOM, _T("vcenter"));§	AddTagToList(_T("bmp"), TAG_BITMAP, _T(""));§	AddTagToList(_T("icon"), TAG_ICON, _T(""));§	AddTagToList(_T("ilst"), TAG_IMAGELIST, _T(""));§	AddTagToList(_T("string"), TAG_STRING, _T(""));§	AddTagToList(_T("body"), TAG_NEWSTYLE, _T("body"));§	AddTagToList(_T("h1"), TAG_NEWSTYLE, _T("h1"));§	AddTagToList(_T("h2"), TAG_NEWSTYLE, _T("h2"));§	AddTagToList(_T("h3"), TAG_NEWSTYLE, _T("h3"));§	AddTagToList(_T("h4"), TAG_NEWSTYLE, _T("h4"));§	AddTagToList(_T("h5"), TAG_NEWSTYLE, _T("h5"));§	AddTagToList(_T("h6"), TAG_NEWSTYLE, _T("h6"));§	AddTagToList(_T("code"), TAG_NEWSTYLE, _T("code"));§	AddTagToList(_T("pre"), TAG_NEWSTYLE, _T("pre"));§	AddTagToList(_T("big"), TAG_NEWSTYLE, _T("big"));§	AddTagToList(_T("small"), TAG_NEWSTYLE, _T("small"));§	AddTagToList(_T("sub"), TAG_NEWSTYLE, _T("sub"));§	AddTagToList(_T("sup"), TAG_NEWSTYLE, _T("sup"));§	AddTagToList(_T("span"), TAG_SPAN, _T("span"));§	AddTagToList(_T("a"), TAG_HYPERLINK, _T("link"));§} //End of SetListOfTags§§////////////////////////////////////////////////////////////////////////§// Format for the new tags:§//		lpszName		- a tag's name in the HTML string§//		dwTagIndex		- ID of the tag§//		lpszFullName	- a custom name if tag must be closing. Empty if not.  §////////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::AddTagToList(LPCTSTR lpszName, DWORD dwTagIndex, LPCTSTR lpszFullName)§{§	STRUCT_TAGPROP tp;§	tp.dwTagIndex = dwTagIndex;§	tp.strTagName = lpszFullName;§§	iterMapTags iterMap = m_mapTags.find(lpszName);§	§	if (iterMap != m_mapTags.end())§		iterMap->second = tp; //Modifies§	else§		m_mapTags.insert(std::make_pair(lpszName, tp)); //Add new§} //End of AddTagToList§§DWORD CPPHtmlDrawer::GetTagFromList(CPPString sTagName, CPPString & strFullName, BOOL & bCloseTag)§{§	strFullName.Empty();§§	bCloseTag = (sTagName.GetAt(0) == _T('/')) ? TRUE : FALSE;§	if (bCloseTag)§		sTagName = sTagName.Mid(1);§§	iterMapTags iterMap = m_mapTags.find(sTagName);§	§	if (iterMap != m_mapTags.end())§	{§		STRUCT_TAGPROP tp = iterMap->second;§		strFullName = tp.strTagName;§		§		return tp.dwTagIndex;§	} //if§§	return TAG_NONE;§} //End of GetTagFromList§§///////////////////////////////////////////////////////§// §///////////////////////////////////////////////////////§void CPPHtmlDrawer::SetTableOfColors()§{§	//Frequency used§	SetColorName(_T("aqua"), RGB(0x00, 0xFF, 0xFF)); §	SetColorName(_T("black"), RGB(0x00, 0x00, 0x00)); §	SetColorName(_T("blue"), RGB(0x00, 0x00, 0xFF)); §	SetColorName(_T("brown"), RGB(0xA5, 0x2A, 0x2A)); §	SetColorName(_T("cyan"), RGB(0x00, 0xFF, 0xFF));§	SetColorName(_T("gold"), RGB(0xFF, 0xD7, 0x00)); §	SetColorName(_T("gray"), RGB(0x80, 0x80, 0x80)); §	SetColorName(_T("green"), RGB(0x00, 0x80, 0x00)); §	SetColorName(_T("magenta"), RGB(0xFF, 0x00, 0xFF)); §	SetColorName(_T("maroon"), RGB(0x80, 0x00, 0x00)); §	SetColorName(_T("navy"), RGB(0x00, 0x00, 0x80)); §	SetColorName(_T("olive"), RGB(0x80, 0x80, 0x00)); §	SetColorName(_T("orange"), RGB(0xFF, 0xA5, 0x00)); §	SetColorName(_T("pink"), RGB(0xFF, 0xC0, 0xCB)); §	SetColorName(_T("purple"), RGB(0x80, 0x00, 0x80)); §	SetColorName(_T("red"), RGB(0xFF, 0x00, 0x00)); §	SetColorName(_T("silver"), RGB(0xC0, 0xC0, 0xC0)); §	SetColorName(_T("snow"), RGB(0xFF, 0xFA, 0xFA)); §	SetColorName(_T("violet"), RGB(0xEE, 0x82, 0xEE)); §	SetColorName(_T("white"), RGB(0xFF, 0xFF, 0xFF)); §	SetColorName(_T("yellow"), RGB(0xFF, 0xFF, 0x00)); §§	//Common Used§	SetColorName(_T("aliceblue"), RGB(0xF0, 0xF8, 0xFF)); §	SetColorName(_T("antiquewhite"), RGB(0xFA, 0xEB, 0xD7)); §	SetColorName(_T("aquamarine"), RGB(0x7F, 0xFF, 0xD4)); §	SetColorName(_T("azure"), RGB(0xF0, 0xFF, 0xFF)); §	SetColorName(_T("beige"), RGB(0xF5, 0xF5, 0xDC)); §	SetColorName(_T("bisque"), RGB(0xFF, 0xE4, 0xC4));§	SetColorName(_T("blanchedalmond"), RGB(0xFF, 0xEB, 0xCD)); §	SetColorName(_T("blueviolet"), RGB(0x8A, 0x2B, 0xE2)); §	SetColorName(_T("burlywood"), RGB(0xDE, 0xB8, 0x87)); §	SetColorName(_T("cadetblue"), RGB(0x5F, 0x9E, 0xA0)); §	SetColorName(_T("chartreuse"), RGB(0x7F, 0xFF, 0x00)); §	SetColorName(_T("chocolate"), RGB(0xD2, 0x69, 0x1E)); §	SetColorName(_T("coral"), RGB(0xFF, 0x7F, 0x50)); §	SetColorName(_T("cornflowerblue"), RGB(0x64, 0x95, 0xED)); §	SetColorName(_T("cornsilk"), RGB(0xFF, 0xF8, 0xDC)); §	SetColorName(_T("crimson"), RGB(0xDC, 0x14, 0x3C)); §	SetColorName(_T("darkblue"), RGB(0x00, 0x00, 0x8B)); §	SetColorName(_T("darkcyan"), RGB(0x00, 0x8B, 0x8B)); §	SetColorName(_T("darkgoldenrod"), RGB(0xB8, 0x86, 0x0B)); §	SetColorName(_T("darkgray"), RGB(0xA9, 0xA9, 0xA9)); §	SetColorName(_T("darkgreen"), RGB(0x00, 0x64, 0x00)); §	SetColorName(_T("darkkhaki"), RGB(0xBD, 0xB7, 0x6B)); §	SetColorName(_T("darkmagenta"), RGB(0x8B, 0x00, 0x8B)); §	SetColorName(_T("darkolivegreen"), RGB(0x55, 0x6B, 0x2F)); §	SetColorName(_T("darkorange"), RGB(0xFF, 0x8C, 0x00)); §	SetColorName(_T("darkorchid"), RGB(0x99, 0x32, 0xCC)); §	SetColorName(_T("darkred"), RGB(0x8B, 0x00, 0x00)); §	SetColorName(_T("darksalmon"), RGB(0xE9, 0x96, 0x7A)); §	SetColorName(_T("darkseagreen"), RGB(0x8F, 0xBC, 0x8B)); §	SetColorName(_T("darkslateblue"), RGB(0x48, 0x3D, 0x8B)); §	SetColorName(_T("darkslategray"), RGB(0x2F, 0x4F, 0x4F)); §	SetColorName(_T("darkturquoise"), RGB(0x00, 0xCE, 0xD1)); §	SetColorName(_T("darkviolet"), RGB(0x94, 0x00, 0xD3)); §	SetColorName(_T("deeppink"), RGB(0xFF, 0x14, 0x93)); §	SetColorName(_T("deepskyblue"), RGB(0x00, 0xBF, 0xFF)); §	SetColorName(_T("dimgray"), RGB(0x69, 0x69, 0x69)); §	SetColorName(_T("dodgerblue"), RGB(0x1E, 0x90, 0xFF)); §	SetColorName(_T("firebrick"), RGB(0xB2, 0x22, 0x22)); §	SetColorName(_T("floralwhite"), RGB(0xFF, 0xFA, 0xF0)); §	SetColorName(_T("forestgreen"), RGB(0x22, 0x8B, 0x22)); §	SetColorName(_T("fuchsia"), RGB(0xFF, 0x00, 0xFF)); §	SetColorName(_T("gainsboro"), RGB(0xDC, 0xDC, 0xDC)); §	SetColorName(_T("ghostwhite"), RGB(0xF8, 0xF8, 0xFF)); §	SetColorName(_T("goldenrod"), RGB(0xDA, 0xA5, 0x20)); §	SetColorName(_T("greenyellow"), RGB(0xAD, 0xFF, 0x2F)); §	SetColorName(_T("honeydew"), RGB(0xF0, 0xFF, 0xF0)); §	SetColorName(_T("hotpink"), RGB(0xFF, 0x69, 0xB4)); §	SetColorName(_T("indianred"), RGB(0xCD, 0x5C, 0x5C)); §	SetColorName(_T("indigo"), RGB(0x4B, 0x00, 0x82)); §	SetColorName(_T("ivory"), RGB(0xFF, 0xFF, 0xF0)); §	SetColorName(_T("khaki"), RGB(0xF0, 0xE6, 0x8C)); §	SetColorName(_T("lavender"), RGB(0xE6, 0xE6, 0xFA)); §	SetColorName(_T("lavenderblush"), RGB(0xFF, 0xF0, 0xF5)); §	SetColorName(_T("lawngreen"), RGB(0x7C, 0xFC, 0x00)); §	SetColorName(_T("lemonchiffon"), RGB(0xFF, 0xFA, 0xCD)); §	SetColorName(_T("lightblue"), RGB(0xAD, 0xD8, 0xE6)); §	SetColorName(_T("lightcoral"), RGB(0xF0, 0x80, 0x80)); §	SetColorName(_T("lightcyan"), RGB(0xE0, 0xFF, 0xFF));§	SetColorName(_T("lightgoldenrodyellow"), RGB(0xFA, 0xFA, 0xD2)); §	SetColorName(_T("lightgreen"), RGB(0x90, 0xEE, 0x90)); §	SetColorName(_T("lightgrey"), RGB(0xD3, 0xD3, 0xD3)); §	SetColorName(_T("lightpink"), RGB(0xFF, 0xB6, 0xC1)); §	SetColorName(_T("lightsalmon"), RGB(0xFF, 0xA0, 0x7A)); §	SetColorName(_T("lightseagreen"), RGB(0x20, 0xB2, 0xAA)); §	SetColorName(_T("lightskyblue"), RGB(0x87, 0xCE, 0xFA)); §	SetColorName(_T("lightslategray"), RGB(0x77, 0x88, 0x99)); §	SetColorName(_T("lightsteelblue"), RGB(0xB0, 0xC4, 0xDE));§	SetColorName(_T("lightyellow"), RGB(0xFF, 0xFF, 0xE0)); §	SetColorName(_T("lime"), RGB(0x00, 0xFF, 0x00)); §	SetColorName(_T("limegreen"), RGB(0x32, 0xCD, 0x32)); §	SetColorName(_T("linen"), RGB(0xFA, 0xF0, 0xE6)); §	SetColorName(_T("mediumaquamarine"), RGB(0x66, 0xCD, 0xAA)); §	SetColorName(_T("mediumblue"), RGB(0x00, 0x00, 0xCD)); §	SetColorName(_T("mediumorchid"), RGB(0xBA, 0x55, 0xD3)); §	SetColorName(_T("mediumpurple"), RGB(0x93, 0x70, 0xDB)); §	SetColorName(_T("mediumseagreen"), RGB(0x3C, 0xB3, 0x71)); §	SetColorName(_T("mediumslateblue"), RGB(0x7B, 0x68, 0xEE)); §	SetColorName(_T("mediumspringgreen"), RGB(0x00, 0xFA, 0x9A)); §	SetColorName(_T("mediumturquoise"), RGB(0x48, 0xD1, 0xCC)); §	SetColorName(_T("mediumvioletred"), RGB(0xC7, 0x15, 0x85)); §	SetColorName(_T("midnightblue"), RGB(0x19, 0x19, 0x70)); §	SetColorName(_T("mintcream"), RGB(0xF5, 0xFF, 0xFA)); §	SetColorName(_T("mistyrose"), RGB(0xFF, 0xE4, 0xE1)); §	SetColorName(_T("moccasin"), RGB(0xFF, 0xE4, 0xB5)); §	SetColorName(_T("navajowhite"), RGB(0xFF, 0xDE, 0xAD)); §	SetColorName(_T("oldlace"), RGB(0xFD, 0xF5, 0xE6)); §	SetColorName(_T("olivedrab"), RGB(0x6B, 0x8E, 0x23)); §	SetColorName(_T("orangered"), RGB(0xFF, 0x45, 0x00)); §	SetColorName(_T("orchid"), RGB(0xDA, 0x70, 0xD6)); §	SetColorName(_T("palegoldenrod"), RGB(0xEE, 0xE8, 0xAA)); §	SetColorName(_T("palegreen"), RGB(0x98, 0xFB, 0x98)); §	SetColorName(_T("paleturquoise"), RGB(0xAF, 0xEE, 0xEE)); §	SetColorName(_T("palevioletred"), RGB(0xDB, 0x70, 0x93)); §	SetColorName(_T("papayawhip"), RGB(0xFF, 0xEF, 0xD5));§	SetColorName(_T("peachpuff"), RGB(0xFF, 0xDA, 0xB9)); §	SetColorName(_T("peru"), RGB(0xCD, 0x85, 0x3F)); §	SetColorName(_T("plum"), RGB(0xDD, 0xA0, 0xDD)); §	SetColorName(_T("powderblue"), RGB(0xB0, 0xE0, 0xE6)); §	SetColorName(_T("rosybrown"), RGB(0xBC, 0x8F, 0x8F)); §	SetColorName(_T("royalblue"), RGB(0x41, 0x69, 0xE1)); §	SetColorName(_T("saddlebrown"), RGB(0x8B, 0x45, 0x13)); §	SetColorName(_T("salmon"), RGB(0xFA, 0x80, 0x72)); §	SetColorName(_T("sandybrown"), RGB(0xF4, 0xA4, 0x60)); §	SetColorName(_T("seagreen"), RGB(0x2E, 0x8B, 0x57)); §	SetColorName(_T("seashell"), RGB(0xFF, 0xF5, 0xEE)); §	SetColorName(_T("sienna"), RGB(0xA0, 0x52, 0x2D)); §	SetColorName(_T("skyblue"), RGB(0x87, 0xCE, 0xEB)); §	SetColorName(_T("slateblue"), RGB(0x6A, 0x5A, 0xCD)); §	SetColorName(_T("slategray"), RGB(0x70, 0x80, 0x90)); §	SetColorName(_T("springgreen"), RGB(0x00, 0xFF, 0x7F)); §	SetColorName(_T("steelblue"), RGB(0x46, 0x82, 0xB4)); §	SetColorName(_T("tan"), RGB(0xD2, 0xB4, 0x8C)); §	SetColorName(_T("teal"), RGB(0x00, 0x80, 0x80)); §	SetColorName(_T("thistle"), RGB(0xD8, 0xBF, 0xD8)); §	SetColorName(_T("tomato"), RGB(0xFF, 0x63, 0x47)); §	SetColorName(_T("turquoise"), RGB(0x40, 0xE0, 0xD0)); §	SetColorName(_T("wheat"), RGB(0xF5, 0xDE, 0xB3)); §	SetColorName(_T("whitesmoke"), RGB(0xF5, 0xF5, 0xF5)); §	SetColorName(_T("yellowgreen"), RGB(0x9A, 0xCD, 0x32));§§	//Systems colors§	SetColorName(_T("activeborder"), ::GetSysColor(COLOR_ACTIVEBORDER)); §	SetColorName(_T("activecaption"), ::GetSysColor(COLOR_ACTIVECAPTION)); §	SetColorName(_T("appworkspace"), ::GetSysColor(COLOR_APPWORKSPACE)); §	SetColorName(_T("background"), ::GetSysColor(COLOR_BACKGROUND)); §	SetColorName(_T("buttonface"), ::GetSysColor(COLOR_BTNFACE)); §	SetColorName(_T("buttonhighlight"), ::GetSysColor(COLOR_BTNHILIGHT)); §	SetColorName(_T("buttonshadow"), ::GetSysColor(COLOR_BTNSHADOW)); §	SetColorName(_T("buttontext"), ::GetSysColor(COLOR_BTNTEXT)); §	SetColorName(_T("captiontext"), ::GetSysColor(COLOR_CAPTIONTEXT)); §	SetColorName(_T("graytext"), ::GetSysColor(COLOR_GRAYTEXT)); §	SetColorName(_T("highlight"), ::GetSysColor(COLOR_HIGHLIGHT)); §	SetColorName(_T("highlighttext"), ::GetSysColor(COLOR_HIGHLIGHTTEXT)); §	SetColorName(_T("inactiveborder"), ::GetSysColor(COLOR_INACTIVEBORDER)); §	SetColorName(_T("inactivecaption"), ::GetSysColor(COLOR_INACTIVECAPTION)); §	SetColorName(_T("inactivecaptiontext"), ::GetSysColor(COLOR_INACTIVECAPTIONTEXT)); §	SetColorName(_T("infobackground"), ::GetSysColor(COLOR_INFOBK)); §	SetColorName(_T("infotext"), ::GetSysColor(COLOR_INFOTEXT)); §	SetColorName(_T("menu"), ::GetSysColor(COLOR_MENU)); §	SetColorName(_T("menutext"), ::GetSysColor(COLOR_MENUTEXT)); §	SetColorName(_T("scrollbar"), ::GetSysColor(COLOR_SCROLLBAR)); §	SetColorName(_T("threeddarkshadow"), ::GetSysColor(COLOR_3DDKSHADOW)); §	SetColorName(_T("threedface"), ::GetSysColor(COLOR_3DFACE)); §	SetColorName(_T("threedhighlight"), ::GetSysColor(COLOR_3DHIGHLIGHT)); §	SetColorName(_T("threedlightshadow"), ::GetSysColor(COLOR_3DLIGHT)); §	SetColorName(_T("threedshadow"), ::GetSysColor(COLOR_3DSHADOW)); §	SetColorName(_T("window"), ::GetSysColor(COLOR_WINDOW)); §	SetColorName(_T("windowframe"), ::GetSysColor(COLOR_WINDOWFRAME)); §	SetColorName(_T("windowtext"), ::GetSysColor(COLOR_WINDOWTEXT)); §} //End SetTableOfColors§§void CPPHtmlDrawer::SetColorName(LPCTSTR lpszColorName, COLORREF color)§{§	iterMapColors iterMap = m_mapColors.find(lpszColorName);§	§	if (iterMap != m_mapColors.end())§		iterMap->second = color; //Modifies§	else§		m_mapColors.insert(std::make_pair(lpszColorName, color)); //Add new§} //End SetColorName§§COLORREF CPPHtmlDrawer::GetColorByName(LPCTSTR lpszColorName, COLORREF crDefColor /* = RGB(0, 0, 0) */)§{§	if (m_bIsEnable)§	{§		iterMapColors iterMap = m_mapColors.find(lpszColorName);§		§		if (iterMap != m_mapColors.end())§			crDefColor = iterMap->second;§	}§	else§	{§		//For disabled output§		crDefColor = m_crDisabled;§	} //if§	return crDefColor;§} //End GetColorByName§§/////////////////////////////////////////////////////////////////§// Gets the system tooltip's logfont§/////////////////////////////////////////////////////////////////§LPLOGFONT CPPHtmlDrawer::GetSystemToolTipFont() const§{§    static LOGFONT lf;§	§    NONCLIENTMETRICS ncm;§    ncm.cbSize = sizeof(NONCLIENTMETRICS);§    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0))§        return FALSE;§	§    memcpy(&lf, &(ncm.lfStatusFont), sizeof(LOGFONT));§	§    return &lf; §} //End GetSystemToolTipFont§§////////////////////////////////////////////§// Check a pointer over the hyperlink§//   In: lpPoint - the coordinates of the mouse pointer §//  Out: -1 - hyperlink not found§//       index of the hyperlink§////////////////////////////////////////////§int CPPHtmlDrawer::PtInHyperlink(LPPOINT lpPoint)§{§	for (UINT i = 0; i < m_arrLinks.size(); ++i)§	{§		STRUCT_HYPERLINK & link = m_arrLinks [i];§		if ((link.rcArea.left <= lpPoint->x) && (link.rcArea.right >= lpPoint->x) &&§			(link.rcArea.top <= lpPoint->y) && (link.rcArea.bottom >= lpPoint->y))§			return i;§	} //for§	return -1;§} //End PtInHyperlink§§void CPPHtmlDrawer::JumpToHyperlink(int nLink)§{§	STRUCT_HYPERLINK & link = m_arrLinks [nLink];§//	TRACE(_T("Jump to Hyperlink number = %d\n"), nLink);§	if (!link.sHyperlink.IsEmpty())§	{§		switch (link.nTypeLink)§		{§		case LINK_HREF:§			GotoURL(link.sHyperlink);§			break;§		case LINK_MESSAGE:§			CallbackOnClickHyperlink(link.sHyperlink);§			break;§		} //switch§	} //if§} //End JumpToHyperlink§§void CPPHtmlDrawer::OnLButtonDown(LPPOINT lpClient)§{§//	TRACE (_T("CPPHtmlDrawer::OnLButtonDown()\n"));§	§	int nLink = PtInHyperlink(lpClient);§	if (nLink >= 0)§	{§		//Hyperlink under the mouse pointer§		JumpToHyperlink(nLink);§	} //if§} //End OnLButtonDown§§BOOL CPPHtmlDrawer::OnSetCursor(LPPOINT lpClient)§{§	int nLink = PtInHyperlink(lpClient);§	if (nLink >= 0)§	{§		STRUCT_HYPERLINK link = m_arrLinks [nLink];§		if (m_nHoverIndexLink != link.nIndexLink)§		{§			m_nHoverIndexLink = link.nIndexLink;§			CallbackOnRepaint(m_nHoverIndexLink);§			//Redraw Window§		} //if§		§		if (!link.sHyperlink.IsEmpty() && (NULL != m_hLinkCursor))§		{§			::SetCursor(m_hLinkCursor);§			return TRUE;§		} //if§	}§	else if (m_nHoverIndexLink != PPHTMLDRAWER_NO_HOVERLINK)§	{§		m_nHoverIndexLink = PPHTMLDRAWER_NO_HOVERLINK;§		CallbackOnRepaint(m_nHoverIndexLink);§		//Redraw Window§	} //if§	§    return FALSE;§} //End OnSetCursor§§BOOL CPPHtmlDrawer::OnTimer()§{§	BOOL bRedraw = FALSE;§	if (m_arrAni.size() > 0)§	{§		for (UINT i = 0; i < m_arrAni.size(); ++i)§		{§			STRUCT_ANIMATION & sa = m_arrAni [i];§			if (sa.nMaxImages > 0)§			{§				sa.nTimerCount ++;§				if (sa.nTimerCount >= sa.nSpeed)§				{§					sa.nTimerCount = 0;§					sa.nIndex ++;§					if (sa.nIndex >= sa.nMaxImages)§						sa.nIndex = 0;§					bRedraw = TRUE;§				} //if§				m_arrAni [i] = sa;§			} //if§		} //for§	} //if§§	return bRedraw;§} //End of OnTimer§§void CPPHtmlDrawer::CallbackOnRepaint(int nIndexLink)§{§//	TRACE(_T("CPPHtmlDrawer::CallbackOnRepaint()\n")); §§	if ((NULL == m_csCallbackRepaint.hWnd) || !m_csCallbackRepaint.nMessage)§		return; § 	§	::SendMessage(m_csCallbackRepaint.hWnd, m_csCallbackRepaint.nMessage, (LPARAM)nIndexLink, m_csCallbackRepaint.lParam);  §} //End CallbackOnRepaint§§void CPPHtmlDrawer::CallbackOnClickHyperlink(LPCTSTR sLink)§{§//	TRACE(_T("CPPHtmlDrawer::CallbackOnClickHyperlink()\n")); §§	if ((NULL == m_csCallbackLink.hWnd) || !m_csCallbackLink.nMessage)§		return; §	§	::SendMessage(m_csCallbackLink.hWnd, m_csCallbackLink.nMessage, (LPARAM)sLink, m_csCallbackLink.lParam);  	§} //if CallbackOnClickHyperlink§§HINSTANCE CPPHtmlDrawer::GotoURL(LPCTSTR url, int showcmd /* = SW_SHOW */)§{§	SetHyperlinkCursor(NULL);§§    TCHAR key[MAX_PATH + MAX_PATH];§§    // First try ShellExecute()§    HINSTANCE result = ShellExecute(NULL, _T("open"), url, NULL, NULL, showcmd);§§    // If it failed, get the .htm regkey and lookup the program§    if ((UINT)result <= HINSTANCE_ERROR) §	{§§        if (GetRegKey(HKEY_CLASSES_ROOT, _T(".htm"), key) == ERROR_SUCCESS) §		{§            lstrcat(key, _T("\\shell\\open\\command"));§§            if (GetRegKey(HKEY_CLASSES_ROOT,key,key) == ERROR_SUCCESS) §			{§                TCHAR *pos;§                pos = _tcsstr(key, _T("\"%1\""));§                if (pos == NULL) §				{                     // No quotes found§                    pos = _tcsstr(key, _T("%1"));      // Check for %1, without quotes §                    if (pos == NULL)                   // No parameter at all...§                        pos = key+lstrlen(key)-1;§                    else§                        *pos = '\0';                   // Remove the parameter§                }§                else§                    *pos = '\0';                       // Remove the parameter§§                lstrcat(pos, _T(" "));§                lstrcat(pos, url);§§                USES_CONVERSION;§                result = (HINSTANCE) WinExec(T2A(key),showcmd);§            } //if§        } //if§    } //if§    return result;§} //End GotoURL§§LONG CPPHtmlDrawer::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)§{§    HKEY hkey;§    LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);§§    if (retval == ERROR_SUCCESS) {§        long datasize = MAX_PATH;§        TCHAR data[MAX_PATH];§        RegQueryValue(hkey, NULL, data, &datasize);§        lstrcpy(retdata,data);§        RegCloseKey(hkey);§    } //if§§    return retval;§} //End GetRegKey§§/////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::DrawHtml (LPSIZE lpSize, LPCRECT lpRect)§{§	//ENG: Bounding rectangle of a current area for output§	//RUS: Œ„‡ÌË˜Ë‚‡˛˘ÂÈ ÔˇÏÓÛ„ÓÎ¸ÌËÍ ‰Îˇ ÚÂÍÛ˘ÂÈ Ó·Î‡ÒÚË ‚˚‚Ó‰‡§	RECT rcArea;§	rcArea.left = lpRect->left;§	rcArea.right = lpRect->right;§	rcArea.top = lpRect->top;§	rcArea.bottom = lpRect->bottom;§§	SIZE szArea;§	szArea.cx = szArea.cy = 0;§	§	if (MODE_FIRSTPASS == m_nNumPass)§	{§		//ENG: In preparing mode clears an auxiliary tables§		//RUS: ¬ ÂÊËÏÂ ÔÓ‰„ÓÚÓ‚ÍË Ó˜Ë˘‡ÂÏ ‚ÒÔÓÏÓ„‡ÚÂÎ¸Ì˚Â Ú‡·ÎËˆ˚ §		m_arrLinks.clear();§//		m_arrTable.clear();§		m_arrHtmlLine.clear();§//		m_arrTableSizes.clear();§		m_arrAni.clear();§	} //if§§	m_nCurLine = 0;§	m_nCurTable = -1;§	m_nNumCurTable = -1;§	m_nCurIndexLink = -1;§	m_nCurIndexAni = -1;§	§	//ENG: Clear stack of tags§	//RUS: Œ˜Ë˘‡ÂÏ ÒÚ˝Í Ú˝„Ó‚§	m_arrStack.clear();§	§	int nIndex = 0;§	int nBegin;§	CPPString strText;§	§	//ENG: Applies a default styles§	//RUS: œËÏÂÌˇÂÏ ÒÚËÎË ÔÓ-ÛÏÓÎ˜‡ÌË˛§	SetDefaultStyles(m_defStyle);§	SelectNewHtmlStyle(_T("body"), m_defStyle);§	§	//ENG: Creates a default font§	//RUS: —ÓÁ‰‡ÂÏ ¯ËÙÚ ÔÓ ÛÏÓÎ˜‡ÌË˛§	m_lfDefault.lfHeight = m_defStyle.nSizeFont;§	m_lfDefault.lfWidth = 0;§	m_lfDefault.lfOrientation = 0;§	m_lfDefault.lfEscapement = 0;§	m_lfDefault.lfWeight = m_defStyle.nWeightFont;§	m_lfDefault.lfItalic = m_defStyle.bItalicFont;§	m_lfDefault.lfStrikeOut = m_defStyle.bStrikeOutFont;§	m_lfDefault.lfUnderline = m_defStyle.bUnderlineFont;§	m_lfDefault.lfCharSet = DEFAULT_CHARSET;§	m_lfDefault.lfOutPrecision = OUT_DEFAULT_PRECIS;§	m_lfDefault.lfClipPrecision = CLIP_DEFAULT_PRECIS;§	m_lfDefault.lfQuality = DEFAULT_QUALITY;§	m_lfDefault.lfPitchAndFamily = FF_DONTCARE;§	_tcscpy (m_lfDefault.lfFaceName, m_defStyle.sFaceFont);§	m_hFont = ::CreateFontIndirect(&m_lfDefault);§	§	//ENG: Remember a current context setting§	//RUS: «‡ÔÓÏËÌ‡ÂÏ ÚÂÍÛ˘ËÂ Ì‡ÒÚÓÈÍË ÍÓÌÚÂÍÒÚ ÛÒÚÓÈÒÚ‚‡§	m_hOldFont = (HFONT)::SelectObject(m_hDC, m_hFont);§	m_nOldBkMode = ::SetBkMode(m_hDC, m_defStyle.nBkMode);§	m_crOldText = ::SetTextColor(m_hDC, m_defStyle.crText);§	m_crOldBk = ::SetBkColor(m_hDC, m_defStyle.crBkgnd);§	::GetTextMetrics(m_hDC, &m_tm);§	§	while (nIndex < m_csHtmlText.GetLength())§	{§		//ENG: Searching a begin of table§		//RUS: »˘ÂÏ Ì‡˜‡ÎÓ Ú‡·ÎËˆ˚§		nBegin = nIndex;§		BOOL bFoundTable = SearchTag(m_csHtmlText, nIndex, _T("table"));§§		//ENG: Gets a text before a table§		//RUS: œÓÎÛ˜‡ÂÏ ÚÂÍÒÚ ‰Ó Ú‡·ÎËˆ˚§		strText = m_csHtmlText.Mid(nBegin, nIndex - nBegin);§§		//ENG: If text before a table is exist§		//RUS: ≈ÒÎË ÚÂÍÒÚ ÔÂÂ‰ Ú‡·ÎËˆÂÈ ÒÛ˘ÂÒÚ‚ÛÂÚ§		if (!strText.IsEmpty())§		{§			//ENG: Add a tag BODY around of a output text§			//RUS: ƒÓ·‡‚ÎˇÂÏ Ú˝„ BODY ‚ÓÍÛ„ ‚˚‚Ó‰ËÏÓ„Ó ÚÂÍÒÚ‡§//			strText = _T("<body>") + strText + _T("</body>");§§			//ENG: Output a text before of a table§			//RUS: ¬˚‚Ó‰ËÏ ÚÂÍÒÚ ÔÂÂ‰ Ú‡·ÎËˆÂÈ§			szArea = DrawHtmlString(strText, &rcArea);§§			//ENG: Updates a output area size§			//RUS: Œ·ÌÓ‚ÎˇÂÏ ‡ÁÏÂ Ó·Î‡ÒÚË ‚˚‚Ó‰‡§			lpSize->cx = std::max(lpSize->cx, szArea.cx);§			lpSize->cy += szArea.cy;§			if (MODE_DRAW == m_nNumPass)§				rcArea.top += szArea.cy;§		} //if§		§		//ENG: If table was found§		//RUS: ≈ÒÎË Ú‡·ÎËˆ‡ ·˚Î‡ Ì‡È‰ÂÌ‡§		if (bFoundTable)§		{§			//ENG: Searching an end of the table§			//RUS: »˘ÂÏ ÓÍÓÌ˜‡ÌËÂ Ú‡·ÎËˆ˚§			nBegin = nIndex;§			nIndex += 6;§			SearchEndOfTable(m_csHtmlText, nIndex);§§			//ENG: Cuts a text of a table§			//RUS: ¬˚ÂÁ‡ÂÏ ÚÂÍÒÚ Ú‡·ÎËˆ˚§			strText = m_csHtmlText.Mid(nBegin, nIndex - nBegin);§§			//ENG: Output a table§			//RUS: ¬˚‚Ó‰ Ú‡·ÎËˆ˚§			szArea = DrawHtmlTable(strText, &rcArea);§			§			//ENG: Updates a output area size§			//RUS: Œ·ÌÓ‚ÎˇÂÏ ‡ÁÏÂ Ó·Î‡ÒÚË ‚˚‚Ó‰‡§			lpSize->cx = std::max(lpSize->cx, szArea.cx);§			lpSize->cy += szArea.cy;§			if (MODE_DRAW == m_nNumPass)§				rcArea.top += szArea.cy;§		} //if§	} //while§	§	//ENG: Restore context setting§	//RUS: ¬ÓÒÒÚ‡Ì‡‚ÎË‚‡ÂÏ Ì‡ÒÚÓÍË ÍÓÌÚÂÍÒÚ‡ ÛÒÚÓÈÒÚ‚‡§	::SetBkMode(m_hDC, m_nOldBkMode);§	::SetBkColor(m_hDC, m_crOldBk);§	::SetTextColor(m_hDC, m_crOldText);§	::SelectObject(m_hDC, m_hOldFont);§	§	//ENG: Clear stack of tags§	//RUS: Œ˜Ë˘‡ÂÏ ÒÚ˝Í Ú˝„Ó‚§	m_arrStack.clear();§	§	//ENG: Delete a font§	//RUS: ”‰‡ÎˇÂÏ ¯ËÙÚ§	::DeleteObject(m_hFont);§} //End of DrawHtml§§§SIZE CPPHtmlDrawer::DrawHtmlTable (CPPString & sTable, LPCRECT lpRect)§{§	//ENG: Jump to the next table§	//RUS: Õ‡˜ËÌ‡ÂÏ ÌÓ‚Û˛ Ú‡·ÎËˆÛ§	m_nCurTable++;§§	int i;§	UINT pos;§	SIZE size = {0, 0};§	SIZE szTable;§	RECT rcTable = {0, 0, 0, 0};§	RECT rcRow;§§	if (MODE_FIRSTPASS == m_nNumPass) §	{§		//ENG: Get size of the table§		//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ˚ Ú‡·ÎËˆ˚§		szTable = GetTableDimensions(sTable);§		§		STRUCT_TABLE st;§		STRUCT_CELL sc;§		sc.nRowSpan = 0;§		sc.nColSpan = 0;§//		sc.bHeightPercent = FALSE;§//		sc.bWidthPercent = FALSE;§//		sc.nHeight = 0;§//		sc.nWidth = 0;§		sc.szText.cx = sc.szText.cy = sc.szCell.cx = sc.szCell.cy = 0;§		sc.bFixedWidth = FALSE;§	§		//ENG: Creates a template of an empty table§		//RUS: —ÓÁ‰‡ÂÏ ¯‡·ÎÓÌ ÔÛÒÚÓÈ Ú‡·ÎËˆ˚§		vecRow rows;§		for (i = 0; i < szTable.cx; i++)§		{§			rows.push_back(sc);§			st.width.push_back(0);§			st.fixed_width.push_back(FALSE);§		} //for§		for (i = 0; i < szTable.cy; i++)§		{§			st.cells.push_back(rows);§			st.height.push_back(0);§		} //for§		§		//ENG: Add a new table§		//RUS: ƒÓ·‡‚ÎˇÂÏ ÌÓ‚Û˛ Ú‡·ÎËˆÛ§		m_arrTables.push_back(st);§	} //if§§	//ENG: Gets an info about a current table§	//RUS: ¬ÁˇÚ¸ ËÌÙÓÏ‡ˆË˛ Ó ÚÂÍÛ˘ÂÈ Ú‡·ÎËˆÂ §	int nIndexTable = m_nCurTable;§	STRUCT_TABLE cur_table = m_arrTables [nIndexTable];§	§	szTable.cx = cur_table.width.size();§	szTable.cy = cur_table.height.size();§§	//ENG: Applies styles of <table> tag§	//RUS: œËÏÂÌˇÂÏ ÒÚËÎË Ú‡·ÎËˆ˚ (Ú˝„ <table>)§	m_defStyle.strTag = _T("table");§	StoreRestoreStyle(FALSE);§	SelectNewHtmlStyle(m_defStyle.strTag, m_defStyle);§	§	//ENG: Passes a tag body and get a properties of the tag§	//RUS: œÓÔÛÒÍ‡ÂÏ Ú˝„ Ì‡˜‡Î‡ ˇ˜ÂÈÍË Ë ÔÓÎÛ˜‡ÂÏ ÒÚÓÍÛ Ò‚ÓÈÒÚ‚ Ú˝„‡§	int nIndex = 0;§	CPPString sTag;§	SearchNextTag(sTable, sTag, nIndex);§	CPPString sProperties = SplitTag(sTag);§§	//ENG: Analyses a properties of the tag§	//RUS: ¿Ì‡ÎËÁËÛÂÏ Ò‚ÓÈÒÚ‚‡ Ú˝„‡§	AnalyseCellParam(sProperties, m_defStyle, TRUE);§	UpdateContext();§§	if (MODE_FIRSTPASS != m_nNumPass)§	{§		//ENG: Gets a real size of the table§		//RUS: œÓÎÛ˜‡ÂÏ Â‡Î¸Ì˚Â ‡ÁÏÂ˚ Ú‡·ÎËˆ˚§		rcTable.left = lpRect->left;§		rcTable.top = rcTable.bottom = lpRect->top;§§		int nWidthTable = m_defStyle.nPadding + cur_table.width.size() - 1;§		for (pos = 0; pos < cur_table.width.size(); ++pos)§			nWidthTable += cur_table.width [pos] + m_defStyle.nPadding;§		rcTable.bottom += m_defStyle.nPadding + cur_table.height.size() - 1;§		for (pos = 0; pos < cur_table.height.size(); ++pos)§			rcTable.bottom += cur_table.height [pos] + m_defStyle.nPadding;§§		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)§		{§			nWidthTable += 6;§			rcTable.bottom += 6;§		}§		else§		{§			nWidthTable += m_defStyle.nBorderWidth * 2;§			rcTable.bottom += m_defStyle.nBorderWidth * 2;§		} //if§§		//ENG: Horizontal align of the table§		//RUS: ¬˚‡‚ÌË‚‡ÌËÂ Ú‡·ÎËˆ˚ ÔÓ „ÓËÁÓÌÚ‡ÎË§		int nRealWidth = lpRect->right - lpRect->left;§§		if (nWidthTable < nRealWidth)§		{§			//RUS: œÓÔ˚Ú‡ÂÏÒˇ ‡ÒÚˇÌÛÚ¸ Ú‡·ÎËˆÛ Ì‡ ‚Ò˛ ‰ÓÒÚÛÔÌÛ˛ Ó·Î‡ÒÚ¸§			int nDelta = nRealWidth - nWidthTable;§			int nNotFixedColumns = 0;§			for (pos = 0; pos < cur_table.fixed_width.size(); ++pos)§			{§				if (!cur_table.fixed_width [pos])§					nNotFixedColumns++;§			} //for§			for (pos = 0; (pos < cur_table.fixed_width.size()) && (nNotFixedColumns > 0); ++pos)§			{§				if (!cur_table.fixed_width [pos])§				{§					int nStep = nDelta / nNotFixedColumns;§					cur_table.width [pos] += nStep;§					nDelta -= nStep;§					nNotFixedColumns--;§					nWidthTable += nStep;§				} //if§			} //for§		} //if§§		if (nWidthTable < nRealWidth)§		{§			switch (m_defStyle.nHorzAlign)§			{§			case ALIGN_RIGHT:§				rcTable.left = lpRect->right - nWidthTable;§				break;§			case ALIGN_CENTER:§				rcTable.left += (nRealWidth - nWidthTable) / 2;§				break;§			} //switch§		} //if§		rcTable.right = rcTable.left + nWidthTable;§§		//Calculate the real column's width and row's height§//		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)§//			rcTable.bottom += m_defStyle.nBorderWidth * 6;§//		else§//			rcTable.bottom += m_defStyle.nBorderWidth * 2;§	} //if§§	//Draw table border§	if (MODE_DRAW == m_nNumPass)§	{§		if (m_defStyle.nFillBkgnd >= 0)§		{§			m_drawmanager.FillEffect(m_hDC, m_defStyle.nFillBkgnd, &rcTable, §				m_defStyle.crBkgnd, m_defStyle.crMidBkgnd, m_defStyle.crEndBkgnd,§				5);§		}§		else if (!m_defStyle.strNameResBk.IsEmpty())§		{§			DrawBackgroundImage(m_hDC, rcTable.left, rcTable.top, rcTable.right - rcTable.left, rcTable.bottom - rcTable.top, m_defStyle.strNameResBk);§		} //if§		if (m_defStyle.nBorderWidth > 0)§		{§			if (m_bIsEnable)§			{§				m_drawmanager.DrawRectangle(m_hDC, &rcTable, m_defStyle.crBorderLight, m_defStyle.crBorderDark,§					m_defStyle.nBorderStyle, m_defStyle.nBorderWidth);§			}§			else§			{§				m_drawmanager.DrawRectangle(m_hDC, &rcTable, m_crDisabled, m_crDisabled,§					m_defStyle.nBorderStyle, m_defStyle.nBorderWidth);§			} //if§		} //if§	} //if§§	rcRow = rcTable;§§	if (MODE_FIRSTPASS != m_nNumPass)§	{§		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)§		{§			rcRow.left += 3;§			rcRow.top  += 3;§			rcRow.right -= 3;§			rcRow.bottom -= 3;§		}§		else§		{§			rcRow.left += m_defStyle.nBorderWidth;§			rcRow.top  += m_defStyle.nBorderWidth;§			rcRow.right -= m_defStyle.nBorderWidth;§			rcRow.bottom -= m_defStyle.nBorderWidth;§		}§	} //if§§	if (szTable.cx && szTable.cy)§	{§		int nNewRow = 0;§		int nEndRow;§		CPPString sTagName, sTagParam, sRow;§		for (i = 0; i < szTable.cy; ++i)§		{§			//ENG: Searching a begin of the row§			//RUS: œÓËÒÍ Ì‡˜‡Î‡ ÒÚÓÍË§			if (SearchTag(sTable, nNewRow, _T("tr")))§			{§				//ENG: The begin of the row was found. Searching end of the row§				//RUS: Õ‡˜‡ÎÓ ÒÚÓÍË Ì‡È‰ÂÌÓ. »˘ÂÏ ÓÍÓÌ˜‡ÌËÂ ÒÚÓÍË§				nEndRow = nNewRow;§				SearchEndOfRow(sTable, nEndRow);§				//ENG: The end of the row was found§				//RUS: ŒÍÓÌ˜‡ÌËÂ ÒÚÓÍË Ì‡È‰ÂÌÓ§				sRow = sTable.Mid(nNewRow, nEndRow - nNewRow);§				§				//ENG: Draw a row of the table§				//RUS: ¬˚‚Ó‰ËÏ ÒÚÓÍÛ Ú‡·ÎËˆ˚§				DrawHtmlTableRow(sRow, &rcRow, cur_table, i);§				§				//ENG: Jump to char after the end of the row§				//RUS: œÂÂÏÂ˘‡ÂÏÒˇ Ì‡ ÒËÏ‚ÓÎ, ÒÎÂ‰Û˛˘ËÈ Á‡ ÓÍÓÌ˜‡ÌËÂÏ ÒÚÓÍË§				nNewRow = nEndRow + 5;§			} //if§		} //for§	} //if§§	if (MODE_DRAW != m_nNumPass)§	{§		//ENG: Analysing cell's width§		//RUS: ¿Ì‡ÎËÁ ¯ËËÌ˚ ˇ˜ÂÈÍË§		for (i = 1; i <= szTable.cx; i++)§		{§			for (int y = 0; y < szTable.cy; y++)§			{§				vecRow & row = cur_table.cells [y];§				for (int x = 0; x < szTable.cx; x++)§				{§					STRUCT_CELL & sc = row [x];§					if (sc.nColSpan == i)§					{§						if (i == 1)§						{§							cur_table.width [x] = std::max ((long)cur_table.width [x], sc.szCell.cx);§							if (sc.bFixedWidth)§								cur_table.fixed_width [x] = TRUE;§						}§						else§						{§							int span_width = 0;§							for (int z = 0; z < i; z++)§							{§								span_width += cur_table.width [x + z];§								if (sc.bFixedWidth)§									cur_table.fixed_width [x + z] = TRUE;§							} //for§							§							if (span_width < sc.szText.cx)§							{§								int step = (sc.szCell.cx - span_width) / i;§								cur_table.width [x + i - 1] += (sc.szCell.cx - span_width) % i;§								for (int z = 0; z < i; z++)§									cur_table.width [x + z] += step;§							} //if§						} //if§					} //if§				} //for§			} //for§		} //for§§		//ENG: Analysing cell's height§		//RUS: ¿Ì‡ÎËÁ ‚˚ÒÓÚ˚ ˇ˜ÂÈÍË§		for (i = 1; i <= szTable.cy; i++)§		{§			for (int y = 0; y < szTable.cy; y++)§			{§				vecRow & row = cur_table.cells [y];§				for (int x = 0; x < szTable.cx; x++)§				{§					STRUCT_CELL & sc = row [x];§					if (sc.nRowSpan == i)§					{§						if (i == 1)§							cur_table.height [y] = std::max ((long)cur_table.height [y], sc.szCell.cy);§						else§						{§							int span_height = 0;§							for (int z = 0; z < i; z++)§								span_height += cur_table.height [y + z];§							§							if (span_height < sc.szCell.cy)§							{§								int step = (sc.szCell.cy - span_height) / i;§								cur_table.height [y] += (sc.szCell.cy - span_height) % i;§								for (int z = 0; z < i; z++)§									cur_table.height [y + z] += step;§							} //if§						} //if§					} //if§				} //for§			} //for§		} //for§§		size.cx += m_defStyle.nPadding + szTable.cx - 1;§		size.cy += m_defStyle.nPadding + szTable.cy - 1;§		for (i = 0; i < szTable.cx; i++)§			size.cx += cur_table.width [i] + m_defStyle.nPadding;§		for (i = 0; i < szTable.cy; i++)§			size.cy += cur_table.height [i] + m_defStyle.nPadding;§		§		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)§		{§			size.cx += m_defStyle.nBorderWidth * 6;§			size.cy += m_defStyle.nBorderWidth * 6;§		}§		else§		{§			size.cx += m_defStyle.nBorderWidth * 2;§			size.cy += m_defStyle.nBorderWidth * 2;§		} //if§§//		size.cx = GetTableWidth(strTable, 0, size.cx, TRUE);§	}§	else§	{§		size.cx = rcTable.right - rcTable.left;§		size.cy = rcTable.bottom - rcTable.top;§	} //if§§	//ENG: Stores a current table§	//RUS: —Óı‡ÌˇÂÏ ÚÂÍÛ˘Û˛ Ú‡·ÎËˆÛ§	m_arrTables [nIndexTable] = cur_table;§§	//ENG: Restore styles before <table> tag§	//RUS: ¬ÓÒÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÒÚËÎË ‰Ó Ú˝„‡ <table>§	m_defStyle.strTag = _T("table");§	if (StoreRestoreStyle(TRUE))§		UpdateContext();§§	return size;§} //End DrawHtmlTable§§///////////////////////////////////////////////////////////////////////////////§// CPPHtmlDrawer::DrawHtmlTableRow§//	Draw a row of the table§//-----------------------------------------------------------------------------§// Parameters:§//		sRow	- a text of the cell with the tags. For example: "<tr>...</tr>"§//		lpRect	- a bounding rectangle for the row§//		st		- the info about current table§//		nRow	- the current row of the table§///////////////////////////////////////////////////////////////////////////////§//§///////////////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::DrawHtmlTableRow(CPPString & sRow, LPCRECT lpRect, STRUCT_TABLE & st, int nRow)§{§	//ENG: Applies styles of <tr> tag§	//RUS: œËÏÂÌˇÂÏ ÒÚËÎË ÒÚÓÍË (Ú˝„ <tr>)§	m_defStyle.strTag = _T("tr");§	StoreRestoreStyle(FALSE);§	SelectNewHtmlStyle(m_defStyle.strTag, m_defStyle);§	§	int nCol = 0;§	int i;§	vecRow & row = st.cells [nRow];§	§	//ENG: Passes a tag body and get a properties of the tag§	//RUS: œÓÔÛÒÍ‡ÂÏ Ú˝„ Ì‡˜‡Î‡ ˇ˜ÂÈÍË Ë ÔÓÎÛ˜‡ÂÏ ÒÚÓÍÛ Ò‚ÓÈÒÚ‚ Ú˝„‡§	int nIndex = 0;§	CPPString sTag;§	SearchNextTag(sRow, sTag, nIndex);§	CPPString sProperties = SplitTag(sTag);§§	//ENG: Analyses a properties of the tag§	//RUS: ¿Ì‡ÎËÁËÛÂÏ Ò‚ÓÈÒÚ‚‡ Ú˝„‡§	AnalyseCellParam(sProperties, m_defStyle, FALSE);§	UpdateContext();§	§	while (nIndex < sRow.GetLength())§	{§		int nEndRow = nIndex;§		int nNewCell = nIndex;§		//ENG: Search an end of the cell or a begin of the nested table§		//RUS: »˘ÂÏ ÍÓÌÂˆ ˇ˜ÂÈÍË ËÎË Ì‡˜‡ÎÓ ‚ÎÓÊÂÌÌÓÈ Ú‡·ÎËˆ˚§		SearchTag(sRow, nEndRow, _T("/tr"));§		SearchTag(sRow, nNewCell, _T("td"));§		if (nNewCell < nEndRow)§		{§			//ENG: Search an existing cell§			//RUS: œÓËÒÍ ÒÛ˘ÂÒÚ‚Û˛˘ÂÈ ˇ˜ÂÈÍË§			STRUCT_CELL * sc2 = &row [nCol];§			while ((sc2->nColSpan < 0) && (nCol < (int)row.size())) §			{§				nCol++;§				sc2 = &row [nCol];§			} //while§			STRUCT_CELL & sc = row [nCol];§			//ENG: Searching the end of the cell§			//RUS: »˘ÂÏ ÓÍÓÌ˜‡ÌËÂ ˇ˜ÂÈÍË§			nIndex = nNewCell;§			SearchEndOfCell(sRow, nIndex);§			CPPString sCell = sRow.Mid(nNewCell, nIndex - nNewCell);§§			RECT rcCell = {0, 0, 0, 0};§			if (MODE_FIRSTPASS != m_nNumPass)§			{§				//ENG: Gets a real rectangle to draw a cell§				//RUS: œÓÎÛ˜‡ÂÏ Â‡Î¸Ì˚È ÔˇÏÓÛ„ÓÎ¸ÌËÍ ‰Îˇ ‚˚‚Ó‰‡ ˇ˜ÂÈÍË§				rcCell = *lpRect;§				rcCell.left += m_defStyle.nPadding;§				for (i = 0; i < nCol; i++)§					rcCell.left += st.width [i] + m_defStyle.nPadding + 1;§				rcCell.right = rcCell.left;§				for (i = 0; i < sc.nColSpan; i++)§					rcCell.right += st.width [nCol + i];§				rcCell.right += (sc.nColSpan - 1) * (m_defStyle.nPadding + 1);§				§				rcCell.top += m_defStyle.nPadding;§				for (i = 0; i < nRow; i++)§					rcCell.top += st.height [i] + m_defStyle.nPadding + 1;§				rcCell.bottom = rcCell.top;§				for (i = 0; i < sc.nRowSpan; i++)§					rcCell.bottom += st.height [nRow + i];§				rcCell.bottom += (sc.nRowSpan - 1) * (m_defStyle.nPadding + 1);§§				//ENG: cellspacing - margins from table's edge to the cell's edge§				//RUS: cellspacing - ÓÚÒÚÛÔ ÓÚ ÍÓÌÚÛ‡ Ú‡·ÎËˆ˚ ‰Ó ˇ˜ÂÈÍË §//				rcCell.left += m_defStyle.nPadding;§//				rcCell.top += m_defStyle.nPadding;§//				rcCell.right -= m_defStyle.nPadding;§//				rcCell.bottom -= m_defStyle.nPadding;§			} //if§§			DrawHtmlTableCell(sCell, &rcCell, sc);§§			if (MODE_DRAW != m_nNumPass)§			{§				//ENG: Add a cellspacing§				//RUS: ƒÓ·‡‚ÎˇÂÏ ÓÚÒÚÛÔ ˇ˜ÂÈÍË ÓÚ§//				sc.szCell.cx += m_defStyle.nPadding + m_defStyle.nPadding;§//				sc.szCell.cy += m_defStyle.nPadding + m_defStyle.nPadding;§				§				//ENG: Stores a span cells§				//RUS: «‡ÔÓÏËÌ‡ÂÏ Ó·˙Â‰ËÌÂÌÌ˚Â ˇ˜ÂÈÍË§				int nColSpan = sc.nColSpan + nCol;§				int nRowSpan = sc.nRowSpan + nRow;§				for (i = nCol + 1; i < nColSpan; i++)§				{§					STRUCT_CELL & scTemp = row [i];§					scTemp.nColSpan = -1;§					scTemp.nRowSpan = -1;§				} //for§				for (i = nRow + 1; i < nRowSpan; i++)§				{§					vecRow & rowTemp = st.cells [i];§					STRUCT_CELL & scTemp = rowTemp [nCol];§					scTemp.nColSpan = -1;§					scTemp.nRowSpan = -1;§				} //for§			} //if§			nCol += sc.nColSpan;§		}§		else§		{§			nIndex = sRow.GetLength();§		} //if§	} //while§§	//ENG: Restore styles before <tr> tag§	//RUS: ¬ÓÒÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÒÚËÎË ‰Ó Ú˝„‡ <tr>§	m_defStyle.strTag = _T("tr");§	if (StoreRestoreStyle(TRUE))§		UpdateContext();§§} //End of DrawHtmlTableRow§§///////////////////////////////////////////////////////////////////////////////§// CPPHtmlDrawer::DrawHtmlTableCell§//	Draw a table's cell§//-----------------------------------------------------------------------------§// Parameters:§//		sCell	- a text of the cell with the tags. For example: "<td>...</td>"§//		lpRect	- a bounding rectangle for cell§//		sc		- the info about current cell§///////////////////////////////////////////////////////////////////////////////§//§///////////////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::DrawHtmlTableCell(CPPString & sCell, LPCRECT lpRect, STRUCT_CELL & sc)§{§	if (MODE_DRAW != m_nNumPass)§	{§		sc.szText.cx = 0;§		sc.szText.cy = 0;§	} //if§	§	RECT rcCell = *lpRect;§	RECT rcText;§§	//ENG: Applies styles of <td> tag§	//RUS: œËÏÂÌˇÂÏ ÒÚËÎË ˇ˜ÂÈÍË (Ú˝„ <td>)§	m_defStyle.strTag = _T("td");§	StoreRestoreStyle(FALSE);§	SelectNewHtmlStyle(m_defStyle.strTag, m_defStyle);§§	//ENG: Passes a tag body and get a properties of the tag§	//RUS: œÓÔÛÒÍ‡ÂÏ Ú˝„ Ì‡˜‡Î‡ ˇ˜ÂÈÍË Ë ÔÓÎÛ˜‡ÂÏ ÒÚÓÍÛ Ò‚ÓÈÒÚ‚ Ú˝„‡§	int nIndex = 0;§	CPPString sTag;§	SearchNextTag(sCell, sTag, nIndex);§	CPPString sProperties = SplitTag(sTag);§§	//ENG: Analyses a properties of the tag§	//RUS: ¿Ì‡ÎËÁËÛÂÏ Ò‚ÓÈÒÚ‚‡ Ú˝„‡§	m_defStyle.nCellWidth = m_defStyle.nCellHeight = 0;§	m_defStyle.bCellWidthPercent = m_defStyle.bCellHeightPercent = FALSE;§	SIZE szSpan = AnalyseCellParam(sProperties, m_defStyle, FALSE);§§	if (MODE_FIRSTPASS == m_nNumPass)§	{§		//ENG: Stores a cell span info§		//RUS: —Óı‡ÌˇÂÏ ËÌÙÓÏ‡ˆË˛ Ó· Ó·˙Â‰ËÌÂÌËË ˇ˜ÂÂÍ§		sc.nColSpan = szSpan.cx;§		sc.nRowSpan = szSpan.cy;§		//ENG: Stores an info about the recommended cell sizes§		//RUS: —Óı‡ÌˇÂÏ ËÌÙÓÏ‡ˆË˛ Ó· ÂÍÓÏÂÌ‰Ó‚‡ÌÌ˚ı ‡ÁÏÂ‡ı ˇ˜ÂÈÍË§//		sc.nWidth = m_defStyle.nCellWidth;§//		sc.bWidthPercent = m_defStyle.bCellWidthPercent;§//		sc.nHeight = m_defStyle.nCellHeight;§//		sc.bHeightPercent = m_defStyle.bCellHeightPercent;§		//ENG: §		//RUS: ≈ÒÎË ÛÍ‡Á‡Ì˚ ÏËÌËÏ‡Î¸Ì˚Â aÁÏÂ˚ ˇ˜ÂÈÍË, ÚÓ ÛÒÚ‡ÌÓ‚ËÚ¸ Ëı Í‡Í Ì‡˜‡Î¸Ì˚Â§		sc.szText.cx = m_defStyle.nCellWidth;§//		sc.szText.cy = m_defStyle.nCellHeight;§		sc.szText.cy = 0;§§		if (m_defStyle.nCellWidth > 0)§			sc.bFixedWidth = TRUE;§§		rcText = rcCell;§		rcText.right = rcText.left + sc.szText.cx;§		rcText.bottom = rcText.top + sc.szText.cy;§	}§	else if (MODE_DRAW == m_nNumPass)§	{§		//ENG: cellspacing - margins from table's edge to the cell's edge§		//RUS: cellspacing - ÓÚÒÚÛÔ ÓÚ ÍÓÌÚÛ‡ Ú‡·ÎËˆ˚ ‰Ó ˇ˜ÂÈÍË §		rcText = rcCell;§§		if (m_defStyle.nFillBkgnd >= 0)§		{§			//ENG: Filling cell background§			//RUS: «‡ÔÓÎÌÂÌËÂ ÙÓÌ‡ ˇ˜ÂÈÍË§			m_drawmanager.FillEffect(m_hDC, m_defStyle.nFillBkgnd, &rcText, §				m_defStyle.crBkgnd, m_defStyle.crMidBkgnd, m_defStyle.crEndBkgnd, 5);§		} //if§		§		//Draws the border§		if (m_bIsEnable) §			m_drawmanager.DrawRectangle(m_hDC, &rcText, m_defStyle.crBorderDark, m_defStyle.crBorderLight, m_defStyle.nBorderStyle);§		else §			m_drawmanager.DrawRectangle(m_hDC, &rcText, m_crDisabled, m_crDisabled, m_defStyle.nBorderStyle);§		§		//ENG: cellpadding - margin from cell's edge to the inside cell text§		//RUS: cellpadding - ÓÚÒÚÛÔ ÓÚ ÍÓÌÚÛ‡ ˇ˜ÂÈÍË, ‰Ó ÚÂÍÒÚ‡ ‚ÌÛÚË ÂÂ§		rcText.left += m_defStyle.nMargin + m_defStyle.nBorderWidth;§		rcText.top += m_defStyle.nMargin + m_defStyle.nBorderWidth;§		rcText.right -= m_defStyle.nMargin + m_defStyle.nBorderWidth;§		rcText.bottom -= m_defStyle.nMargin + m_defStyle.nBorderWidth;§		§		//Vertical align§		switch (m_defStyle.nVertAlign)§		{§		case ALIGN_BOTTOM:§			rcText.top = rcText.bottom - sc.szText.cy;§			break;§		case ALIGN_VCENTER:§			rcText.top += (rcText.bottom - rcText.top - sc.szText.cy) / 2;§			break;§		} //switch§	} //if§§	//ENG: Draws a cell§	//RUS: ¬˚‚Ó‰ ˇ˜ÂÈÍË§	while(nIndex < sCell.GetLength())§	{§		int nEndCell = nIndex;§		int nNewTable = nIndex;§		//ENG: Search an end of the cell or a begin of the nested table§		//RUS: »˘ÂÏ ÍÓÌÂˆ ˇ˜ÂÈÍË ËÎË Ì‡˜‡ÎÓ ‚ÎÓÊÂÌÌÓÈ Ú‡·ÎËˆ˚§		SearchTag(sCell, nEndCell, _T("/td"));§		SearchTag(sCell, nNewTable, _T("table"));§		//ENG: Gets a nearly index of the tag§		//RUS: œÓÎÛ˜‡ÂÏ ËÌ‰ÂÍÒ ·ÎËÊ‡È¯Â„Ó Ú˝„‡§		int nNearlyTag = std::min(nEndCell, nNewTable);§		SIZE szTemp = {0, 0};§		if (nNearlyTag > nIndex)§		{§			//ENG: If between the last index and the current index there is a text§			//RUS: ≈ÒÎË ÏÂÊ‰Û ÔÓÒÎÂ‰ÌËÏ ËÌ‰ÂÍÒÓÏ Ë ÚÂÍÛ˘ËÏ ËÌ‰ÂÍÒÓÏ ÒÛ˘ÂÒÚ‚ÛÂÚ ÚÂÍÒÚ§			CPPString sText = sCell.Mid(nIndex, nNearlyTag - nIndex);§			szTemp = DrawHtmlString(sText, &rcText);§			nIndex = nNearlyTag;§		} //if§		else if (nNewTable < nEndCell)§		{§			//ENG: A nested table was found§			//RUS: Õ‡È‰ÂÌ‡ ‚ÎÓÊÂÌÌ‡ˇ Ú‡·ÎËˆ‡§			nIndex = nNewTable;§			SearchEndOfTable(sCell, nIndex);§			CPPString sTable = sCell.Mid(nNewTable, nIndex - nNewTable);§			szTemp = DrawHtmlTable(sTable, &rcText); §		}§		else§		{§			//ENG: Alas, it is the end of the cell§			//RUS:  ÓÌÂˆ ˇ˜ÂÈÍË§			nIndex = sCell.GetLength();§		} //if§		§		if (MODE_DRAW != m_nNumPass)§		{§			//ENG: On first and second passes we are calculate the dimensions of the cell§			//RUS: Õ‡ ÔÂ‚ÓÏ Ë ‚ÚÓÓÏ ÔÓıÓ‰‡ı ‚˚˜ËÒÎˇÂÏ ‡ÁÏÂ˚ ˇ˜ÂÈÍË.§			sc.szText.cx = std::max(szTemp.cx, sc.szText.cx);§			sc.szText.cy += szTemp.cy;§		} //if§		rcText.top += szTemp.cy;§	} //while§§	if (MODE_DRAW != m_nNumPass)§	{§		//ENG: On first and second passes we are calculate the dimensions of the cell§		//RUS: Õ‡ ÔÂ‚ÓÏ Ë ‚ÚÓÓÏ ÔÓıÓ‰‡ı ‚˚˜ËÒÎˇÂÏ ‡ÁÏÂ˚ ˇ˜ÂÈÍË.§		sc.szCell.cx = std::max((long)m_defStyle.nCellWidth, sc.szText.cx);§		sc.szCell.cy = std::max((long)m_defStyle.nCellHeight, sc.szText.cy);§§		//ENG: Add the margins of the text from the cell's edges§		//RUS: ƒÓ·‡‚ÎˇÂÏ ÓÚÒÚÛÔ˚ ÚÂÍÒÚ‡ ÓÚ „‡ÌËˆ ˇ˜ÂÈÍË§		sc.szCell.cx += 2 * (m_defStyle.nMargin + m_defStyle.nBorderWidth);§		sc.szCell.cy += 2 * (m_defStyle.nMargin + m_defStyle.nBorderWidth);§	} //if§		§	//ENG: Restore styles before <td> tag§	//RUS: ¬ÓÓÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÒÚËÎË, ÍÓÚÓ˚Â ·˚ÎË ‰Ó Ú˝„‡ <td>§	m_defStyle.strTag = _T("td");§	if (StoreRestoreStyle(TRUE))§		UpdateContext();§}§§SIZE CPPHtmlDrawer::DrawHtmlString (CPPString & sHtml, LPCRECT lpRect)§{§	SIZE szTextArea = {0, 0};§§	COLORREF clrShadow = m_bIsEnable ? m_crShadow : GetColorByName("");§§	//ENG: For any string we are add a <body> tag as wrapper§	//RUS: ƒÎˇ Î˛·ÓÈ ÒÚÓÍË ‰Ó·‡‚ÎˇÂÏ Ú˝„ <body>§	sHtml = _T("<body>") + sHtml;§	sHtml += _T("</body>");§§	//ENG: Bounding rectangle for a full text§	//RUS: Œ„‡ÌË˜Ë‚‡˛˘ËÈ ÔˇÏÓÛ„ÓÎ¸ÌËÍ ‰Îˇ ‚˚‚Ó‰‡ ‚ÒÂ„Ó ÚÂÍÒÚ‡§	m_rcOutput.top = lpRect->top;§	m_rcOutput.left = lpRect->left;§	m_rcOutput.bottom = lpRect->bottom;§	m_rcOutput.right = lpRect->right;§§	//ENG: The width of the bounding rectangle§	//RUS: ÿËËÌ‡ Ó„‡ÌË˜Ë‚‡˛˘Â„Ó ÔˇÏÓÛ„ÓÎ¸ÌËÍ‡§	int nTextWrapWidth = m_rcOutput.right - m_rcOutput.left;§§	//ENG: A current position for output§	//RUS: “ÂÍÛ˘‡ˇ ÔÓÁËˆËˇ ‰Îˇ ‚˚‚Ó‰‡§	POINT ptOutput;§	ptOutput.x = lpRect->left;§	ptOutput.y = lpRect->top;§§//	szTextArea.cx = szTextArea.cy = 0;§//	m_szOutput.cx = m_szOutput.cy = 0;§§//	m_szOutput = CSize(0, 0);§§	//ENG: If a text is empty§	//RUS: ≈ÒÎË ÚÂÍÒÚ‡ ‰Îˇ ‚˚‚Ó‰‡ ÌÂÚ§//	if (str.IsEmpty())§//	{§//		szTextArea.cx = szTextArea.cy = 0;§//		return;§//	} //if§§	int nFirstLine = m_nCurLine;§§//	POINT pt;§//	pt.x = lpRect->left;§//	pt.y = lpRect->top;§§	int y;§	SIZE sz;§§	CPPString sText = _T("");§	CPPString sTag = _T(""); //String of the tag§	CPPString sProperties = _T(""); //String of the tag's property§	CPPString sParameter = _T("");§	CPPString sValue = _T("");§§	BOOL bCloseTag = FALSE; //TRUE if tag have symbol '\'§§	//ENG: Initializing a new line§	//RUS: »ÌËˆË‡ÎËÁ‡ˆËˇ ÌÓ‚ÓÈ ÒÚÓÍË§	ptOutput.x = InitNewLine(ptOutput.x);§	int nBeginLineX = ptOutput.x;§	int nSpacesInLine = m_hline.nSpaceChars;§	int nRealWidth = m_hline.nWidthLine;§§	int nIndex = 0;§	int nBegin = 0;§	int i = 0;§	while (i < sHtml.GetLength())§	{§		//ENG: Searching a first tag§		//RUS: œÓËÒÍ ÔÂ‚Ó„Ó Ú˝„‡§		sText = SearchNextTag(sHtml, sTag, i);§		sProperties = SplitTag(sTag);§§		//ENG: Before a tag was exist a text§		//RUS: œÂÂ‰ Ú˝„ÓÏ ÂÒÚ¸ ÚÂÍÒÚ ‰Îˇ ‚˚‚Ó‰‡§		if (!sText.IsEmpty())§		{§			//ENG: Transform text§			//RUS: œÂÓ·‡ÁÛÂÏ ÚÂÍÒÚ§			switch (m_defStyle.nTextTransform)§			{§			case TEXT_TRANSFORM_UPPERCASE:§				//ENG: All chars make upper§				//RUS: ¬ÒÂ ÒËÏ‚ÓÎ˚ ÔÂÂ‚Ó‰ËÏ ‚ ‚ÂıÌËÈ Â„ËÒÚ§				sText.MakeUpper();§				break;§			case TEXT_TRANSFORM_LOWERCASE:§				//ENG: All chars make lower§				//RUS: ¬ÒÂ ÒËÏ‚ÓÎ˚ ÔÂÂ‚Ó‰ËÏ ‚ ÌËÊÌËÈ Â„ËÒÚ§				sText.MakeLower();§				break;§			case TEXT_TRANSFORM_CAPITALIZE:§				//ENG: Each first char of a word to upper§				//RUS:  ‡‰˚È ÔÂ‚˚È ÒËÏ‚ÓÎ ÒÎÓ‚‡ ‚ ‚ÂıÌËÈ Â„ËÒÚ, ÓÒÚ‡Î¸Ì˚Â ‚ ÌËÊÌËÈ§				sText.MakeLower();§				for (nIndex = 0; nIndex < sText.GetLength(); nIndex++)§				{§					if ((sText.GetAt(nIndex) >= _T('a')) && (sText.GetAt(nIndex) <= _T('z')))§					{§						if ((0 == nIndex) || (_T(' ') == sText.GetAt(nIndex - 1)))§							sText.SetAt(nIndex, sText.GetAt(nIndex) - _T('a') + _T('A'));§					} //if§				} //if§				break;§			} //switch§§			//RUS: «‡ˆËÍÎË‚‡ÂÏ ‰Ó ÚÂı ÔÓ, ÔÓÍ‡ ÌÂ ·Û‰ÂÚ ‚˚‚Â‰ÂÌ ‚ÂÒ¸ ÚÂÍÒÚ§			while (!sText.IsEmpty())§			{§				//ENG: Reset an additional interval for space chars§				//RUS: —·ÓÒ ‰ÓÔÓÎÌËÚÂÎ¸ÌÓ„Ó ËÌÚÂ‚‡Î‡ ÏÂÊ‰Û ÒÎÓ‚‡ÏË§				::SetTextJustification(m_hDC, 0, 0);§§				//ENG: Gets a size a output text§				//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ ‚˚‚Ó‰ËÏÓ„Ó ÚÂÍÒÚ‡§				::GetTextExtentPoint32(m_hDC, sText, sText.GetLength(), &sz);§§				//ENG: Gets a real top coordinate to output with vertical alignment§				//RUS: œÓÎÛ˜‡ÂÏ Â‡Î¸ÌÛ˛ ÍÓÓ‰ËÌ‡ÚÛ ‚Âı‡ ‚˚‚Ó‰‡ Ò Û˜ÂÚÓÏ ‚ÂÚËÍ‡Î¸ÌÓ„Ó ‚˚‡‚ÌË‚‡ÌËˇ§				y = VerticalAlignText(ptOutput.y, sz.cy);§§				CPPString sTemp = sText;§				int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;§§				if (m_nMaxWidth && ((nMaxSize - sz.cx) < 0) && nTextWrapWidth)§				{§					//ENG: Text wrap was enabled and text out for a bounding rectangle§					int nRealSize = nMaxSize;§					sTemp = GetWordWrap(sText, nTextWrapWidth, nRealSize);§					sz.cx = nRealSize;§				}§				else§				{§					sText.Empty();§				} //if§§				if (MODE_DRAW == m_nNumPass)§				{§					if (sz.cx)§					{§						if ((0 == (nRealWidth - sz.cx)) && (_T(' ') == sTemp.GetAt(sTemp.GetLength() - 1)))§						{§							//ENG: Removes the right space chars for the last output in line§							//RUS: ≈ÒÎË ˝ÚÓ ÔÓÒÎÂ‰ÌËÈ ‚˚‚Ó‰ ‚ ÒÚÓÍÂ, ÚÓ Û·Ë‡ÂÏ ÔÓ·ÂÎ˚ ÒÔ‡‚‡§							sTemp.TrimRight();§							nSpacesInLine = GetCountOfChars(sTemp);§							SIZE szTemp;§							::GetTextExtentPoint32(m_hDC, sTemp, sTemp.GetLength(), &szTemp);§							nRealWidth -= (sz.cx - szTemp.cx);§						} //if§§						if ((ALIGN_JUSTIFY == m_hline.nHorzAlign) && m_hline.bWrappedLine)§							::SetTextJustification(m_hDC, nMaxSize - nRealWidth, nSpacesInLine);§						nRealWidth -= sz.cx;§						§						//ENG: Gets a size a output text§						//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ ‚˚‚Ó‰ËÏÓ„Ó ÚÂÍÒÚ‡§						::GetTextExtentPoint32(m_hDC, sTemp, sTemp.GetLength(), &sz);§						§						//ENG: Stores a current area as a hyperlink area if it available§						//RUS: —Óı‡ÌˇÍÏ ÚÂÍÛ˘Û˛ Ó·Î‡ÒÚ¸ Í‡Í Ó·Î‡ÒÚ¸ „ËÔÂÎËÌÍ‡ ÂÒÎË ÓÌ ÛÒÚ‡ÌÓ‚ÎÂÌ§						StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);§						§						//ENG: Real output a text§						//RUS: ¬˚‚Ó‰ ÚÂÍÒÚ‡§						::TextOut(m_hDC, ptOutput.x, y, sTemp, sTemp.GetLength());§						nSpacesInLine -= GetCountOfChars(sTemp);§						§						//ENG: If sets an overline style then draw a line over the text§						//RUS: ≈ÒÎË ÛÒÚ‡ÌÓ‚ÎÂÌ ÒÚËÎ¸ overline, ÚÓ ËÒÛÂÏ ÎËÌË˛ Ì‡‰ ÚÂÍÒÚÓÏ§						if (m_defStyle.bOverlineFont)§						{§							HPEN hpenOverline = ::CreatePen(PS_SOLID, (m_defStyle.nWeightFont >= FW_BOLD) ? 2 : 1, m_defStyle.crText);§							HPEN hOldPen = (HPEN)::SelectObject(m_hDC, hpenOverline);§							::MoveToEx(m_hDC, ptOutput.x, y, NULL);§							::LineTo(m_hDC, ptOutput.x + sz.cx, y);§							::SelectObject(m_hDC, hOldPen);§						} //if§					} //if§				}§				else§				{§					//ENG: Stores a last horizontal alignment§					//RUS: —Óı‡ÌˇÂÏ ÔÓÒÎÂ‰ÌÂÂ „ÓËÁÓÌÚ‡Î¸ÌÓÂ ‚˚‡‚ÌË‚‡ÌËÂ§					m_hline.nHorzAlign = m_defStyle.nHorzAlign;§§					//ENG:§					//RUS:§					m_hline.nSpaceChars += GetCountOfChars(sTemp);§				} //if§§				//ENG: Moves to a right of the outputed text§				//RUS: œÂÂÏÂ˘‡ÂÏÒˇ ÒÔ‡‚‡ ÓÚ ‚˚‚Â‰ÂÌÌÓ„Ó ÚÂÍÒÚ‡§				ptOutput.x += sz.cx;§				if (!sText.IsEmpty())§				{§					//ENG: Not all text was printed (cause text wrap) §					//RUS: ÕÂ ‚Òˇ ÒÚÓÍ‡ Â˘Â ‚˚‚ÂÎ‡Ò¸ (‚ ÒÎÛ˜‡Â ÔÂÂÌÓÒ‡ ÚÂÍÒÚ‡)§					m_hline.bWrappedLine = TRUE;§					Tag_NewLine(&ptOutput, 1, &szTextArea);§					nBeginLineX = ptOutput.x;§					nSpacesInLine = m_hline.nSpaceChars;§					nRealWidth = m_hline.nWidthLine;§				}§			} //while§		} //if§§		//ENG: If tag was found then analyzing ...§		//RUS: ≈ÒÎË Ú˝„ Ì‡È‰ÂÌ, ‡Ì‡ÎËÁËÛÂÏ ...§		if (!sTag.IsEmpty())§		{§			//ENG: Reset temporary parameters§			//RUS: —·ÓÒ ‚ÂÏÂÌÌ˚ı Ô‡‡ÏÂÚÓ‚§			m_defStyle.strTag.Empty();§			bCloseTag = FALSE;§			§			//ENG: Get Tag's name§			//RUS: œÓÎÛ˜‡ÂÏ ËÏˇ Ú˝„‡§			nIndex = 0;§			§			//ENG: Searching a tag's value§			//RUS: œÓËÒÍ ÁÌ‡˜ÂÌËˇ Ú˝„‡§			DWORD dwTag = GetTagFromList(sTag, m_defStyle.strTag, bCloseTag);§			§			//ENG: If a tag was found in a list of the tags§			//RUS: ≈ÒÎË Ú˝„ Ì‡È‰ÂÌ ‚ ÒÔËÒÍÂ§			if (TAG_NONE != dwTag)§			{§				//ENG: If it is a style tag §				//RUS: ≈ÒÎË ÚÂÍÛ˘ËÈ Ú˝„ ‰Îˇ ‡·ÓÚ˚ ÒÓ ÒÚËÎˇÏË§				if (!m_defStyle.strTag.IsEmpty())§				{§					//ENG: Checks on permissibility of tag§					//RUS: œÓ‚ÂˇÂÏ Ì‡ ‰ÓÔÛÒÚËÏÓÒÚ¸ Ú˝„‡§					if (StoreRestoreStyle(bCloseTag))§					{§						//ENG: If it isn't a close tag§						//RUS: ≈ÒÎË ˝ÚÓ ÌÂ ÓÍÓÌ˜‡ÌËÂ Ú˝„‡§						if (!bCloseTag)§						{§							//ENG: Processing a tag§							//RUS: Œ·‡·ÓÚÍ‡ Ú˝„‡§							switch (dwTag)§							{§							case TAG_BOLD:§								m_defStyle.nWeightFont <<= 1;§								if (m_defStyle.nWeightFont > FW_BLACK)§									m_defStyle.nWeightFont = FW_BLACK;§								break;§							case TAG_ITALIC:§								m_defStyle.bItalicFont = m_defStyle.bItalicFont ? FALSE : TRUE;§								break;§							case TAG_UNDERLINE:§								m_defStyle.bUnderlineFont = m_defStyle.bUnderlineFont ? FALSE : TRUE;§								break;§							case TAG_STRIKEOUT:§								m_defStyle.bStrikeOutFont = m_defStyle.bStrikeOutFont ? FALSE : TRUE;§								break;§							case TAG_FONT:§								//Search parameters§								while (nIndex < sProperties.GetLength())§								{§									//ENG: Searching a parameters of a tag§									//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§									sValue = GetNextProperty(sProperties, nIndex, sParameter);§									//ENG: If a parameter was found§									//RUS: ≈ÒÎË Ô‡‡ÏÂÚ Ì‡È‰ÂÌ§									if (!sParameter.IsEmpty())§									{§										//ENG: Processing a parameters of a tag§										//RUS: Œ·‡·ÓÚÍ‡ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§										if (sParameter == _T("face"))§											m_defStyle.sFaceFont = GetStyleString(sValue, m_defStyle.sFaceFont);§										else if (sParameter == _T("size"))§											m_defStyle.nSizeFont = GetLengthUnit(sValue, m_defStyle.nSizeFont, TRUE);§										else if (sParameter == _T("color"))§										{§											if (m_bIsEnable)§												m_defStyle.crText = GetStyleColor(sValue, m_defStyle.crText);§											else§												m_defStyle.crText = GetColorByName("");§										}§										else if (sParameter == _T("style"))§											GetStyleFontShortForm(sValue);§										else if (sParameter == _T("weight"))§											m_defStyle.nWeightFont = GetStyleFontWeight(sValue, m_defStyle.nWeightFont);§										else if (sParameter == _T("bkgnd"))§										{§											if (((sValue == _T("transparent")) && sValue.IsEmpty()) || !m_bIsEnable)§											{§												m_defStyle.nBkMode = TRANSPARENT;§											}§											else§											{§												m_defStyle.nBkMode = OPAQUE;§												m_defStyle.crBkgnd = GetStyleColor(sValue, m_defStyle.crBkgnd);§											} //if§										} //if§									} //if§								} //while§								break;§							case TAG_LEFT:§								m_defStyle.nHorzAlign = ALIGN_LEFT;§								break;§							case TAG_CENTER:§								m_defStyle.nHorzAlign = ALIGN_CENTER;§								break;§							case TAG_RIGHT:§								m_defStyle.nHorzAlign = ALIGN_RIGHT;§								break;§							case TAG_JUSTIFY:§								m_defStyle.nHorzAlign = ALIGN_JUSTIFY;§								break;§							case TAG_BASELINE:§								m_defStyle.nVertAlign = ALIGN_BASELINE;§								break;§							case TAG_TOP:§								m_defStyle.nVertAlign = ALIGN_TOP;§								break;§							case TAG_VCENTER:§								m_defStyle.nVertAlign = ALIGN_VCENTER;§								break;§							case TAG_BOTTOM:§								m_defStyle.nVertAlign = ALIGN_BOTTOM;§								break;§							case TAG_NEWSTYLE:§								SelectNewHtmlStyle(sTag, m_defStyle);§								break;§							case TAG_SPAN:§								while (nIndex < sProperties.GetLength())§								{§									//ENG: Searching a parameters of a tag§									//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§									sValue = GetNextProperty(sProperties, nIndex, sParameter);§									//ENG: If a parameter was found§									//RUS: ≈ÒÎË Ô‡‡ÏÂÚ Ì‡È‰ÂÌ§									if (sParameter == _T("class"))§										SelectNewHtmlStyle(_T(".") + GetStyleString(sValue, _T("")), m_defStyle);§								} //while§								break;§							case TAG_HYPERLINK:§								//ENG: A default values§								//RUS: «Ì‡˜ÂÌËˇ ÔÓ ÛÏÓÎ˜‡ÌË˛§								m_defStyle.nTypeLink = LINK_MESSAGE;§								m_defStyle.sHyperlink.Empty();§								while (nIndex < sProperties.GetLength())§								{§									//ENG: Searching a parameters of a tag§									//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§									sValue = GetNextProperty(sProperties, nIndex, sParameter);§									//ENG: If a parameter was found§									//RUS: ≈ÒÎË Ô‡‡ÏÂÚ Ì‡È‰ÂÌ§									if (!sParameter.IsEmpty())§									{§										//ENG: Processing a parameters of a tag§										//RUS: Œ·‡·ÓÚÍ‡ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§										if (sParameter == _T("href"))§										{§											m_defStyle.nTypeLink = LINK_HREF;§											m_defStyle.sHyperlink = GetStyleString(sValue, _T(""));§										} //if§										if (sParameter == _T("msg"))§										{§											m_defStyle.nTypeLink = LINK_MESSAGE;§											m_defStyle.sHyperlink = GetStyleString(sValue, _T(""));§										} //if§									} //if§								} //while§								//ENG: Gets a index of a current link§								//RUS: œÓÎÛ˜‡ÂÏ ËÌ‰ÂÍÒ ÚÂÍÛ˘ÂÈ „ËÔÂÒÒ˚ÎÍË§								m_nCurIndexLink ++;§								//ENG: If a mouse over this link§								//RUS: ≈ÒÎË Ï˚¯ Ì‡‰ ˝ÚËÏ Ú˝„ÓÏ§								if (m_nCurIndexLink == m_nHoverIndexLink)§									SelectNewHtmlStyle(_T("a:hover"), m_defStyle);§								else§									SelectNewHtmlStyle(_T("a:link"), m_defStyle);§								break;§								} //switch§							} //if§							//ENG: Update a device context§							//RUS: Œ·ÌÓ‚ÎÂÌËÂ ÍÓÌÚÂÍÒÚ‡ ÛÒÚÓÈÒÚ‚‡§							UpdateContext();§						} //if§					}§					else §					{§						BOOL bPercent;§						BOOL bShadow;§						BOOL bAutoDelete;§						int nWidth, nNum;§						§						STRUCT_IMAGE si;§						STRUCT_CHANGESTYLE csTemp; //Temporary structure§						STRUCT_ANIMATION sa;§						§						SIZE szReal;§						HBITMAP hBitmap = NULL;;§						HICON hIcon = NULL;§						§						DWORD nMaxCol, nMaxRow;§						UINT nIdRes, nIdDll;§						//CPPString str;§						§						//ENG: Processing a tag§						//RUS: Œ·‡·ÓÚÍ‡ Ú˝„‡§						switch (dwTag)§						{§						case TAG_HLINE:§							//ENG: Draws the horizontal line§							//RUS: –ËÒÓ‚‡ÌËÂ „ÓËÁÓÌÚ‡Î¸ÌÓÈ ÎËÌËË§							csTemp = m_defStyle;§							csTemp.nBorderWidth = 1;§							//ENG: Applies a new styles for <hr> tag§							SelectNewHtmlStyle(_T("hr"), csTemp);§							nWidth = 100;§							bPercent = TRUE;§							§							while (nIndex < sProperties.GetLength())§							{§								//ENG: Searching a parameters of a tag§								//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§								sValue = GetNextProperty(sProperties, nIndex, sParameter);§								//ENG: If a parameter was found§								//RUS: ≈ÒÎË Ô‡‡ÏÂÚ Ì‡È‰ÂÌ§								if (!sParameter.IsEmpty())§								{§									//ENG: Processing a parameters of a tag§									//RUS: Œ·‡·ÓÚÍ‡ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§									if (sParameter == _T("width"))§									{§										bPercent = IsPercentableValue(sValue);§										nWidth = GetLengthUnit(sValue, 100);§									}§									else if (sParameter == _T("size"))§										csTemp.nBorderWidth = GetLengthUnit(sValue, csTemp.nBorderWidth);§									else if (sParameter == _T("color"))§									{§										if (m_bIsEnable)§											csTemp.crText = GetStyleColor(sValue, csTemp.crText);§										else§											csTemp.crText = GetColorByName("");§									}§								} //if§							} //while§							§							if (bPercent)§							{§								if (MODE_FIRSTPASS == m_nNumPass)§								{§									m_hline.nAddPercentWidth += nWidth;§									nWidth = 1;§								}§								else nWidth = ::MulDiv(lpRect->right - lpRect->left, nWidth, 100);§							} //if§							§							if (MODE_FIRSTPASS == m_nNumPass)§							{§								m_hline.nHeightLine = std::max(m_hline.nHeightLine, csTemp.nBorderWidth + 8);§								m_hline.nHorzAlign = m_defStyle.nHorzAlign; //Store a last horizontal alignment§							}§							else if (MODE_DRAW == m_nNumPass)§							{§								m_drawmanager.DrawLine(m_hDC, ptOutput.x, ptOutput.y + m_hline.nHeightLine / 2, §									ptOutput.x + nWidth, ptOutput.y + m_hline.nHeightLine / 2, §									csTemp.crText, CPPDrawManager::PEN_SOLID, csTemp.nBorderWidth);§							} //if§							ptOutput.x += nWidth;§							break;§						case TAG_NEWLINE:§							//ENG: New line§							//RUS: ÕÓ‚‡ˇ ÒÚÓÍ‡§							nNum = 1;§							if (!sProperties.IsEmpty())§							{§								sProperties = sProperties.Mid(1);§								nNum = GetLengthUnit(sProperties, nNum);§							} //if§							m_hline.bWrappedLine = FALSE;§							Tag_NewLine(&ptOutput, nNum, &szTextArea);§							nBeginLineX = ptOutput.x;§							nSpacesInLine = m_hline.nSpaceChars;§							nRealWidth = m_hline.nWidthLine;§							break;§						case TAG_TABULATION:§							//ENG: Tabulation§							//RUS: “‡·ÛÎˇˆËˇ§							nNum = 1;§							if (!sProperties.IsEmpty())§							{§								sProperties = sProperties.Mid(1);§								nNum = GetLengthUnit(sProperties, nNum);§							} //if§							Tag_Tabulation(&ptOutput, nNum);§							break;§						case TAG_BITMAP:§							//-----------------------------§							//Draws the bitmap §							//-----------------------------§							//ENG: Default Parameters§							//RUS: œ‡‡ÏÂÚ˚ ÔÓ ÛÏÓÎ˜‡ÌË˛§							si.nIdRes = 0;§							si.nIdDll = 0;§							si.nHandle = 0;§							si.nWidth = 100;§							si.bPercentWidth = TRUE;§							si.nHeight = 100;§							si.bPercentHeight = TRUE;§							si.crMask = RGB(255, 0, 255);§							si.bUseMask = FALSE;§							si.nStyles = 0;§							si.nHotStyles = 0;§							si.strSrcFile.Empty();§							si.strPathDll.Empty();§							§							//ENG: Searching image parameters§							//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ ËÁÓ·‡ÊÂÌËˇ§							AnalyseImageParam(sProperties, si);§							§							//ENG: If a image's source was specified§							//RUS: ≈ÒÎË ÛÍ‡Á‡Ì ËÒÚÓ˜ÌËÍ ËÁÓ·‡ÊÂÌËˇ§							if (si.nIdRes || si.nIdDll || si.nHandle || !si.strSrcFile.IsEmpty())§							{§								//ENG: Sets a autodelete flag of the image object§								//RUS: ”ÒÚ‡ÌÓ‚ÎÂÌ ÙÎ‡„ ‡‚ÚÓÏ‡ÚË˜ÂÒÍÓ„Ó Û‰‡ÎÂÌËˇ Ó·˙ÂÍÚ‡ ËÁÓ·‡ÊÂÌËˇ§								bAutoDelete = TRUE;§								§								//ENG: Gets a handle of the image§								//RUS: œÓÎÛ˜ËÚ¸ ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ§								if (si.nIdRes)§									hBitmap = GetBitmapFromResources(si.nIdRes);§								else if (!si.strSrcFile.IsEmpty())§									hBitmap = GetBitmapFromFile(si.strSrcFile);§								else if (si.nIdDll)§									hBitmap = GetBitmapFromDll(si.nIdDll, si.strPathDll);§								else if (si.nHandle)§								{§									hBitmap = (HBITMAP)si.nHandle;§									//ENG: If an image handle specified, disables autodelete§									//RUS: ≈ÒÎË ÛÍ‡Á‡Ì ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ, ÚÓ Á‡ÔÂ˘‡ÂÏ Û‰‡ÎÂÌËÂ§									bAutoDelete = FALSE;§								} //if§								§								//ENG: If a handle of an image was retrieved§								//RUS: ≈ÒÎË ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ ÔÓÎÛ˜ÂÌ§								if (NULL != hBitmap)§								{§									//ENG: Image with shadow or not?§									//RUS: »ÁÓ·‡ÊÂÌËÂ Ò ÚÂÌ¸˛ ËÎË ÌÂÚ§									bShadow = IsImageWithShadow(si);§									§									//ENG: Retrieves an original size of an image§									//RUS: œÓÎÛ˜‡ÂÏ ÓË„ËÌ‡Î¸Ì˚È ‡ÁÏÂ ËÁÓ·‡ÊÂÌËˇ§									m_drawmanager.GetSizeOfBitmap(hBitmap, &sz);§									§									//ENG: Retrieves an output size§									//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ˚ ‰Îˇ ËÒÓ‚‡ÌËˇ§									if (si.bPercentWidth) si.nWidth = ::MulDiv(sz.cx, si.nWidth, 100);§									if (si.bPercentHeight) si.nHeight = ::MulDiv(sz.cy, si.nHeight, 100);§									§									//ENG: If a shadow was enabled then set a real size§									//RUS: ≈ÒÎË ÚÂÌ¸ ‰ÓÒÚÛÔÌ‡, ÚÓ ÛÒÚ‡Ì‡‚ÎË‚‡ÂÏ Â‡Î¸Ì˚È ‡ÁÏÂ§									if (si.nWidth && si.nHeight && bShadow)§									{§										sz.cx = si.nWidth + m_szOffsetShadow.cx;§										sz.cy = si.nHeight + m_szOffsetShadow.cy;§									} //if§									§									int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;§									if (m_nMaxWidth && ((nMaxSize - sz.cx) < 0) && nTextWrapWidth) §									{§										//ENG: Not all text was printed (cause text wrap) §										//RUS: ÕÂ ‚Òˇ ÒÚÓÍ‡ Â˘Â ‚˚‚ÂÎ‡Ò¸ (‚ ÒÎÛ˜‡Â ÔÂÂÌÓÒ‡ ÚÂÍÒÚ‡)§										m_hline.bWrappedLine = TRUE;§										Tag_NewLine(&ptOutput, 1, &szTextArea);§										nBeginLineX = ptOutput.x;§										nSpacesInLine = m_hline.nSpaceChars;§										nRealWidth = m_hline.nWidthLine;§									} //if§									nRealWidth -= sz.cx;§§									//ENG: Store a last horizontal alignment§									//RUS: «‡ÔÓÏËÌ‡ÂÏ ÔÓÒÎÂ‰ÌÂÂ „ÓËÁÓÌÚ‡Î¸ÌÓÂ ‚˚‡‚ÌË‚‡ÌËÂ§									if (MODE_FIRSTPASS == m_nNumPass) §										m_hline.nHorzAlign = m_defStyle.nHorzAlign;§									§									//ENG: Retrieves a vertical coordinates of drawing area§									//RUS: œÓÎÛ˜‡ÂÏ ‚ÂÚËÍ‡Î¸ÌÛ˛ ÍÓÓ‰ËÌ‡ÚÛ Ó·Î‡ÒÚË ËÒÓ‚‡ÌËˇ§									y = VerticalAlignImage(ptOutput.y, si.nHeight);§									§									//ENG: If an image is exist and not prepare mode§									//RUS: ≈ÒÎË ËÁÓ·‡ÊÂÌËÂ ‰ÓÒÚÛÔÌÓ Ë ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÔÓ‰„ÓÚÓ‚ÍË§									if (si.nWidth && si.nHeight && (MODE_DRAW == m_nNumPass))§									{§										//ENG: Add an output area to hyperlink list if needed§										//RUS: ≈ÒÎË ÌÂÓ·ıÓ‰ËÏÓ ‰Ó·‡‚ÎˇÂÏ Ó·Î‡ÒÚ¸ ‚˚‚Ó‰‡ ‚ ÒÔËÒÓÍ „ËÔÂÒÒ˚ÎÓÍ§										StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);§										§										//ENG: If a mouse over an image then applies a hot styles§										//RUS: ≈ÒÎË Ï˚¯¸ Ì‡‰ ËÁÓ·‡ÊÂÌËÂÏ, ÚÓ ÔËÏÂÌˇÂÏ ÒÓÓÚ‚ÂÒÚ‚Û˛˘ËÂ ÒÚËÎË§										if (m_defStyle.nTypeLink != LINK_NONE)§										{§											if (m_nCurIndexLink == m_nHoverIndexLink)§												si.nStyles = si.nHotStyles;§										} //if§										§										if (!m_bIsEnable)§											si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;§										§										//ENG: Drawing an image§										//RUS: –ËÒÓ‚‡ÌËÂ ËÁÓ·‡ÊÂÌËˇ§										m_drawmanager.DrawBitmap(m_hDC, ptOutput.x, y, si.nWidth, si.nHeight, hBitmap, §											si.bUseMask, si.crMask, si.nStyles, §											bShadow, §											m_szOffsetShadow.cx, m_szOffsetShadow.cy, §											m_szDepthShadow.cx, m_szDepthShadow.cy, §											clrShadow);§									} //if§									§									//ENG: Moves to a right of the outputed image§									//RUS: œÂÂÏÂ˘‡ÂÏÒˇ ÒÔ‡‚‡ ÓÚ ‚˚‚Â‰ÂÌÌÓ„Ó ËÁÓ·‡ÊÂÌËˇ§									ptOutput.x += sz.cx; //si.nWidth;§									§									//ENG: If needed delete a handle of an image§									//RUS: ≈ÒÎË ÌÂÓ·ıÓ‰ËÏÓ Û‰‡ÎˇÂÏ ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ§									if (bAutoDelete)§										::DeleteObject(hBitmap);§								} //if§							} //if§							break;§						case TAG_ICON:§							//-----------------------------§							//Draws the icon§							//-----------------------------§							//ENG: Default Parameters§							//RUS: œ‡‡ÏÂÚ˚ ÔÓ ÛÏÓÎ˜‡ÌË˛§							si.nIdRes = 0;§							si.nIdDll = 0;§							si.nHandle = 0;§							si.nWidth = 100;§							si.bPercentWidth = TRUE;§							si.nHeight = 100;§							si.bPercentHeight = TRUE;§							si.nStyles = 0;§							si.nHotStyles = 0;§							si.strSrcFile.Empty();§							si.strPathDll.Empty();§							§							//ENG: Searching image parameters§							//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ ËÁÓ·‡ÊÂÌËˇ§							AnalyseImageParam(sProperties, si);§							§							//ENG: If a image's source was specified§							//RUS: ≈ÒÎË ÛÍ‡Á‡Ì ËÒÚÓ˜ÌËÍ ËÁÓ·‡ÊÂÌËˇ§							if (si.nIdRes || si.nIdDll || si.nHandle || !si.strSrcFile.IsEmpty())§							{§								//ENG: Sets a autodelete flag of the image object§								//RUS: ”ÒÚ‡ÌÓ‚ÎÂÌ ÙÎ‡„ ‡‚ÚÓÏ‡ÚË˜ÂÒÍÓ„Ó Û‰‡ÎÂÌËˇ Ó·˙ÂÍÚ‡ ËÁÓ·‡ÊÂÌËˇ§								bAutoDelete = TRUE;§								§								//RUS: œÓÎÛ˜‡ÂÏ ÚÂ·ÛÂÏ˚È ‡ÁÏÂ ËÍÓÌÍË§								sz.cx = si.nWidth;§								sz.cy = si.nHeight;§								if (si.bPercentWidth) sz.cx = ::MulDiv(::GetSystemMetrics(SM_CXICON), si.nWidth, 100);§								if (si.bPercentHeight) sz.cy = ::MulDiv(::GetSystemMetrics(SM_CYICON), si.nHeight, 100);§								§								//ENG: Gets a handle of the image§								//RUS: œÓÎÛ˜ËÚ¸ ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ§								if (si.nIdRes)§									hIcon = GetIconFromResources(si.nIdRes, sz.cx, sz.cy);§								else if (!si.strSrcFile.IsEmpty())§									hIcon = GetIconFromFile(si.strSrcFile, sz.cx, sz.cy);§								else if (si.nIdDll)§									hIcon = GetIconFromDll(si.nIdDll, sz.cx, sz.cy, si.strPathDll);§								else if (si.nHandle)§								{§									hIcon = (HICON)si.nHandle;§									§									//ENG: If an image handle specified, disables autodelete§									//RUS: ≈ÒÎË ÛÍ‡Á‡Ì ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ, ÚÓ Á‡ÔÂ˘‡ÂÏ Û‰‡ÎÂÌËÂ§									bAutoDelete = FALSE;§								} //if§								§								//ENG: If a handle of an image was retrieved§								//RUS: ≈ÒÎË ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ ÔÓÎÛ˜ÂÌ§								if (NULL != hIcon)§								{§									//ENG: Image with shadow or not?§									//RUS: »ÁÓ·‡ÊÂÌËÂ Ò ÚÂÌ¸˛ ËÎË ÌÂÚ§									BOOL bShadow = IsImageWithShadow(si);§									§									//ENG: Retrieves an original size of an image§									//RUS: œÓÎÛ˜‡ÂÏ ÓË„ËÌ‡Î¸Ì˚È ‡ÁÏÂ ËÁÓ·‡ÊÂÌËˇ§									m_drawmanager.GetSizeOfIcon(hIcon, &sz);§									si.nWidth = sz.cx;§									si.nHeight = sz.cy;§									§									//ENG: Retrieves an output size§									//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ˚ ‰Îˇ ËÒÓ‚‡ÌËˇ§									//									if (si.bPercentWidth) si.nWidth = ::MulDiv(sz.cx, si.nWidth, 100);§									//									if (si.bPercentHeight) si.nHeight = ::MulDiv(sz.cy, si.nHeight, 100);§									§									//ENG: If a shadow was enabled then set a real size§									//RUS: ≈ÒÎË ÚÂÌ¸ ‰ÓÒÚÛÔÌ‡, ÚÓ ÛÒÚ‡Ì‡‚ÎË‚‡ÂÏ Â‡Î¸Ì˚È ‡ÁÏÂ§									if (si.nWidth && si.nHeight && bShadow)§									{§										sz.cx = si.nWidth + m_szOffsetShadow.cx;§										sz.cy = si.nHeight + m_szOffsetShadow.cy;§									} //if§§									int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;§									if (m_nMaxWidth && ((nMaxSize - sz.cx) < 0) && nTextWrapWidth) §									{§										//ENG: Not all text was printed (cause text wrap) §										//RUS: ÕÂ ‚Òˇ ÒÚÓÍ‡ Â˘Â ‚˚‚ÂÎ‡Ò¸ (‚ ÒÎÛ˜‡Â ÔÂÂÌÓÒ‡ ÚÂÍÒÚ‡)§										m_hline.bWrappedLine = TRUE;§										Tag_NewLine(&ptOutput, 1, &szTextArea);§										nBeginLineX = ptOutput.x;§										nSpacesInLine = m_hline.nSpaceChars;§										nRealWidth = m_hline.nWidthLine;§									} //if§									nRealWidth -= sz.cx;§									§									//ENG: Store a last horizontal alignment§									//RUS: «‡ÔÓÏËÌ‡ÂÏ ÔÓÒÎÂ‰ÌÂÂ „ÓËÁÓÌÚ‡Î¸ÌÓÂ ‚˚‡‚ÌË‚‡ÌËÂ§									if (MODE_FIRSTPASS == m_nNumPass) §										m_hline.nHorzAlign = m_defStyle.nHorzAlign;§									§									//ENG: Retrieves a vertical coordinates of drawing area§									//RUS: œÓÎÛ˜‡ÂÏ ‚ÂÚËÍ‡Î¸ÌÛ˛ ÍÓÓ‰ËÌ‡ÚÛ Ó·Î‡ÒÚË ËÒÓ‚‡ÌËˇ§									y = VerticalAlignImage(ptOutput.y, si.nHeight);§									§									//ENG: If an image is exist and not prepare mode§									//RUS: ≈ÒÎË ËÁÓ·‡ÊÂÌËÂ ‰ÓÒÚÛÔÌÓ Ë ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÔÓ‰„ÓÚÓ‚ÍË§									if (si.nWidth && si.nHeight && (MODE_DRAW == m_nNumPass))§									{§										//ENG: Add an output area to hyperlink list if needed§										//RUS: ≈ÒÎË ÌÂÓ·ıÓ‰ËÏÓ ‰Ó·‡‚ÎˇÂÏ Ó·Î‡ÒÚ¸ ‚˚‚Ó‰‡ ‚ ÒÔËÒÓÍ „ËÔÂÒÒ˚ÎÓÍ§										StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);§										§										//ENG: If a mouse over an image then applies a hot styles§										//RUS: ≈ÒÎË Ï˚¯¸ Ì‡‰ ËÁÓ·‡ÊÂÌËÂÏ, ÚÓ ÔËÏÂÌˇÂÏ ÒÓÓÚ‚ÂÒÚ‚Û˛˘ËÂ ÒÚËÎË§										if (m_defStyle.nTypeLink != LINK_NONE)§										{§											if (m_nCurIndexLink == m_nHoverIndexLink)§												si.nStyles = si.nHotStyles;§										} //if§										§										if (!m_bIsEnable)§											si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;§										§										//ENG: Drawing an image§										//RUS: –ËÒÓ‚‡ÌËÂ ËÁÓ·‡ÊÂÌËˇ§										m_drawmanager.DrawIcon(m_hDC, ptOutput.x, y, si.nWidth, si.nHeight, hIcon, si.nStyles, §											bShadow, §											m_szOffsetShadow.cx, m_szOffsetShadow.cy, §											m_szDepthShadow.cx, m_szDepthShadow.cy, §											clrShadow);§									} //if§									//ENG: Moves to a right of the outputed image§									//RUS: œÂÂÏÂ˘‡ÂÏÒˇ ÒÔ‡‚‡ ÓÚ ‚˚‚Â‰ÂÌÌÓ„Ó ËÁÓ·‡ÊÂÌËˇ§									ptOutput.x += sz.cx; //si.nWidth;§									§									//ENG: If needed delete a handle of an image§									//RUS: ≈ÒÎË ÌÂÓ·ıÓ‰ËÏÓ Û‰‡ÎˇÂÏ ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ§									if (bAutoDelete) §										::DestroyIcon(hIcon);§								} //if§							} //if§							break;§						case TAG_IMAGELIST:§							//-----------------------------§							//Draws the icon from image list§							//-----------------------------§							//ENG: Default Parameters§							//RUS: œ‡‡ÏÂÚ˚ ÔÓ ÛÏÓÎ˜‡ÌË˛§							si.nIndexImageList = 0;§							si.nIdRes = 0;§							si.nIdDll = 0;§							si.nHandle = 0;§							si.nWidth = 100;§							si.bPercentWidth = TRUE;§							si.nHeight = 100;§							si.bPercentHeight = TRUE;§							si.nSpeed = 0;§							si.bUseMask = FALSE;§							si.crMask = RGB(255, 0, 255);§							si.cx = 0;//GetSystemMetrics(SM_CXICON);§							si.cy = 0;//GetSystemMetrics(SM_CYICON);§							si.nStyles = 0;§							si.nHotStyles = 0;§							si.strSrcFile.Empty();§							si.strPathDll.Empty();§							§							//ENG: Searching image parameters§							//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ ËÁÓ·‡ÊÂÌËˇ§							AnalyseImageParam(sProperties, si);§							§							//ENG: Image with shadow or not?§							//RUS: »ÁÓ·‡ÊÂÌËÂ Ò ÚÂÌ¸˛ ËÎË ÌÂÚ§							bShadow = IsImageWithShadow(si);§							§							if (si.nIdRes || si.nIdDll || si.nHandle || !si.strSrcFile.IsEmpty())§							{§								//ENG: Sets a autodelete flag of the image object§								//RUS: ”ÒÚ‡ÌÓ‚ÎÂÌ ÙÎ‡„ ‡‚ÚÓÏ‡ÚË˜ÂÒÍÓ„Ó Û‰‡ÎÂÌËˇ Ó·˙ÂÍÚ‡ ËÁÓ·‡ÊÂÌËˇ§								bAutoDelete = TRUE;§								§								//ENG: Gets a handle of the image§								//RUS: œÓÎÛ˜ËÚ¸ ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ§								if (si.nIdRes)§									hBitmap = GetBitmapFromResources(si.nIdRes);§								else if (!si.strSrcFile.IsEmpty())§									hBitmap = GetBitmapFromFile(si.strSrcFile);§								else if (si.nIdDll)§									hBitmap = GetBitmapFromDll(si.nIdDll, si.strPathDll);§								else if (si.nHandle)§								{§									hBitmap = (HBITMAP)si.nHandle;§									//ENG: If an image handle specified, disables autodelete§									//RUS: ≈ÒÎË ÛÍ‡Á‡Ì ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ, ÚÓ Á‡ÔÂ˘‡ÂÏ Û‰‡ÎÂÌËÂ§									bAutoDelete = FALSE;§								} //if§								§								//ENG: If a handle of an image was retrieved§								//RUS: ≈ÒÎË ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ ÔÓÎÛ˜ÂÌ§								if (NULL != hBitmap)§								{§									//ENG: Retrieves an original size of an image§									//RUS: œÓÎÛ˜‡ÂÏ ÓË„ËÌ‡Î¸Ì˚È ‡ÁÏÂ ËÁÓ·‡ÊÂÌËˇ§									m_drawmanager.GetSizeOfBitmap(hBitmap, &sz);§§									//ENG: Creates a no specified sizes§									//RUS: —ÓÁ‰‡ÂÏ ÌÂÁ‡‰‡ÌÌ˚Â ‡ÁÏÂ˚§									if (!si.cx && !si.cy)§										si.cx = si.cy = std::min(sz.cx, sz.cy);§									else if (!si.cx)§										si.cx = si.cy;§									else if (!si.cy)§										si.cy = si.cx;§									§									//ENG: Retrieves an output size§									//RUS: œÓÎÛ˜‡ÂÏ ‡ÁÏÂ˚ ‰Îˇ ËÒÓ‚‡ÌËˇ§									if (si.bPercentWidth) si.nWidth = ::MulDiv(si.cx, si.nWidth, 100);§									if (si.bPercentHeight) si.nHeight = ::MulDiv(si.cy, si.nHeight, 100);§									§									//ENG: If a shadow was enabled then set a real size§									//RUS: ≈ÒÎË ÚÂÌ¸ ‰ÓÒÚÛÔÌ‡, ÚÓ ÛÒÚ‡Ì‡‚ÎË‚‡ÂÏ Â‡Î¸Ì˚È ‡ÁÏÂ§									szReal.cx = si.nWidth;§									szReal.cy = si.nHeight;§									if (si.nWidth && si.nHeight && bShadow)§									{§										szReal.cx += m_szOffsetShadow.cx;§										szReal.cy += m_szOffsetShadow.cy;§									} //if§									§									//ENG: Gets a max columns and rows of the images on the bitmap§									//RUS: œÓÎÛ˜‡ÂÏ Ï‡ÍÒËÏ‡Î¸ÌÓÂ ˜ËÒÎÓ ÍÓÎÓÌÓÍ Ë ÒÚÓÍ ËÁÓ·‡ÊÂÌËÈ Ì‡ ·ËÚÏ‡ÔÍÂ§									nMaxCol = sz.cx / si.cx;§									nMaxRow = sz.cy / si.cy;§									§									if (si.nSpeed)§									{§										if (MODE_FIRSTPASS == m_nNumPass)§										{§											sa.nIndex = si.nIndexImageList;§											sa.nMaxImages = nMaxCol * nMaxRow;§											sa.nSpeed = si.nSpeed;§											sa.nTimerCount = 0;§											m_arrAni.push_back(sa);§										}§										else if (MODE_DRAW == m_nNumPass)§										{§											m_nCurIndexAni ++;§											sa = m_arrAni [m_nCurIndexAni];§											si.nIndexImageList = sa.nIndex;§										} //if§									} //if§									§									//ENG: If a specified index of image is a legitimate value§									//RUS: ≈ÒÎË ÛÍ‡Á‡ÌÌ˚È ËÌ‰ÂÍÒ ËÁÓ·‡ÊÂÌËˇ ‰ÓÔÛÒÚËÏ§									if ((si.nIndexImageList < (int)(nMaxCol * nMaxRow)) && nMaxCol && nMaxRow)§									{§										int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;§										if (m_nMaxWidth && ((nMaxSize - szReal.cx) < 0) && nTextWrapWidth) §										{§											//ENG: Not all text was printed (cause text wrap) §											//RUS: ÕÂ ‚Òˇ ÒÚÓÍ‡ Â˘Â ‚˚‚ÂÎ‡Ò¸ (‚ ÒÎÛ˜‡Â ÔÂÂÌÓÒ‡ ÚÂÍÒÚ‡)§											m_hline.bWrappedLine = TRUE;§											Tag_NewLine(&ptOutput, 1, &szTextArea);§											nBeginLineX = ptOutput.x;§											nSpacesInLine = m_hline.nSpaceChars;§											nRealWidth = m_hline.nWidthLine;§										} //if§										nRealWidth -= szReal.cx;§										§										//ENG: Store a last horizontal alignment§										//RUS: «‡ÔÓÏËÌ‡ÂÏ ÔÓÒÎÂ‰ÌÂÂ „ÓËÁÓÌÚ‡Î¸ÌÓÂ ‚˚‡‚ÌË‚‡ÌËÂ§										if (MODE_FIRSTPASS == m_nNumPass) §											m_hline.nHorzAlign = m_defStyle.nHorzAlign;§										§										//ENG: Retrieves a vertical coordinates of drawing area§										//RUS: œÓÎÛ˜‡ÂÏ ‚ÂÚËÍ‡Î¸ÌÛ˛ ÍÓÓ‰ËÌ‡ÚÛ Ó·Î‡ÒÚË ËÒÓ‚‡ÌËˇ§										y = VerticalAlignImage(ptOutput.y, szReal.cy);§										§										//ENG: If an image is exist and not prepare mode§										//RUS: ≈ÒÎË ËÁÓ·‡ÊÂÌËÂ ‰ÓÒÚÛÔÌÓ Ë ÌÂ ÛÒÚ‡ÌÓ‚ÎÂÌ ÂÊËÏ ÔÓ‰„ÓÚÓ‚ÍË§										if (si.nWidth && si.nHeight && (MODE_DRAW == m_nNumPass))§										{§											//ENG: Add an output area to hyperlink list if needed§											//RUS: ≈ÒÎË ÌÂÓ·ıÓ‰ËÏÓ ‰Ó·‡‚ÎˇÂÏ Ó·Î‡ÒÚ¸ ‚˚‚Ó‰‡ ‚ ÒÔËÒÓÍ „ËÔÂÒÒ˚ÎÓÍ§											StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + szReal.cx, y + szReal.cy);§											§											//ENG: If a mouse over an image then applies a hot styles§											//RUS: ≈ÒÎË Ï˚¯¸ Ì‡‰ ËÁÓ·‡ÊÂÌËÂÏ, ÚÓ ÔËÏÂÌˇÂÏ ÒÓÓÚ‚ÂÒÚ‚Û˛˘ËÂ ÒÚËÎË§											if (m_defStyle.nTypeLink != LINK_NONE)§											{§												if (m_nCurIndexLink == m_nHoverIndexLink)§													si.nStyles = si.nHotStyles;§											} //if§											§											if (!m_bIsEnable)§												si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;§											§											//ENG: Drawing an image§											//RUS: –ËÒÓ‚‡ÌËÂ ËÁÓ·‡ÊÂÌËˇ§											m_drawmanager.DrawImageList(m_hDC, ptOutput.x, y, si.nWidth, si.nHeight, hBitmap,§												si.nIndexImageList, si.cx, si.cy,§												si.bUseMask, si.crMask, si.nStyles, §												bShadow, §												m_szOffsetShadow.cx, m_szOffsetShadow.cy, §												m_szDepthShadow.cx, m_szDepthShadow.cy, §												clrShadow);§										} //if§										§										//ENG: Moves to a right of the outputed image§										//RUS: œÂÂÏÂ˘‡ÂÏÒˇ ÒÔ‡‚‡ ÓÚ ‚˚‚Â‰ÂÌÌÓ„Ó ËÁÓ·‡ÊÂÌËˇ§										ptOutput.x += szReal.cx;§									} //if§									§									//ENG: If needed delete a handle of an image§									//RUS: ≈ÒÎË ÌÂÓ·ıÓ‰ËÏÓ Û‰‡ÎˇÂÏ ‰ÂÒÍËÔÚÓ ËÁÓ·‡ÊÂÌËˇ§									if (bAutoDelete)§										::DeleteObject(hBitmap);§								} //if§							}§							else if (NULL != m_hImageList)§							{§								// Ensure that the common control DLL is loaded. §								InitCommonControls(); §§								if ((int)si.nIndexImageList < ImageList_GetImageCount(m_hImageList))§								{§									hIcon = ImageList_ExtractIcon(NULL, m_hImageList, si.nIndexImageList);§									if (NULL != hIcon)§									{§										sz.cx = si.nWidth;§										sz.cy = si.nHeight;§										if (si.bPercentWidth) sz.cx = ::MulDiv(m_szImageList.cx, si.nWidth, 100);§										if (si.bPercentHeight) sz.cy = ::MulDiv(m_szImageList.cy, si.nHeight, 100);§										§										szReal.cx = sz.cx;§										szReal.cy = sz.cy;§										if (sz.cx && sz.cy && bShadow)§										{§											szReal.cx += m_szOffsetShadow.cx;§											szReal.cy += m_szOffsetShadow.cy;§										} //if§										§										int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;§										if (m_nMaxWidth && ((nMaxSize - szReal.cx) < 0) && nTextWrapWidth) §										{§											//ENG: Not all text was printed (cause text wrap) §											//RUS: ÕÂ ‚Òˇ ÒÚÓÍ‡ Â˘Â ‚˚‚ÂÎ‡Ò¸ (‚ ÒÎÛ˜‡Â ÔÂÂÌÓÒ‡ ÚÂÍÒÚ‡)§											m_hline.bWrappedLine = TRUE;§											Tag_NewLine(&ptOutput, 1, &szTextArea);§											nBeginLineX = ptOutput.x;§											nSpacesInLine = m_hline.nSpaceChars;§											nRealWidth = m_hline.nWidthLine;§										} //if§										nRealWidth -= sz.cx;§§										if (MODE_FIRSTPASS == m_nNumPass) §											m_hline.nHorzAlign = m_defStyle.nHorzAlign; //Store a last horizontal alignment§										y = VerticalAlignImage(ptOutput.y, szReal.cy);§										if (sz.cx && sz.cy && (MODE_DRAW == m_nNumPass))§										{§											StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + szReal.cx, y + szReal.cy);§											§											if (m_defStyle.nTypeLink != LINK_NONE)§											{§												if (m_nCurIndexLink == m_nHoverIndexLink)§													si.nStyles = si.nHotStyles;§											} //if§											§											if (!m_bIsEnable)§												si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;§											§											m_drawmanager.DrawIcon(m_hDC, ptOutput.x, y, §												sz.cx, sz.cy, hIcon, si.nStyles, §												bShadow, §												m_szOffsetShadow.cx, m_szOffsetShadow.cy, §												m_szDepthShadow.cx, m_szDepthShadow.cy, §												clrShadow);§											::DestroyIcon(hIcon);§										} //if§										ptOutput.x += szReal.cx;§									} //if§								} //if§							} //if§							break;§						case TAG_STRING:§							//-----------------------------§							//Draws the string§							//-----------------------------§							nIdRes = 0;§							nIdDll = 0;§							sText.Empty();§							while (nIndex < sProperties.GetLength())§							{§								//ENG: Searching a parameters of a tag§								//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§								sValue = GetNextProperty(sProperties, nIndex, sParameter);§								//ENG: If a parameter was found§								//RUS: ≈ÒÎË Ô‡‡ÏÂÚ Ì‡È‰ÂÌ§								if (!sParameter.IsEmpty())§								{§									if (sParameter == _T("idres"))§										nIdRes = GetLengthUnit(sValue, nIdRes);§									else if (sParameter == _T("iddll"))§										nIdRes = GetLengthUnit(sValue, nIdDll);§									else if (sParameter == _T("srcdll"))§										sText = GetStyleString(sValue, sText);§								} //if§							} //while§							if (nIdRes || nIdDll)§							{§								if (nIdRes)§									sText = GetStringFromResource(nIdRes);§								else if (nIdDll)§									sText = GetStringFromDll(nIdDll, sText);§								§								if (!sText.IsEmpty())§								{§									::GetTextExtentPoint32(m_hDC, sText, sText.GetLength(), &sz);§									if (MODE_FIRSTPASS == m_nNumPass) m_hline.nHorzAlign = m_defStyle.nHorzAlign; //Store a last horizontal alignment§									y = VerticalAlignText(ptOutput.y, sz.cy);§									if (MODE_DRAW == m_nNumPass)§									{§										StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);§										::TextOut(m_hDC, ptOutput.x, y, sText, sText.GetLength());§									} //if§									ptOutput.x += sz.cx;§								} //if§							} //if§							break;§						} //switch§					} //if§				} //if§		} //if§	} //for§	if (nBeginLineX != ptOutput.x)§	{§		m_hline.bWrappedLine = FALSE;§		Tag_NewLine(&ptOutput, 1, &szTextArea);§	}§§	//ENG: Reset an additional interval for space chars§	//RUS: —·ÓÒ ‰ÓÔÓÎÌËÚÂÎ¸ÌÓ„Ó ËÌÚÂ‚‡Î‡ ÏÂÊ‰Û ÒÎÓ‚‡ÏË§	::SetTextJustification(m_hDC, 0, 0);§§	szTextArea.cy = ptOutput.y - lpRect->top;§§	//Adds the percent's length to the line's length§	for (i = nFirstLine; i < m_nCurLine; i++)§	{§		m_hline = m_arrHtmlLine [i];§		if (0 != m_hline.nAddPercentWidth)§		{§			m_hline.nWidthLine += ::MulDiv(m_hline.nAddPercentWidth, szTextArea.cx, 100);§			szTextArea.cx = std::max((long)szTextArea.cx, (long)m_hline.nWidthLine);§		} //if§	} //for§//§//	if (NULL != lpSize)§//	{§//		szTextArea.cx = m_szOutput.cx;§//		szTextArea.cy = m_szOutput.cy;§//	} //if§	return szTextArea;§} //End DrawHtmlString§§void CPPHtmlDrawer::StoreHyperlinkArea(int left, int top, int right, int bottom)§{§	if (m_defStyle.nTypeLink != LINK_NONE)§	{§		STRUCT_HYPERLINK link;§		link.rcArea.left = left;§		link.rcArea.top = top;§		link.rcArea.right = right;§		link.rcArea.bottom = bottom;§		link.sHyperlink = m_defStyle.sHyperlink;§		link.nTypeLink = m_defStyle.nTypeLink;§		link.nIndexLink = m_nCurIndexLink;§		m_arrLinks.push_back(link);§	} //if§} //StoreHyperlinkArea§§void CPPHtmlDrawer::SelectNewHtmlStyle(LPCTSTR lpszNameStyle, STRUCT_CHANGESTYLE & cs)§{§	//Unpack a new styles§	UnpackTextStyle(GetTextStyle(lpszNameStyle), cs);§}§§BOOL CPPHtmlDrawer::StoreRestoreStyle(BOOL bRestore)§{§	BOOL bOk = FALSE;§	if (bRestore)§	{§		//Restore styles§		if (m_arrStack.size() > 0)§		{§			STRUCT_CHANGESTYLE cs = m_arrStack.back();§			if (cs.strTag == m_defStyle.strTag)§			{§				m_defStyle = cs;§				m_arrStack.pop_back();§				bOk = TRUE;§			} //if§		} //if§		m_defStyle.strTag.Empty();§	}§	else §	{§		m_arrStack.push_back(m_defStyle);§		bOk = TRUE;§	} //if§§	return bOk;§} //End StoreRestoreStyle§§void CPPHtmlDrawer::UpdateContext()§{§	::SelectObject(m_hDC, m_hOldFont);§	::DeleteObject(m_hFont);§	m_lfDefault.lfHeight = m_defStyle.nSizeFont;§	m_lfDefault.lfWeight = m_defStyle.nWeightFont;§	m_lfDefault.lfItalic = m_defStyle.bItalicFont;§	m_lfDefault.lfStrikeOut = m_defStyle.bStrikeOutFont;§	m_lfDefault.lfUnderline = m_defStyle.bUnderlineFont;§	_tcscpy (m_lfDefault.lfFaceName, m_defStyle.sFaceFont);§	m_hFont = ::CreateFontIndirect(&m_lfDefault);§	m_hOldFont = (HFONT)::SelectObject(m_hDC, m_hFont);§	::GetTextMetrics(m_hDC, &m_tm);§	§	::SetBkMode(m_hDC, m_defStyle.nBkMode);§	::SetTextColor(m_hDC, m_defStyle.crText);§	::SetBkColor(m_hDC, m_defStyle.crBkgnd);§} //End UpdateContext§§int CPPHtmlDrawer::VerticalAlignText(int y, int nHeight)§{§	//Vertical align§	if (MODE_FIRSTPASS == m_nNumPass)§	{§		//If calculate then don't output text§		m_hline.nDescentLine = std::max((long)m_hline.nDescentLine, (long)nHeight - m_tm.tmAscent);§		m_hline.nHeightLine = std::max((long)m_hline.nHeightLine, m_tm.tmAscent);§	}§	else if (MODE_DRAW == m_nNumPass)§	{§		switch (m_defStyle.nVertAlign)§		{§		case ALIGN_VCENTER:§			y += (m_hline.nHeightLine - m_tm.tmHeight) / 2;§			break;§		case ALIGN_BASELINE:§			y += m_hline.nHeightLine - m_hline.nDescentLine - m_tm.tmAscent;§			break;§		case ALIGN_BOTTOM:§			y += m_hline.nHeightLine - m_tm.tmAscent;§			break;§		} //switch§	} //if§	return y;§} //End VerticalAlignText§§int CPPHtmlDrawer::VerticalAlignImage(int y, int nHeight)§{§	//Vertical align§	if (MODE_FIRSTPASS == m_nNumPass)§	{§		//If calculate then don't output text§		m_hline.nHeightLine = std::max(m_hline.nHeightLine, nHeight);§	}§	else if (MODE_DRAW == m_nNumPass)§	{§		switch (m_defStyle.nVertAlign)§		{§		case ALIGN_VCENTER:§			y += (m_hline.nHeightLine - nHeight) / 2;§			break;§		case ALIGN_BASELINE:§			y += m_hline.nHeightLine - m_hline.nDescentLine - nHeight;§			break;§		case ALIGN_BOTTOM:§			y += m_hline.nHeightLine - nHeight;§			break;§		} //switch§	} //if§	return y;§} //End VerticalAlignImage§§void CPPHtmlDrawer::Tag_NewLine(LPPOINT lpPoint, int nNum, LPSIZE lpSize)§{§	//New line§	if (nNum <= 0)§		nNum = 1;§§	if (MODE_FIRSTPASS == m_nNumPass)§	{§		if (!m_hline.nHeightLine)§			m_hline.nHeightLine = m_tm.tmHeight;§		lpSize->cx = std::max(lpSize->cx, lpPoint->x - m_rcOutput.left);§		m_hline.nWidthLine = lpPoint->x - m_rcOutput.left; //Adds the real length of the lines§		m_hline.nHeightLine += m_hline.nDescentLine; //Adds the real height of the lines§		m_arrHtmlLine [m_nCurLine] = m_hline;§	} //if§	§	m_nCurLine ++;§§	lpPoint->y += m_hline.nHeightLine * nNum;§	lpPoint->x = InitNewLine(m_rcOutput.left);	§} //End Tag_NewLine§§int CPPHtmlDrawer::InitNewLine(int x)§{§	if (MODE_FIRSTPASS == m_nNumPass)§	{§		//ENG: Creates a new line with default parameters§		//RUS: —ÓÁ‰‡ÌËÂ ÌÓ‚ÓÈ ÎËÌËË Ò Ô‡‡ÏÂÚ‡ÏË ÔÓ-ÛÏÓÎ˜‡ÌË˛§		m_hline.nAddPercentWidth = 0;§		m_hline.nDescentLine = 0;§		m_hline.nHeightLine = 0;§		m_hline.nWidthLine = 0;§		m_hline.nHorzAlign = m_defStyle.nHorzAlign;§		m_hline.nSpaceChars = 0;§		m_arrHtmlLine.push_back(m_hline);§	}§	else if (MODE_DRAW == m_nNumPass)§	{§		//ENG: Gets the data of the first line and converts the percent value to the real width§		//RUS: œÓÎÛ˜‡ÂÏ ‰‡ÌÌ˚Â ÔÂ‚ÓÈ ÒÚÓÍË Ë ÔÂÓ·‡ÁÛÂÏ ÔÓˆÂÌÚÌÛ˛ ¯ËËÌÛ ‚ Â‡Î¸ÌÛ˛§		m_hline = m_arrHtmlLine [m_nCurLine];§		int nRealWidth = m_rcOutput.right - m_rcOutput.left;§		§		if (m_hline.nAddPercentWidth)§			m_hline.nWidthLine += ::MulDiv(nRealWidth, m_hline.nAddPercentWidth, 100);§§		if ((ALIGN_JUSTIFY == m_hline.nHorzAlign) && m_hline.bWrappedLine)§			::SetTextJustification(m_hDC, nRealWidth - m_hline.nWidthLine, m_hline.nSpaceChars);§		else§			::SetTextJustification(m_hDC, 0, 0);§		§		//ENG: Horizontal coordinate of the begin output§		//RUS:  ÓÓ‰ËÌ‡Ú‡ Ì‡˜‡Î‡ ‚˚‚Ó‰‡ Ò Û˜ÂÚÓÏ ‚˚‡‚ÌË‚‡ÌËˇ§		switch (m_hline.nHorzAlign)§		{§		case ALIGN_CENTER:§			x = m_rcOutput.left + (nRealWidth - m_hline.nWidthLine) / 2;§			break;§		case ALIGN_RIGHT:§			x = m_rcOutput.left + nRealWidth - m_hline.nWidthLine;§			break;§		} //switch§	} //if§	return x;§} //End of InitNewLine§§void CPPHtmlDrawer::Tag_Tabulation(LPPOINT lpPoint, int nNum)§{§	//Tabulation§	if (!nNum)§		nNum = 1;§	int nWidth = (lpPoint->x - m_rcOutput.left) % m_nTabSize;§	if (nWidth)§	{§		//aligns with tab§		lpPoint->x += m_nTabSize - nWidth;§		nNum --;§	} //if§	lpPoint->x += (nNum * m_nTabSize);§} //End Tag_Tabulation§§/////////////////////////////////////////////////////////////////////////////////////////§§void CPPHtmlDrawer::Draw(HDC hDC, LPCTSTR lpszHtml, LPPOINT lpPoint)§{§	//ENG: Preparing an output text§	//RUS: œÓ‰„ÓÚÓ‚Í‡ ÚÂÍÒÚ‡ Í ‚˚‚Ó‰Û§	SIZE size;§	PrepareOutput(hDC, lpszHtml, &size);§§	//ENG: If output was disabled§	//RUS: ≈ÒÎË ‚˚‚Ó‰ Á‡ÔÂ˘ÂÌ§	if (!size.cx || !size.cy)§		return;§	§	//ENG: Calculates an output area§	//RUS: œÓ‰Ò˜ÂÚ Ó·Î‡ÒÚË ‚˚‚Ó‰‡§	RECT rect;§	rect.left = lpPoint->x;§	rect.top = lpPoint->y;§	rect.right = rect.left + size.cx;§	rect.bottom = rect.top + size.cy;§	§	//ENG: Output a prepared text§	//RUS: ¬˚‚Ó‰ ÔÓ‰„ÓÚÓ‚ÎÂÌÌÓ„Ó ÚÂÍÒÚ‡§	DrawPreparedOutput(hDC, &rect);§} //End Draw§§void CPPHtmlDrawer::PrepareOutput(HDC hDC, LPCTSTR lpszHtml, LPSIZE lpSize)§{§	//ENG: Copy initial parameters§	//RUS:  ÓÔËÓ‚‡ÌËÂ Ì‡˜‡Î¸Ì˚ı Ô‡‡ÏÂÚÓ‚§	m_hDC = hDC;§§	//ENG: Reset text justification§	::SetTextJustification(m_hDC, 0, 0);§§	RECT rect;§	rect.left = rect.right = rect.top = rect.bottom = 0;§//	if (m_bIsTextWrapEnabled)§		rect.right = m_nMaxWidth;§	m_csHtmlText = lpszHtml;§	ReplaceSpecChars();§	lpSize->cx = lpSize->cy = 0;§	§	//ENG: If prepared text wasn't empty then return§	//RUS: ≈ÒÎË ÔÓ‰„ÓÚÓ‚ÎÂÌÌ˚È ÚÂÍÒÚ ÌÂ ÔÛÒÚÓÈ, ÚÓ ‚˚ıÓ‰§	if (!m_csHtmlText.IsEmpty())§	{§		//ENG: Sets a prepare mode§		//RUS: ”ÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÂÊËÏ ÔÓ‰„ÓÚÓ‚ÍË§		m_nNumPass = MODE_FIRSTPASS;§§		m_arrTables.clear();§§		//ENG: Prepares to real output§		//RUS: œÓ‰„ÓÚÓ‚Í‡ Í Â‡Î¸ÌÓÏÛ ‚˚‚Ó‰Û§		DrawHtml(lpSize, &rect);§§		if (!lpSize->cx && !lpSize->cy)§			m_csHtmlText.Empty();§§		//Cuts a tooltip if his real width more than m_nMaxWidth§		if (m_nMaxWidth/*m_bIsTextWrapEnabled*/ && (lpSize->cx > m_nMaxWidth))§			lpSize->cx = m_nMaxWidth;§		§		lpSize->cx ++;§		lpSize->cy ++;§	} //if§} //End PrepareOutput§§////////////////////////////////////////////////////////////////////§// CPPHtmlDrawer::DrawPreparedOutput()§//		Draw a string prepared by PrepareOutput method.§//------------------------------------------------------------------§// Parameters:§//		hDC				- Device Context to drawing §//		lpRect			- Pointer to RECT structure contains a bounding rectangle of§//						  drawing area.§////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::DrawPreparedOutput(HDC hDC, LPCRECT lpRect)§{§	//ENG: If prepared text was empty then return§	//RUS: ≈ÒÎË ÔÓ‰„ÓÚÓ‚ÎÂÌÌ˚È ÚÂÍÒÚ ÔÛÒÚÓÈ, ÚÓ ‚˚ıÓ‰§	if (m_csHtmlText.IsEmpty())§		return;§§	//ENG: Copy initial parameters§	//RUS:  ÓÔËÓ‚‡ÌËÂ Ì‡˜‡Î¸Ì˚ı Ô‡‡ÏÂÚÓ‚§	m_hDC = hDC;§	SIZE size = {0, 0};§§	//ENG: Sets a output mode§	//RUS: ”ÒÚ‡Ì‡‚ÎË‚‡ÂÏ ÂÊËÏ ‚˚‚Ó‰‡§	m_nNumPass = MODE_DRAW;§§	RECT rect = *lpRect;§//	if (((rect.right - rect.left) > m_nMaxWidth) && m_bIsTextWrapEnabled)§//		rect.right = rect.left + m_nMaxWidth;§§	//ENG: Real output the prepared string§	//RUS: ¬˚‚Ó‰ ÔÓ‰„ÓÚÓ‚ÎÂÌÌÓÈ ÒÚÓÍË§	DrawHtml(&size, &rect);§} //End of DrawPreparedOutput§§// The following appeared in Paul DiLascia's Jan 1998 MSJ articles.§// It loads a "hand" cursor from the winhlp32.exe module§void CPPHtmlDrawer::SetDefaultCursor()§{§	if (m_hLinkCursor == NULL)                // No cursor handle - load our own§    {§#ifdef IDC_HAND§		//This code was added from Zorglab's comments to hyperlink control from Chris Maunder§		m_hLinkCursor = ::LoadCursor(NULL, IDC_HAND); // Load Windows' hand cursor§		if (m_hLinkCursor != NULL)                    // if not available, load it from winhlp32.exe§			return;§#endif //IDC_HAND§		// Get the windows directory§        CPPString strWndDir;§        GetWindowsDirectory(strWndDir.GetBuffer(MAX_PATH), MAX_PATH);§        strWndDir.ReleaseBuffer();§§        strWndDir += _T("\\winhlp32.exe");§        // This retrieves cursor #106 from winhlp32.exe, which is a hand pointer§        HMODULE hModule = LoadLibrary(strWndDir);§        if (hModule) §		{§            HCURSOR hHandCursor = ::LoadCursor(hModule, MAKEINTRESOURCE(106));§            if (hHandCursor)§                m_hLinkCursor = CopyCursor(hHandCursor);§        } //if§        FreeLibrary(hModule);§    } //if§} //End SetDefaultCursor§§void CPPHtmlDrawer::SetHyperlinkCursor(HCURSOR hCursor /* = NULL */)§{§	if ((m_hLinkCursor == hCursor) && (NULL != m_hLinkCursor))§		return;§§	if (NULL != m_hLinkCursor)§	{§		::DestroyCursor(m_hLinkCursor);§		m_hLinkCursor = NULL;§	} //if§	§§    if (NULL == hCursor)§		SetDefaultCursor();§	else§		m_hLinkCursor = hCursor;§} //End SetHyperlinkCursor§§HCURSOR CPPHtmlDrawer::GetHyperlinkCursor() const§{§    return m_hLinkCursor;§} //End GetHyperlinkCursor§§/////////////////////////////////////////////////////////////////////§// CPPHtmlDrawer::SetCallbackHyperlink§// This function sets or removes the notification messages from the control before display.§//§// Parameters:§//	hWnd [in] -    If non-NULL the control will be send the notification §//				   to specified window§//				   Else the notification will not send§///////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam /* = 0 */)§{§//	TRACE(_T("CPPHtmlDrawer::SetCallbackHyperlink()\n"));§§	m_csCallbackLink.hWnd = hWnd;§	if (NULL == hWnd)§	{§		m_csCallbackLink.nMessage = 0;§		m_csCallbackLink.lParam = 0;§	}§	else§	{§		m_csCallbackLink.nMessage = nMessage;§		m_csCallbackLink.lParam = lParam;§	} //if§} //End SetCallbackHyperlink§§void CPPHtmlDrawer::SetCallbackRepaint(HWND hWnd, UINT nMessage, LPARAM lParam /* = 0 */)§{§//	TRACE(_T("CPPHtmlDrawer::SetCallbackRepaint()\n"));§§	m_csCallbackRepaint.hWnd = hWnd;§	if (NULL == hWnd)§	{§		m_csCallbackRepaint.nMessage = 0;§		m_csCallbackRepaint.lParam = 0;§	}§	else§	{§		m_csCallbackRepaint.nMessage = nMessage;§		m_csCallbackRepaint.lParam = lParam;§	} //if§} //End SetCallbackRepaint§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetImageList (public member function)§//    sets the image list to tooltip§//§//  Parameters :§//		nIdBitmap	[in] - Resource IDs of the bitmap to be associated with the image list§//		cx			[in] - Dimensions of each image, in pixels.§//		cy			[in] - Dimensions of each image, in pixels.§//		nCount		[in] - Number of images that the image list initially contains.§//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the §//						   specified bitmap is changed to black, and the corresponding §//						   bit in the mask is set to one.§//  Returns :§//		None§//§/////////////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)§{§	// Load bitmap§	HBITMAP hBitmap = GetBitmapFromResources(nIdBitmap);§	SetImageList(hBitmap, cx, cy, nCount, crMask);§} //End SetImageList§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::SetImageList (public member function)§//    sets the image list to tooltip§//§//  Parameters :§//		hBitmap		[in] - Handle of the bitmap to be associated with the image list§//		cx			[in] - Dimensions of each image, in pixels.§//		cy			[in] - Dimensions of each image, in pixels.§//		nCount		[in] - Number of images that the image list initially contains.§//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the §//						   specified bitmap is changed to black, and the corresponding §//						   bit in the mask is set to one.§//  Returns :§//		None§//§/////////////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)§{§	//ENG: Removes previously image list§	//RUS: ”‰‡ÎˇÂÏ ÔÂ‰˚‰Û˘ËÈ ÒÔËÒÓÍ ËÁÓ·‡ÊÂÌËÈ§	if (NULL != m_hImageList)§		::DeleteObject(m_hImageList);§§	//ENG: If don't need to create a new image list§	//RUS: ≈ÒÎË ÌÂ ÌÛÊÌÓ ÒÓÁ‰‡‚‡Ú¸ ÌÓ‚˚È ÒÔËÒÓÍ ËÁÓ·‡ÊÂÌËÈ§	if (NULL == hBitmap)§		return;§§	// Ensure that the common control DLL is loaded. §	InitCommonControls(); §	§	m_hImageList = ImageList_Create(cx, cy, ILC_COLOR32 | ILC_MASK, nCount, 1);§	ImageList_AddMasked(m_hImageList, hBitmap, crMask);§	m_szImageList.cx = cx;§	m_szImageList.cy = cy;§} //End SetImageList§§/////////////////////////////////////////////////////////////////////////////§//  CPPToolTip::GetImageList (public member function)§//    gets the image list from tooltip§//§//  Parameters :§//		sz		   [out] - Dimensions of each image, in pixels.§//  Returns :§//		A pointer to a CImageList object§//§/////////////////////////////////////////////////////////////////////////////§//CImageList * CPPHtmlDrawer::GetImageList(CSize & sz)§//{§//	sz = m_szImageList;§//	return &m_ImageList;§//} //End GetImageList§§void CPPHtmlDrawer::EnableEscapeSequences(BOOL bEnable /* = TRUE */)§{§	m_bEnableEscapeSequences = bEnable;§}§§void CPPHtmlDrawer::LoadResourceDll(LPCTSTR lpszPathDll, DWORD dwFlags /* = 0 */)§{§	HINSTANCE hInst = NULL;§	if (NULL != lpszPathDll)§		hInst = ::LoadLibraryEx(lpszPathDll, NULL, dwFlags);§	§	SetResourceDll(hInst);§§	if (NULL != hInst)§		m_bFreeInstDll = TRUE;§} //End LoadResourceDll§§void CPPHtmlDrawer::SetResourceDll(HINSTANCE hInstDll /* = NULL */)§{§	if (NULL != m_hInstDll)§	{§		if (!m_bFreeInstDll)§			return;§		::FreeLibrary(m_hInstDll);§		m_hInstDll = NULL;§	} //if§§	m_bFreeInstDll = FALSE;§§	if (NULL != hInstDll)§		m_hInstDll = hInstDll;§} //End SetResourceDll§§§CPPDrawManager * CPPHtmlDrawer::GetDrawManager()§{§	return &m_drawmanager;§} //End GetDrawManager§§BOOL CPPHtmlDrawer::IsImageWithShadow(_STRUCT_IMAGE & si)§{§	DWORD dwStyles = si.nStyles | si.nHotStyles;§	if ((dwStyles & IMAGE_EFFECT_MONO_SHADOW) || §		(dwStyles & IMAGE_EFFECT_GRADIENT_SHADOW))§		return TRUE;§	§	return FALSE;§}§§///////////////////////////////////////////////////////////////////////////§// Map of the styles§void CPPHtmlDrawer::SetDefaultCssStyles()§{§	CPPString str = _T("");§	str += _T("body {font-size: 10pt; color:black; font-family:Verdana}\r\n");§	str += _T("p {font-size: 10pt; color:black; font-family:Verdana; font-weight:bold}\r\n");§	str += _T("h1 {font-size: 14pt; color:black; font-family:Verdana; font-weight:bold}\r\n");§	str += _T("h2 {font-size: 13pt; color:#ff9900; font-family:Verdana; font-weight:bold}\r\n");§	str += _T("h3 {font-size: 12pt; color:#ff9900; font-family:Arial; font-weight:bold}\r\n");§	str += _T("h4 {font-size: 10pt; color:black; font-family:Verdana; font-weight:bold}\r\n");§	str += _T("h5 {font-size: 9pt; color:#ff9900; font-family:Verdana; font-weight:bold}\r\n");§	str += _T("h6 {font-size: 65%; color:#626262; font-family:Verdana; font-weight:normal}\r\n");§	str += _T("pre {font-size: 9pt; font-family:\"Courier\"; background-color:#fbedbb}\r\n");§	str += _T("code {color:#990000; font-family:Arial}\r\n");§	str += _T("a:link {text-decoration:none; color:blue}\r\n");§	str += _T("a:hover {text-decoration:underline; color:blue}\r\n");§	str += _T("sub {font-size:65%; vertical-align:bottom}\r\n");§	str += _T("sup {font-size:65%; vertical-align:top}\r\n");§	str += _T("big {font-size:125%}\r\n");§	str += _T("small {font-size:75%}\r\n");§	str += _T(".cpp-comment {color:green; font-style:italic}\r\n");§//	str += _T("td {text-align:center; color:#ff0000; vertical-align:middle}\r\n");§//	str += _T("table {padding:2; border-width:1; color:red}\r\n");§§	SetCssStyles(str);§} //End SetDefaultCssStyle§§void CPPHtmlDrawer::SetCssStyles(DWORD dwIdCssString, LPCTSTR lpszPathDll /* = NULL */)§{§	CPPString str;§	if (NULL == lpszPathDll)§		str = GetStringFromResource(dwIdCssString);§	else§		str = GetStringFromDll(dwIdCssString, lpszPathDll);§	SetCssStyles(str);§} //End SetCssStyles§§void CPPHtmlDrawer::SetCssStyles(LPCTSTR lpszCssString /* = NULL */)§{§	m_mapStyles.clear(); //removes previously styles§§	if (NULL == lpszCssString)§	{§		SetDefaultCssStyles();§	}§	else§	{§		CPPString str = (CPPString)lpszCssString;§		m_strCssStyles = str;§		§		CPPString strName;§		CPPString strProperty;§		§		int nBegin;§		TCHAR chSymbol;§		int nIndex = 0;§		§		while (nIndex < str.GetLength())§		{§			//Passes a space in begin string§			if (GetIndexNextAlphaNum(str, nIndex))§			{§				nBegin = nIndex;§				//Searching end of the style name§				chSymbol = GetIndexNextChars(str, nIndex, _T(" {"));§				if ((nIndex > nBegin) && (0 != chSymbol))§				{§					strName = str.Mid(nBegin, nIndex - nBegin);§					if (!strName.IsEmpty())§					{§						if (chSymbol != _T(' '))§							nIndex --;§						chSymbol = GetIndexNextChars(str, nIndex, _T("{"));§						if (0 != chSymbol)§						{§							nBegin = nIndex + 1;§							chSymbol = GetIndexNextChars(str, nIndex, _T("}"));§							if ((nIndex > nBegin) && (0 != chSymbol))§							{§								strProperty = str.Mid(nBegin, nIndex - nBegin);§								SetTextStyle(strName, strProperty);§							} //if§						} //if§					} //if§				} //if§			} //if§		} //while§	} //if§} //End SetCssStyles§§LPCTSTR CPPHtmlDrawer::GetCssStyles()§{§	return (LPCTSTR)m_strCssStyles;§} //End GetCssStyles§§LPCTSTR CPPHtmlDrawer::GetTextStyle(LPCTSTR lpszStyleName)§{§	CPPString name = (CPPString)lpszStyleName;§	name.MakeLower();§	iter_mapStyles iterMap = m_mapStyles.find(name);§	§	if (iterMap != m_mapStyles.end())§		return (LPCTSTR)iterMap->second;§§	//Not found§	return NULL;§} //End GetTextStyle§§void CPPHtmlDrawer::SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue)§{§	CPPString name = (CPPString)lpszStyleName;§	name.MakeLower();§	iter_mapStyles iterMap = m_mapStyles.find(name);§	§	if (iterMap != m_mapStyles.end())§	{§		//Modifies §		iterMap->second = (CPPString)lpszStyleValue;§	}§	else§	{§		//Add new§		m_mapStyles.insert(std::make_pair(name, (CPPString)lpszStyleValue));§	} //if§} //End SetTextStyle§§void CPPHtmlDrawer::RemoveTextStyle(LPCTSTR lpszStyleName)§{§	CPPString name = (CPPString)lpszStyleName;§	name.MakeLower();§	iter_mapStyles iterMap = m_mapStyles.find(name);§	§	if (iterMap == m_mapStyles.end())§		return; //item was not found§	§	m_mapStyles.erase(iterMap);§} //End RemoveTextStyle§§void CPPHtmlDrawer::AddToTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszAddStyle)§{§} //End AddToTextStyle§§void CPPHtmlDrawer::UnpackTextStyle(CPPString strStyle, _STRUCT_CHANGESTYLE & cs)§{§	//Gets a string§	strStyle.MakeLower();§	if (strStyle.IsEmpty())§		return;§§	CPPString strName;§	CPPString strParameter;§§	int nBegin;§	TCHAR chSymbol;§	int nIndex = 0;§	CPPString str;§§	while (nIndex < strStyle.GetLength())§	{§		//Passes a space in begin string§		if (GetIndexNextAlphaNum(strStyle, nIndex))§		{§			nBegin = nIndex;§			//Searching end of the style name§			chSymbol = GetIndexNextChars(strStyle, nIndex, _T(" :"));§			if (0 != chSymbol)§			{§				//Gets a property's name§				strName = strStyle.Mid(nBegin, nIndex - nBegin);§§				//Gets a property's value§				strParameter = GetParameterString(strStyle, nIndex, _T(':'));§§				//Analyzing name§				if (strName == _T("font-size"))§				{§					cs.nSizeFont = GetLengthUnit(strParameter, cs.nSizeFont, TRUE);§				}§				else if (strName == _T("font-family"))§				{§					if (!strParameter.IsEmpty())§						cs.sFaceFont = strParameter;§				}§				else if (strName == _T("font-style"))§				{§					cs.bItalicFont = GetStyleFontStyle(strParameter, cs.bItalicFont);§				}§				else if (strName == _T("font-weight"))§				{§					cs.nWeightFont = GetStyleFontWeight(strParameter, cs.nWeightFont);§				}§				else if (strName == _T("text-align"))§				{§					cs.nHorzAlign = GetStyleHorzAlign(strParameter, cs.nHorzAlign);§				}§				else if (strName == _T("text-transform"))§				{§					cs.nTextTransform = GetStyleTextTransform(strParameter, cs.nTextTransform);§				}§				else if (strName == _T("color"))§				{§					if (m_bIsEnable)§						cs.crText = GetStyleColor(strParameter, cs.crText);§					else§						cs.crText = GetColorByName("");§				}§				else if (strName == _T("background-color"))§				{§					if (((strParameter == _T("transparent")) && strParameter.IsEmpty()) || !m_bIsEnable)§					{§						cs.nBkMode = TRANSPARENT;§					}§					else§					{§						cs.nBkMode = OPAQUE;§						cs.crBkgnd = GetStyleColor(strParameter, cs.crBkgnd);§					} //if§				}§				else if (strName == _T("text-decoration"))§				{§					StyleTextDecoration(strParameter, cs);§				}§				else if (strName == _T("vertical-align"))§				{§					cs.nVertAlign = GetStyleVertAlign(strParameter, cs.nVertAlign);§				}§				else if (strName == _T("border-color"))§				{§					if (m_bIsEnable)§						cs.crBorderLight = GetStyleColor(strParameter, cs.crBorderLight);§					else§						cs.crBorderLight = GetColorByName("");§					cs.crBorderDark = cs.crBorderLight;§				}§				else if ((strName == _T("border-width")) || (strName == _T("size")))§				{§					cs.nBorderWidth = StyleBorderWidth(strParameter, cs.nBorderWidth);§					if (!cs.nBorderWidth)§						cs.nBorderStyle = CPPDrawManager::PEN_NULL;§					else if (CPPDrawManager::PEN_NULL == cs.nBorderStyle)§						cs.nBorderStyle = CPPDrawManager::PEN_SOLID;§				}§				else if (strName == _T("border-style"))§				{§					cs.nBorderStyle = StyleBorder(strParameter, cs.nBorderStyle);§					if ((CPPDrawManager::PEN_NULL != cs.nBorderStyle) && !cs.nBorderWidth)§						cs.nBorderWidth = 1;§				}§				else if (strName == _T("margin"))§				{§					cs.nMargin = GetLengthUnit(strParameter, cs.nMargin);§				}§				else if (strName == _T("padding"))§				{§					cs.nPadding = GetLengthUnit(strParameter, cs.nPadding);§				} //if§			} //if§		} //if§	} //while§} //End UnpackTextStyle§§BOOL CPPHtmlDrawer::GetStyleFontStyle(CPPString & str, BOOL bDefault)§{§	if ((str == _T("normal")) || str.IsEmpty())§	{§		bDefault = FALSE;§	}§	else if ((str == _T("italic")) || (str == _T("oblique"))) §	{§		bDefault = TRUE;§	} //if§§	return bDefault;§} //End GetStyleFontStyle§§int CPPHtmlDrawer::GetStyleFontWeight(CPPString & str, int nDefault)§{§	if ((str == _T("normal")) || str.IsEmpty())§	{§		nDefault = FW_NORMAL;§	}§	else if (str == _T("bold"))§	{§		nDefault = FW_BOLD;§	}§	else if (str == _T("bolder"))§	{§		nDefault = 900;§	}§	else if (str == _T("lighter"))§	{§		nDefault = 100;§	}§	else§	{§		nDefault = _ttoi(str);§	} //if§§	return nDefault;§} //End GetStyleFontWeight§§int CPPHtmlDrawer::GetStyleHorzAlign(CPPString & str, int nDefault)§{§	if ((str == _T("left")) || str.IsEmpty())§	{§		nDefault = ALIGN_LEFT;§	}§	else if (str == _T("center"))§	{§		nDefault = ALIGN_CENTER;§	}§	else if (str == _T("right"))§	{§		nDefault = ALIGN_RIGHT;§	}§§	return nDefault;§} //End GetStyleHorzAlign§§int CPPHtmlDrawer::GetStyleVertAlign(CPPString & str, int nDefault)§{§	if ((str == _T("baseline")) || str.IsEmpty())§	{§		nDefault = ALIGN_BASELINE;§	}§	else if ((str == _T("middle")) || (str == _T("vcenter")))§	{§		nDefault = ALIGN_VCENTER;§	}§	else if (str == _T("top"))§	{§		nDefault = ALIGN_TOP;§	}§	else if (str == _T("bottom"))§	{§		nDefault = ALIGN_BOTTOM;§	}§	§	return nDefault;§} //End GetStyleVertAlign§§int CPPHtmlDrawer::GetStyleTextTransform(CPPString & str, int nDefault)§{§	if ((str == _T("none")) || str.IsEmpty())§	{§		nDefault = TEXT_TRANSFORM_NONE;§	}§	else if (str == _T("uppercase"))§	{§		nDefault = TEXT_TRANSFORM_UPPERCASE;§	}§	else if (str == _T("lowercase"))§	{§		nDefault = TEXT_TRANSFORM_LOWERCASE;§	}§	else if (str == _T("capitalize"))§	{§		nDefault = TEXT_TRANSFORM_CAPITALIZE;§	}§	§	return nDefault;§}§§COLORREF CPPHtmlDrawer::GetStyleColor(CPPString & str, COLORREF crDefault)§{§//	if (!m_bIsEnable)§//		return GetColorByName("");§	§	if (!str.IsEmpty())§	{§		if (str.GetAt(0) == _T('#'))§		{§			if (str.GetLength() == 7)§			{§				CPPString strHex = _T("0x");§				strHex += str.Mid(5, 2);§				strHex += str.Mid(3, 2);§				strHex += str.Mid(1, 2);§				crDefault = (COLORREF)_tcstoul(strHex, 0, 0);§			} //if§		}§		else if ((str.GetAt(0) >= '0') && (str.GetAt(0) <= '9'))§			crDefault = (COLORREF)_tcstoul(str, 0, 0);§		else§			crDefault = GetColorByName(str, crDefault);§	} //if §§	return crDefault;§} //End GetStyleColor§§int CPPHtmlDrawer::GetLengthUnit(CPPString & str, int nDefault, BOOL bFont /* = FALSE */)§{§	if (str.IsEmpty())§		return nDefault;§	§	if (IsPercentableValue(str))§	{§		//Percent value§		int percent = _ttoi(str.Left(str.GetLength() - 1));§		return ::MulDiv(nDefault, percent, 100);§	} //if§§	int nSign = 0;§	if (str.GetAt(0) == _T('+')) nSign = 1;§	else if (str.GetAt(0) == _T('-')) nSign = -1;§	§	if (0 != nSign) str = str.Right(str.GetLength() - 1);§	§	//ENG: This code fragment fixed by Reinhard Steiner(2004/10/20).§	int nValue = _ttoi(str);§	CPPString strUnit;§	if(str.GetLength() >= 2)§		strUnit = str.Right(2);§§	if (strUnit == _T("px"))		nDefault = nValue;§	else if (strUnit == _T("ex"))§	{§		SIZE szText;§		CPPString strText = _T("x");§		::GetTextExtentPoint32(m_hDC, strText, strText.GetLength(), &szText);§		nDefault = nValue * szText.cy;§	}§	else if (strUnit == _T("em"))	nDefault = nValue * m_tm.tmHeight;§	else§	{§		//Gets pixel in inch§		nValue *= ::GetDeviceCaps(m_hDC, LOGPIXELSY);§		if (strUnit == _T("in"))		nDefault = nValue;§		else if (strUnit == _T("cm"))	nDefault = (int)((double)nValue / 2.54);§		else if (strUnit == _T("mm"))	nDefault = (int)((double)nValue / 25.4);§		else if (strUnit == _T("pt"))	nDefault = nValue / 72;§		else if (strUnit == _T("pc"))	nDefault = nValue / 6;§		else§		{§			nValue = _tcstoul(str, 0, 0);//_ttoi(str);§			if ((nValue > 0) && (nValue < 8) && bFont)§			{§				int nSize [] = {8, 10, 12, 14, 18, 24, 36};§				nDefault = nSize [nValue - 1];§			}§			else§			{§				nDefault = nValue;§			} //if§		} //if§	} //if§	§	return nDefault;§} //End GetLengthUnit§§void CPPHtmlDrawer::StyleTextDecoration(CPPString & str, _STRUCT_CHANGESTYLE & cs)§{§	if (str.IsEmpty())§		str = _T("none");§	§	int nBegin = 0;§	int nEnd = 0;§	CPPString strTemp;§	while (nBegin < str.GetLength())§	{§		if (GetIndexNextAlphaNum(str, nBegin))§		{§			nEnd = nBegin;§			GetIndexNextChars(str, nEnd, _T(" ,"));§			strTemp = str.Mid(nBegin, nEnd - nBegin);§			nBegin = nEnd;§			if (strTemp == _T("none"))§			{§				cs.bUnderlineFont = FALSE;§				cs.bStrikeOutFont = FALSE;§				cs.bOverlineFont = FALSE;§			}§			else if (strTemp == _T("underline"))§			{§				cs.bUnderlineFont = TRUE;§			}§			else if (strTemp == _T("line-through"))§			{§				cs.bStrikeOutFont = TRUE;§			}§			else if (strTemp == _T("overline"))§			{§				cs.bOverlineFont = TRUE;§			}  //if§		} //if§	} //while§} //End StyleTextDecoration§§int CPPHtmlDrawer::StyleBorderWidth(CPPString & str, int nDefault)§{§	if (str ==_T("thin"))		nDefault = ::MulDiv(75, nDefault, 100);§	else if (str ==_T("thick"))	nDefault = ::MulDiv(125, nDefault, 100);§	else if (str !=_T("medium"))nDefault = GetLengthUnit(str, nDefault);§§	return nDefault;§} //End StyleBorderWidth§§int CPPHtmlDrawer::StyleBorder(CPPString & str, int nDefault)§{§	if ((str == _T("none")) || str.IsEmpty()) nDefault = CPPDrawManager::PEN_NULL;§	else if (str == _T("solid")) nDefault = CPPDrawManager::PEN_SOLID;§	else if (str == _T("dotted")) nDefault = CPPDrawManager::PEN_DOT;§	else if (str == _T("dashed")) nDefault = CPPDrawManager::PEN_DASH;§	else if (str == _T("double")) nDefault = CPPDrawManager::PEN_DOUBLE;§§	return nDefault;§} //End StyleBorder§§void CPPHtmlDrawer::SetDefaultStyles(_STRUCT_CHANGESTYLE & cs)§{§	m_defStyle.strTag.Empty();		//The name of the last opened tag§	§	//Font§	m_defStyle.nSizeFont = 16;		//The height of the logic font§	m_defStyle.nWeightFont = FW_NORMAL;	//The weight of the logic font§	m_defStyle.bItalicFont = FALSE;	//Is italic logic font?§	m_defStyle.bUnderlineFont = FALSE;//Is underline logic font?§	m_defStyle.bStrikeOutFont = FALSE;//Is strikeout logic font?§	m_defStyle.bOverlineFont = FALSE; //Is overline logic font?§	m_defStyle.sFaceFont = _T("Verdana");  //The face name of the logic font§	§	//Color		§	m_defStyle.crText = RGB (0, 0, 0);	//The foreground color §	m_defStyle.crBkgnd = RGB (255, 255, 255);	//The background color (also begin for the gradient)§	m_defStyle.crBorderLight = RGB (0, 0, 0);	//The border color§	m_defStyle.crBorderDark = RGB (0, 0, 0);	//The border color§	m_defStyle.crMidBkgnd = RGB (255, 255, 255);//The middle background color§	m_defStyle.crEndBkgnd = RGB (255, 255, 255);//The end background color§	§	//Fill§	m_defStyle.nBkMode = TRANSPARENT;		//The background mode for the text (TRANSPARENT, OPAQUE)§	m_defStyle.nFillBkgnd = -1;	//The fill effect of the background§	m_defStyle.strNameResBk.Empty();§	§	//Align§	m_defStyle.nHorzAlign = ALIGN_LEFT;	//The horizontal align§	m_defStyle.nVertAlign = ALIGN_BASELINE;	//The vertical align§	§	//Border§	m_defStyle.nBorderStyle = CPPDrawManager::PEN_NULL;	//The border style§	m_defStyle.nBorderWidth = 0;	//The width of the border§	§	//Text§	m_defStyle.nTextTransform = TEXT_TRANSFORM_NONE;//Transformation of the text (NONE, UPPERCASE, LOWERCASE, CAPITALIZE)§	§	//Margins§	m_defStyle.nMargin = 2;§	§	//Padding§	m_defStyle.nPadding = 0;§	§	//Hyperlink§	m_defStyle.nTypeLink = LINK_NONE;		//The type of the link (NONE, HREF, MESSAGE)§	m_defStyle.sHyperlink.Empty(); //The additional parameter for the link§} //SetDefaultStyles§§/////////////////////////////////////////////////////////////////§// Search body of the next tag§//---------------------------------------------------------------§// Parameters:§//     In: str    - a string with html text§//         nIndex - an index of the first char to the searching in the string§//    Out: nIndex - an index of the char in the string after found tag's text§//         strTag - a string contained the tag's text if was found§// Return: A string before found tag's text §/////////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::SearchNextTag(CPPString & str, CPPString & strTag, int & nIndex)§{§	int nBegin;§	CPPString sText = _T("");§	strTag.Empty();§§	while (nIndex < str.GetLength())§	{§		nBegin = nIndex;§		//Searching a chars of the begin tag§		nIndex = str.Find(_T("<"), nIndex);§		if (nIndex < 0)§			nIndex = str.GetLength(); //A tag wasn't found§		sText += str.Mid(nBegin, nIndex - nBegin);§		if (nIndex < str.GetLength())§		{§			//May be it is a begin of the tag?§			if ((nIndex < (str.GetLength() - 1)) && (_T('<') != str.GetAt(nIndex + 1)))§			{§				//Yes of cause!!!§				strTag = GetTagBody(str, nIndex);§				return sText;§			}§			//No, it is a char '<'§			sText += _T("<");§			nIndex += 2;§			break;§		} //if§	} //while§	return sText;§} //End SearchNextTag§§/////////////////////////////////////////////////////////////////§// CPPHtmlDrawer::GetTagBody§//	Gets a name of tag with a parameters§//---------------------------------------------------------------§// Parameters:§//	[in]§//		str		-	a string with html text§//		nIndex	-   an index of the begin of the tag. §//	[out]§//		nIndex  -	an index of char after the tag§//---------------------------------------------------------------§// Return values:§//	A tag's name .§/////////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::GetTagBody(CPPString & str, int & nIndex)§{§	CPPString sTagName = _T("");§	//ENG: Search the tag's end §	//RUS: »˘ÂÏ ÓÍÓÌ˜‡ÌËÂ Ú˝„‡§	int nEndOfTag = str.Find(_T('>'), nIndex);§	//ENG: The tag's end was found. Passes a tag's begin char ('<')§	//RUS:  ÓÌÂˆ Ú˝„‡ Ì‡È‰ÂÌ˛ œÓÔÛÒÍ‡ÂÏ ÒËÏ‚ÓÎ Ì‡˜‡Î‡ Ú˝„‡§	nIndex++;§	if (nEndOfTag > nIndex)§	{§		//ENG: Gets a full body of tag§		//RUS: œÓÎÛ˜‡ÂÏ ÔÓÎÌÛ˛ ÒÚÓÍÛ Ú˝„‡§		sTagName = str.Mid(nIndex, nEndOfTag - nIndex);§		//ENG: Jump to next char after the tag§		//RUS: œÂÂÏÂ˘‡ÂÏÒˇ Ì‡ ÒÎÂ‰Û˛˘ËÈ Á‡ Ú˝„ÓÏ ÒËÏ‚ÓÎ§		nIndex = nEndOfTag + 1;§	} //if§	return sTagName;§} //End of GetTagBody§§/////////////////////////////////////////////////////////////////§// Split a tag to his name and properties§//---------------------------------------------------------------§// Parameters:§//     In: sTag    - a string with tag's text§//    Out: sTag	   - a tag's name§// Return: A property's string §/////////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::SplitTag(CPPString & sTag)§{§	CPPString sParam(_T(""));§	int nIndex = 0;§	TCHAR tch = GetIndexNextChars(sTag, nIndex, _T(" ="));§	if (tch != _T('\0'))§	{§		//ENG: The separator was found. Splits a tag's body to his name and his parameteres §		//RUS: –‡Á‰ÂÎËÚÂÎ¸ Ì‡È‰ÂÌ. –‡Á‰ÂÎˇÂÏ ÚÂÎÓ Ú˝„‡ Ì‡ ËÏˇ Ë Ô‡‡ÏÂÚ˚§		sParam = sTag.Mid(nIndex);§		sTag = sTag.Left(nIndex);§		sParam.TrimLeft(_T(' '));§	} //if§	return sParam;§} //End of SplitTag§§CPPString CPPHtmlDrawer::GetNextProperty(CPPString & str, int & nIndex, CPPString & sProp)§{§	CPPString sValue(_T(""));§	sProp.Empty();§	§	//Passes the spaces before a property§	if (GetIndexNextAlphaNum(str, nIndex))§	{§		//The begin of the property was found§		int nBegin = nIndex;§		//Searching end of the property§		GetIndexNextChars(str, nIndex, _T(" ="));§		//Gets a property's string§		sProp = str.Mid(nBegin, nIndex - nBegin);§		TCHAR chFound = GetIndexNextNoChars(str, nIndex, _T(" "));§		if (_T('=') == chFound)§		{§			chFound = GetIndexNextNoChars(str, nIndex, _T(" ="));§			if ((_T('\'') == chFound) || (_T('\"') == chFound))§			{§				nIndex++;§			}§			else§			{§				chFound = _T(' ');§			} //if§			sValue += chFound;§			nBegin = nIndex;§			GetIndexNextChars(str, nIndex, sValue);§			sValue = str.Mid(nBegin, nIndex - nBegin);§			nIndex ++;§		} //if§	} //if§	return sValue;§} //End of GetNextProperty§§/////////////////////////////////////////////////////////////////§// Searching the next property of the tag§//---------------------------------------------------------------§// Parameters:§//     In: str    - a string with html text§//         nIndex - an index of the first char to the searching in the string§//    Out: nIndex - an index of the char in the string after found tag's text§// Return: A property's string §/////////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::SearchPropertyOfTag(CPPString & str, int & nIndex)§{§	CPPString sText = _T("");§	§	//Passes the spaces before a property§	if (GetIndexNextAlphaNum(str, nIndex))§	{§		//The begin of the property was found§		int nBegin = nIndex;§		//Searching end of the property§		TCHAR chFound = GetIndexNextChars(str, nIndex, _T(" ="));§		//Gets a property's string§		sText = str.Mid(nBegin, nIndex - nBegin);§	} //if§	return sText;§} //End SearchPropertyOfTag§§/////////////////////////////////////////////////////////////////§// Search a tag§//---------------------------------------------------------------§// Parameters:§//     In: str    - a string with html text§//         nIndex - an index of the first char to the searching in the string§//    Out: nIndex - an index of the first char of the tag§// Return: TRUE if specified tag was found §//---------------------------------------------------------------§// Example: (strTag = "table") or (strTag = "/table")§/////////////////////////////////////////////////////////////////§BOOL CPPHtmlDrawer::SearchTag(CPPString & str, int & nIndex, CPPString strTag)§{§	strTag = _T("<") + strTag;§	while (nIndex < str.GetLength())§	{§		nIndex = str.Find(strTag, nIndex);§		if (nIndex < 0)§			nIndex = str.GetLength();§		else§		{§			if (nIndex > 0)§			{§				if (str.GetAt(nIndex - 1) != _T('<'))§					return TRUE;§				nIndex += 2;§			}§			else return TRUE;§		} //if§	}§	return FALSE;§} //End SearchTag§§/////////////////////////////////////////////////////////////////§// Search a first alpha_num chars or first arithmetic char§//---------------------------------------------------------------§// Parameters:§//     In: str    - a string with html text§//         nIndex - an index of the first char to the searching in the string§//    Out: nIndex - an index of the first found char§// Return: TRUE if specified char was found §/////////////////////////////////////////////////////////////////§BOOL CPPHtmlDrawer::GetIndexNextAlphaNum(CPPString & str, int & nIndex, BOOL bArithmetic /* = FALSE */)§{§	TCHAR ch;§	for (; nIndex < str.GetLength(); nIndex++)§	{§		ch = str.GetAt(nIndex);§		if ((ch >= _T('0')) && (ch <= _T('9')))§			return TRUE;§		if ((ch >= _T('A')) && (ch <= _T('Z')))§			return TRUE;§		if ((ch >= _T('a')) && (ch <= _T('z')))§			return TRUE;§		if (ch == _T('.'))§			return TRUE;§		if (bArithmetic)§		{§			if ((_T('+') == ch) || (_T('-') == ch) || §				(_T('*') == ch) || (_T('/') == ch))§				return TRUE;§		} //if§	} //for§	return FALSE;§} //End GetIndexNextAlphaNum§§/////////////////////////////////////////////////////////////////§// Search a first char of the chars set§//---------------------------------------------------------------§// Parameters:§//     In: str      - a string with html text§//         nIndex   - an index of the first char to the searching in the string§//		   strChars - the set of the chars§//    Out: nIndex   - an index of the first found char§// Return: A found char or zero if chars was not found  §/////////////////////////////////////////////////////////////////§TCHAR CPPHtmlDrawer::GetIndexNextChars(CPPString & str, int & nIndex, CPPString strChars)§{§	int i;§	for (; nIndex < str.GetLength(); nIndex++)§	{§		for (i = 0; i < strChars.GetLength(); i++)§		{§			if (str.GetAt(nIndex) == strChars.GetAt(i))§				return str.GetAt(nIndex);§		} //for§	} //for§	return 0;§} //End GetIndexNextChars§§/////////////////////////////////////////////////////////////////§// Search a first char isn't specified in chars set§//---------------------------------------------------------------§// Parameters:§//     In: str      - a string with html text§//         nIndex   - an index of the first char to the searching in the string§//		   strChars - the set of the chars§//    Out: nIndex   - an index of the first char isn't from chars set§// Return: A found char or zero if all chars was specified in the chars set  §/////////////////////////////////////////////////////////////////§TCHAR CPPHtmlDrawer::GetIndexNextNoChars(CPPString & str, int & nIndex, CPPString strChars)§{§	int i;§	BOOL bFound;§	for (; nIndex < str.GetLength(); nIndex++)§	{§		bFound = FALSE;§		for (i = 0; (i < strChars.GetLength()) && !bFound; i++)§		{§			if (str.GetAt(nIndex) == strChars.GetAt(i))§				bFound = TRUE;§		} //for§		if (!bFound)§			return str.GetAt(nIndex);§	} //for§	return 0;§} //End GetIndexNextNoChars§§/////////////////////////////////////////////////////////////////§// Is exist a property's parameter?§//---------------------------------------------------------------§// Parameters:§//     In: str         - a string with html text§//         nIndex      - an index of the first char to the searching in the string§//		   chSeparator - the char is a begin of the parameter§//    Out: nIndex   - an index of the begin parameter (if it exist) or the begin of the next property§// Return: TRUE if parameter was found  §/////////////////////////////////////////////////////////////////§BOOL CPPHtmlDrawer::GetBeginParameter(CPPString & str, int & nIndex, TCHAR chSeparator /* = _T(':') */)§{§	TCHAR ch;§	for (; nIndex < str.GetLength(); nIndex++) §	{§		//Gets a current char§		ch = str.GetAt(nIndex);§		if (_T(' ') != ch)§		{§			//if it is not space char§			if (chSeparator == ch)§			{§				//if begin of the property's parameter was found§				nIndex ++; //jump to the next char after a begin parameter§				return TRUE;§			}§			else§			{§				return FALSE;§			}//if§		} //if§	} //for§	return FALSE;§} //End GetBeginParameter§§/////////////////////////////////////////////////////////////////§// Gets a parameter for the currrent property§//---------------------------------------------------------------§// Parameters:§//     In: str         - a string with html text§//         nIndex      - an index of the first char to the searching in the string§//		   chSeparator - the char is a begin of the parameter§//    Out: nIndex   - an index of the first char after the parameter§// Return: String of the property's parameter (empty if it is not exist)  §/////////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::GetParameterString(CPPString & str, int & nIndex, TCHAR chBeginParam /* = _T(':') */, CPPString strSeparators /* = _T(";") */)§{§	if (GetBeginParameter(str, nIndex, chBeginParam))§	{§		//Parameter for the current property was found§		TCHAR ch = GetIndexNextNoChars(str, nIndex, strSeparators + _T(" "));§		if (0 != ch)§		{§			int nBegin = nIndex;§			if (_T('"') == str.GetAt(nIndex))§			{§				nIndex++;§				TCHAR ch = GetIndexNextChars(str, nIndex, _T("\""));§				if (_T('"') == ch)§				{§					nIndex ++;§					return str.Mid(nBegin + 1, nIndex - nBegin - 2);§				} //if§			}§			else§			{§				GetIndexNextChars(str, nIndex, strSeparators);§				return str.Mid(nBegin, nIndex - nBegin);§			} //if§		} //if§	} //if§	return _T("");§} //End GetParameterString§§/////////////////////////////////////////////////////////////////§// Gets a name of the tag§//---------------------------------------------------------------§// Parameters:§//     In: str         - a tag's string§//         nIndex      - an index of the first char to the searching in the string§//    Out: nIndex   - an index of the first char after the parameter§// Return: Name of the tag (empty if it is not exist)  §/////////////////////////////////////////////////////////////////§CPPString CPPHtmlDrawer::GetNameOfTag(CPPString & str, int & nIndex)§{§	CPPString strName = _T("");§	GetIndexNextNoChars(str, nIndex, _T(" "));§	int nBegin = nIndex;§	GetIndexNextChars(str, nIndex, _T(" ="));§	if (nIndex > nBegin)§		strName = str.Mid(nBegin, nIndex - nBegin);§	§	return strName;§} //End GetNameOfTag§§/////////////////////////////////////////////////////§// Gets dimensions of the table§//---------------------------------------------------§//  In: sTable - the string contains a HTML table§// Return: cx - number of the columns§//         cy - number of the row§/////////////////////////////////////////////////////§SIZE CPPHtmlDrawer::GetTableDimensions(CPPString & sTable)§{§	//ENG: A table dimensions by default§	//RUS: –‡ÁÏÂ˚ Ú‡·ÎËˆ˚ ÔÓ ÛÏÓÎ˜‡ÌË˛§	SIZE szTable = {0, 0};§	int nIndex = 0;§	int nCol = 0;§	while (nIndex < sTable.GetLength())§	{§		//ENG: Search a begin of the row§		//RUS: »˘ÂÏ Ì‡˜‡ÎÓ ÒÚÓÍË§		if (SearchTag(sTable, nIndex, _T("tr")))§		{§			//ENG: Increment count of the rows§			//RUS: ”‚ÂÎË˜Ë‚‡ÂÏ ÍÓÎË˜ÂÒÚ‚Ó ÒÚÓÍ§			szTable.cy++;§§			//ENG: Count of the columns in current row§			//RUS:  ÓÎË˜ÂÒÚ‚Ó ÍÓÎÓÌÓÍ ‚ ÚÂÍÛ˘ÂÈ ÒÚÓÍÂ§			nCol = 0;§			int nEndRow;§			int nNewCell;§			do §			{§				nEndRow = nNewCell = nIndex;§				//ENG: Search an end of the row or a begin of the cell§				//RUS: »˘ÂÏ ÍÓÌÂˆ ÒÚÓÍË ËÎË Ì‡˜‡ÎÓ ˇ˜ÂÈÍË§				SearchTag(sTable, nEndRow, _T("/tr"));§				SearchTag(sTable, nNewCell, _T("td"));§				if (nNewCell < nEndRow)§				{§					nIndex = nNewCell;§§					//ENG: Passes a tag body and get a properties of the tag§					//RUS: œÓÔÛÒÍ‡ÂÏ Ú˝„ Ì‡˜‡Î‡ ˇ˜ÂÈÍË Ë ÔÓÎÛ˜‡ÂÏ ÒÚÓÍÛ Ò‚ÓÈÒÚ‚ Ú˝„‡§					CPPString sTag;§					SearchNextTag(sTable, sTag, nNewCell);§					CPPString sProperties = SplitTag(sTag);§§					//ENG: Analyses a properties of the tag§					//RUS: ¿Ì‡ÎËÁËÛÂÏ Ò‚ÓÈÒÚ‚‡ Ú˝„‡§					STRUCT_CHANGESTYLE style;§					SIZE szSpan = AnalyseCellParam(sProperties, style, TRUE);§§					//ENG: Increment count of the cells§					//RUS: ”‚ÂÎË˜Ë‚‡ÂÏ ÍÓÎË˜ÂÒÚ‚Ó ˇ˜ÂÂÍ ‚ ÒÚÓÍÂ§					nCol += szSpan.cx;§§					//ENG: Jump to end of the cell§					//RUS: œÂÂıÓ‰ËÏ Ì‡ ÍÓÌÂˆ ˇ˜ÂÈÍË§					SearchEndOfCell(sTable, nIndex);§				} //if§			} while (nNewCell < nEndRow);§			nIndex = nEndRow;§			if (nCol > szTable.cx)§				szTable.cx = nCol;§		} //if§	} //while§	return szTable;§} //End GetTableDimensions§§/////////////////////////////////////////////////////§// CPPHtmlDrawer::SearchEndOfTable§//	Searching the end of the table§//---------------------------------------------------§//  Parameter:    §//		str - the string contains a HTML table§//		nIndex - index of the first char after the <table> tag§//	Return values:§//		nIndex - index of the begin char of a </table> tag§/////////////////////////////////////////////////////§void CPPHtmlDrawer::SearchEndOfTable(CPPString & str, int & nIndex)§{§	int nBeginTable = nIndex + 7;§	int nEndTable = nIndex + 7;§	int nTable = 1;§	do§	{§		SearchTag(str, nBeginTable, _T("table"));§		SearchTag(str, nEndTable, _T("/table"));§		if (nBeginTable < nEndTable)§		{§			nTable++;§			nBeginTable += 7;§		}§		else if (nEndTable < nBeginTable)§		{§			nTable --;§			nEndTable += 8;§		} //if§	}§	while ((nBeginTable != nEndTable) && nTable); //while§	nIndex = nEndTable - 8;§} //End SearchEndOfTable§§/////////////////////////////////////////////////////§// CPPHtmlDrawer::SearchEndOfRow§//	Searching the end of the row§//---------------------------------------------------§//  Parameter:    §//		str - the string contains a HTML table§//		nIndex - index of the first char after the <tr> tag§//	Return values:§//		nIndex - index of the begin char of a </tr> tag§/////////////////////////////////////////////////////§void CPPHtmlDrawer::SearchEndOfRow(CPPString & str, int & nIndex)§{§	nIndex += 4;§	int nBeginRow, nEndRow, nStartTable;§	int nRow = 1;§§	do§	{§		nBeginRow = nEndRow = nStartTable = nIndex;§§		SearchTag(str, nBeginRow, _T("tr"));§		SearchTag(str, nEndRow, _T("/tr"));§		SearchTag(str, nStartTable, _T("table"));§		§		if ((nStartTable < nBeginRow) && (nStartTable < nEndRow))§		{§			SearchEndOfTable(str, nStartTable);§			nIndex = nStartTable + 6;§		}§		else if (nBeginRow < nEndRow)§		{§			nRow++;§			nIndex = nBeginRow + 4;§		}§		else if (nEndRow < nBeginRow)§		{§			nRow --;§			nIndex = nEndRow + 5;§		} //if§	}§	while ((nIndex < str.GetLength()) && nRow); //while§	nIndex -= 5;§} //End SearchEndOfRow§§/////////////////////////////////////////////////////§// CPPHtmlDrawer::SearchEndOfCell§//	Searching the end of the cell§//---------------------------------------------------§//  Parameter:    §//		str - the string contains a HTML table§//		nIndex - index of the first char after the <td> tag§//	Return values:§//		nIndex - index of the begin char of a </td> tag§/////////////////////////////////////////////////////§void CPPHtmlDrawer::SearchEndOfCell(CPPString & str, int & nIndex)§{§	nIndex += 4;§	int nEndCell, nStartTable;§	do§	{§		nEndCell = nStartTable = nIndex;§§		SearchTag(str, nEndCell, _T("/td"));§		SearchTag(str, nStartTable, _T("table"));§		§		if (nStartTable < nEndCell)§		{§			SearchEndOfTable(str, nStartTable);§			nEndCell = nIndex = nStartTable + 6;§		}§		else§		{§			nIndex = nEndCell + 5;§		} //if§	}§	while (nStartTable < nEndCell); //while§	nIndex -= 5;§} //End SearchEndOfCell§§///////////////////////////////////////////////////////////////////////§// Analysing the cell parameters§//---------------------------------------------------------------------§// Parameters:§//   In: strTag - str string contains parameters of the <table>, <td> or <tr> tags§//           cs - the structures contains the current styles§//		 bTable - §//  Out:     cs - the structures contains the new styles§///////////////////////////////////////////////////////////////////////§SIZE CPPHtmlDrawer::AnalyseCellParam(CPPString & sProperties, _STRUCT_CHANGESTYLE & cs, BOOL bTable)§{§	SIZE szSpan = {1, 1};§	if (sProperties.IsEmpty())§		return szSpan;§	§	int i = 0;§	CPPString sParameter;§	CPPString sValue;§	§	while (i < sProperties.GetLength())§	{§		//ENG: Searching a parameters of a tag§		//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§		sValue = GetNextProperty(sProperties, i, sParameter);§§		//ENG: Processes the specific parameters for <table> tag.§		//RUS: Œ·‡·‡Ú˚‚‡ÂÏ ÒÔÂˆËÙË˜ÂÒÍËÂ ‰Îˇ Ú˝„‡ <table> Ô‡‡ÏÂÚ˚§		if(bTable)§		{§			if (sParameter == _T("cellpadding"))§			{§				cs.nMargin = GetLengthUnit(sValue, cs.nMargin);§			}§			else if (sParameter == _T("cellspacing"))§			{§				cs.nPadding = GetLengthUnit(sValue, cs.nPadding);§			} §			else if (sParameter == _T("background"))§			{§				cs.strNameResBk = sValue;§			} //if§		} //if§§		if (sParameter == _T("rowspan"))§		{§			szSpan.cy = GetLengthUnit(sValue, szSpan.cy);§		}§		else if (sParameter == _T("colspan"))§		{§			szSpan.cx = GetLengthUnit(sValue, szSpan.cx);§		}§		else if (sParameter == _T("border"))§		{§			cs.nBorderWidth = GetLengthUnit(sValue, cs.nBorderWidth);§			if (!cs.nBorderWidth)§				cs.nBorderStyle = CPPDrawManager::PEN_NULL;§			else if (CPPDrawManager::PEN_NULL == cs.nBorderStyle)§				cs.nBorderStyle = CPPDrawManager::PEN_SOLID;§		}§		else if (sParameter == _T("borderstyle"))§		{§			cs.nBorderStyle = StyleBorder(sValue, cs.nBorderStyle);§			if ((CPPDrawManager::PEN_NULL != cs.nBorderStyle) && !cs.nBorderWidth)§					cs.nBorderWidth = 1;§		}§		else if (sParameter == _T("bordercolor"))§		{§			if (m_bIsEnable)§				cs.crBorderLight = GetStyleColor(sValue, cs.crBorderLight);§			else§				cs.crBorderLight = GetColorByName("");§			cs.crBorderDark = cs.crBorderLight;§		}§		else if (sParameter == _T("bordercolorlight"))§		{§			if (m_bIsEnable)§				cs.crBorderLight = GetStyleColor(sValue, cs.crBorderLight);§			else§				cs.crBorderLight = GetColorByName("");§		}§		else if (sParameter == _T("bordercolordark"))§		{§			if (m_bIsEnable)§				cs.crBorderDark = GetStyleColor(sValue, cs.crBorderDark);§			else§				cs.crBorderDark = GetColorByName("");§		}§		else if (sParameter == _T("bgcolor"))§		{§			if (m_bIsEnable)§			{§				cs.crBkgnd = GetStyleColor(sValue, cs.crBkgnd);§				if (cs.nFillBkgnd < 0)§					cs.nFillBkgnd = CPPDrawManager::EFFECT_SOLID;§			} //if§		}§		else if (sParameter == _T("bgmidcolor"))§		{§			if (m_bIsEnable)§				cs.crMidBkgnd = GetStyleColor(sValue, cs.crMidBkgnd);§		}§		else if (sParameter == _T("bgendcolor"))§		{§			if (m_bIsEnable)§				cs.crEndBkgnd = GetStyleColor(sValue, cs.crEndBkgnd);§		}§		else if (sParameter == _T("bgeffect"))§		{§			if (m_bIsEnable)§				cs.nFillBkgnd = GetStyleBkgndEffect(sValue, cs.nFillBkgnd);§		}§		else if (sParameter == _T("align"))§		{§			cs.nHorzAlign = GetStyleHorzAlign(sValue, cs.nHorzAlign);§		}§		else if (sParameter == _T("valign"))§		{§			cs.nVertAlign = GetStyleVertAlign(sValue, cs.nVertAlign);§		}§		else if (sParameter == _T("width"))§		{§			cs.nCellWidth = GetLengthUnit(sValue, cs.nCellWidth);§		}§		else if (sParameter == _T("height"))§		{§			cs.nCellHeight = GetLengthUnit(sValue, cs.nCellHeight);§		} //if§	} //for§§	//ENG:§	//RUS: §	if ((CPPDrawManager::PEN_NULL == cs.nBorderStyle) || !cs.nBorderWidth)§	{§		cs.nBorderStyle = CPPDrawManager::PEN_NULL;§		cs.nBorderWidth = 0;§	}§	else if (CPPDrawManager::PEN_SOLID != cs.nBorderStyle)§	{§		cs.nBorderWidth = 1;§	}	//if§§	//ENG: §	//RUS: ƒÎˇ ˇ˜ÂÂÍ ¯ËËÌ‡ ‚ÒÂ„‰‡ ‡‚Ì‡ 1§	if (!bTable && cs.nBorderWidth)§		cs.nBorderWidth = 1;§§	return szSpan;§} //End AnalyseCellParam§§///////////////////////////////////////////////////////////////////////§// Analysing the image parameters§//---------------------------------------------------------------------§// Parameters:§//   In: sProperties - the sing contains§//           si - the structures contains the image parameters§//  Out:     si - the structures contains the image parameters§///////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::AnalyseImageParam(CPPString & sProperties, _STRUCT_IMAGE & si)§{§	if (sProperties.IsEmpty())§		return;§	§	int i = 0;§	CPPString sParameter;§	CPPString sValue;§	§	while (i < sProperties.GetLength())§	{§		//ENG: Searching a parameters of a tag§		//RUS: œÓËÒÍ Ô‡‡ÏÂÚÓ‚ Ú˝„‡§		sValue = GetNextProperty(sProperties, i, sParameter);§§//		sParameter = SearchPropertyOfTag(sProperties, i);§//		sValue = GetParameterString(sProperties, i, _T('='), _T(" "));§			§		if (sParameter == _T("index"))§		{§			si.nIndexImageList = GetLengthUnit(sValue, si.nIndexImageList);§		}§		else if (sParameter == _T("idres"))§		{§			si.nIdRes = GetLengthUnit(sValue, si.nIdRes);§		}§		else if (sParameter == _T("iddll"))§		{§			si.nIdDll = GetLengthUnit(sValue, si.nIdDll);§		}§		else if (sParameter == _T("handle"))§		{§			si.nHandle = GetLengthUnit(sValue, si.nHandle);§		}§		else if (sParameter == _T("file"))§		{§			si.strSrcFile = GetStyleString(sValue, si.strSrcFile);§		}§		else if (sParameter == _T("srcdll"))§		{§			si.strPathDll = GetStyleString(sValue, si.strPathDll);§		}§		else if (sParameter == _T("mask"))§		{§			si.crMask = GetStyleColor(sValue, si.crMask);§			si.bUseMask = TRUE;§		}§		else if (sParameter == _T("style"))§		{§			si.nStyles = GetStyleImageShortForm(sValue);§			si.nHotStyles = si.nStyles;§		}§		else if (sParameter == _T("hotstyle"))§		{§			si.nHotStyles = GetStyleImageShortForm(sValue);§		}§		else if (sParameter == _T("cx"))§		{§			si.cx = GetLengthUnit(sValue, si.cx);§		}§		else if (sParameter == _T("cy"))§		{§			si.cy = GetLengthUnit(sValue, si.cy);§		}§		else if (sParameter == _T("width"))§		{§			si.bPercentWidth = IsPercentableValue(sValue);§			si.nWidth = GetLengthUnit(sValue, si.nWidth);§		}§		else if (sParameter == _T("height"))§		{§			si.bPercentHeight = IsPercentableValue(sValue);§			si.nHeight = GetLengthUnit(sValue, si.nHeight);§		}§		else if (sParameter == _T("speed"))§		{§			si.nSpeed = GetLengthUnit(sValue, si.nSpeed);§		} //if§	} //for§} //End AnalyseImageParam§§CPPString CPPHtmlDrawer::GetStyleString(CPPString str, CPPString strDefault)§{§	if (!str.IsEmpty())§		strDefault = str;§	return str;§}§§///////////////////////////////////////////////////////////////////////§// Analysing the short form of the font style§//---------------------------------------------------------------------§// Parameters:§//   In: str - string contains parameters of the font in the short form§// Short form styles§//       [+] - positive style§//       [-] - inverse style§//       [b] - bold§//       [i] - italic§//       [u] - underlined§//       [s] - strikeout§//       [o] - overline§///////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::GetStyleFontShortForm(CPPString & str)§{§	if (!str.IsEmpty())§	{§		BOOL bSetValue = TRUE;§		for (int i = 0; i < str.GetLength(); i++)§		{§			switch (str.GetAt(i))§			{§			case _T('-'):§				bSetValue = FALSE;§				break;§			case _T('+'):§				bSetValue = TRUE;§				break;§			case _T('b'):§				m_defStyle.nWeightFont = (bSetValue) ? FW_BOLD : FW_NORMAL;§				bSetValue = TRUE;§				break;§			case _T('i'):§				m_defStyle.bItalicFont = bSetValue;§				bSetValue = TRUE;§				break;§			case _T('u'):§				m_defStyle.bUnderlineFont = bSetValue;§				bSetValue = TRUE;§				break;§			case _T('s'):§				m_defStyle.bStrikeOutFont = bSetValue;§				bSetValue = TRUE;§				break;§			case _T('o'):§				m_defStyle.bOverlineFont = bSetValue;§				bSetValue = TRUE;§				break;§			} //switch§		} //for§	} //if§} //End GetStyleFontShortForm§§//Get font style value§UINT CPPHtmlDrawer::GetStyleImageShortForm(CPPString & str)§{§	UINT uStyle = 0; //Original image§	§	if (!str.IsEmpty())§	{§		for (int i = 0; i < str.GetLength(); i++)§		{§			switch (str.GetAt(i))§			{§			case _T('d'):§				uStyle |= IMAGE_EFFECT_DARKEN;§				break;§			case _T('g'):§				uStyle |= IMAGE_EFFECT_GRAYEN;§				break;§			case _T('s'):§				if (m_szOffsetShadow.cx || m_szOffsetShadow.cy)§				{§					if (m_bGradientShadow)§						uStyle |= IMAGE_EFFECT_GRADIENT_SHADOW;§					else uStyle |= IMAGE_EFFECT_MONO_SHADOW;§				} //if§				break;§			case _T('l'):§				uStyle |= IMAGE_EFFECT_LIGHTEN;§				break;§			} //switch§		} //for§	} //if§	§	return uStyle;§} //End GetStyleImageShortForm§§BOOL CPPHtmlDrawer::IsPercentableValue(CPPString & str)§{§	if (!str.IsEmpty())§	{§		if (str.GetAt(str.GetLength() - 1) == _T('%'))§			return TRUE;§	}§	return FALSE;§}§§int CPPHtmlDrawer::GetStyleBkgndEffect(CPPString & str, int nDefault)§{§	if (!str.IsEmpty())§	{§		if (str == _T("transparent"))§			nDefault = -1;§		else if (str == _T("solid"))§			nDefault = CPPDrawManager::EFFECT_SOLID;§		else if (str == _T("hgradient"))§			nDefault = CPPDrawManager::EFFECT_HGRADIENT;§		else if (str == _T("vgradient"))§			nDefault = CPPDrawManager::EFFECT_VGRADIENT;§		else if (str == _T("hcgradient"))§			nDefault = CPPDrawManager::EFFECT_HCGRADIENT;§		else if (str == _T("vcgradient"))§			nDefault = CPPDrawManager::EFFECT_VCGRADIENT;§		else if (str == _T("3hgradient"))§			nDefault = CPPDrawManager::EFFECT_3HGRADIENT;§		else if (str == _T("3vgradient"))§			nDefault = CPPDrawManager::EFFECT_3VGRADIENT;§#ifdef USE_SHADE§		else if (str == _T("noise"))§			nDefault = CPPDrawManager::EFFECT_NOISE;§		else if (str == _T("diagshade"))§			nDefault = CPPDrawManager::EFFECT_DIAGSHADE;§		else if (str == _T("hshade"))§			nDefault = CPPDrawManager::EFFECT_HSHADE;§		else if (str == _T("vshade"))§			nDefault = CPPDrawManager::EFFECT_VSHADE;§		else if (str == _T("hbump"))§			nDefault = CPPDrawManager::EFFECT_HBUMP;§		else if (str == _T("vbump"))§			nDefault = CPPDrawManager::EFFECT_VBUMP;§		else if (str == _T("softbump"))§			nDefault = CPPDrawManager::EFFECT_SOFTBUMP;§		else if (str == _T("hardbump"))§			nDefault = CPPDrawManager::EFFECT_HARDBUMP;§		else if (str == _T("metal"))§			nDefault = CPPDrawManager::EFFECT_METAL;§#endif§		else nDefault = GetLengthUnit(str, nDefault);§	} //if§§	return nDefault;§} //End GetStyleBkgndEffect§§int CPPHtmlDrawer::GetTableWidth(CPPString & str, int nClientWidth, int nMinWidth, BOOL bSet /* = FALSE */)§{§	if (!str.IsEmpty())§	{§		int i = 0;§		CPPString strProperty;§		CPPString strParameter;§		§		while (i < str.GetLength())§		{§			strProperty = SearchPropertyOfTag(str, i);§			strParameter = GetParameterString(str, i, _T('='), _T(" "));§			strProperty.MakeLower();§			§			if (strProperty == _T("width"))§			{§				if (IsPercentableValue(strParameter))§				{§					int nWidth = GetLengthUnit(strParameter, 100);§					if (bSet)§					{§						if (nWidth <= 100)§							nClientWidth = ::MulDiv(nMinWidth, 100, nWidth);§						else§							nClientWidth = ::MulDiv(nMinWidth, nWidth, 100);§					}§					else§					{§						if (nWidth < 100)§							nClientWidth = ::MulDiv(nClientWidth, nWidth, 100);§					} //if§				}§				else§				{§					nClientWidth = GetLengthUnit(strParameter, nMinWidth);§				} //if§				break;§			} //if§		} //while§	} //if§§	if (nClientWidth < nMinWidth)§		nClientWidth = nMinWidth;§§	return nClientWidth;§} //End GetTableWidth§§void CPPHtmlDrawer::DrawBackgroundImage(HDC hDC, int nDestX, int nDestY, int nWidth, int nHeight, CPPString strNameImage)§{§	if (!m_bIsEnable)§		return;§	if (strNameImage.IsEmpty())§		return;§	if (strNameImage.GetLength() < 6)§		return;§§	HBITMAP hBitmap = NULL;§§	int nIndex = 0;§	if (GetIndexNextAlphaNum(strNameImage, nIndex))§	{§		int nBegin = nIndex;§		//Searching end of the style name§		TCHAR chSymbol = GetIndexNextChars(strNameImage, nIndex, _T(" :"));§		if (0 != chSymbol)§		{§			//Gets a property's name§			CPPString strName = strNameImage.Mid(nBegin, nIndex - nBegin);§			//Gets a property's value§			CPPString strParameter = GetParameterString(strNameImage, nIndex, _T(':'));§			§			if (strName == _T("idres"))§			{§				UINT nID = (UINT)GetLengthUnit(strParameter, 0);§				hBitmap = GetBitmapFromResources(nID);§			}§			else if (strName == _T("iddll"))§			{§				UINT nID = (UINT)GetLengthUnit(strParameter, 0);§				hBitmap = GetBitmapFromDll(nID);§			}§			else if (strName == _T("file"))§			{§				hBitmap = GetBitmapFromFile(strParameter);§			} //if§		} //if§	} //if§§	if (NULL == hBitmap)§		return;§§	SIZE sz;§	m_drawmanager.GetSizeOfBitmap(hBitmap, &sz);§	HDC hSrcDC = ::CreateCompatibleDC(hDC);§	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hSrcDC, hBitmap);§	m_drawmanager.MultipleCopy(hDC, nDestX, nDestY, nWidth, nHeight, hSrcDC, 0, 0, sz.cx, sz.cy);§	::SelectObject(hSrcDC, hOldBitmap);§	::DeleteDC(hSrcDC);§§	::DeleteObject(hBitmap);§	hBitmap = NULL;§} //End of DrawBackgroundImage§§////////////////////////////////////////////////////////////////////§// CPPHtmlDrawer::SetTooltipShadow()§//		Sets a image's shadow.§//------------------------------------------------------------------§// Parameters:§//		nOffsetX, §//		nOffsetY		- The offsets of the tooltip's shadow from the tooltip's window.§//		nDarkenPercent	- So far as colors under the shadow will be darken (0 - 100)§//      bGradient		- TRUE to use a gradient shadow.§//		nDepthX,§//		nDepthY			- The gradient depths of the tooltip's shadow.§////////////////////////////////////////////////////////////////////§void CPPHtmlDrawer::SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent /* = 50 */, §								  BOOL bGradient /* = TRUE */, int nDepthX /* = 7 */, int nDepthY /* = 7 */)§{§	m_szOffsetShadow.cx = nOffsetX;§	m_szOffsetShadow.cy = nOffsetY;§	m_szDepthShadow.cx = nDepthX;§	m_szDepthShadow.cy = nDepthY;§	m_nDarkenShadow = std::min(100, (int)nDarkenPercent);§	m_bGradientShadow = bGradient;§	BYTE nColor = ::MulDiv(255, 100 - m_nDarkenShadow, 100);§	m_crShadow = RGB(nColor, nColor, nColor);§} //End of SetTooltipShadow§§CPPString CPPHtmlDrawer::GetWordWrap(CPPString & str, int nMaxSize, int & nRealSize)§{§	int nCurIndex = 0;§	int nLastIndex = 0;§	SIZE sz = {0, 0};§	TCHAR tch = _T(' ');§	CPPString sResult = _T("");§	while ((sz.cx <= nRealSize) && (0 != tch))§	{§		nLastIndex = nCurIndex;§		nCurIndex ++;§		tch = GetIndexNextChars(str, nCurIndex, PPHTMLDRAWER_BREAK_CHARS);§		::GetTextExtentPoint32(m_hDC, str, nCurIndex, &sz);§	} //while§§	if (0 == nLastIndex)§	{§		if (nMaxSize == nRealSize)§		{§			//RUS: –‡Á˚‚Ó‚ ‚ ÒÚÓÍÂ ÌÂ Ó·Ì‡ÛÊÂÌÓ, ÔÓ˝ÚÓÏÛ ·Û‰ÂÏ ‡Á·Ë‚‡Ú¸ ÒÚÓÍÛ §			//     ÔÓ ÒËÏ‚ÓÎ‡Ï, ‡ ÌÂ ÔÓ ÒÎÓ‚‡Ï§			sz.cx = 0;§			int i = 1;§			for (; i < str.GetLength(); i++)§			{§				::GetTextExtentPoint32(m_hDC, str, i + 1, &sz);§				if (sz.cx > nRealSize)§				{§					sResult = str.Left(i);§					str = str.Mid(i);§					::GetTextExtentPoint32(m_hDC, sResult, i, &sz);§					nRealSize = sz.cx;§					return sResult;§				} //if§			} //for§			::GetTextExtentPoint32(m_hDC, str, i, &sz);§			//RUS: ÕÂ‚ÓÁÏÓÊÌÓ ‡Á·ËÚ¸ ÒÚÓÍÛ, ‚˚‚Ó‰ËÏ ˆÂÎËÍÓÏ§			sResult = str;§			str.Empty();§		}§		else§		{§			//RUS: ¬ ÓÚÒÚ‡‚¯ÂÂÒˇ ÏÂÒÚÓ ÚÂÍÛ˘ÂÈ ÒÚÓÍË ÌÂ ‚Î‡ÁËÚ ÌË Ó‰ÌÓ„Ó ÒÎÓ‚‡§			sz.cx = 0;§		} //if§	}§	else §	{§		sResult = str.Left(nLastIndex + 1);§		str = str.Mid(nLastIndex + 1);§		sResult.TrimRight();§		::GetTextExtentPoint32(m_hDC, sResult, sResult.GetLength(), &sz);§//		str.TrimRight();§		str.TrimLeft();§	} //if§	nRealSize = sz.cx;§	return sResult;§} //End of GetWordWrap§§int CPPHtmlDrawer::GetCountOfChars(CPPString str, TCHAR tchar /*= _T(' ')*/)§{§	int nCount = 0;§	//ENG:§	//RUS:§	for (int i = 0; i < str.GetLength(); i++)§	{§		if (tchar == str.GetAt(i))§			nCount++;§	} //if§	return nCount;§}§//#UC END# *4700B81F006D*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B81F006D_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B81F006D_DESTR_BODY*§	SetResourceDll(NULL);§§	if (NULL != m_hLinkCursor)§	{§		::DestroyCursor(m_hLinkCursor);§		m_hLinkCursor = NULL;§	}§	§	if (NULL != m_hImageList)§		::DeleteObject(m_hImageList);§	//#UC END# *4700B81F006D_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B81F006D_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B81F006D_CUSTOM_INCLUDES*§#include "shared/WinGUI/Controls/CPPDrawManager.h"§#include <vector>§#include <map>§§#ifdef _MFC_VER§	#define CPPString	CString //MFC program§#endif§//#UC END# *4700B81F006D_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B81F006D*"
		    value      	(value Text 
|//#UC START# *4700B81F006D*§public:§	CPPHtmlDrawer();§§// Attributes§public:§§// Operations§public:§	//Drawing methods§	void  Draw(HDC hDC, LPCTSTR lpszHtml, LPPOINT lpPoint);§	void  PrepareOutput(HDC hDC, LPCTSTR lpszHtml, LPSIZE lpSize); //Prepares to draw the HTML string§	void  DrawPreparedOutput(HDC hDC, LPCRECT lpRect);§§	void  EnableEscapeSequences(BOOL bEnable = TRUE);§	void  EnableOutput(BOOL bEnable = TRUE);§	void  SetDisabledColor(COLORREF color);§	§	//Shadow of the image§	void SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent = 50, BOOL bGradient = TRUE, int nDepthX = 7, int nDepthY = 7);§§	CPPString GetResCommandPrompt(UINT nID, UINT nNumParam = 0);§§	//Functions for the styles§	void SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue);§	void SetCssStyles(LPCTSTR lpszCssString = NULL); //Sets the CSS styles§	void SetCssStyles(DWORD dwIdCssString, LPCTSTR lpszPathDll = NULL); //Sets the CSS styles§	LPCTSTR GetCssStyles(); //Returns the current CSS styles§§	void OnLButtonDown(LPPOINT lpClient);§	BOOL OnSetCursor(LPPOINT lpClient);§	BOOL OnTimer(); //New timer count§§	void SetHyperlinkCursor(HCURSOR hCursor = NULL); //Sets the cursor to be displayed when moving the mouse over a link. Specifying NULL will cause the control to display its default 'hand' cursor.§	HCURSOR GetHyperlinkCursor() const; //Returns the current link cursor.§§	void SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam = 0); //Sets the callback message: "Mouse over the link".§	void SetCallbackRepaint(HWND hWnd, UINT nMessage, LPARAM lParam = 0); //Sets the callback message: "Please repaint me".§§	//Functions for images§	void SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));§	void SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));§§	void LoadResourceDll(LPCTSTR lpszPathDll, DWORD dwFlags = 0); //Sets the path to the resource's DLL§	void SetResourceDll(HINSTANCE hInstDll = NULL); //Sets the handle of the loaded resource's DLL§§	void SetMaxWidth(int nWidth = 0) {m_nMaxWidth = nWidth;}; //Sets the maximum width of the output window.§	int  GetMaxWidth() {return m_nMaxWidth;}; //Gets the maximum width of the output window.§//	void EnableTextWrap(BOOL bEnable = TRUE){§//		m_bIsTextWrapEnabled = bEnable;};§//	BOOL IsTextWrapEnabled() {return m_bIsTextWrapEnabled;};§§	void SetTabSize(int nSize) {m_nTabSize = nSize;};§§	CPPDrawManager * GetDrawManager();§§	static short GetVersionI()		{return 0x13;}§	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("1.3 beta");}§	§// Implementation§protected:§	enum{	ALIGN_LEFT = 0,§			ALIGN_CENTER,§			ALIGN_RIGHT,§			ALIGN_JUSTIFY§		};§	§	enum{	ALIGN_TOP = 0,§			ALIGN_VCENTER,§			ALIGN_BOTTOM,§			ALIGN_BASELINE§		};§§	enum{	LINK_NONE = 0,§			LINK_HREF,§			LINK_MESSAGE§		};§§	enum{	TEXT_TRANSFORM_NONE = 0,§			TEXT_TRANSFORM_UPPERCASE,§			TEXT_TRANSFORM_LOWERCASE,§			TEXT_TRANSFORM_CAPITALIZE§		};§§	enum{	BORDER_STYLE_NONE = 0,§			BORDER_STYLE_SOLID,§			BORDER_STYLE_DOTTED,§			BORDER_STYLE_DASHED,§			BORDER_STYLE_DOUBLE,§		};§§	enum {	TAG_NONE = 0,§			TAG_BOLD,§			TAG_ITALIC,§			TAG_UNDERLINE,§			TAG_STRIKEOUT,§			TAG_FONT,§			TAG_HLINE,§			TAG_NEWLINE,§			TAG_TABULATION,§			TAG_LEFT,§			TAG_CENTER,§			TAG_RIGHT,§			TAG_JUSTIFY,§			TAG_BASELINE,§			TAG_TOP,§			TAG_VCENTER,§			TAG_BOTTOM,§			TAG_BITMAP,§			TAG_ICON,§			TAG_IMAGELIST,§			TAG_STRING,§			TAG_NEWSTYLE,§			TAG_SPAN,§			TAG_HYPERLINK§		};§§#pragma pack(1)§	typedef struct _STRUCT_TAGPROP§	{§		DWORD dwTagIndex;	// The hot rect of the hyperlink§		CPPString strTagName;	// The type of the hyperlink§	} STRUCT_TAGPROP;§#pragma pack()§§#pragma pack(1)§	typedef struct _STRUCT_ANIMATION§	{§		int nIndex;		//The current index of the image§		int nMaxImages; //The max images in the bitmap§		int nTimerCount;//The current time position§		int nSpeed;		//The speed of animation§	} STRUCT_ANIMATION;§#pragma pack()§§#pragma pack(1)§	typedef struct _STRUCT_HYPERLINK§	{§		RECT rcArea;		// The hot rect of the hyperlink§		int nTypeLink;		// The type of the hyperlink§		int nIndexLink;		// The index of the hyperlink§		CPPString sHyperlink; // The hyperlink§	} STRUCT_HYPERLINK;§#pragma pack()§	§#pragma pack(1)§	typedef struct _STRUCT_CHANGESTYLE §	{§		CPPString strTag;		//The name of the last opened tag§		§		//Font§		int  nSizeFont;		//The height of the logic font§		int	 nWeightFont;	//The weight of the logic font§		BOOL bItalicFont;	//Is italic logic font?§		BOOL bUnderlineFont;//Is underline logic font?§		BOOL bStrikeOutFont;//Is strikeout logic font?§		BOOL bOverlineFont; //Is overline logic font?§		CPPString sFaceFont;  //The face name of the logic font§		§		//Color		§		COLORREF crText;	//The foreground color §		COLORREF crBkgnd;	//The background color (also begin for the gradient)§		COLORREF crBorderLight;	//The border color§		COLORREF crBorderDark;	//The border color§		COLORREF crMidBkgnd;//The middle background color§		COLORREF crEndBkgnd;//The end background color§§		//Fill§		int  nBkMode;		//The background mode for the text (TRANSPARENT, OPAQUE)§		int  nFillBkgnd;	//The fill effect of the background§		CPPString strNameResBk;§§		//Align§		int  nHorzAlign;	//The horizontal align§		int  nVertAlign;	//The vertical align§		§		//Border§		int  nBorderStyle;	//The border style§		int  nBorderWidth;	//The width of the border§§		//Cell Sizes§		int nCellWidth;		//The width of the cell§		int nCellHeight;	//The height of the cell§		BOOL bCellWidthPercent; //The width value in the percent§		BOOL bCellHeightPercent; //The height value in the percent§§		//Text§		int  nTextTransform;//Transformation of the text (NONE, UPPERCASE, LOWERCASE, CAPITALIZE)§§		int nMargin;		//Margins§		§		int nPadding;		//Padding§		§		//Hyperlink§		int  nTypeLink;		//The type of the link (NONE, HREF, MESSAGE)§		CPPString sHyperlink; //The additional parameter for the link§	} STRUCT_CHANGESTYLE; §#pragma pack()§	§#pragma pack(1)§	typedef struct _STRUCT_IMAGE§	{§		int			nIndexImageList;//image's index of the image list§		int			nIdRes;			//ID resource from app§		int			nIdDll;			//ID resource from dll§		int			nHandle;		//handle of the resource§		int			cx;				//horizontal size of image§		int			cy;				//vertical size of image§		int			nWidth;			//width of image§		int			nHeight;		//height of image§		int         nSpeed;			//speed for animation§		UINT		nStyles;		//styles of image§		UINT		nHotStyles;		//hot styles of image§		BOOL        bUseMask;		//§		BOOL		bPercentWidth;§		BOOL		bPercentHeight;§		COLORREF	crMask;			//color of mask§		CPPString	strSrcFile;		//path on the source file§		CPPString   strPathDll;		//path on the resource dll§	} STRUCT_IMAGE;§#pragma pack()§	§#pragma pack(1)§	typedef struct _STRUCT_CALLBACK§	{§		HWND		hWnd;			/* ƒÂÒÍËÔÚÓ ÓÍÌ‡, ÔËÌËÏ‡˛˘Â„Ó ÒÓÓ·˘ÂÌËÂ */§		UINT		nMessage;		// Message identifier§		WPARAM		wParam;§		LPARAM		lParam;§	} STRUCT_CALLBACK;§#pragma pack()§§#pragma pack(1)§	typedef struct _STRUCT_HTMLLINE§	{§		int  nWidthLine;§		int  nHeightLine;§		int  nDescentLine;§		int  nAddPercentWidth;§		int  nHorzAlign;§		int  nSpaceChars;	//a count of space chars in the line§		BOOL bWrappedLine;	//TRUE if text was wrapped in the current line§	} STRUCT_HTMLLINE;§#pragma pack()§§#pragma pack(1)§	typedef struct _STRUCT_CELL§	{§		int   nColSpan;			//-1 = Cell isn't used, >0 - How much columns was spaned§		int   nRowSpan;			//-1 = Cell isn't used, >0 - How much rows was spaned§		SIZE  szText;			//Real size of the text's area§		SIZE  szCell;			//Real size of the cell§		BOOL  bFixedWidth;		//TRUE if width of this cell was fixed§//		vecHtmlLine vecLines;§//		int   nWidth;			//Width of the cell§//		int   nHeight;			//Height of the cell§//		BOOL  bWidthPercent;	//if TRUE nWidth member in a percents§//		BOOL  bHeightPercent;	//if TRUE nHeight member in a percents§	} STRUCT_CELL;§#pragma pack()§§	//Cells of Table§	typedef std::vector<STRUCT_CELL> vecRow;	//Alone row§	typedef std::vector<vecRow> vecTable;		//Vector of the rows is a table§	typedef std::vector<int> vecSize;			//Width of the columns or height of the rows§	typedef std::vector<BOOL> vecFlag;			//Flags for fixed widthes of the columns§§#pragma pack(1)§	typedef struct _STRUCT_TABLE§	{§		vecTable  cells;	//Info about each cell of the table§		vecSize   width;	//Dimensions of the width of the columns§		vecSize	  height;	//Dimensions of the height of the rows§		vecFlag   fixed_width; //§	} STRUCT_TABLE;§#pragma pack()§§	typedef std::vector<STRUCT_TABLE> vecTables;§	vecTables m_arrTables;	//All tables§	int   m_nCurTable;	  //The current index of the table§	int   m_nCurTableRow; //The current row of the table§§	STRUCT_CALLBACK	m_csCallbackRepaint; //Callback for repaint HTML drawer§	STRUCT_CALLBACK	m_csCallbackLink; //Callback for hyperlink message§	STRUCT_CHANGESTYLE m_defStyle;§	STRUCT_HTMLLINE m_hline;§§	CPPDrawManager m_drawmanager;§	§	//Values of the system context§	HIMAGELIST m_hImageList;§	SIZE m_szImageList;§§	HINSTANCE m_hInstDll;§	BOOL m_bFreeInstDll;§§	HCURSOR m_hLinkCursor;§	HFONT m_hOldFont;§	int m_nOldBkMode;§	COLORREF m_crOldText;§	COLORREF m_crOldBk;§§//	BOOL m_bIsTextWrapEnabled;		//Is text wrap enabled§	BOOL m_bIsEnable; //TRUE for fullcolor output, FALSE for disabled output§	COLORREF m_crDisabled;§//	SIZE m_szOutput; // Output size§	RECT m_rcOutput; //Output rectangle§//	POINT m_ptOutput; //Output coordinates§	HDC m_hDC; //Device context to output or to prepare§	CPPString m_csHtmlText; //String to output§§//	COLORREF m_clrShadow;§§	int	  m_nNumPass;	//The number or type of the pass§§	int   m_nTabSize;	// The max size for the each tabulation§	int   m_nMaxWidth;	// The max width for wrapping output§	int   m_nCurLine;   // The current drawing line§	int   m_nNumCurTable; //The number of the current table§//	RECT  m_rect; //§//	int m_nLineHeight; //The height of the current line§//	int m_nLineDescent;§	int m_nHoverIndexLink; //The index of the link under the mouse§	int m_nCurIndexLink;§	int m_nCurIndexAni; //The index of the animation§	BOOL m_bLastValueIsPercent;§	BOOL m_bEnableEscapeSequences; // §§	//Shadow of the image§	BOOL m_bGradientShadow;§	SIZE m_szOffsetShadow;§	SIZE m_szDepthShadow;§	BYTE m_nDarkenShadow;§	COLORREF m_crShadow;§§	TEXTMETRIC m_tm;§§	LOGFONT m_lfDefault; //Default font§	HFONT m_hFont;§§	//Wrapper string§	CPPString m_strPrefix; //Prefix string §	CPPString m_strPostfix; //Postfix string§	CPPString m_strCssStyles;§§	//Vectors§	typedef std::vector<STRUCT_HTMLLINE> vecHtmlLine;§	vecHtmlLine m_arrHtmlLine;§§	//Vector of the stack§	typedef std::vector<STRUCT_CHANGESTYLE> arrStack;§	arrStack m_arrStack;§§	//Vector of the hyperlinks§	typedef std::vector<STRUCT_HYPERLINK> arrLink;§	arrLink m_arrLinks;§§	typedef std::vector<STRUCT_ANIMATION> arrAni;§	arrAni m_arrAni;§§	//Map of the colors by name§	typedef std::map<CPPString, COLORREF> mapColors;§	typedef std::map<CPPString, COLORREF>::iterator iterMapColors;§	mapColors m_mapColors;§§	//Map of the styles§	typedef std::map<CPPString, CPPString> mapStyles;§	typedef std::map<CPPString, CPPString>::iterator iter_mapStyles;§	mapStyles m_mapStyles;§	mapStyles m_mapSpecChars;§§	//Map of the colors by name§	typedef std::map<CPPString, STRUCT_TAGPROP> mapTags;§	typedef mapTags::iterator iterMapTags;§	mapTags m_mapTags;§//	mapTags m_mapTableProp;§§protected:§	void SetListOfTags(); //Fill a map of tags§	void AddTagToList(LPCTSTR lpszName, DWORD dwTagIndex, LPCTSTR lpszFullName); //Add tag to the list of tags§	DWORD GetTagFromList(CPPString sTagName, CPPString & strFullName, BOOL & bCloseTag); //Get tag from the list§§	void SetListSpecChars();§	void AddSpecChar(LPCTSTR lpszAlias, TCHAR tch);§	void AddSpecChar(LPCTSTR lpszAlias, LPCTSTR lpszValue);§	void ReplaceSpecChars();§§	//The resource's methods§	HICON GetIconFromResources(DWORD dwID, int nWidth = 0, int nHeight = 0) const; //Load an icon from the app resources§	HICON GetIconFromFile(LPCTSTR lpszPath, int nWidth = 0, int nHeight = 0) const; //Load an icon from the file§	HICON GetIconFromDll(DWORD dwID, int nWidth = 0, int nHeight = 0, LPCTSTR lpszPathDll = NULL) const; //Load an icon from the dll resources§	HBITMAP GetBitmapFromResources(DWORD dwID) const; //Load a bitmap from the app resources§	HBITMAP GetBitmapFromFile(LPCTSTR lpszPath) const; //Load a bitmap from the file§	HBITMAP GetBitmapFromDll(DWORD dwID, LPCTSTR lpszPathDll = NULL) const; //Load a bitmap from the dll resources§	CPPString GetStringFromResource(DWORD dwID) const; //Load a string from the app resources§	CPPString GetStringFromDll(DWORD dwID, LPCTSTR lpszPathDll = NULL) const; //Load a string from the dll resources§§	//The drawing methods§	void DrawHtml(LPSIZE lpSize, LPCRECT lpRect); //Draws the HTML text on device context or gets the size of the output area.§	SIZE DrawHtmlTable(CPPString & sTable, LPCRECT lpRect); //Draws the HTML table on device context or gets the size of the output area.§//	SIZE DrawHtmlTableRow(CPPString & sRow, LPCRECT lpRect, vecCol & row); //Draws the HTML row of the table§	void DrawHtmlTableRow(CPPString & sRow, LPCRECT lpRect, STRUCT_TABLE & st, int nRow);§	void DrawHtmlTableCell(CPPString & sCell, LPCRECT lpRect, STRUCT_CELL & sc); //Draws the HTML cell of the table§	SIZE DrawHtmlString(CPPString & sHtml, LPCRECT lpRect); //Draws the HTML string on device context or gets the size of the output area.§§//public:§	//The methods§	void SetDefaultCssStyles();§	void SetDefaultCursor();§	LPLOGFONT GetSystemToolTipFont() const; //Gets the system logfont§§	CPPString SearchNextTag(CPPString & str, CPPString & strTag, int & nIndex); //Search next tag§	BOOL SearchTag(CPPString & str, int & nIndex, CPPString strTag); //Search begin of the specified tag§§	CPPString GetTagBody(CPPString & str, int & nIndex); //Gets a name of tag and the parameters of tag§	CPPString SplitTag(CPPString & sTag); //Split a tag to the tag's name and parameters§	CPPString GetNextProperty(CPPString & str, int & nIndex, CPPString & sProp); //Gets next property§§§	CPPString SearchPropertyOfTag(CPPString & str, int & nIndex); //Search a name or a property of a tag§	SIZE  AnalyseCellParam(CPPString & sTag, _STRUCT_CHANGESTYLE & cs, BOOL bTable);§	void  AnalyseImageParam(CPPString & strTag, _STRUCT_IMAGE & si);§	BOOL  IsImageWithShadow(_STRUCT_IMAGE & si);§§	//Functions for hyperlink§	int PtInHyperlink(LPPOINT lpPoint);§	void JumpToHyperlink(int nLink);§	void StoreHyperlinkArea(int left, int top, int right, int bottom);§	HINSTANCE GotoURL(LPCTSTR url, int showcmd = SW_SHOW);§	LONG GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata);§§	//Functions for notify§	void CallbackOnClickHyperlink(LPCTSTR sLink);§	void CallbackOnRepaint(int nIndexLink);§§	//Running tag§	int  VerticalAlignText(int y, int nHeight);§	int  VerticalAlignImage(int y, int nHeight);§	void UpdateContext();§	BOOL StoreRestoreStyle(BOOL bRestore);§	void Tag_NewLine(LPPOINT lpPoint, int nNum, LPSIZE lpSize);§	void Tag_Tabulation(LPPOINT lpPoint, int nNum);§	int  InitNewLine(int x);§§	void SelectNewHtmlStyle(LPCTSTR lpszNameStyle, STRUCT_CHANGESTYLE & cs);§§	SIZE  GetTableDimensions(CPPString & sTable); //Gets dimensions of the table§	void  SearchEndOfTable(CPPString & str, int & nIndex); //Searching end of the table§	void  SearchEndOfRow(CPPString & str, int & nIndex); //Searching end of the row§	void  SearchEndOfCell(CPPString & str, int & nIndex); //Searching end of the cell§§	//Functions for the map of the styles§	void SetTableOfColors();§	void SetColorName(LPCTSTR lpszColorName, COLORREF color);§	COLORREF GetColorByName(LPCTSTR lpszColorName, COLORREF crDefColor = RGB(0, 0, 0));§§	BOOL GetIndexNextAlphaNum(CPPString & str, int & nIndex, BOOL bArithmetic = FALSE);§	BOOL GetBeginParameter(CPPString & str, int & nIndex, TCHAR chSeparator = _T(':'));§	TCHAR GetIndexNextChars(CPPString & str, int & nIndex, CPPString strChars);§	TCHAR GetIndexNextNoChars(CPPString & str, int & nIndex, CPPString strChars);§	CPPString GetParameterString(CPPString & str, int & nIndex, TCHAR chBeginParam = _T(':'), CPPString strSeparators = _T(";"));§	CPPString GetNameOfTag(CPPString & str, int & nIndex);§	CPPString GetWordWrap(CPPString & str, int nMaxSize, int & nRealSize);§§	//Functions for the map of the styles§	LPCTSTR GetTextStyle(LPCTSTR lpszStyleName);§	void RemoveTextStyle(LPCTSTR lpszStyleName);§	void AddToTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszAddStyle);§	void UnpackTextStyle(CPPString strStyle, _STRUCT_CHANGESTYLE & cs);§§	//Functions for analyzing parameters§	void SetDefaultStyles(_STRUCT_CHANGESTYLE & cs);§	BOOL GetStyleFontStyle(CPPString & str, BOOL bDefault);§	int  GetStyleFontWeight(CPPString & str, int nDefault);§	int  GetStyleHorzAlign(CPPString & str, int nDefault);§	int  GetStyleVertAlign(CPPString & str, int nDefault);§	COLORREF GetStyleColor(CPPString & str, COLORREF crDefault);§	int  GetStyleTextTransform(CPPString & str, int nDefault);§	CPPString GetStyleString(CPPString str, CPPString strDefault);§	void GetStyleFontShortForm(CPPString & str);§	UINT GetStyleImageShortForm(CPPString & str);§	int GetStyleBkgndEffect(CPPString & str, int nDefault);§	§	void StyleTextDecoration(CPPString & str, _STRUCT_CHANGESTYLE & cs);§	int StyleBorderWidth(CPPString & str, int Default);§	int StyleBorder(CPPString & str, int nDefault);§§	//Get§	int GetLengthUnit(CPPString & str, int nDefault, BOOL bFont = FALSE);§	BOOL IsPercentableValue(CPPString & str);§	int GetTableWidth(CPPString & str, int nClientWidth, int nMinWidth, BOOL bSet = FALSE);§§	//Drawing§	void DrawBackgroundImage(HDC hDC, int nDestX, int nDestY, int nWidth, int nHeight, CPPString strNameImage);§§	int GetCountOfChars(CPPString str, TCHAR tchar = _T(' ')); //Gets counts of chars§//#UC END# *4700B81F006D*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPHtmlDrawer|4700B81F006D
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659777444"))
	    quid       	"4700B81F006D"
	    documentation 	"ÍÎ‡ÒÒ ‰Îˇ ÓÚËÒÓ‚ÍË html'ˇ"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator")
	(object Class "CPPDrawManager"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CPPDrawManager.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CPPDrawManager.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8C80280_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4700B8C80280_CUSTOM_INCLUDES*§#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))§//#UC END# *4700B8C80280_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8C80280*"
		    value      	(value Text 
|//#UC START# *4700B8C80280*§CPPDrawManager::CPPDrawManager()§{§§}§§void CPPDrawManager::GetSizeOfIcon(HICON hIcon, LPSIZE pSize) const§{§	pSize->cx = 0;§	pSize->cy = 0;§	if (hIcon != NULL)§	{§		ICONINFO ii;§		// Gets icon dimension§		::ZeroMemory(&ii, sizeof(ICONINFO));§		if (::GetIconInfo(hIcon, &ii))§		{§			pSize->cx = (DWORD)(ii.xHotspot * 2);§			pSize->cy = (DWORD)(ii.yHotspot * 2);§			//release icon mask bitmaps§			if(ii.hbmMask)§				::DeleteObject(ii.hbmMask);§			if(ii.hbmColor)§				::DeleteObject(ii.hbmColor);§		} //if§	} //if§} //End GetSizeOfIcon§§void CPPDrawManager::GetSizeOfBitmap(HBITMAP hBitmap, LPSIZE pSize) const§{§	pSize->cx = 0;§	pSize->cy = 0;§	if (hBitmap != NULL)§	{§		BITMAP	csBitmapSize;§		// Get bitmap size§		int nRetValue = ::GetObject(hBitmap, sizeof(csBitmapSize), &csBitmapSize);§		if (nRetValue)§		{§			pSize->cx = (DWORD)csBitmapSize.bmWidth;§			pSize->cy = (DWORD)csBitmapSize.bmHeight;§		} //if§	} //if§} //End GetSizeOfBitmap§§void CPPDrawManager::AlphaBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY, int percent /* = 100 */)§{§	_ASSERT ((NULL != hDestDC) || (NULL != hSrcDC));§§	if (percent >= 100)§	{§		::BitBlt(hDestDC, nDestX, nDestY, dwWidth, dwHeight, hSrcDC, nSrcX, nSrcY, SRCCOPY);§		return;§	} //if§§	HDC hTempDC = ::CreateCompatibleDC(hDestDC);§	if (NULL == hTempDC)§		return;§	§	//Creates Source DIB§	LPBITMAPINFO lpbiSrc;§	// Fill in the BITMAPINFOHEADER§	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§	lpbiSrc->bmiHeader.biWidth = dwWidth;§	lpbiSrc->bmiHeader.biHeight = dwHeight;§	lpbiSrc->bmiHeader.biPlanes = 1;§	lpbiSrc->bmiHeader.biBitCount = 32;§	lpbiSrc->bmiHeader.biCompression = BI_RGB;§	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;§	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biClrUsed = 0;§	lpbiSrc->bmiHeader.biClrImportant = 0;§	§	COLORREF* pSrcBits = NULL;§	HBITMAP hSrcDib = CreateDIBSection (§		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,§		NULL, NULL);§	§	if ((NULL != hSrcDib) && (NULL != pSrcBits))§	{§		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hSrcDib);§		::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hSrcDC, nSrcX, nSrcY, SRCCOPY);§		::SelectObject (hTempDC, hOldTempBmp);§		§		//Creates Destination DIB§		LPBITMAPINFO lpbiDest;§		// Fill in the BITMAPINFOHEADER§		lpbiDest = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§		lpbiDest->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§		lpbiDest->bmiHeader.biWidth = dwWidth;§		lpbiDest->bmiHeader.biHeight = dwHeight;§		lpbiDest->bmiHeader.biPlanes = 1;§		lpbiDest->bmiHeader.biBitCount = 32;§		lpbiDest->bmiHeader.biCompression = BI_RGB;§		lpbiDest->bmiHeader.biSizeImage = dwWidth * dwHeight;§		lpbiDest->bmiHeader.biXPelsPerMeter = 0;§		lpbiDest->bmiHeader.biYPelsPerMeter = 0;§		lpbiDest->bmiHeader.biClrUsed = 0;§		lpbiDest->bmiHeader.biClrImportant = 0;§		§		COLORREF* pDestBits = NULL;§		HBITMAP hDestDib = CreateDIBSection (§			hDestDC, lpbiDest, DIB_RGB_COLORS, (void **)&pDestBits,§			NULL, NULL);§		§		if ((NULL != hDestDib) && (NULL != pDestBits))§		{§			::SelectObject (hTempDC, hDestDib);§			::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hDestDC, nDestX, nDestY, SRCCOPY);§			::SelectObject (hTempDC, hOldTempBmp);§§			double src_darken = (double)percent / 100.0;§			double dest_darken = 1.0 - src_darken;§			§			for (DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pSrcBits++, pDestBits++)§			{§				*pDestBits = PixelAlpha(*pSrcBits, src_darken, *pDestBits, dest_darken);§			} //for§			§			::SelectObject (hTempDC, hDestDib);§			::BitBlt (hDestDC, nDestX, nDestY, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);§			::SelectObject (hTempDC, hOldTempBmp);§§			delete lpbiDest;§			::DeleteObject(hDestDib);§		} //if§		delete lpbiSrc;§		::DeleteObject(hSrcDib);§	} //if§§	::DeleteDC(hTempDC);§} //End AlphaBitBlt§§void CPPDrawManager::AlphaChannelBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY)§{§	_ASSERT ((NULL != hDestDC) || (NULL != hSrcDC));§§	HDC hTempDC = ::CreateCompatibleDC(hDestDC);§	if (NULL == hTempDC)§		return;§	§	//Creates Source DIB§	LPBITMAPINFO lpbiSrc;§	// Fill in the BITMAPINFOHEADER§	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§	lpbiSrc->bmiHeader.biWidth = dwWidth;§	lpbiSrc->bmiHeader.biHeight = dwHeight;§	lpbiSrc->bmiHeader.biPlanes = 1;§	lpbiSrc->bmiHeader.biBitCount = 32;§	lpbiSrc->bmiHeader.biCompression = BI_RGB;§	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;§	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biClrUsed = 0;§	lpbiSrc->bmiHeader.biClrImportant = 0;§	§	COLORREF* pSrcBits = NULL;§	HBITMAP hSrcDib = CreateDIBSection (§		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,§		NULL, NULL);§	§	if ((NULL != hSrcDib) && (NULL != pSrcBits))§	{§		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hSrcDib);§		::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hSrcDC, nSrcX, nSrcY, SRCCOPY);§		::SelectObject (hTempDC, hOldTempBmp);§		§		//Creates Destination DIB§		LPBITMAPINFO lpbiDest;§		// Fill in the BITMAPINFOHEADER§		lpbiDest = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§		lpbiDest->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§		lpbiDest->bmiHeader.biWidth = dwWidth;§		lpbiDest->bmiHeader.biHeight = dwHeight;§		lpbiDest->bmiHeader.biPlanes = 1;§		lpbiDest->bmiHeader.biBitCount = 32;§		lpbiDest->bmiHeader.biCompression = BI_RGB;§		lpbiDest->bmiHeader.biSizeImage = dwWidth * dwHeight;§		lpbiDest->bmiHeader.biXPelsPerMeter = 0;§		lpbiDest->bmiHeader.biYPelsPerMeter = 0;§		lpbiDest->bmiHeader.biClrUsed = 0;§		lpbiDest->bmiHeader.biClrImportant = 0;§		§		COLORREF* pDestBits = NULL;§		HBITMAP hDestDib = CreateDIBSection (§			hDestDC, lpbiDest, DIB_RGB_COLORS, (void **)&pDestBits,§			NULL, NULL);§		§		if ((NULL != hDestDib) && (NULL != pDestBits))§		{§			::SelectObject (hTempDC, hDestDib);§			::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hDestDC, nDestX, nDestY, SRCCOPY);§			::SelectObject (hTempDC, hOldTempBmp);§§			double src_darken;§			BYTE nAlpha;§			§			for (DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pSrcBits++, pDestBits++)§			{§				nAlpha = LOBYTE(*pSrcBits >> 24);§				src_darken = (double)nAlpha / 255.0;§				*pDestBits = PixelAlpha(*pSrcBits, src_darken, *pDestBits, 1.0 - src_darken);§			} //for§			§			::SelectObject (hTempDC, hDestDib);§			::BitBlt (hDestDC, nDestX, nDestY, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);§			::SelectObject (hTempDC, hOldTempBmp);§§			delete lpbiDest;§			::DeleteObject(hDestDib);§		} //if§		delete lpbiSrc;§		::DeleteObject(hSrcDib);§	} //if§§	::DeleteDC(hTempDC);§} //End of AlphaChannelBitBlt§§HBITMAP CPPDrawManager::CreateImageEffect(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, DWORD dwEffect, BOOL bUseMask /* = TRUE */, COLORREF clrMask /* = RGB(255, 0, 255) */, COLORREF clrMono /* = RGB(255, 255, 255) */)§{§	HBITMAP hOldSrcBmp = NULL;§	HBITMAP hOldResBmp = NULL;  §	HDC hMainDC = NULL;§	HDC hSrcDC = NULL;§	HDC hResDC = NULL;§	§	hMainDC = ::GetDC(NULL);§	hSrcDC = ::CreateCompatibleDC(hMainDC);§	hResDC = ::CreateCompatibleDC(hMainDC);§§	hOldSrcBmp = (HBITMAP)::SelectObject(hSrcDC, hBitmap);§§	LPBITMAPINFO lpbi;§§	// Fill in the BITMAPINFOHEADER§	lpbi = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§	lpbi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§	lpbi->bmiHeader.biWidth = dwWidth;§	lpbi->bmiHeader.biHeight = dwHeight;§	lpbi->bmiHeader.biPlanes = 1;§	lpbi->bmiHeader.biBitCount = 32;§	lpbi->bmiHeader.biCompression = BI_RGB;§	lpbi->bmiHeader.biSizeImage = dwWidth * dwHeight;§	lpbi->bmiHeader.biXPelsPerMeter = 0;§	lpbi->bmiHeader.biYPelsPerMeter = 0;§	lpbi->bmiHeader.biClrUsed = 0;§	lpbi->bmiHeader.biClrImportant = 0;§§	COLORREF* pBits = NULL;§	HBITMAP hDibBmp = CreateDIBSection (§		hSrcDC, lpbi, DIB_RGB_COLORS, (void **)&pBits,§		NULL, NULL);§§	if (hDibBmp == NULL || pBits == NULL)§	{§		delete lpbi;§		_ASSERT (FALSE);§		return NULL;§	} //if§§	hOldResBmp = (HBITMAP)::SelectObject (hResDC, hDibBmp);§	::BitBlt (hResDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, SRCCOPY);§§	clrMask = CLR_TO_RGBQUAD(clrMask);§	clrMono = CLR_TO_RGBQUAD(clrMono);§§	DWORD dwAlpha;§	for (DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, *pBits++)§	{§		COLORREF color = (COLORREF)*pBits;§		//ENG: Extract an original alpha value§		dwAlpha = color & 0xFF000000;§		if (dwAlpha != 0) §			m_bIsAlpha = TRUE;§		if (bUseMask && (color == clrMask))§		{§			//This is transparent area§			color = RGB(0, 0, 0);§		}§		else §		{§			//ENG: Color conversion§			if (dwEffect & IMAGE_EFFECT_GRAYEN) color = GrayMirrorColor(color);§			if (dwEffect & IMAGE_EFFECT_DARKEN) color = DarkenColor(color, 0.75);§			if (dwEffect & IMAGE_EFFECT_LIGHTEN) color = LightenColor(color, 0.25);§			if (dwEffect & IMAGE_EFFECT_MONOCHROME) color = clrMono;§		} //if§		if (dwEffect & IMAGE_EFFECT_INVERT) color = InvertColor(color);§		//ENG: Merges a color with an original alpha value§		*pBits = (color | dwAlpha);§	} //for§§	::SelectObject(hSrcDC, hOldSrcBmp);§	::SelectObject(hResDC, hOldResBmp);§	::DeleteDC(hSrcDC);§	::DeleteDC(hResDC);§	::ReleaseDC(NULL, hMainDC);§	§	delete lpbi;§§	return hDibBmp;§} //End CreateImageEffect§§//----------------------------------------------------------§// CPPDrawManager::GrayMirrorColor()§//	Graying color in RGBQUAD format§//----------------------------------------------------------§// Parameter:§//	clrColor	- RGBQUAD value from DIB§// Return value:§//	A grayed color in the RGBQUAD format§//----------------------------------------------------------§COLORREF CPPDrawManager::GrayMirrorColor(COLORREF clrColor)§{§	BYTE nGrayColor = (BYTE)((GetBValue(clrColor) * 0.299) + (GetGValue(clrColor) * 0.587) + (GetRValue(clrColor) * 0.114));§	§	return RGB(nGrayColor, nGrayColor, nGrayColor);§} //End of GrayMirrorColor§§COLORREF CPPDrawManager::GrayColor(COLORREF clrColor)§{§	BYTE nGrayColor = (BYTE)((GetRValue(clrColor) * 0.299) + (GetGValue(clrColor) * 0.587) + (GetBValue(clrColor) * 0.114));§	§	return RGB(nGrayColor, nGrayColor, nGrayColor);§} //End GrayColor§§COLORREF CPPDrawManager::InvertColor(COLORREF clrColor)§{§	return RGB(255 - GetRValue(clrColor), 255 - GetGValue(clrColor), 255 - GetBValue(clrColor));§} //End InvertColor§§COLORREF CPPDrawManager::DarkenColor(COLORREF clrColor, double darken)§{§	if (darken >= 0.0 && darken < 1.0)§	{§		BYTE color_r, color_g, color_b;§		color_r = (BYTE)(GetRValue(clrColor) * darken);§		color_g = (BYTE)(GetGValue(clrColor) * darken);§		color_b = (BYTE)(GetBValue(clrColor) * darken);§		clrColor = RGB(color_r, color_g, color_b);§	} //if§	§	return clrColor;§} //End DarkenColor§§COLORREF CPPDrawManager::LightenColor(COLORREF clrColor, double lighten)§{§	if (lighten > 0.0 && lighten <= 1.0)§	{§		BYTE color_r, color_g, color_b;§		§		lighten += 1.0;§		color_r = (BYTE)std::min((DWORD)GetRValue(clrColor) * lighten, 255.0);§		color_g = (BYTE)std::min((DWORD)GetGValue(clrColor) * lighten, 255.0);§		color_b = (BYTE)std::min((DWORD)GetBValue(clrColor) * lighten, 255.0);§		clrColor = RGB(color_r, color_g, color_b);§/*		§		lighten *= 255§		color_r = (BYTE)max(0, min(255, (int)((color_r - 128) * 2.0 + 128 + lighten)));§		color_g = (BYTE)max(0, min(255, (int)((color_g - 128) * 2.0 + 128 + lighten)));§		color_b = (BYTE)max(0, min(255, (int)((color_b - 128) * 2.0 + 128 + lighten)));§		clrColor = RGB(color_r, color_g, color_b);§*/§	} //if§	§	return clrColor;§} //End LightenColor§§COLORREF CPPDrawManager::PixelAlpha(COLORREF clrSrc, double src_darken, COLORREF clrDest, double dest_darken)§{§	return RGB (GetRValue (clrSrc) * src_darken + GetRValue (clrDest) * dest_darken, §				GetGValue (clrSrc) * src_darken + GetGValue (clrDest) * dest_darken, §				GetBValue (clrSrc) * src_darken + GetBValue (clrDest) * dest_darken);§	§} //End PixelAlpha§§HICON CPPDrawManager::StretchIcon(HICON hIcon, DWORD dwWidth, DWORD dwHeight)§{§	HICON hStretchedIcon = NULL;§	HDC   hMainDC = NULL;§	HDC   hSrcDC = NULL;§	HDC   hDestDC = NULL;§	BITMAP bmp;§	HBITMAP hOldSrcBitmap = NULL;§	HBITMAP hOldDestBitmap = NULL;§	ICONINFO csOriginal, csStretched;§	§	if (!::GetIconInfo(hIcon, &csOriginal))§		return FALSE;§	§	hMainDC = ::GetDC(NULL);§	hSrcDC = ::CreateCompatibleDC(hMainDC);§	hDestDC = ::CreateCompatibleDC(hMainDC);§	§	if ((NULL == hMainDC) || (NULL == hSrcDC) || (NULL == hDestDC))§		return NULL;§	§	if (::GetObject(csOriginal.hbmColor, sizeof(BITMAP), &bmp))§	{§		DWORD	dwWidthOrg = csOriginal.xHotspot * 2;§		DWORD	dwHeightOrg = csOriginal.yHotspot * 2;§		§		csStretched.hbmColor = ::CreateBitmap(dwWidth, dwHeight, bmp.bmPlanes, bmp.bmBitsPixel, NULL);§		if (NULL != csStretched.hbmColor)§		{§			hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, csOriginal.hbmColor);§			hOldDestBitmap = (HBITMAP)::SelectObject(hDestDC, csStretched.hbmColor);§			::StretchBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, dwWidthOrg, dwHeightOrg, SRCCOPY);§			if (::GetObject(csOriginal.hbmMask, sizeof(BITMAP), &bmp))§			{§				csStretched.hbmMask = ::CreateBitmap(dwWidth, dwHeight, bmp.bmPlanes, bmp.bmBitsPixel, NULL);§				if (NULL != csStretched.hbmMask)§				{§					::SelectObject(hSrcDC, csOriginal.hbmMask);§					::SelectObject(hDestDC, csStretched.hbmMask);§					::StretchBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, dwWidthOrg, dwHeightOrg, SRCCOPY);§				} //if§			} //if§			::SelectObject(hSrcDC, hOldSrcBitmap);§			::SelectObject(hDestDC, hOldDestBitmap);§			csStretched.fIcon = TRUE;§			hStretchedIcon = ::CreateIconIndirect(&csStretched);§		} //if§		::DeleteObject(csStretched.hbmColor);§		::DeleteObject(csStretched.hbmMask);§	} //if§	§	::DeleteObject(csOriginal.hbmColor);§	::DeleteObject(csOriginal.hbmMask);§	::DeleteDC(hSrcDC);§	::DeleteDC(hDestDC);§	::ReleaseDC(NULL, hMainDC);§	§	return hStretchedIcon;§} //End StretchIcon§§void CPPDrawManager::FillGradient (HDC hDC, LPCRECT lpRect, §								COLORREF colorStart, COLORREF colorFinish, §								BOOL bHorz/* = TRUE*/)§{§    // this will make 2^6 = 64 fountain steps§    int nShift = 6;§    int nSteps = 1 << nShift;§§	RECT r2;§	r2.top = lpRect->top;§	r2.left = lpRect->left;§	r2.right = lpRect->right;§	r2.bottom = lpRect->bottom;§§	int nHeight = lpRect->bottom - lpRect->top;§	int nWidth = lpRect->right - lpRect->left;§§	for (int i = 0; i < nSteps; i++)§    {§        // do a little alpha blending§        BYTE bR = (BYTE) ((GetRValue(colorStart) * (nSteps - i) +§                   GetRValue(colorFinish) * i) >> nShift);§        BYTE bG = (BYTE) ((GetGValue(colorStart) * (nSteps - i) +§                   GetGValue(colorFinish) * i) >> nShift);§        BYTE bB = (BYTE) ((GetBValue(colorStart) * (nSteps - i) +§                   GetBValue(colorFinish) * i) >> nShift);§§		HBRUSH hBrush = ::CreateSolidBrush(RGB(bR, bG, bB));§		§        // then paint with the resulting color§§        if (!bHorz)§        {§            r2.top = lpRect->top + ((i * nHeight) >> nShift);§            r2.bottom = lpRect->top + (((i + 1) * nHeight) >> nShift);§            if ((r2.bottom - r2.top) > 0)§                ::FillRect(hDC, &r2, hBrush);§        }§        else§        {§            r2.left = lpRect->left + ((i * nWidth) >> nShift);§            r2.right = lpRect->left + (((i + 1) * nWidth) >> nShift);§            if ((r2.right - r2.left) > 0)§                ::FillRect(hDC, &r2, hBrush);§        } //if§		§		if (NULL != hBrush)§		{§			::DeleteObject(hBrush);§			hBrush = NULL;§		} //if§    } //for§} //End FillGradient§§#ifdef USE_SHADE§void CPPDrawManager::SetShade(LPCRECT lpRect, UINT shadeID /* = 0 */, BYTE granularity /* = 8 */, §						  BYTE coloring /* = 0 */, COLORREF hicr /* = 0 */, COLORREF midcr /* = 0 */, COLORREF locr /* = 0 */)§{§	long	sXSize,sYSize,bytes,j,i,k,h;§	BYTE	*iDst ,*posDst;§	§	sYSize = lpRect->bottom - lpRect->top; §	sXSize = lpRect->right - lpRect->left; §§	m_dNormal.Create(sXSize,sYSize,8);					//create the default bitmap§§	long r,g,b;											//build the shaded palette§	for(i = 0; i < 129; i++)§	{§		r=((128-i)*GetRValue(locr)+i*GetRValue(midcr))/128;§		g=((128-i)*GetGValue(locr)+i*GetGValue(midcr))/128;§		b=((128-i)*GetBValue(locr)+i*GetBValue(midcr))/128;§		m_dNormal.SetPaletteIndex((BYTE)i,(BYTE)r,(BYTE)g,(BYTE)b);§	} //for§	for(i=1;i<129;i++){§		r=((128-i)*GetRValue(midcr)+i*GetRValue(hicr))/128;§		g=((128-i)*GetGValue(midcr)+i*GetGValue(hicr))/128;§		b=((128-i)*GetBValue(midcr)+i*GetBValue(hicr))/128;§		m_dNormal.SetPaletteIndex((BYTE)(i+127),(BYTE)r,(BYTE)g,(BYTE)b);§	} //for§§	m_dNormal.BlendPalette(hicr,coloring);	//color the palette§§	bytes = m_dNormal.GetLineWidth();§	iDst = m_dNormal.GetBits();§	posDst =iDst;§	long a,x,y,d,xs,idxmax,idxmin;§§	int grainx2 = RAND_MAX/(max(1,2*granularity));§	idxmax=255-granularity;§	idxmin=granularity;§§	switch (shadeID)§	{§//----------------------------------------------------§	case EFFECT_METAL:§		m_dNormal.Clear();§		// create the strokes§		k=40;	//stroke granularity§		for(a=0;a<200;a++){§			x=rand()/(RAND_MAX/sXSize); //stroke postion§			y=rand()/(RAND_MAX/sYSize);	//stroke position§			xs=rand()/(RAND_MAX/min(sXSize,sYSize))/2; //stroke lenght§			d=rand()/(RAND_MAX/k);	//stroke color§			for(i=0;i<xs;i++){§				if (((x-i)>0)&&((y+i)<sYSize))§					m_dNormal.SetPixelIndex(x-i,y+i,(BYTE)d);§				if (((x+i)<sXSize)&&((y-i)>0))§					m_dNormal.SetPixelIndex(sXSize-x+i,y-i,(BYTE)d);§			} //for§		} //for§		//blend strokes with SHS_DIAGONAL§		posDst =iDst;§		a=(idxmax-idxmin-k)/2;§		for(i = 0; i < sYSize; i++) {§			for(j = 0; j < sXSize; j++) {§				d=posDst[j]+((a*i)/sYSize+(a*(sXSize-j))/sXSize);§				posDst[j]=(BYTE)d;§				posDst[j]+=rand()/grainx2;§			} //for§			posDst+=bytes;§		} //for§§		break;§//----------------------------------------------------§	case EFFECT_HARDBUMP:	// §		//set horizontal bump§		for(i = 0; i < sYSize; i++) {§			k=(255*i/sYSize)-127;§			k=(k*(k*k)/128)/128;§			k=(k*(128-granularity*2))/128+128;§			for(j = 0; j < sXSize; j++) {§				posDst[j]=(BYTE)k;§				posDst[j]+=rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§		//set vertical bump§		d=min(16,sXSize/6);	//max edge=16§		a=sYSize*sYSize/4;§		posDst =iDst;§		for(i = 0; i < sYSize; i++) {§			y=i-sYSize/2;§			for(j = 0; j < sXSize; j++) {§				x=j-sXSize/2;§				xs=sXSize/2-d+(y*y*d)/a;§				if (x>xs) posDst[j]=(BYTE)idxmin+(BYTE)(((sXSize-j)*128)/d);§				if ((x+xs)<0) posDst[j]=(BYTE)idxmax-(BYTE)((j*128)/d);§				posDst[j]+=rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§		break;§//----------------------------------------------------§	case EFFECT_SOFTBUMP: //§		for(i = 0; i < sYSize; i++) {§			h=(255*i/sYSize)-127;§			for(j = 0; j < sXSize; j++) {§				k=(255*(sXSize-j)/sXSize)-127;§				k=(h*(h*h)/128)/128+(k*(k*k)/128)/128;§				k=k*(128-granularity)/128+128;§				if (k<idxmin) k=idxmin;§				if (k>idxmax) k=idxmax;§				posDst[j]=(BYTE)k;§				posDst[j]+=rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§		break;§//----------------------------------------------------§	case EFFECT_VBUMP: // §		for(j = 0; j < sXSize; j++) {§			k=(255*(sXSize-j)/sXSize)-127;§			k=(k*(k*k)/128)/128;§			k=(k*(128-granularity))/128+128;§			for(i = 0; i < sYSize; i++) {§				posDst[j+i*bytes]=(BYTE)k;§				posDst[j+i*bytes]+=rand()/grainx2-granularity;§			} //for§		} //for§		break;§//----------------------------------------------------§	case EFFECT_HBUMP: //§		for(i = 0; i < sYSize; i++) {§			k=(255*i/sYSize)-127;§			k=(k*(k*k)/128)/128;§			k=(k*(128-granularity))/128+128;§			for(j = 0; j < sXSize; j++) {§				posDst[j]=(BYTE)k;§				posDst[j]+=rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§		break;§//----------------------------------------------------§	case EFFECT_DIAGSHADE:	//§		a=(idxmax-idxmin)/2;§		for(i = 0; i < sYSize; i++) {§			for(j = 0; j < sXSize; j++) {§				posDst[j]=(BYTE)(idxmin+a*i/sYSize+a*(sXSize-j)/sXSize);§				posDst[j]+=rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§		break;§//----------------------------------------------------§	case EFFECT_HSHADE:	//§		a=idxmax-idxmin;§		for(i = 0; i < sYSize; i++) {§			k=a*i/sYSize+idxmin;§			for(j = 0; j < sXSize; j++) {§				posDst[j]=(BYTE)k;§				posDst[j]+=rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§		break;§//----------------------------------------------------§	case EFFECT_VSHADE:	//:§		a=idxmax-idxmin;§		for(j = 0; j < sXSize; j++) {§			k=a*(sXSize-j)/sXSize+idxmin;§			for(i = 0; i < sYSize; i++) {§				posDst[j+i*bytes]=(BYTE)k;§				posDst[j+i*bytes]+=rand()/grainx2-granularity;§			} //for§		} //for§		break;§//----------------------------------------------------§	case EFFECT_NOISE:§		for(i = 0; i < sYSize; i++) {§			for(j = 0; j < sXSize; j++) {§				posDst[j]=128+rand()/grainx2-granularity;§			} //for§			posDst+=bytes;§		} //for§	} //switch§//----------------------------------------------------§} //End SetShade§#endif§§void CPPDrawManager::FillEffect(HDC hDC, DWORD dwEffect, LPCRECT lpRect, COLORREF clrBegin, COLORREF clrMid /* = 0 */, COLORREF clrEnd /* = 0 */,  BYTE granularity /* = 0 */, BYTE coloring /* = 0 */)§{§	HBRUSH hBrush = NULL;§§	RECT rect;§	rect.left = lpRect->left;§	rect.top = lpRect->top;§	rect.right = lpRect->right;§	rect.bottom = lpRect->bottom;§§	int nHeight = rect.bottom - rect.top;§	int nWidth = rect.right - rect.left;§	§	switch (dwEffect)§	{§	default:§		hBrush = ::CreateSolidBrush(clrBegin);§		::FillRect(hDC, lpRect, hBrush);§		break;§	case EFFECT_HGRADIENT:§		FillGradient(hDC, lpRect, clrBegin, clrEnd, TRUE);§		break;§	case EFFECT_VGRADIENT:§		FillGradient(hDC, lpRect, clrBegin, clrEnd, FALSE);§		break;§	case EFFECT_HCGRADIENT:§		rect.right = rect.left + nWidth / 2;§		FillGradient(hDC, &rect, clrBegin, clrEnd, TRUE);§		rect.left = rect.right;§		rect.right = lpRect->right;§		FillGradient(hDC, &rect, clrEnd, clrBegin, TRUE);§		break;§	case EFFECT_3HGRADIENT:§		rect.right = rect.left + nWidth / 2;§		FillGradient(hDC, &rect, clrBegin, clrMid, TRUE);§		rect.left = rect.right;§		rect.right = lpRect->right;§		FillGradient(hDC, &rect, clrMid, clrEnd, TRUE);§		break;§	case EFFECT_VCGRADIENT:§		rect.bottom = rect.top + nHeight / 2;§		FillGradient(hDC, &rect, clrBegin, clrEnd, FALSE);§		rect.top = rect.bottom;§		rect.bottom = lpRect->bottom;§		FillGradient(hDC, &rect, clrEnd, clrBegin, FALSE);§		break;§	case EFFECT_3VGRADIENT:§		rect.bottom = rect.top + nHeight / 2;§		FillGradient(hDC, &rect, clrBegin, clrMid, FALSE);§		rect.top = rect.bottom;§		rect.bottom = lpRect->bottom;§		FillGradient(hDC, &rect, clrMid, clrEnd, FALSE);§		break;§#ifdef USE_SHADE§	case EFFECT_NOISE:§	case EFFECT_DIAGSHADE:§	case EFFECT_HSHADE:§	case EFFECT_VSHADE:§	case EFFECT_HBUMP:§	case EFFECT_VBUMP:§	case EFFECT_SOFTBUMP:§	case EFFECT_HARDBUMP:§	case EFFECT_METAL:§		rect.left = 0;§		rect.top = 0;§		rect.right = nWidth;§		rect.bottom = nHeight;§		SetShade(&rect, dwEffect, granularity, coloring, clrBegin, clrMid, clrEnd);§		m_dNormal.Draw(hDC, lpRect->left, lpRect->top);§		break; §#endif§	} //switch§§	if (NULL != hBrush)§	{§		::DeleteObject(hBrush);§		hBrush = NULL;§	} //if§} //End FillEffect§§void CPPDrawManager::MultipleCopy(HDC hDestDC, int nDestX, int nDestY, DWORD dwDestWidth, DWORD dwDestHeight, §										HDC hSrcDC, int nSrcX, int nSrcY, DWORD dwSrcWidth, DWORD dwSrcHeight)§{§	// Horizontal copying§	int right, bottom;§	int nDestRight = (int)(nDestX + dwDestWidth);§	int nDestBottom = (int)(nDestY + dwDestHeight);§	for (int x = nDestX; x < nDestRight; x+= dwSrcWidth)§	{§		right = std::min (x + (int)dwSrcWidth, nDestRight);§		// Vertical copying§		for (int y = nDestY; y < nDestBottom; y+= dwSrcHeight)§		{§			bottom = std::min (y + (int)dwSrcHeight, nDestBottom);§			::BitBlt(hDestDC, x, y, right - x, bottom - y, hSrcDC, nSrcX, nSrcY, SRCCOPY);§		} //for§	} //for§} //End MultipleCopy§§void CPPDrawManager::DrawBitmap(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,§					BOOL bUseMask, COLORREF crMask, §					DWORD dwEffect /* = IMAGE_EFFECT_NONE */, §					BOOL bShadow /* = FALSE */, §					DWORD dwCxShadow /* = PPDRAWMANAGER_SHADOW_XOFFSET */, §					DWORD dwCyShadow /* = PPDRAWMANAGER_SHADOW_YOFFSET */,§					DWORD dwCxDepth /* = PPDRAWMANAGER_SHADOW_XDEPTH */, §					DWORD dwCyDepth /* = PPDRAWMANAGER_SHADOW_YDEPTH */,§					COLORREF clrShadow /* = PPDRAWMANAGER_SHADOW_COLOR */)§{§	m_bIsAlpha = FALSE;§	if (NULL == hSrcBitmap)§		return;§§	SIZE sz;§	GetSizeOfBitmap(hSrcBitmap, &sz);§§	HDC hSrcDC = ::CreateCompatibleDC(hDC);§	HDC hDestDC = ::CreateCompatibleDC(hDC);§	§	HBITMAP hBitmapTemp = ::CreateCompatibleBitmap(hDC, dwWidth, dwHeight);§§	HBITMAP hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, hSrcBitmap);§	HBITMAP hOldDestBitmap = (HBITMAP)::SelectObject(hDestDC, hBitmapTemp);§§	//Scales a bitmap if need§	if (((DWORD)sz.cx != dwWidth) || ((DWORD)sz.cy != dwHeight))§		::StretchBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, sz.cx, sz.cy, SRCCOPY);§	else§		::BitBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, SRCCOPY);§§	::SelectObject(hDestDC, hOldDestBitmap);§	§	HBITMAP hMaskBmp = CreateImageEffect(hBitmapTemp, dwWidth, dwHeight, IMAGE_EFFECT_MASK, bUseMask, crMask);§	HBITMAP hBitmap = CreateImageEffect(hBitmapTemp, dwWidth, dwHeight, dwEffect, bUseMask, crMask, clrShadow);§	§	if (bShadow)§	{§		if (dwEffect & IMAGE_EFFECT_SHADOW)§		{§			POINT ptShadow;§			ptShadow.x = x + dwCxShadow;§			ptShadow.y = y + dwCyShadow;§			HBITMAP hShadowBmp =  CreateImageEffect(hBitmapTemp, dwWidth, dwHeight, IMAGE_EFFECT_MASK, bUseMask, crMask, InvertColor(clrShadow));§			DrawShadow(hDC, ptShadow.x, ptShadow.y, dwWidth, dwHeight, hShadowBmp, dwEffect & IMAGE_EFFECT_GRADIENT_SHADOW, dwCxDepth, dwCyDepth);§			::DeleteObject(hShadowBmp);§		}§		else§		{§			x += dwCxShadow;§			y += dwCyShadow;§		} //if§	} //if§	§	if (m_bIsAlpha)§	{§		::SelectObject(hSrcDC, hBitmap);§		AlphaChannelBitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0);§	}§	else§	{§		//Merge the image mask with background§		::SelectObject(hSrcDC, hMaskBmp);§		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCAND);§		§		//Draw the image§		::SelectObject(hSrcDC, hBitmap);§		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCPAINT);§	}§	§	::SelectObject(hSrcDC, hOldSrcBitmap);§	§	::DeleteDC(hDestDC);§	::DeleteDC(hSrcDC);§§	::DeleteObject(hBitmap);§	::DeleteObject(hMaskBmp);§	::DeleteObject(hBitmapTemp);§} //End DrawBitmap§§void CPPDrawManager::DrawIcon(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HICON hSrcIcon,§  							DWORD dwEffect /* = IMAGE_EFFECT_NONE */, §							BOOL bShadow /* = FALSE */, §							DWORD dwCxShadow /* = PPDRAWMANAGER_SHADOW_XOFFSET */, §							DWORD dwCyShadow /* = PPDRAWMANAGER_SHADOW_YOFFSET */,§							DWORD dwCxDepth /* = PPDRAWMANAGER_SHADOW_XDEPTH */, §							DWORD dwCyDepth /* = PPDRAWMANAGER_SHADOW_YDEPTH */,§							COLORREF clrShadow /* = PPDRAWMANAGER_SHADOW_COLOR */)§{§	m_bIsAlpha = FALSE;§	if (NULL == hSrcIcon)§		return;§§	SIZE sz;§	GetSizeOfIcon(hSrcIcon, &sz);§§	HICON hIcon = NULL;§§	if (((DWORD)sz.cx == dwWidth) && ((DWORD)sz.cy == dwHeight))§		hIcon = ::CopyIcon(hSrcIcon);§	else hIcon = StretchIcon(hSrcIcon, dwWidth, dwHeight);§	§	ICONINFO csOriginal;§§	if (!::GetIconInfo(hIcon, &csOriginal))§		return;§§	HDC hSrcDC = ::CreateCompatibleDC(hDC);§	§	HBITMAP hBitmap;§	if (dwEffect & IMAGE_EFFECT_MONOCHROME)§		hBitmap = CreateImageEffect(csOriginal.hbmMask, dwWidth, dwHeight, dwEffect, TRUE, RGB(255, 255, 255), clrShadow);§	else§		hBitmap = CreateImageEffect(csOriginal.hbmColor, dwWidth, dwHeight, dwEffect, TRUE, RGB(0, 0, 0), clrShadow);§	HBITMAP hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, hBitmap);§§	if (bShadow)§	{§		if (dwEffect & IMAGE_EFFECT_SHADOW)§		{§			POINT ptShadow;§			ptShadow.x = x + dwCxShadow;§			ptShadow.y = y + dwCyShadow;§			HBITMAP hShadowBmp =  CreateImageEffect(csOriginal.hbmMask, dwWidth, dwHeight, IMAGE_EFFECT_MASK, TRUE, RGB(255, 255, 255), InvertColor(clrShadow));§			DrawShadow(hDC, ptShadow.x, ptShadow.y, dwWidth, dwHeight, hShadowBmp, dwEffect & IMAGE_EFFECT_GRADIENT_SHADOW, dwCxDepth, dwCyDepth);§			::DeleteObject(hShadowBmp);§		}§		else§		{§			x += dwCxShadow;§			y += dwCyShadow;§		} //if§	} //if§	§	if (m_bIsAlpha)§	{§//		::SelectObject(hSrcDC, hBitmap);§		AlphaChannelBitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0);§	}§	else§	{§		//-------------------------------------------------------------------§		// !!! ATTENTION !!!§		// I don't know why a icon uses text's color§		// Therefore I change a text's color to BLACK and after draw I restore§		// original color§		//-------------------------------------------------------------------§		COLORREF crOldColor = ::SetTextColor(hDC, RGB(0, 0, 0));§		//Merge the image mask with background§		::SelectObject(hSrcDC, csOriginal.hbmMask);§		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCAND);§		//Draw the image§		::SelectObject(hSrcDC, hBitmap);§		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCPAINT);§		::SetTextColor(hDC, crOldColor);§	} //if§§	::SelectObject(hSrcDC, hOldSrcBitmap);§	::DeleteDC(hSrcDC);§	::DeleteObject(hBitmap);§	::DestroyIcon(hIcon);§§	::DeleteObject(csOriginal.hbmColor);§	::DeleteObject(csOriginal.hbmMask);§} //End DrawIcon§§void CPPDrawManager::DrawShadow(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, BOOL bGradient /* = FALSE */, DWORD dwDepthX /* = PPDRAWMANAGER_SHADOW_YOFFSET */, DWORD dwDepthY /* = PPDRAWMANAGER_SHADOW_XOFFSET */)§{§	HDC hSrcDC = ::CreateCompatibleDC(hDestDC);§	if (NULL == hSrcDC)§		return;§§	HDC hTempDC = ::CreateCompatibleDC(hDestDC);§	if (NULL == hTempDC)§	{§		::DeleteDC(hSrcDC);§		return;§	} // if§	§	//Creates Source DIB§	LPBITMAPINFO lpbiSrc;§	// Fill in the BITMAPINFOHEADER§	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§	lpbiSrc->bmiHeader.biWidth = dwWidth;§	lpbiSrc->bmiHeader.biHeight = dwHeight;§	lpbiSrc->bmiHeader.biPlanes = 1;§	lpbiSrc->bmiHeader.biBitCount = 32;§	lpbiSrc->bmiHeader.biCompression = BI_RGB;§	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;§	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biClrUsed = 0;§	lpbiSrc->bmiHeader.biClrImportant = 0;§	§	COLORREF* pSrcBits = NULL;§	HBITMAP hSrcDib = CreateDIBSection (§		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,§		NULL, NULL);§	§	if ((NULL != hSrcDib) && (NULL != pSrcBits))§	{§		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);§		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hMask);§		if (bGradient)§		{§			if (!(dwDepthX & 0x1)) dwDepthX++;§			if (!(dwDepthY & 0x1)) dwDepthY++;§			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, WHITENESS);§			::StretchBlt (hSrcDC, dwDepthX / 2, dwDepthY / 2, dwWidth - dwDepthX, dwHeight - dwDepthY, hTempDC, 0, 0, dwWidth, dwHeight, SRCCOPY);§		}§		else§		{§			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);§		} //if§		::SelectObject (hTempDC, hOldTempBmp);§		::SelectObject (hSrcDC, hOldSrcBmp);§		§		//Creates Destination DIB§		LPBITMAPINFO lpbiDest;§		// Fill in the BITMAPINFOHEADER§		lpbiDest = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§		lpbiDest->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§		lpbiDest->bmiHeader.biWidth = dwWidth;§		lpbiDest->bmiHeader.biHeight = dwHeight;§		lpbiDest->bmiHeader.biPlanes = 1;§		lpbiDest->bmiHeader.biBitCount = 32;§		lpbiDest->bmiHeader.biCompression = BI_RGB;§		lpbiDest->bmiHeader.biSizeImage = dwWidth * dwHeight;§		lpbiDest->bmiHeader.biXPelsPerMeter = 0;§		lpbiDest->bmiHeader.biYPelsPerMeter = 0;§		lpbiDest->bmiHeader.biClrUsed = 0;§		lpbiDest->bmiHeader.biClrImportant = 0;§		§		COLORREF* pDestBits = NULL;§		HBITMAP hDestDib = CreateDIBSection (§			hDestDC, lpbiDest, DIB_RGB_COLORS, (void **)&pDestBits,§			NULL, NULL);§		§		if ((NULL != hDestDib) && (NULL != pDestBits))§		{§			::SelectObject (hTempDC, hDestDib);§			::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hDestDC, nDestX, nDestY, SRCCOPY);§			::SelectObject (hTempDC, hOldTempBmp);§			§			if (bGradient)§			{§				double * depth = new double [dwWidth * dwHeight];§				SmoothMaskImage(dwWidth, dwHeight, pSrcBits, dwDepthX, dwDepthY, depth);§				for(DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pDestBits++)§					*pDestBits = DarkenColor(*pDestBits, *(depth + pixel));§				delete [] depth;§			}§			else§			{§				for(DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pSrcBits++, pDestBits++)§					*pDestBits = DarkenColor(*pDestBits, (double)GetRValue(*pSrcBits) / 255.0);§			} //if§				§			§			::SelectObject (hTempDC, hDestDib);§			::BitBlt (hDestDC, nDestX, nDestY, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);§			::SelectObject (hTempDC, hOldTempBmp);§§			delete lpbiDest;§			::DeleteObject(hDestDib);§		} //if§		delete lpbiSrc;§		::DeleteObject(hSrcDib);§	} //if§	::DeleteDC(hTempDC);§	::DeleteDC(hSrcDC);§} //End DrawIcon§§void CPPDrawManager::DrawImageList(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,§					int nIndex, int cx, int cy,§					BOOL bUseMask, COLORREF crMask, §					DWORD dwEffect /*= IMAGE_EFFECT_NONE*/, §					BOOL bShadow /*= FALSE*/, §					DWORD dwCxShadow /*= PPDRAWMANAGER_SHADOW_XOFFSET*/, §					DWORD dwCyShadow /*= PPDRAWMANAGER_SHADOW_YOFFSET*/,§					DWORD dwCxDepth /*= PPDRAWMANAGER_SHADOW_XDEPTH*/, §					DWORD dwCyDepth /*= PPDRAWMANAGER_SHADOW_YDEPTH*/,§					COLORREF clrShadow /*= PPDRAWMANAGER_SHADOW_COLOR*/)§{§	if ((NULL == hSrcBitmap) || !cx || !cy)§		return;§§	SIZE sz;§	GetSizeOfBitmap(hSrcBitmap, &sz);§§	//ENG: Gets a max columns and rows of the images on the bitmap§	//RUS: œÓÎÛ˜‡ÂÏ Ï‡ÍÒËÏ‡Î¸ÌÓÂ ˜ËÒÎÓ ÍÓÎÓÌÓÍ Ë ÒÚÓÍ ËÁÓ·‡ÊÂÌËÈ Ì‡ ·ËÚÏ‡ÔÍÂ§	int nMaxCol = sz.cx / cx;§	int nMaxRow = sz.cy / cy;§	int nMaxImages = nMaxCol * nMaxRow;§§	if ((nIndex < nMaxImages) && nMaxCol && nMaxRow)§	{§		//ENG: Gets an specified image from the bitmap§		//RUS: œÓÎÛ˜‡ÂÏ ÛÍ‡Á‡ÌÌÓÂ ËÁÓ·‡ÊÂÌËÂ ËÁ ·ËÚÏ‡Ô‡§		HDC hSrcDC = ::CreateCompatibleDC(hDC);§		HDC hDestDC = ::CreateCompatibleDC(hDC);§		HBITMAP hIconBmp = ::CreateCompatibleBitmap(hDC, cx, cy);§		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject(hSrcDC, hSrcBitmap);§		HBITMAP hOldDestBmp = (HBITMAP)::SelectObject(hDestDC, hIconBmp);§		::BitBlt(hDestDC, 0, 0, cx, cy, hSrcDC, (nIndex % nMaxCol) * cx, (nIndex / nMaxCol) * cy, SRCCOPY);§		::SelectObject(hSrcDC, hOldSrcBmp);§		::SelectObject(hDestDC, hOldDestBmp);§		::DeleteDC(hSrcDC);§		::DeleteDC(hDestDC);§		DrawBitmap( hDC, x, y, dwWidth, dwHeight, hIconBmp, §					bUseMask, crMask, dwEffect, §					bShadow, dwCxShadow, dwCyShadow, §					dwCxDepth, dwCyDepth, clrShadow);§		::DeleteObject(hIconBmp);§	} //if§} //End of DrawImageList§§void CPPDrawManager::MaskToDepth(HDC hDC, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, double * pDepth, BOOL bGradient /* = FALSE */, DWORD dwDepthX /* = PPDRAWMANAGER_CXSHADOW */, DWORD dwDepthY /* = PPDRAWMANAGER_CYSHADOW */)§{§	HDC hSrcDC = ::CreateCompatibleDC(hDC);§	if (NULL == hSrcDC)§	{§		::DeleteDC(hSrcDC);§		hSrcDC = NULL;§		return;§	} //if§§	HDC hTempDC = ::CreateCompatibleDC(hDC);§	if (NULL == hTempDC)§	{§		::DeleteDC(hTempDC);§		hTempDC = NULL;§		return;§	} //if§	§	//Creates Source DIB§	LPBITMAPINFO lpbiSrc;§	// Fill in the BITMAPINFOHEADER§	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§	lpbiSrc->bmiHeader.biWidth = dwWidth;§	lpbiSrc->bmiHeader.biHeight = dwHeight;§	lpbiSrc->bmiHeader.biPlanes = 1;§	lpbiSrc->bmiHeader.biBitCount = 32;§	lpbiSrc->bmiHeader.biCompression = BI_RGB;§	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;§	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biClrUsed = 0;§	lpbiSrc->bmiHeader.biClrImportant = 0;§	§	COLORREF* pSrcBits = NULL;§	HBITMAP hSrcDib = CreateDIBSection (§		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,§		NULL, NULL);§	§	if ((NULL != hSrcDib) && (NULL != pSrcBits))§	{§		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);§		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hMask);§		if (bGradient)§		{§			if (!(dwDepthX & 0x1)) dwDepthX++;§			if (!(dwDepthY & 0x1)) dwDepthY++;§			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, WHITENESS);§			::StretchBlt (hSrcDC, dwDepthX / 2, dwDepthY / 2, dwWidth - dwDepthX, dwHeight - dwDepthY, hTempDC, 0, 0, dwWidth, dwHeight, SRCCOPY);§		}§		else§		{§			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);§		} //if§		::SelectObject (hTempDC, hOldTempBmp);§		::SelectObject (hSrcDC, hOldSrcBmp);§		§		if (bGradient)§		{§			SmoothMaskImage(dwWidth, dwHeight, pSrcBits, dwDepthX, dwDepthY, pDepth);§		}§		else§		{§			for (DWORD pixel = 0; pixel < (dwHeight * dwWidth); pixel++, pSrcBits++, pDepth++)§			{§				*pDepth = GetRValue(*pSrcBits) / 255;§			} //for§		} //if§		delete lpbiSrc;§		::DeleteObject(hSrcDib);§	} //if§	::DeleteDC(hTempDC);§	::DeleteDC(hSrcDC);§} //End MaskToDepth§§void CPPDrawManager::DarkenByDepth(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, double * pDepth)§{§	HDC hSrcDC = ::CreateCompatibleDC(hDC);§	if (NULL == hSrcDC)§	{§		::DeleteDC(hSrcDC);§		hSrcDC = NULL;§		return;§	} //if§	§	//Creates Source DIB§	LPBITMAPINFO lpbiSrc;§	// Fill in the BITMAPINFOHEADER§	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];§	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);§	lpbiSrc->bmiHeader.biWidth = dwWidth;§	lpbiSrc->bmiHeader.biHeight = dwHeight;§	lpbiSrc->bmiHeader.biPlanes = 1;§	lpbiSrc->bmiHeader.biBitCount = 32;§	lpbiSrc->bmiHeader.biCompression = BI_RGB;§	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;§	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;§	lpbiSrc->bmiHeader.biClrUsed = 0;§	lpbiSrc->bmiHeader.biClrImportant = 0;§	§	COLORREF* pSrcBits = NULL;§	HBITMAP hSrcDib = CreateDIBSection (§		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,§		NULL, NULL);§	§	if ((NULL != hSrcDib) && (NULL != pSrcBits))§	{§		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);§		::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hDC, x, y, SRCCOPY);§		::SelectObject (hSrcDC, hOldSrcBmp);§		§		for (DWORD pixel = 0; pixel < (dwHeight * dwWidth); pixel++, pSrcBits++, pDepth++)§		{§			*pSrcBits = DarkenColor(*pSrcBits, *pDepth);§		} //for§§		hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);§		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCCOPY);§		::SelectObject (hSrcDC, hOldSrcBmp);§§		delete lpbiSrc;§		::DeleteObject(hSrcDib);§	} //if§	::DeleteDC(hSrcDC);§} //DarkenByDepth§§void CPPDrawManager::SmoothMaskImage(const int ImageWidth, §									 const int ImageHeight,§									 const COLORREF* const pInitImg,§									 const int KerWidth,§									 const int KerHeight,§									 double* const pResImg_R /*= NULL*/)§{§	double* const pfBuff1 = new double[(ImageWidth  + KerWidth  - 1) * §		(ImageHeight + KerHeight - 1)];§	double* const pfBuff2 = new double[(ImageWidth  + KerWidth  - 1) * §		(ImageHeight + KerHeight - 1)];§	§	// expanding initial image with a padding procdure§	double* p = pfBuff1;§	const COLORREF * pInitImg_It = pInitImg;§	if(NULL != pResImg_R)§	{§		for(int _i = - KerHeight/2; _i < ImageHeight +  KerHeight/2; _i++)§		{§			for(int _j = -KerWidth/2; _j < ImageWidth + KerWidth/2;  _j++, p++)§			{§				if ((_i >= 0) && (_i < ImageHeight) && (_j >= 0) && (_j < ImageWidth))§				{§					*p = GetRValue(*pInitImg_It++);§					//					pInitImg_It++;§				}§				else§					*p = 255;§			} //for§		} //for§		§		//---§		GetPartialSums(pfBuff1,§			(ImageHeight + KerHeight - 1),§			(ImageWidth  + KerWidth  - 1),§			KerHeight,§			KerWidth,§			pfBuff2,§			pResImg_R);§		§		for(int i = 0; i < ImageHeight*ImageWidth; i++)§			*(pResImg_R + i) /= KerHeight*KerWidth*255;§	} //if§	§	§	delete []pfBuff1;§	delete []pfBuff2;§} //End SmoothMaskImage§§void CPPDrawManager::GetPartialSums(const double* const pM,§									unsigned int nMRows,§									unsigned int nMCols,§									unsigned int nPartRows,§									unsigned int nPartCols,§									double* const pBuff,§									double* const pRes)§{§	const double* it1;§	const double* it2;§	const double* it3;§	§	double* pRowsPartSums;§	const unsigned int nRowsPartSumsMRows = nMRows;§	const unsigned int nRowsPartSumsMCols = nMCols - nPartCols + 1;	§	§	const unsigned int nResMRows = nMRows - nPartRows + 1;§	const unsigned int nResMCols = nMCols - nPartCols + 1;§	§	§	unsigned int i,j;§	double s;§	§	// ˜‡ÒÚË˜Ì˚Â ÒÛÏÏ˚ ÒÚÓÍ§	it1          = pM;§	pRowsPartSums = pBuff;§	§	for(i = 0; i < nMRows; i++)§	{§		//-------------§		it2 = it1;§		s = 0;§		for(j = 0;j < nPartCols;j++)s+=*it2++;§		//-------------§		it3 = it1;§		*pRowsPartSums++ = s;§		for(/*j = nPartCols*/; j < nMCols; j++)§		{§			s+=*it2 - *it3;§			*pRowsPartSums++ = s;§			it2++;§			it3++;§		} //for§		//--§		it1 += nMCols;§	} //for§	// ÙÓÏËÓ‚‡ÌËÂ ÂÁÛ¸Ú‡Ú‡§	const double* it4;§	const double* it5;§	const double* it6;§	§	double* pResIt;§	§	it4    = pBuff;§	pResIt = pRes;§	§	for(j = 0; j < nRowsPartSumsMCols; j++)§	{§		pResIt = pRes + j;§		//-------------§		it5 = it4;§		s = 0;§		for(i = 0; i < nPartRows; i++)§		{§			s += *it5;§			it5 += nRowsPartSumsMCols; §		} //for§		//-------------§		it6 = it4;§		*pResIt = s;§		pResIt += nRowsPartSumsMCols;§		§		for(; i < nRowsPartSumsMRows; i++)§		{§			s += *it5 - *it6;//cout<<s<<endl;§			*pResIt = s;§			pResIt += nResMCols;§			it5 += nRowsPartSumsMCols;§			it6 += nRowsPartSumsMCols;§		} //for§		//--§		it4 ++;§	} //for§} //End GetPartialSums§§void CPPDrawManager::DrawRectangle(HDC hDC, LPRECT lpRect, COLORREF crLight, COLORREF crDark, int nStyle /* = PEN_SOLID */, int nSize /* = 1 */)§{§	DrawRectangle(hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, crLight, crDark, nStyle, nSize);§}§§void CPPDrawManager::DrawRectangle(HDC hDC, int left, int top, int right, int bottom, §								   COLORREF crLight, COLORREF crDark, int nStyle /* = PEN_SOLID */, §								   int nSize /* = 1 */)§{§	if ((PEN_NULL == nStyle) || (nSize < 1))§		return;§§	int nSysPenStyle = PS_SOLID;§	int nDoubleLineOffset = nSize * 2;§	switch (nStyle)§	{§	case PEN_DASH: nSysPenStyle = PS_DASH; break;§	case PEN_DOT: nSysPenStyle = PS_DOT; break;§	case PEN_DASHDOT: nSysPenStyle = PS_DASHDOT; break;§	case PEN_DASHDOTDOT: nSysPenStyle = PS_DASHDOTDOT; break;§	case PEN_DOUBLE:§	case PEN_SOLID:§	default:§		nSysPenStyle = PS_SOLID; §		break;§	} //switch§§	//Insideframe§	left += nSize / 2;§	top += nSize / 2;§	right -= nSize / 2;§	bottom -= nSize / 2;§§	//Creates a light pen§	HPEN hPen = ::CreatePen(nSysPenStyle, nSize, crLight);§	HPEN hOldPen = (HPEN)::SelectObject(hDC, hPen);§§	//Draw light border§	::MoveToEx(hDC, left, bottom, NULL);§	::LineTo(hDC, left, top);§	::LineTo(hDC, right, top);§	if (PEN_DOUBLE == nStyle)§	{§		::MoveToEx(hDC, left + nDoubleLineOffset, bottom - nDoubleLineOffset, NULL);§		::LineTo(hDC, left + nDoubleLineOffset, top + nDoubleLineOffset);§		::LineTo(hDC, right - nDoubleLineOffset, top + nDoubleLineOffset);§	} //if§§	//Creates a dark pen if needed§	if (crLight != crDark)§	{§		SelectObject(hDC, hOldPen);§		::DeleteObject(hPen);§		hPen = ::CreatePen(nSysPenStyle, nSize, crDark);§		hOldPen = (HPEN)::SelectObject(hDC, hPen);§	} //if§§	//Draw dark border§	::MoveToEx(hDC, right, top, NULL);§	::LineTo(hDC, right, bottom);§	::LineTo(hDC, left, bottom);§	if (PEN_DOUBLE == nStyle)§	{§		::MoveToEx(hDC, right - nDoubleLineOffset, top + nDoubleLineOffset, NULL);§		::LineTo(hDC, right - nDoubleLineOffset, bottom - nDoubleLineOffset);§		::LineTo(hDC, left + nDoubleLineOffset, bottom - nDoubleLineOffset);§	} //if§§	SelectObject(hDC, hOldPen);§	::DeleteObject(hPen);§} //End DrawRectangle§§void CPPDrawManager::DrawLine(HDC hDC, §							  int xStart, int yStart, int xEnd, int yEnd, §							  COLORREF color, int nStyle /* = PEN_SOLID */, §							  int nSize /* = 1 */) const§{§	if ((PEN_NULL == nStyle) || (nSize < 1))§		return;§	§	int nSysPenStyle;§	int nDoubleLineOffset = nSize * 2;§	switch (nStyle)§	{§	case PEN_DASH: nSysPenStyle = PS_DASH; break;§	case PEN_DOT: nSysPenStyle = PS_DOT; break;§	case PEN_DASHDOT: nSysPenStyle = PS_DASHDOT; break;§	case PEN_DASHDOTDOT: nSysPenStyle = PS_DASHDOTDOT; break;§	case PEN_DOUBLE:§	case PEN_SOLID:§	default:§		nSysPenStyle = PS_SOLID; §		break;§	} //switch§§	HPEN hPen = ::CreatePen(nSysPenStyle, nSize, color);§	HPEN hOldPen = (HPEN)::SelectObject(hDC, hPen);§§	::MoveToEx(hDC, xStart, yStart, NULL);§	::LineTo(hDC, xEnd, yEnd);§	§	if (PEN_DOUBLE == nStyle)§	{§		if (xStart != xEnd)§		{§			yStart += nDoubleLineOffset;§			yEnd += nDoubleLineOffset;§		} //if§		§		if (yStart != yEnd)§		{§			xStart += nDoubleLineOffset;§			xEnd += nDoubleLineOffset;§		} //if§		::MoveToEx(hDC, xStart, yStart, NULL);§		::LineTo(hDC, xEnd, yEnd);§	} //if§	SelectObject(hDC, hOldPen);§	::DeleteObject(hPen);§} //End DrawLine§//#UC END# *4700B8C80280*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8C80280_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B8C80280_DESTR_BODY*§	//#UC END# *4700B8C80280_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8C80280_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B8C80280_CUSTOM_INCLUDES*§#include "shared/WinGUI/Controls/CCeXDib.h"§§#define PPDRAWMANAGER_SHADOW_XOFFSET	4	// §#define PPDRAWMANAGER_SHADOW_YOFFSET	4	//§#define PPDRAWMANAGER_SHADOW_XDEPTH		7	// §#define PPDRAWMANAGER_SHADOW_YDEPTH		7	//§#define PPDRAWMANAGER_SHADOW_COLOR		RGB(128, 128, 128)§§//Image Effects§#define IMAGE_EFFECT_NONE				0x0000 //No effect§#define IMAGE_EFFECT_GRAYEN				0x0001 //An image will grayen§#define IMAGE_EFFECT_DARKEN				0x0002 //An image will darken§#define IMAGE_EFFECT_LIGHTEN			0x0004 //An image will lighten§#define IMAGE_EFFECT_MONOCHROME			0x0008 //An Image will monochrome§#define IMAGE_EFFECT_MONO_SHADOW		0x0100§#define IMAGE_EFFECT_GRADIENT_SHADOW	0x0200§#define IMAGE_EFFECT_INVERT				0x8000§§#define IMAGE_EFFECT_MASK				(IMAGE_EFFECT_MONOCHROME | IMAGE_EFFECT_INVERT)§#define IMAGE_EFFECT_SHADOW				(IMAGE_EFFECT_MONO_SHADOW | IMAGE_EFFECT_GRADIENT_SHADOW)§§//#UC END# *4700B8C80280_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8C80280*"
		    value      	(value Text 
|//#UC START# *4700B8C80280*§public:§	CPPDrawManager();§§	enum {	EFFECT_SOLID = 0,§			EFFECT_HGRADIENT,§			EFFECT_VGRADIENT,§			EFFECT_HCGRADIENT,§			EFFECT_VCGRADIENT,§			EFFECT_3HGRADIENT,§			EFFECT_3VGRADIENT,§			EFFECT_NOISE,§			EFFECT_DIAGSHADE,§			EFFECT_HSHADE,§			EFFECT_VSHADE,§			EFFECT_HBUMP,§			EFFECT_VBUMP,§			EFFECT_SOFTBUMP,§			EFFECT_HARDBUMP,§			EFFECT_METAL,§			MAX_EFFECTS§		};§§	enum	{ §			PEN_NULL = 0,§			PEN_SOLID,§			PEN_DASH,§			PEN_DOT,§			PEN_DASHDOT,§			PEN_DASHDOTDOT,§			PEN_DOUBLE,§§			MAX_PEN_STYLES§			};§§public:§	void  DrawLine(HDC hDC, int xStart, int yStart, int xEnd, int yEnd, COLORREF color, int nStyle = PEN_SOLID, int nSize = 1) const;§	void  DrawRectangle(HDC hDC, LPRECT lpRect, COLORREF crLight, COLORREF crDark, int nStyle = PEN_SOLID, int nSize = 1);§	void  DrawRectangle(HDC hDC, int left, int top, int right, int bottom, COLORREF crLight, COLORREF crDark, int nStyle = PEN_SOLID, int nSize = 1);§	void  GetSizeOfIcon(HICON hIcon, LPSIZE pSize) const;§	void  GetSizeOfBitmap(HBITMAP hBitmap, LPSIZE pSize) const;§	§	void  AlphaBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY, int percent = 100);§	void  AlphaChannelBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY);§	void  DrawShadow(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, BOOL bGradient = FALSE, DWORD dwDepthX = PPDRAWMANAGER_SHADOW_XOFFSET, DWORD dwDepthY = PPDRAWMANAGER_SHADOW_YOFFSET);§	void  MaskToDepth(HDC hDC, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, double * pDepth, BOOL bGradient = FALSE, DWORD dwDepthX = PPDRAWMANAGER_SHADOW_XOFFSET, DWORD dwDepthY = PPDRAWMANAGER_SHADOW_YOFFSET);§	void  DarkenByDepth(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, double * pDepth);§§	void  SmoothMaskImage(const int ImageWidth, §				    const int ImageHeight,§                    const COLORREF* const pInitImg,§			        const int KerWidth,§			        const int KerHeight,§					double* const pResImg_R = NULL);§§	void GetPartialSums(const double* const pM,§					unsigned int nMRows,§					unsigned int nMCols,§					unsigned int nPartRows,§					unsigned int nPartCols,§					double* const pBuff,§					double* const pRes);§	§	void  DrawBitmap(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,§					BOOL bUseMask, COLORREF crMask, §					DWORD dwEffect = IMAGE_EFFECT_NONE, §					BOOL bShadow = FALSE, §					DWORD dwCxShadow = PPDRAWMANAGER_SHADOW_XOFFSET, §					DWORD dwCyShadow = PPDRAWMANAGER_SHADOW_YOFFSET,§					DWORD dwCxDepth = PPDRAWMANAGER_SHADOW_XDEPTH, §					DWORD dwCyDepth = PPDRAWMANAGER_SHADOW_YDEPTH,§					COLORREF clrShadow = PPDRAWMANAGER_SHADOW_COLOR);§§	void  DrawIcon( HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HICON hSrcIcon, §					DWORD dwEffect = IMAGE_EFFECT_NONE, §					BOOL bShadow = FALSE, §					DWORD dwCxShadow = PPDRAWMANAGER_SHADOW_XOFFSET, §					DWORD dwCyShadow = PPDRAWMANAGER_SHADOW_YOFFSET,§					DWORD dwCxDepth = PPDRAWMANAGER_SHADOW_XDEPTH, §					DWORD dwCyDepth = PPDRAWMANAGER_SHADOW_YDEPTH,§					COLORREF clrShadow = PPDRAWMANAGER_SHADOW_COLOR);§§	void  DrawImageList(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,§					int nIndex, int cx, int cy,§					BOOL bUseMask, COLORREF crMask, §					DWORD dwEffect = IMAGE_EFFECT_NONE, §					BOOL bShadow = FALSE, §					DWORD dwCxShadow = PPDRAWMANAGER_SHADOW_XOFFSET, §					DWORD dwCyShadow = PPDRAWMANAGER_SHADOW_YOFFSET,§					DWORD dwCxDepth = PPDRAWMANAGER_SHADOW_XDEPTH, §					DWORD dwCyDepth = PPDRAWMANAGER_SHADOW_YDEPTH,§					COLORREF clrShadow = PPDRAWMANAGER_SHADOW_COLOR);§§	HBITMAP CreateImageEffect(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, DWORD dwEffect, BOOL bUseMask = TRUE, COLORREF clrMask = RGB(255, 0, 255), COLORREF clrMono = RGB(255, 255, 255));§§	COLORREF GrayMirrorColor(COLORREF clrColor);§	COLORREF GrayColor(COLORREF clrColor);§	COLORREF DarkenColor(COLORREF clrColor, double darken);§	COLORREF LightenColor(COLORREF clrColor, double lighten);§	COLORREF InvertColor(COLORREF clrColor);§	COLORREF PixelAlpha (COLORREF clrSrc, double src_darken, COLORREF clrDest, double dest_darken);§	§	HICON StretchIcon(HICON hIcon, DWORD dwWidth, DWORD dwHeight);§§	void FillEffect(HDC hDC, DWORD dwEffect, LPCRECT lpRect, COLORREF clrBegin, COLORREF clrMid = 0, COLORREF clrEnd = 0,  BYTE granularity = 0, BYTE coloring = 0);§	void FillGradient(HDC hDC, LPCRECT lpRect, COLORREF colorStart, COLORREF colorFinish, BOOL bHorz = TRUE);§	void MultipleCopy(HDC hDestDC, int nDestX, int nDestY, DWORD dwDestWidth, DWORD dwDestHeight, HDC hSrcDC, int nSrcX, int nSrcY, DWORD dwSrcWidth, DWORD dwSrcHeight);§#ifdef USE_SHADE§	void SetShade(LPCRECT lpRect, UINT shadeID = 0, BYTE granularity = 8, BYTE coloring = 0, COLORREF hicr = 0, COLORREF midcr = 0, COLORREF locr = 0);§	CCeXDib m_dNormal/*,m_dh,m_dv*/;§#endif§§	static short GetVersionI()		{return 0x13;}§//	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("1.3");}§§protected:§	BOOL m_bIsAlpha;§//#UC END# *4700B8C80280*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CPPDrawManager|4700B8C80280
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659777955"))
	    quid       	"4700B8C80280"
	    documentation 	"ÍÎ‡ÒÒ ‰Îˇ ‡·ÓÚ˚ Ò „‡ÙËÍÓÈ"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator")
	(object Class "CCeXDib"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CCeXDib.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CCeXDib.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8F90119_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4700B8F90119_CUSTOM_INCLUDES*§#include <windows.h>§#include <tchar.h>§//#UC END# *4700B8F90119_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8F90119*"
		    value      	(value Text 
|//#UC START# *4700B8F90119*§CCeXDib::CCeXDib()§{§	m_hDib = NULL;§	m_dwLineWidth = 0;§	m_wColors = 0;§§	m_hMemDC = NULL;§	m_hBitmap = NULL;§	m_lpBits = NULL;§§	FreeResources();§}§§void CCeXDib::FreeResources()§{§	if (m_hMemDC)	§		::DeleteDC(m_hMemDC);§	if (m_hBitmap)	§		::DeleteObject(m_hBitmap);§	if (m_hDib)		§		delete m_hDib;§§	m_hDib = NULL;§	m_hMemDC = NULL;§	m_hBitmap = NULL;§	m_lpBits = NULL;§	memset(&m_bi, 0, sizeof(m_bi));§} // End of FreeResources§§HDIB CCeXDib::Create(DWORD dwWidth, DWORD dwHeight, WORD wBitCount)§{§    LPBITMAPINFOHEADER  lpbi = NULL;	// Pointer to BITMAPINFOHEADER§    DWORD               dwLen = 0;		// Size of memory block§§	FreeResources();§§	// Following <switch> is taken from§	// CDIBSectionLite class by Chris Maunder§    switch (wBitCount) §    {§	    case 1:  m_wColors = 2;   break;§#ifdef _WIN32_WCE§        case 2:  m_wColors = 4;   break;   // winCE only       §#endif§        case 4:  m_wColors = 16;  break;§        case 8:  m_wColors = 256; break;§        case 16:§        case 24:§        case 32: m_wColors = 0;   break;   // 16,24 or 32 bpp have no color table§§        default:§           m_wColors = 0;§    } // switch§/*§    // Make sure bits per pixel is valid§    if (wBitCount <= 1)			wBitCount = 1;§    else if (wBitCount <= 4)	wBitCount = 4;§    else if (wBitCount <= 8)	wBitCount = 8;§    else				        wBitCount = 24;§§    switch (wBitCount)§	{§        case 1:§            m_wColors = 2;§			break;§        case 4:§            m_wColors = 16;§			break;§        case 8:§            m_wColors = 256;§			break;§        default:§            m_wColors = 0;§			break;§    } // switch§*/§    m_dwLineWidth = WIDTHBYTES(wBitCount * dwWidth);§§    // Initialize BITMAPINFOHEADER§    m_bi.biSize = sizeof(BITMAPINFOHEADER);§    m_bi.biWidth = dwWidth;         // fill in width from parameter§    m_bi.biHeight = dwHeight;       // fill in height from parameter§    m_bi.biPlanes = 1;              // must be 1§    m_bi.biBitCount = wBitCount;    // from parameter§    m_bi.biCompression = BI_RGB;    §    m_bi.biSizeImage = m_dwLineWidth * dwHeight;§    m_bi.biXPelsPerMeter = 0;§    m_bi.biYPelsPerMeter = 0;§    m_bi.biClrUsed = 0;§    m_bi.biClrImportant = 0;§§    // Calculate size of memory block required to store the DIB.  This§    // block should be big enough to hold the BITMAPINFOHEADER, the color§    // table, and the bits.§    dwLen = GetSize();§§	m_hDib = new HDIB[dwLen]; // Allocate memory block to store our bitmap§    if (m_hDib == NULL) return NULL;§§    // Use our bitmap info structure to fill in first part of§    // our DIB with the BITMAPINFOHEADER§	lpbi = (LPBITMAPINFOHEADER)(m_hDib);§    *lpbi = m_bi;§§    return m_hDib; // Return handle to the DIB§} // End of Create§§DWORD CCeXDib::GetSize()§{§	return m_bi.biSize + m_bi.biSizeImage + GetPaletteSize();§} // End of GetSize§§DWORD CCeXDib::GetPaletteSize()§{§	return (m_wColors * sizeof(RGBQUAD));§} // End of GetPaletteSize§§LPBYTE CCeXDib::GetBits()§{§	if (m_hDib)	§		return ((LPBYTE)m_hDib + *(LPDWORD)m_hDib + GetPaletteSize()); §§	return NULL;§} // End of GetBits§§DWORD CCeXDib::GetWidth()§{§	return m_bi.biWidth;§} // End of GetWidth§§DWORD CCeXDib::GetHeight()§{§	return m_bi.biHeight;§} // End of GetHeight§§DWORD CCeXDib::GetLineWidth()§{§	return m_dwLineWidth;§} // End of GetLineWidth§§void CCeXDib::BlendPalette(COLORREF crColor, DWORD dwPerc)§{§	if (m_hDib == NULL || m_wColors == 0) §		return;§§	LPBYTE iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);§§	long i,r,g,b;§§	RGBQUAD* pPal = (RGBQUAD*)iDst;§§	r = GetRValue(crColor);§	g = GetGValue(crColor);§	b = GetBValue(crColor);§§	if (dwPerc > 100) §		dwPerc = 100;§§	for (i = 0; i < m_wColors; i++)§	{§		pPal[i].rgbBlue = (BYTE)((pPal[i].rgbBlue * (100 - dwPerc) + b * dwPerc) / 100);§		pPal[i].rgbGreen = (BYTE)((pPal[i].rgbGreen * (100 - dwPerc) + g * dwPerc) / 100);§		pPal[i].rgbRed = (BYTE)((pPal[i].rgbRed * (100 - dwPerc) + r * dwPerc) / 100);§	} // for§} // End of BlendPalette§§void CCeXDib::Clear(BYTE byVal)§{§	if (m_hDib) §		memset(GetBits(), byVal, m_bi.biSizeImage);§} // End of Clear§§void CCeXDib::SetPixelIndex(DWORD dwX, DWORD dwY, BYTE byI)§{§	if ((m_hDib == NULL) || (m_wColors == 0) ||§		((long)dwX < 0) || ((long)dwY < 0) || (dwX >= (DWORD)m_bi.biWidth) || (dwY >= (DWORD)m_bi.biHeight)) return;§§	LPBYTE iDst = GetBits();§	iDst[(m_bi.biHeight - dwY - 1) * m_dwLineWidth + dwX] = byI;§} // End of SetPixelIndex§§void CCeXDib::Clone(CCeXDib* src)§{§	Create(src->GetWidth(), src->GetHeight(), src->GetBitCount());§	if (m_hDib) §		memcpy(m_hDib, src->m_hDib, GetSize());§} // End of Clone§§WORD CCeXDib::GetBitCount()§{§	return m_bi.biBitCount;§} // End of GetBitCount§§void CCeXDib::SetPaletteIndex(BYTE byIdx, BYTE byR, BYTE byG, BYTE byB)§{§	if (m_hDib && m_wColors)§	{§		LPBYTE iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);§		if ((byIdx >= 0) && (byIdx < m_wColors))§		{	§			long ldx = byIdx * sizeof(RGBQUAD);§			iDst[ldx++] = (BYTE)byB;§			iDst[ldx++] = (BYTE)byG;§			iDst[ldx++] = (BYTE)byR;§			iDst[ldx] = (BYTE)0;§		} // if§	} // if§} // End of SetPaletteIndex§§void CCeXDib::Draw(HDC hDC, DWORD dwX, DWORD dwY)§{§	HBITMAP	hBitmap = NULL;§	HBITMAP	hOldBitmap = NULL;§	HDC		hMemDC = NULL;§§	if (m_hBitmap == NULL)§	{§		m_hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)m_hDib, DIB_RGB_COLORS, &m_lpBits, NULL, 0);§		if (m_hBitmap == NULL)	return;§		if (m_lpBits == NULL)§		{§			::DeleteObject(m_hBitmap);§			m_hBitmap = NULL;§			return;§		} // if§	} // if§§    memcpy(m_lpBits, GetBits(), m_bi.biSizeImage);§§	if (m_hMemDC == NULL)§	{§		m_hMemDC = CreateCompatibleDC(hDC);§		if (m_hMemDC == NULL)	return;§	} // if§§	hOldBitmap = (HBITMAP)SelectObject(m_hMemDC, m_hBitmap);§§	BitBlt(hDC, dwX, dwY, m_bi.biWidth, m_bi.biHeight, m_hMemDC, 0, 0, SRCCOPY);§§	SelectObject(m_hMemDC, hOldBitmap);§} // End of Draw§§void CCeXDib::Copy(HDC hDC, DWORD dwX, DWORD dwY)§{§	if (m_hBitmap == NULL)§	{§		m_hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)m_hDib, DIB_RGB_COLORS, &m_lpBits, NULL, 0);§		if (m_hBitmap == NULL)§			return;§		if (m_lpBits == NULL)§		{§			::DeleteObject(m_hBitmap);§			m_hBitmap = NULL;§			return;§		} // if§	} // if§	§	HDC hMemDC = ::CreateCompatibleDC(hDC);§	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hMemDC, m_hBitmap);§	::BitBlt(hMemDC, 0, 0, m_bi.biWidth, m_bi.biHeight, hDC, dwX, dwY, SRCCOPY);§	::SelectObject(hMemDC, hOldBitmap);§} // End of Copy§§void CCeXDib::SetGrayPalette()§{§	RGBQUAD		pal[256];§	RGBQUAD*	ppal;§	LPBYTE		iDst;§	int			ni;§§	if (m_hDib == NULL || m_wColors == 0) return;§§	ppal = (RGBQUAD*)&pal[0];§	iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);§	for (ni = 0; ni < m_wColors; ni++)§	{§		pal[ni] = RGB2RGBQUAD(RGB(ni,ni,ni));§	} // for§§	pal[0] = RGB2RGBQUAD(RGB(0,0,0));§	pal[m_wColors-1] = RGB2RGBQUAD(RGB(255,255,255));§§	memcpy(iDst, ppal, GetPaletteSize());§} // End of SetGrayPalette§§RGBQUAD CCeXDib::RGB2RGBQUAD(COLORREF cr)§{§	RGBQUAD c;§	c.rgbRed = GetRValue(cr);	/* get R, G, and B out of DWORD */§	c.rgbGreen = GetGValue(cr);§	c.rgbBlue = GetBValue(cr);§	c.rgbReserved=0;§	return c;§} // End of RGB2RGBQUAD§§WORD CCeXDib::GetNumColors()§{§	return m_wColors;§} // End of GetNumColors§§BOOL CCeXDib::WriteBMP(LPCTSTR bmpFileName)§{§	BITMAPFILEHEADER	hdr;§	HANDLE	hFile;§	DWORD	nByteWrite;§§	if (*bmpFileName == _T('\0') || m_hDib == 0) return 0;§§	hFile=CreateFile(			// open if exist ini file§		bmpFileName,			// pointer to name of the file §		GENERIC_WRITE,			// access mode §		0,						// share mode §		NULL,					// pointer to security descriptor §		CREATE_ALWAYS,			// how to create §		FILE_ATTRIBUTE_NORMAL,	// file attributes §		NULL				 	// handle to file with attributes to copy  §		);§	if (hFile == INVALID_HANDLE_VALUE) return FALSE;§§    // Fill in the fields of the file header§	hdr.bfType = BFT_BITMAP;§	hdr.bfSize = GetSize() + sizeof(BITMAPFILEHEADER);§	hdr.bfReserved1 = hdr.bfReserved2 = 0;§	hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER)+§					m_bi.biSize + GetPaletteSize();§§    // Write the file header§	WriteFile(						// write ini (sync mode <-> no overlapped)§		hFile,						// handle of file to write §		(LPSTR) &hdr,				// address of buffer that contains data  §		sizeof(BITMAPFILEHEADER),	// number of bytes to write §		&nByteWrite,				// address of number of bytes written §		NULL	 					// address of structure for data §		);§§    // Write the DIB header and the bits§	WriteFile(						// write ini (sync mode <-> no overlapped)§		hFile,						// handle of file to write §		(LPSTR) m_hDib,				// address of buffer that contains data  §		GetSize(),					// number of bytes to write §		&nByteWrite,				// address of number of bytes written §		NULL	 					// address of structure for data §		);§§	CloseHandle(hFile);				// free file handle§§	return TRUE;§} // End of WriteBMP§//#UC END# *4700B8F90119*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8F90119_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B8F90119_DESTR_BODY*§	FreeResources();§	//#UC END# *4700B8F90119_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8F90119_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B8F90119_CUSTOM_INCLUDES*§#ifndef	HDIB§#define HDIB	HANDLE§#endif§§#ifndef WIDTHBYTES§#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)§#endif§§#ifndef BFT_BITMAP§#define BFT_BITMAP 0x4d42   // 'BM'§#endif§//#UC END# *4700B8F90119_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8F90119*"
		    value      	(value Text 
|//#UC START# *4700B8F90119*§public:§	CCeXDib();§§	HDIB Create(DWORD dwWidth, DWORD dwHeight, WORD wBitCount);§	void Clone(CCeXDib* src);§	void Draw(HDC hDC, DWORD dwX, DWORD dwY);§	void Copy(HDC hDC, DWORD dwX, DWORD dwY);§	LPBYTE GetBits();§	void Clear(BYTE byVal = 0);§§	void SetGrayPalette();§	void SetPaletteIndex(BYTE byIdx, BYTE byR, BYTE byG, BYTE byB);§	void SetPixelIndex(DWORD dwX, DWORD dwY, BYTE byI);§	void BlendPalette(COLORREF crColor, DWORD dwPerc);§§	WORD GetBitCount();§	DWORD GetLineWidth();§	DWORD GetWidth();§	DWORD GetHeight();§	WORD GetNumColors();§§	BOOL WriteBMP(LPCTSTR bmpFileName);§§private:§	void FreeResources();§§	DWORD GetPaletteSize();§	DWORD GetSize();§§	RGBQUAD RGB2RGBQUAD(COLORREF cr);§§	HDIB				m_hDib;§    BITMAPINFOHEADER    m_bi;§	DWORD				m_dwLineWidth;§	WORD				m_wColors;§§	HBITMAP				m_hBitmap;	// Handle to bitmap§	HDC					m_hMemDC;	// Handle to memory DC§	LPVOID				m_lpBits;	// Pointer to actual bitmap bits§//#UC END# *4700B8F90119*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/CCeXDib|4700B8F90119
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659778454"))
	    quid       	"4700B8F90119"
	    documentation 	"ÍÎ‡ÒÒ ‰Îˇ ÔÓ‰‰ÂÊÍË ‡Ò¯ËÂÌÌ˚ı „‡ÙËÂÒÍËı ˝ÙÙÂÍÚÓ‚"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator")
	(object Class "CommonControls"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (rc)"
		    value      	"w:/shared/WinGUI/Controls/CommonControls.rc")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (rc)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CommonControls.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"rc:*4AD426890274*"
		    value      	(value Text 
|//#UC START# *4AD426890274*§// Microsoft Visual C++ generated resource script.§//§#include "winuser.h"§§#define APSTUDIO_READONLY_SYMBOLS§/////////////////////////////////////////////////////////////////////////////§//§// Generated from the TEXTINCLUDE 2 resource.§//§ §/////////////////////////////////////////////////////////////////////////////§#undef APSTUDIO_READONLY_SYMBOLS§§/////////////////////////////////////////////////////////////////////////////§// Russian resources§§#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)§#ifdef APSTUDIO_INVOKED§/////////////////////////////////////////////////////////////////////////////§//§// TEXTINCLUDE§//§§1 TEXTINCLUDE §BEGIN§    "resource.h\0"§END§§2 TEXTINCLUDE §BEGIN§    "\0"§END§§3 TEXTINCLUDE §BEGIN§    "\r\n"§    "\0"§END§§#endif    // APSTUDIO_INVOKED§§§/////////////////////////////////////////////////////////////////////////////§//§// Dialog§//§§IDD_PROGRESS_INDICATOR DIALOGEX 0, 0, 288, 63§STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION§CAPTION "Progress:"§FONT 8, "MS Shell Dlg", 400, 0, 0x1§BEGIN§    PUSHBUTTON      "Cancel",IDCANCEL,115,42,50,14§    CONTROL         "",IDC_PROGRESS_INDICATOR,"msctls_progress32",WS_BORDER,7,7,274,14§    LTEXT           "Generation in process...",IDC_PROGRESS_LABEL,7,24,78,8§END§§§/////////////////////////////////////////////////////////////////////////////§//§// DESIGNINFO§//§§#ifdef APSTUDIO_INVOKED§GUIDELINES DESIGNINFO §BEGIN§    IDD_PROGRESS_INDICATOR, DIALOG§    BEGIN§        LEFTMARGIN, 7§        RIGHTMARGIN, 281§        TOPMARGIN, 7§        BOTTOMMARGIN, 56§    END§END§#endif    // APSTUDIO_INVOKED§§#endif    // Russian resources§/////////////////////////////////////////////////////////////////////////////§§//#UC END# *4AD426890274*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local helper"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"weak"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4AD426890274*"
		    value      	"//#UC START# *4AD426890274*§#ifdef IDD_PROGRESS_INDICATOR§#undef IDD_PROGRESS_INDICATOR§#endif§§#define IDD_PROGRESS_INDICATOR          101§§#ifdef IDC_PROGRESS_INDICATOR§#undef IDC_PROGRESS_INDICATOR§#endif§§#define IDC_PROGRESS_INDICATOR          102§§#ifdef IDC_PROGRESS_LABEL§#undef IDC_PROGRESS_LABEL§#endif§§#define IDC_PROGRESS_LABEL              -1§//#UC END# *4AD426890274*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659778955"))
	    quid       	"4AD426890274"
	    documentation 	"ÂÒÛÒ˚"
	    stereotype 	"Resource"
	    language   	"MDA Generator")
	(object Class "ProgressIndicator"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/ProgressIndicator.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/ProgressIndicator.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Refcount"
		    value      	"none")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"base wnd class"
		    value      	"CWnd")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"resizeable"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_DESTR_BODY*	§	//#UC END# *4AD426A003AF_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_MESSAGE_MAP*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_MESSAGE_MAP*§	ON_BN_CLICKED(IDCANCEL, on_cancel)§	ON_BN_CLICKED(IDOK, on_ok)§	ON_MESSAGE(WM_UPDATE_LABEL_TEXT, update_label_impl)§	ON_MESSAGE(WM_PROGRESS_STEPIT, step_impl)§	//#UC END# *4AD426A003AF_MESSAGE_MAP*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_DO_DATA_EXCHANGE*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_DO_DATA_EXCHANGE*§	DDX_Control(pDX, IDC_PROGRESS_INDICATOR, m_progress);§	//#UC END# *4AD426A003AF_DO_DATA_EXCHANGE*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_ON_INIT_DLG*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_ON_INIT_DLG*§		GUARD(m_mutex);§		if (m_delegate) {§			m_progress.SetRange32 (0, m_delegate->get_progress_size ());§			m_progress.SetStep (m_delegate->get_step_size ());§			this->SetWindowText ("Progress: 0%");§		}§		//#UC END# *4AD426A003AF_ON_INIT_DLG*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4AD426A003AF_CUSTOM_INCLUDES*§//#UC END# *4AD426A003AF_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF*§/*void ProgressIndicator::PostNcDestroy () {§	CDialog::PostNcDestroy();§	if(!m_was_canceled && m_delegate) {§		try {§			if (m_delegate) {§				m_delegate->progress_indicator_closed (*this);§			}§			delete this;§		} catch (...) {§			delete this;§			throw;§		}§	}§}*/§//#UC END# *4AD426A003AF*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4AD426A003AF_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_CUSTOM_INCLUDES*§#include "shared/WinGUI/Controls/Controls.h"§//#UC END# *4AD426A003AF_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4AD426A003AF*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF*§protected:§	//virtual void PostNcDestroy ();§//#UC END# *4AD426A003AF*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/ProgressIndicator|4AD426A003AF
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659779438"))
	    quid       	"4AD426A003AF"
	    documentation 	
|œÓ„ÂÒÒ ËÌ‰ËÍ‡ÚÓ. ¬˚ÔÓÎÌÂÌ ‚ ‚Ë‰Â Õ≈ ÏÓ‰‡Î¸ÌÓ„Ó ‰Ë‡ÎÓ„‡, ÔË Á‡Í˚ÚËË "Û·Ë‚‡ÂÚ Ò‡Ï ÒÂ·ˇ", ÔÓ˝ÚÓÏÛ Ó·˙ÂÍÚ Â„Ó ÒÓÁ‰‡˛˘ËÈ ÌÂ ‰ÓÎÊÂÌ Á‡·ÓÚËÚÒˇ Ó· Û‰‡ÎÂÌËË!!!
	    
	    stereotype 	"Dialog"
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659790974"))
		    quid       	"4AD702EE00C3"
		    stereotype 	"uses"
		    supplier   	"Logical View::external::boost::lexical_cast::lexical_cast"
		    quidu      	"46FCA22B0280"))
	    operations 	(list Operations
		(object Operation "ctor"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD426BE03A6_BASE_INIT*"
			    value      	(value Text 
|//#UC START# *4AD426BE03A6_BASE_INIT*§	, m_delegate (delegate)§	, m_is_showed (false)§//#UC END# *4AD426BE03A6_BASE_INIT*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD426BE03A6_BODY*"
			    value      	(value Text 
|//#UC START# *4AD426BE03A6_BODY*§	//#UC END# *4AD426BE03A6_BODY*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659784107"))
		    quid       	"4AD426BE03A6"
		    documentation 	"ÍÓÌÒÚÛÍÚÓ"
		    stereotype 	"ctor"
		    parameters 	(list Parameters
			(object Parameter "inout delegate"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD43CA40312")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659784411"))
			    quid       	"4AD5DFE30054"
			    type       	"ProgressIndicatorDelegate"
			    quidu      	"4AD43CA40312"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "step"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD427C5028C*"
			    value      	(value Text 
|//#UC START# *4AD427C5028C*§	GUARD(m_mutex);§	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§		this->PostMessage (WM_PROGRESS_STEPIT, 0, 0);§	}§	//#UC END# *4AD427C5028C*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659784813"))
		    quid       	"4AD427C5028C"
		    documentation 	"¯‡„ ÔÓ„ÂÒÒ‡"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "step"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD427E002AC*"
			    value      	(value Text 
|//#UC START# *4AD427E002AC*§	GUARD(m_mutex);§	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§		this->update_label_text (message);§		this->PostMessage (WM_PROGRESS_STEPIT, 0, 0);§	}§	//#UC END# *4AD427E002AC*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659785159"))
		    quid       	"4AD427E002AC"
		    documentation 	"ËÌËˆËËÛÂÚ ¯‡„, ÔÂÂ‰‡ÂÚ ÒÓÓ·˘ÂÌËÂ ÓÔËÒ˚‚‡˛˘ÂÂ ¯‡„"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "message"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659785466"))
			    quid       	"4AD427EC0158"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "on_cancel"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD5DED5035E*"
			    value      	(value Text 
|//#UC START# *4AD5DED5035E*§	GUARD(m_mutex);§		§	try {§		if (m_delegate) {§			m_delegate->progress_indicator_canceled (*this);§		}§	} catch (...) {§		CDialog::OnCancel ();§		m_was_canceled = true;§		m_is_showed = false;§§		throw;§	}§	§	CDialog::OnCancel ();§	m_was_canceled = true;§	m_is_showed = false;§	//#UC END# *4AD5DED5035E*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659785868"))
		    quid       	"4AD5DED5035E"
		    documentation 	
|Ó·‡·Ó˜ÚËÍ Ì‡Ê‡ÚËˇ ÍÌÓÔÍË "Cancel"
		    
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0)
		(object Operation "update_label_text"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD5E0F70198*"
			    value      	(value Text 
|//#UC START# *4AD5E0F70198*§	GUARD(m_mutex);§	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§		char* msg = new char[text.size () + 1];§		strcpy (msg, text.c_str ());§		this->PostMessage (WM_UPDATE_LABEL_TEXT, 0, (LPARAM)msg);§	}§	//#UC END# *4AD5E0F70198*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659786210"))
		    quid       	"4AD5E0F70198"
		    documentation 	"Ó·ÌÓ‚ÎˇÂÚ ÚÂÍÒÚ ‚ IDC_PROGRESS_LABEL Ì‡ text"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "text"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659787332"))
			    quid       	"4AD5E11100BC"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "step_impl"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"45CC2F60000F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6C2080148*"
			    value      	(value Text 
|//#UC START# *4AD6C2080148*§	GUARD(m_mutex);§	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§		m_progress.StepIt ();§		unsigned int pos = static_cast<unsigned int> (m_progress.GetPos ());§		int lower = 0;§		int upper = 0;§		m_progress.GetRange (lower, upper);§		if (pos >= static_cast<unsigned int> (upper)) {§			m_progress.SetPos (upper);§			§			if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§				this->PostMessage (WM_COMMAND, MAKEWPARAM (IDOK, 0), 0);§			}§§			if (m_delegate) {§				m_delegate->progress_indicator_finished (*this);§			}§		} else {§			std::string text ("Progress: ");§			text += boost::lexical_cast<std::string> (unsigned int (ceil(float(pos*100)/float(upper))));§			text += "%";§			this->SetWindowText (text.c_str ());§		}§	}§§	return S_OK;§	//#UC END# *4AD6C2080148*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659787761"))
		    quid       	"4AD6C2080148"
		    documentation 	"Â‡ÎËÁ‡ˆËˇ ¯‡„‡ ÔÓ„ÂÒÒ ËÌ‰ËÍ‡ÚÓ‡, ÂÒÎË ÔÓ„ÂÒÒ ‰ÓÒÚË„ ÍÓÌˆ‡ - ‰Ë‡ÎÓ„ Ò ËÌ‰ËÍ‡ÚÓ Á‡Í˚‚‡ÂÚÒˇ, ÔÂÂ‰ ˝ÚËÏ ÔÓÒ˚Î‡ÂÚÒˇ ÒÓÓ·˘ÂÌËÂ progress_indicator_finished ()"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "w_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F3F0109")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659788069"))
			    quid       	"4AD6DAD6020E"
			    type       	"WPARAM"
			    quidu      	"45CC2F3F0109")
			(object Parameter "l_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F6701F4")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659788435"))
			    quid       	"4AD6DAD6023F"
			    type       	"LPARAM"
			    quidu      	"45CC2F6701F4"))
		    result     	"LRESULT"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0
		    quidu      	"45CC2F60000F")
		(object Operation "close"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6CFC00148*"
			    value      	(value Text 
|//#UC START# *4AD6CFC00148*§	GUARD(m_mutex);§	if(!m_was_canceled && m_delegate) {§		try {§			if (m_delegate) {§				m_delegate->progress_indicator_closed (*this);§			}§			if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§				this->PostMessage (WM_COMMAND, MAKEWPARAM (IDOK, 0), 0);§			}§		} catch (...) {§			if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {§				this->PostMessage (WM_COMMAND, MAKEWPARAM (IDOK, 0), 0);§			}§			throw;§		}§	}§	//#UC END# *4AD6CFC00148*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659788838"))
		    quid       	"4AD6CFC00148"
		    documentation 	"Á‡Í˚Ú¸ ‰Ë‡ÎÓ„"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "update_label_impl"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"45CC2F60000F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6DAE3001C*"
			    value      	(value Text 
|//#UC START# *4AD6DAE3001C*§	char* str = (char*)l_param;§	std::string text (str);§	delete [] str;§§	GUARD(m_mutex);§	CWnd* label = this->GetDlgItem (IDC_PROGRESS_LABEL);§	if (label) {§		label->SetWindowText (text.c_str ());§	}§§	return S_OK;§	//#UC END# *4AD6DAE3001C*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659789178"))
		    quid       	"4AD6DAE3001C"
		    documentation 	"Ó·‡·ÓÚ˜ËÍ ÒÓÓ·˘ÂÌËˇ WM_UPDATE_LABEL_TEXT"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "w_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F3F0109")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659789485"))
			    quid       	"4AD6DB1A021F"
			    type       	"WPARAM"
			    quidu      	"45CC2F3F0109")
			(object Parameter "l_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F6701F4")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659789843"))
			    quid       	"4AD6DB1A0252"
			    type       	"LPARAM"
			    quidu      	"45CC2F6701F4"))
		    result     	"LRESULT"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0
		    quidu      	"45CC2F60000F")
		(object Operation "show"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6F7840166*"
			    value      	(value Text 
|//#UC START# *4AD6F7840166*§	bool need_show = false;§	{§		GUARD(m_mutex);§		if (m_is_showed == false) {§			need_show = true;§			m_is_showed = true;§		}§	}§	if (need_show) {§		try {§			this->DoModal ();§			{§				GUARD(m_mutex);§				m_is_showed = false;§			}§			delete this;§		} catch (...) {§			{§				GUARD(m_mutex);§				m_is_showed = false;§			}§			delete this;§			throw;§		}		§	}§	//#UC END# *4AD6F7840166*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659790260"))
		    quid       	"4AD6F7840166"
		    documentation 	"ÔÓÍ‡Á‡Ú¸ ‰Ë‡ÎÓ„"
		    stereotype 	"oneway,chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "on_ok"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD702720358*"
			    value      	(value Text 
|//#UC START# *4AD702720358*§	GUARD(m_mutex);§	CDialog::OnOK ();§	//#UC END# *4AD702720358*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659790602"))
		    quid       	"4AD702720358"
		    documentation 	"Á‡Í˚‚‡ÂÚ ‰Ë‡ÎÓ„"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "was_canceled"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"3DBFFE100240")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659782193"))
		    quid       	"4AD6C1390067"
		    documentation 	
|ÒÓ·˚ÚËÂ Ó ÚÓÏ, ˜ÚÓ ·˚Î‡ Ì‡Ê‡Ú‡ ÍÌÓÔÍ‡ "Cancel"
		    
		    type       	"boolean"
		    quidu      	"3DBFFE100240"
		    initv      	"false"
		    Containment 	"By Value")
		(object ClassAttribute "mutex"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"finished"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is mutable"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"smart pointer"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450E6C340232")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659782569"))
		    quid       	"4AD6F7DF00C8"
		    documentation 	"Ï¸˛ÚÂÍÒ ‰ˇÎ ÒËÌıÓÌËÁ‡ˆËË"
		    type       	"mutex"
		    quidu      	"450E6C340232"
		    Containment 	"By Value")
		(object ClassAttribute "is_showed"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"3DBFFE100240")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659782918"))
		    quid       	"4AD6F7F70141"
		    documentation 	"ÙÎ‡„, ˜ÚÓ ‰ËÎÓ„ ÔÓÍ‡Á‡Ì Ì‡ ˝Í‡ÌÂ"
		    type       	"boolean"
		    quidu      	"3DBFFE100240"
		    Containment 	"By Value"))
	    language   	"MDA Generator"
	    nestedClasses 	(list nestedClasses
		(object Class "Messages"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659779863"))
		    quid       	"4AD6DB87005B"
		    documentation 	"ÒÓÓ·˘ÂÌËˇ"
		    stereotype 	"Constants"
		    class_attributes 	(list class_attribute_list
			(object ClassAttribute "WM_UPDATE_LABEL_TEXT"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFDE101CA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659781117"))
			    quid       	"4AD6DB9601EB"
			    documentation 	"ÒÓÓ·˘ÂÌËÂ Ó· Ó·ÌÓ‚ÎÂÌËË ÚÂÍÒÚ‡ Î˝È·Î‡"
			    type       	"unsigned long"
			    quidu      	"3DBFFDE101CA"
			    initv      	"WM_USER + 1000"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "WM_PROGRESS_STEPIT"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFDE101CA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659781585"))
			    quid       	"4AD6DC760061"
			    documentation 	"ÒÓÓ·˘ÂÌËÂ Ó ¯‡„Â"
			    type       	"unsigned long"
			    quidu      	"3DBFFDE101CA"
			    initv      	"WM_USER + 1001"
			    exportControl 	"Public"
			    Containment 	"By Value")))))
	(object Class "ProgressIndicatorDelegate"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/ÃÓ‰ÂÎ¸ ÔÓÂÍÚ‡ "shared"/WinGUI/Controls/ProgressIndicatorDelegate|4AD43CA40312
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16663702216"))
	    quid       	"4AD43CA40312"
	    documentation 	"‰ÂÎÂ„‡Ú ‰Îˇ ËÌ‰ËÍ‡ÚÓ‡"
	    stereotype 	"Facet"
	    operations 	(list Operations
		(object Operation "progress_indicator_canceled"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E310354_4AD423B900A4*"
			    value      	(value Text 
|//#UC START# *4AD43E310354_4AD423B900A4*§	GUARD (m_mutex);§	m_indicator = 0;	§	//#UC END# *4AD43E310354_4AD423B900A4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659792720"))
		    quid       	"4AD43E310354"
		    documentation 	
|Ó·‡·ÓÚ˜ËÍ Ì‡Ê‡ÚËˇ ÍÌÓÔÍË "CANCEL" ÔË ˝ÚÓÏ ÒÓ·˚ÚËÂ progress_indicator_closed ÌÂ ‚˚Á˚‚‡ÂÚÒˇ!
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "indicator"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD426A003AF")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659793023"))
			    quid       	"4AD43E6F00A5"
			    type       	"ProgressIndicator"
			    quidu      	"4AD426A003AF"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "progress_indicator_finished"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6C07103E7_4AD423B900A4*"
			    value      	(value Text 
|//#UC START# *4AD6C07103E7_4AD423B900A4*§	GUARD (m_mutex);§	m_indicator = 0;§	//#UC END# *4AD6C07103E7_4AD423B900A4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659793436"))
		    quid       	"4AD6C07103E7"
		    documentation 	"ÒÓ·‡ÚËÂ  Ó ÚÓÏ, ˜ÚÓ ÔÓ„ÂÒÒ ·‡ ‰Ó¯ÂÎ ‰Ó ÍÓÌˆ‡"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "indicator"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD426A003AF")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659793734"))
			    quid       	"4AD6C0A2027A"
			    type       	"ProgressIndicator"
			    quidu      	"4AD426A003AF"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "progress_indicator_closed"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6C0F50143_4AD423B900A4*"
			    value      	(value Text 
|//#UC START# *4AD6C0F50143_4AD423B900A4*§	GUARD (m_mutex);§	m_indicator = 0;§	//#UC END# *4AD6C0F50143_4AD423B900A4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659794133"))
		    quid       	"4AD6C0F50143"
		    documentation 	"ÒÓ·˚ÚËÂ Ó Á‡Í˚ÚËË ÓÍÌ‡ ÔÓ„ÂÒÒ ËÌ‰ËÍ‡ÚÓ‡"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "indicator"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD426A003AF")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659794478"))
			    quid       	"4AD6C10B0174"
			    type       	"ProgressIndicator"
			    quidu      	"4AD426A003AF"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "progress_size"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_GET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_GET_ACCESSOR*§	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);§	//#UC END# *4AD43E140385_GET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_SET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_SET_ACCESSOR*§	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);§	//#UC END# *4AD43E140385_SET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"calling conventions"
			    value      	"none")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"finished"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force use const arg"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is default"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is mutable"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"needs field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"pm"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"reads field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"smart pointer"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"writes field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_4AD423B900A4_GET*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_4AD423B900A4_GET*§	return m_progress_size;§	//#UC END# *4AD43E140385_4AD423B900A4_GET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_4AD423B900A4_SET*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_4AD423B900A4_SET*§	m_progress_size = progress_size;§	//#UC END# *4AD43E140385_4AD423B900A4_SET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A6117003E")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659791949"))
		    quid       	"4AD43E140385"
		    documentation 	"‡ÁÏÂ ÔÓ„ÂÒÒ-ËÌ‰ËÍ‡ÚÓ‡"
		    stereotype 	"property"
		    type       	"unsigned integer"
		    quidu      	"450A6117003E"
		    exportControl 	"Public"
		    Containment 	"By Value")
		(object ClassAttribute "step_size"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_GET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_GET_ACCESSOR*§	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);§	//#UC END# *4AD43E170080_GET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_SET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_SET_ACCESSOR*§	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);§	//#UC END# *4AD43E170080_SET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"calling conventions"
			    value      	"none")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"finished"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force use const arg"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is default"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is mutable"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"needs field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"pm"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"reads field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"smart pointer"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"writes field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_4AD423B900A4_GET*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_4AD423B900A4_GET*§	return m_step_size;§	//#UC END# *4AD43E170080_4AD423B900A4_GET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_4AD423B900A4_SET*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_4AD423B900A4_SET*§	m_step_size = step_size;§	//#UC END# *4AD43E170080_4AD423B900A4_SET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A6117003E")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659792332"))
		    quid       	"4AD43E170080"
		    documentation 	"ÛÒÚ‡Ì‡‚ÎË‚‡ÂÚ ‡ÁÏÂ ¯‡„‡"
		    stereotype 	"property"
		    type       	"unsigned integer"
		    quidu      	"450A6117003E"
		    exportControl 	"Public"
		    Containment 	"By Value"))
	    language   	"MDA Generator")
	(object Association "$UNNAMED$0"
	    quid       	"46960BF40261"
	    roles      	(list role_list
		(object Role "image_path_to_index"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659769733"))
		    quid       	"46960BF500BB"
		    documentation 	
|Ï‡Ô‡: "ÔÛÚ¸ Í Ù‡ÈÎÛ Ò ËÁÓ·‡ÊÂÌËÂÏ" -> ËÌ‰ÂÍÒ ‚ ImageList'Â
		    
		    label      	"image_path_to_index"
		    supplier   	"Logical View::shared::WinGUI::Controls::CImageListEx::ImagePathToIndex"
		    quidu      	"46960BC80119"
		    Containment 	"By Value"
		    exportControl 	"Private"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$1"
		    quid       	"46960BF500CB"
		    supplier   	"Logical View::shared::WinGUI::Controls::CImageListEx"
		    quidu      	"46960B1401F4"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$2"
	    quid       	"46960C3002DE"
	    roles      	(list role_list
		(object Role "$UNNAMED$3"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659767959"))
		    quid       	"46960C31009C"
		    supplier   	"Logical View::Primitives::unsigned integer"
		    quidu      	"450A6117003E"
		    keys       	(list class_attribute_list
			(object ClassAttribute "key"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659768290"))
			    quid       	"46960C3A034B"
			    type       	"a-string"
			    exportControl 	"Public"
			    Containment 	"By Value"))
		    Containment 	"By Value"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$4"
		    quid       	"46960C31009E"
		    supplier   	"Logical View::shared::WinGUI::Controls::CImageListEx::ImagePathToIndex"
		    quidu      	"46960BC80119"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$5"
	    quid       	"4AD427080065"
	    roles      	(list role_list
		(object Role "progress"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659783294"))
		    quid       	"4AD427120271"
		    documentation 	"ÍÓÌÚÓÎÎ ‰Îˇ ÓÚÓ·‡ÊÂÌËˇ ÔÓˆÂÒÒ‡"
		    label      	"progress"
		    supplier   	"Logical View::external::MFCTypes::Controls::CProgressCtrl"
		    quidu      	"4AD426EA0372"
		    Containment 	"By Value"
		    exportControl 	"Private"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$6"
		    quid       	"4AD427120274"
		    supplier   	"Logical View::shared::WinGUI::Controls::ProgressIndicator"
		    quidu      	"4AD426A003AF"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$7"
	    quid       	"4AD43CD2023C"
	    roles      	(list role_list
		(object Role "delegate"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43CD20389_GET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43CD20389_GET_ACCESSOR*§	GUARD(m_mutex);§	return m_delegate;§	//#UC END# *4AD43CD20389_GET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43CD20389_SET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43CD20389_SET_ACCESSOR*§	GUARD(m_mutex);§	m_delegate = delegate;§	//#UC END# *4AD43CD20389_SET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659783732"))
		    quid       	"4AD43CD20389"
		    documentation 	"‰ÂÎÂ„‡Ú, Â‡ÎËÁÛ˛˘ËÈ ÎÓ„ËÍÛ Ò‚ˇÁ‡ÌÌÛ˛ Ò ‡·ÓÚÓÈ ËÌ‰ËÍ‡ÚÓ‡ Ë Ó·ÂÒÔÂ˜Ë‚‡˛˘ËÈ Â„Ó ‰‡ÌÌ˚ÏË"
		    stereotype 	"property"
		    label      	"delegate"
		    supplier   	"Logical View::shared::WinGUI::Controls::ProgressIndicatorDelegate"
		    quidu      	"4AD43CA40312"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$8"
		    quid       	"4AD43CD2038B"
		    supplier   	"Logical View::shared::WinGUI::Controls::ProgressIndicator"
		    quidu      	"4AD426A003AF"))))
    logical_presentations 	(list unit_reference_list
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsChanged"
		    value      	""))
	    quid       	"46960ABA0119"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	1384
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::external::MFCTypes::Types::CImageList" @1
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"522")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"141")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(522, 141)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@1
			location   	(357, 113)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"ï CImageList")
		    stereotype 	(object ItemLabel
			Parent_View 	@1
			location   	(357, 63)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"46960AE00157"
		    width      	348
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CImageListEx" @2
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1002")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1161")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"1810")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"642"))
		    location   	(1002, 1161)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@2
			location   	(116, 902)
			fill_color 	13434879
			nlines     	1
			max_width  	1772
			justify    	0
			label      	"CImageListEx")
		    stereotype 	(object ItemLabel
			Parent_View 	@2
			location   	(116, 852)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1772
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"46960B1401F4"
		    width      	1790
		    height     	642
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::Primitives::unsigned integer" @3
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1770")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"108")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"404")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"116"))
		    location   	(1770, 108)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	TRUE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@3
			location   	(1577, 62)
			fill_color 	13434879
			nlines     	1
			max_width  	386
			justify    	0
			label      	"unsigned integer")
		    icon_style 	"None"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"450A6117003E"
		    width      	404
		    height     	117
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CImageListEx::ImagePathToIndex" @4
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1782")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"552")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"382")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(1782, 552)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	6572835
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@4
			location   	(1600, 524)
			nlines     	1
			max_width  	364
			justify    	0
			label      	"ImagePathToIndex")
		    stereotype 	(object ItemLabel
			Parent_View 	@4
			location   	(1600, 474)
			anchor     	10
			nlines     	1
			max_width  	364
			justify    	0
			label      	"<<Map>>")
		    icon_style 	"Label"
		    line_color 	6572835
		    fill_color 	16777215
		    quidu      	"46960BC80119"
		    width      	382
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object AssociationViewNew "$UNNAMED$0" @5
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"1410,839;1664,642"))
		    location   	(1538, 740)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"46960BF40261"
		    roleview_list 	(list RoleViews
			(object RoleView "image_path_to_index" @6
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1538,740;1664,642"))
			    Parent_View 	@5
			    location   	(644, -61)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    label      	(object SegLabel @7
				Parent_View 	@6
				location   	(1529, 702)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	1
				anchor_loc 	1
				nlines     	1
				max_width  	412
				justify    	0
				label      	"-image_path_to_index"
				pctDist    	0.109719
				height     	37
				orientation 	0)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960BF500BB"
			    client     	@5
			    supplier   	@4
			    vertices   	(list Points
				(1538, 740)
				(1664, 642))
			    line_style 	0)
			(object RoleView "$UNNAMED$1" @8
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1538,740;1410,839"))
			    Parent_View 	@5
			    location   	(644, -61)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960BF500CB"
			    client     	@5
			    supplier   	@2
			    vertices   	(list Points
				(1538, 740)
				(1410, 839))
			    line_style 	0)))
		(object AssociationViewNew "$UNNAMED$2" @9
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"1779,461;1771,166"))
		    location   	(1775, 313)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"46960C3002DE"
		    roleview_list 	(list RoleViews
			(object RoleView "$UNNAMED$3" @10
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1775,313;1771,166"))
			    Parent_View 	@9
			    location   	(884, -959)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960C31009C"
			    client     	@9
			    supplier   	@3
			    vertices   	(list Points
				(1775, 313)
				(1771, 166))
			    line_style 	0)
			(object RoleView "$UNNAMED$4" @11
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1775,313;1779,461"))
			    Parent_View 	@9
			    location   	(884, -959)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960C31009E"
			    client     	@9
			    supplier   	@4
			    vertices   	(list Points
				(1775, 313)
				(1778, 461))
			    line_style 	0
			    label      	(object SegLabel @12
				Parent_View 	@11
				location   	(1779, 420)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	5
				anchor_loc 	1
				nlines     	1
				max_width  	234
				justify    	0
				label      	"key : a-string"
				pctDist    	0.900000
				height     	12
				orientation 	1))))
		(object InheritView "" @13
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"850,839;564,231"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"46960C560119"
		    client     	@2
		    supplier   	@1
		    vertices   	(list Points
			(850, 839)
			(564, 231))
		    line_style 	0)
		(object ClassView "Class" "Logical View::external::cximage::CxImageUnit::CxImage" @14
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1146")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"141")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(1146, 141)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@14
			location   	(981, 113)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"ï CxImage")
		    stereotype 	(object ItemLabel
			Parent_View 	@14
			location   	(981, 63)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"4649B9520148"
		    width      	348
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @15
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"1047,839;1132,231"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	(object SegLabel @16
			Parent_View 	@15
			location   	(1152, 440)
			font       	(object Font
			    size       	10
			    face       	"Arial"
			    charSet    	204
			    bold       	FALSE
			    italics    	FALSE
			    underline  	FALSE
			    strike     	FALSE
			    color      	0
			    default_color 	TRUE)
			anchor     	10
			anchor_loc 	1
			nlines     	1
			max_width  	450
			justify    	0
			label      	"<<uses>>"
			pctDist    	0.669625
			height     	48
			orientation 	1)
		    line_color 	3947680
		    quidu      	"469610550167"
		    client     	@2
		    supplier   	@14
		    vertices   	(list Points
			(1047, 839)
			(1132, 231))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ETSLayout" @17
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"2259")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"957")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"318")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(2259, 957)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@17
			location   	(2110, 927)
			fill_color 	13434879
			nlines     	1
			max_width  	298
			justify    	0
			label      	"ï ETSLayout")
		    stereotype 	(object ItemLabel
			Parent_View 	@17
			location   	(2110, 877)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	298
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"46A88BDA035B"
		    width      	316
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CPPToolTip" @18
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"294")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1980")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(294, 1980)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@18
			location   	(129, 1950)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"ï CPPToolTip")
		    stereotype 	(object ItemLabel
			Parent_View 	@18
			location   	(129, 1900)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B6AC00CB"
		    width      	348
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CPPHtmlDrawer" @19
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"696")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1656")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(696, 1656)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@19
			location   	(511, 1626)
			fill_color 	13434879
			nlines     	1
			max_width  	370
			justify    	0
			label      	"ï CPPHtmlDrawer")
		    stereotype 	(object ItemLabel
			Parent_View 	@19
			location   	(511, 1576)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	370
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B81F006D"
		    width      	388
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CPPDrawManager" @20
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1137")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1671")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"388")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1137, 1671)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@20
			location   	(939, 1641)
			fill_color 	13434879
			nlines     	1
			max_width  	396
			justify    	0
			label      	"ï CPPDrawManager")
		    stereotype 	(object ItemLabel
			Parent_View 	@20
			location   	(939, 1591)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	396
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B8C80280"
		    width      	414
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CCeXDib" @21
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1572")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1665")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1572, 1665)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@21
			location   	(1407, 1635)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"ï CCeXDib")
		    stereotype 	(object ItemLabel
			Parent_View 	@21
			location   	(1407, 1585)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B8F90119"
		    width      	348
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::external::MFCTypes::Controls::CWnd" @22
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"276")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1641")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(276, 1641)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@22
			location   	(111, 1613)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"ï CWnd")
		    stereotype 	(object ItemLabel
			Parent_View 	@22
			location   	(111, 1563)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"4652B53F01F4"
		    width      	348
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object InheritView "" @23
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"288,1887;280,1731"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"4700C599006D"
		    client     	@18
		    supplier   	@22
		    vertices   	(list Points
			(288, 1887)
			(280, 1731))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CommonControls" @24
		    ShowCompartmentStereotypes 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(2397, 183)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@24
			location   	(2218, 153)
			fill_color 	13434879
			nlines     	1
			max_width  	358
			justify    	0
			label      	"CommonControls")
		    stereotype 	(object ItemLabel
			Parent_View 	@24
			location   	(2218, 103)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	358
			justify    	0
			label      	"<<Resource>>")
		    icon_style 	"Label"
		    fill_color 	16769520
		    quidu      	"4AD426890274"
		    width      	376
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::external::MFCTypes::Controls::CProgressCtrl" @25
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    location   	(2361, 2958)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@25
			location   	(2188, 2930)
			fill_color 	13434879
			nlines     	1
			max_width  	346
			justify    	0
			label      	"ï CProgressCtrl")
		    stereotype 	(object ItemLabel
			Parent_View 	@25
			location   	(2188, 2880)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	346
			justify    	0
			label      	"<<GuiControl>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"4AD426EA0372"
		    width      	364
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ProgressIndicatorDelegate" @26
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(2061, 2007)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@26
			location   	(1425, 1848)
			fill_color 	13434879
			nlines     	1
			max_width  	1272
			justify    	0
			label      	"ï ProgressIndicatorDelegate")
		    stereotype 	(object ItemLabel
			Parent_View 	@26
			location   	(1425, 1798)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1272
			justify    	0
			label      	"<<Facet>>")
		    icon_style 	"Label"
		    fill_color 	16766935
		    quidu      	"4AD43CA40312"
		    width      	1290
		    height     	442
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ProgressIndicator" @27
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(858, 2958)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@27
			location   	(83, 2599)
			fill_color 	13434879
			nlines     	1
			max_width  	1550
			justify    	0
			label      	"ï ProgressIndicator")
		    stereotype 	(object ItemLabel
			Parent_View 	@27
			location   	(83, 2549)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1550
			justify    	0
			label      	"<<Dialog>>")
		    icon_style 	"Label"
		    line_color 	7885055
		    fill_color 	15448575
		    quidu      	"4AD426A003AF"
		    width      	1568
		    height     	842
		    annotation 	8
		    autoResize 	TRUE)
		(object AssociationViewNew "$UNNAMED$5" @28
		    location   	(1910, 2958)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3342489
		    quidu      	"4AD427080065"
		    roleview_list 	(list RoleViews
			(object RoleView "progress" @29
			    Parent_View 	@28
			    location   	(857, 675)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    label      	(object SegLabel @30
				Parent_View 	@29
				location   	(1891, 3011)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	1
				anchor_loc 	1
				nlines     	1
				max_width  	190
				justify    	0
				label      	"-progress"
				pctDist    	-0.073446
				height     	53
				orientation 	1)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"4AD427120271"
			    client     	@28
			    supplier   	@25
			    vertices   	(list Points
				(1910, 2958)
				(2178, 2958))
			    line_style 	0)
			(object RoleView "$UNNAMED$6" @31
			    Parent_View 	@28
			    location   	(857, 675)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"4AD427120274"
			    client     	@28
			    supplier   	@27
			    vertices   	(list Points
				(1910, 2958)
				(1642, 2958))
			    line_style 	0)))
		(object AssociationViewNew "$UNNAMED$7" @32
		    location   	(1583, 2382)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3342489
		    quidu      	"4AD43CD2023C"
		    roleview_list 	(list RoleViews
			(object RoleView "delegate" @33
			    Parent_View 	@32
			    location   	(944, 15)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    label      	(object SegLabel @34
				Parent_View 	@33
				location   	(1127, 2475)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	1
				anchor_loc 	1
				nlines     	1
				max_width  	184
				justify    	0
				label      	"+delegate"
				pctDist    	-1.675349
				height     	210
				orientation 	0)
			    stereotype 	(object SegLabel @35
				Parent_View 	@33
				location   	(1152, 2397)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	10
				anchor_loc 	1
				nlines     	1
				max_width  	450
				justify    	0
				label      	"<<property>>"
				pctDist    	-1.400509
				height     	276
				orientation 	0)
			    line_color 	3342489
			    quidu      	"4AD43CD20389"
			    client     	@32
			    supplier   	@26
			    vertices   	(list Points
				(1583, 2382)
				(1777, 2228))
			    line_style 	0)
			(object RoleView "$UNNAMED$8" @36
			    Parent_View 	@32
			    location   	(944, 15)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"4AD43CD2038B"
			    client     	@32
			    supplier   	@27
			    vertices   	(list Points
				(1583, 2382)
				(1387, 2536))
			    line_style 	0)))
		(object ClassView "Class" "Logical View::external::boost::lexical_cast::lexical_cast" @37
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    location   	(2370, 3321)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@37
			location   	(2209, 3293)
			fill_color 	13434879
			nlines     	1
			max_width  	322
			justify    	0
			label      	"ï lexical_cast")
		    stereotype 	(object ItemLabel
			Parent_View 	@37
			location   	(2209, 3243)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	322
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"46FCA22B0280"
		    width      	340
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @38
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	(object SegLabel @39
			Parent_View 	@38
			location   	(1949, 3095)
			font       	(object Font
			    size       	10
			    face       	"Arial"
			    charSet    	204
			    bold       	FALSE
			    italics    	FALSE
			    underline  	FALSE
			    strike     	FALSE
			    color      	0
			    default_color 	TRUE)
			anchor     	10
			anchor_loc 	1
			nlines     	1
			max_width  	450
			justify    	0
			label      	"<<uses>>"
			pctDist    	0.500000
			height     	120
			orientation 	0)
		    line_color 	3342489
		    quidu      	"4AD702EE00C3"
		    client     	@27
		    supplier   	@37
		    vertices   	(list Points
			(1642, 3144)
			(2199, 3278))
		    line_style 	0)))
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ClassUID"
		    value      	"4AD426A003AF")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsChanged"
		    value      	""))
	    quid       	"4AD6DB820348"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	0
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ProgressIndicator::Messages" @40
		    ShowCompartmentStereotypes 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(780, 456)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@40
			location   	(147, 374)
			fill_color 	13434879
			nlines     	1
			max_width  	1266
			justify    	0
			label      	"Messages")
		    stereotype 	(object ItemLabel
			Parent_View 	@40
			location   	(147, 324)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1266
			justify    	0
			label      	"<<Constants>>")
		    icon_style 	"Label"
		    fill_color 	16119285
		    quidu      	"4AD6DB87005B"
		    width      	1284
		    height     	288
		    annotation 	8
		    autoResize 	TRUE)))))
