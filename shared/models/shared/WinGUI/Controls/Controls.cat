
(object Petal
    version    	50
    _written   	"Rose 2006.0.0.061205"
    charSet    	204)

(object Class_Category "Controls"
    is_unit    	TRUE
    is_loaded  	TRUE
    attributes 	(list Attribute_Set
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"AbstarctOperation"
	    value      	"regular")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"IsNative"
	    value      	"false")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (h)"
	    value      	"w:/shared/WinGUI/Controls/CCeXDib.h::4700B8F90119,w:/shared/WinGUI/Controls/CImageListEx.h::46960B1401F4,w:/shared/WinGUI/Controls/CPPDrawManager.h::4700B8C80280,w:/shared/WinGUI/Controls/CPPHtmlDrawer.h::4700B81F006D,w:/shared/WinGUI/Controls/CPPToolTip.h::4700B6AC00CB,w:/shared/WinGUI/Controls/ETSLayout.h::46A88BDA035B")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED FILES (cpp)"
	    value      	"w:/shared/WinGUI/Controls/CCeXDib.cpp::4700B8F90119,w:/shared/WinGUI/Controls/CImageListEx.cpp::46960B1401F4,w:/shared/WinGUI/Controls/CPPDrawManager.cpp::4700B8C80280,w:/shared/WinGUI/Controls/CPPHtmlDrawer.cpp::4700B81F006D,w:/shared/WinGUI/Controls/CPPToolTip.cpp::4700B6AC00CB,w:/shared/WinGUI/Controls/ETSLayout.cpp::46A88BDA035B")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"NESTED GENERATED WikiPageID (wiki)"
	    value      	(value Text 
|Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CCeXDib|4700B8F90119::4700B8F90119;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPDrawManager|4700B8C80280::4700B8C80280;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPHtmlDrawer|4700B81F006D::4700B81F006D;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB::4700B6AC00CB;Shared (c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B::46A88BDA035B;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/Модель проекта "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (c++),key:SHR,guid:45ED9AFC026A/Home/Модель проекта "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB::4700B6AC00CB;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CCeXDib|4700B8F90119::4700B8F90119;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPDrawManager|4700B8C80280::4700B8C80280;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPHtmlDrawer|4700B81F006D::4700B81F006D;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB::4700B6AC00CB;Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B::46A88BDA035B;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CImageListEx|46960B1401F4::46960B1401F4;Shared (java/c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B::46A88BDA035B
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"WikiPageID (wiki)"
	    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls|46960AAE0251
	    ))
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SourceType (wiki)"
	    value      	"wiki")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SELF GENERATED FILE (h)"
	    value      	"w:/shared/WinGUI/Controls/Controls.h")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"SourceType (h)"
	    value      	"file")
	(object Attribute
	    tool       	"MDA Generator"
	    name       	"ElementCreationOrder"
	    value      	"16659753046"))
    quid       	"46960AAE0251"
    documentation 	"пакет контролов"
    stereotype 	"Views"
    visible_categories 	(list visibility_relationship_list
	(object Visibility_Relationship
	    quid       	"46960ACC01B5"
	    supplier   	"Logical View::external::MFCTypes::Types"
	    quidu      	"4652B4FB036B")
	(object Visibility_Relationship
	    quid       	"4696104001B5"
	    supplier   	"Logical View::external::cximage::CxImageUnit"
	    quidu      	"4649B9200222"))
    exportControl 	"Public"
    logical_models 	(list unit_reference_list
	(object Class "CImageListEx"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CImageListEx.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CImageListEx.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*46960B1401F4_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *46960B1401F4_DESTR_BODY*¤	//#UC END# *46960B1401F4_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ImplementSelectType"
		    value      	"all")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"OverloadSelectType"
		    value      	"include")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CImageListEx|46960B1401F4
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659767117"))
	    quid       	"46960B1401F4"
	    documentation 	"Расширенный ImageList, позволяет формировать список изображений из отдельных файлов-картинок"
	    stereotype 	"SimpleClass"
	    superclasses 	(list inheritance_relationship_list
		(object Inheritance_Relationship
		    quid       	"46960C560119"
		    supplier   	"Logical View::external::MFCTypes::Types::CImageList"
		    quidu      	"46960AE00157"))
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659775854"))
		    quid       	"469610550167"
		    stereotype 	"uses"
		    supplier   	"Logical View::external::cximage::CxImageUnit::CxImage"
		    quidu      	"4649B9520148"))
	    operations 	(list Operations
		(object Operation "add"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46960C7C0138*"
			    value      	(value Text 
|//#UC START# *46960C7C0138*¤	¤	ImagePathToIndex::const_iterator it = m_image_path_to_index.find (path);¤	if (it != m_image_path_to_index.end ()) {¤		return it->second;¤	} else if (ACE_OS::access(path.c_str (), F_OK) != -1) { //file exists		¤		CxImage image;¤		if (¤			image.Load (path.c_str ())¤			&& image.IsValid ()¤		) {¤			int idx = -1;¤			/*RGBQUAD rgbquad_mask = image.GetPixelColor (0, 0, false);¤			COLORREF rgb_mask = RGB (¤				rgbquad_mask.rgbRed, rgbquad_mask.rgbGreen, rgbquad_mask.rgbBlue¤			);*/¤			HBITMAP bitmap = image.MakeBitmap ();¤			if (bitmap != NULL) {¤				idx = this->add_image (bitmap, 1);¤				if (idx != -1) {¤					m_image_path_to_index.insert (ImagePathToIndex::value_type (path, idx));¤				}				¤				DeleteObject (bitmap);¤			}¤			return idx;¤		}¤	}¤	return -1;¤	//#UC END# *46960C7C0138*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659770117"))
		    quid       	"46960C7C0138"
		    documentation 	
|Добавляет изображение в список.
|path - путь к файлу с изображением
|в случае успешного добавления возвращает индекс изображения в списке, иначе возврщает -1
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "path"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659770417"))
			    quid       	"4696156F034B"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    result     	"integer"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"450A61050251")
		(object Operation "get_image_index"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46960D0B034B*"
			    value      	(value Text 
|//#UC START# *46960D0B034B*¤	ImagePathToIndex::const_iterator it = m_image_path_to_index.find (path);¤	if (it != m_image_path_to_index.end ()) {¤		return it->second;¤	} else {¤		return this->add (path);¤	}¤	return -1;¤	//#UC END# *46960D0B034B*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659770834"))
		    quid       	"46960D0B034B"
		    documentation 	"возвращает индекс изображения, соответствующего пути (path)"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "path"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659771135"))
			    quid       	"46976C12004E"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    result     	"integer"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"450A61050251")
		(object Operation "delete_list"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4696256F031C*"
			    value      	(value Text 
|//#UC START# *4696256F031C*¤	m_cx = -1;¤	m_cy = -1;¤	m_image_path_to_index.clear ();¤	this->DeleteImageList();¤	//#UC END# *4696256F031C*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659771537"))
		    quid       	"4696256F031C"
		    documentation 	"удаляет ImageList, очищает мапу"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "remove_images"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*46976C1800DA*"
			    value      	(value Text 
|//#UC START# *46976C1800DA*¤	for (int i = 0; i < this->GetImageCount (); ++i) {¤		this->Remove (i);¤	}¤	m_image_path_to_index.clear ();¤	//#UC END# *46976C1800DA*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659771893"))
		    quid       	"46976C1800DA"
		    documentation 	"удаляет изображения из списка"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "create"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C88D80109*"
			    value      	(value Text 
|//#UC START# *469C88D80109*¤	m_cx = cx;¤	m_cy = cy;¤	this->Create (cx, cy, flags, initial, grow);¤	//#UC END# *469C88D80109*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659772237"))
		    quid       	"469C88D80109"
		    documentation 	
|аналог Create из MSDN:
|cx - размер каждого изображения
|cy - размер каждого изображения
|flags - флаги, задающие тип
|initial - сколько изображений лист хранит сначала
|grow - на сколько растет список при добавлении изображения
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "cx"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659772532"))
			    quid       	"469C89C5003E"
			    type       	"integer"
			    quidu      	"450A61050251")
			(object Parameter "cy"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659772906"))
			    quid       	"469C89C5008C"
			    type       	"integer"
			    quidu      	"450A61050251")
			(object Parameter "flags"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A6117003E")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659773260"))
			    quid       	"469C89C500EA"
			    type       	"unsigned integer"
			    quidu      	"450A6117003E")
			(object Parameter "initial"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659773611"))
			    quid       	"469C89C50148"
			    type       	"integer"
			    quidu      	"450A61050251")
			(object Parameter "grow"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659773991"))
			    quid       	"469C89C50196"
			    type       	"integer"
			    quidu      	"450A61050251"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "new_ctor_op"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C8A0F03D8_BASE_INIT*"
			    value      	"//#UC START# *469C8A0F03D8_BASE_INIT*¤: m_cx (-1), m_cy (-1)¤//#UC END# *469C8A0F03D8_BASE_INIT*")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C8A0F03D8_BODY*"
			    value      	(value Text 
|//#UC START# *469C8A0F03D8_BODY*¤	//#UC END# *469C8A0F03D8_BODY*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659774401"))
		    quid       	"469C8A0F03D8"
		    documentation 	"конструктор"
		    stereotype 	"ctor"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "add_image"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*469C8E2301C5*"
			    value      	(value Text 
|//#UC START# *469C8E2301C5*¤	class _local {¤	public:¤		static void fill_dc (HDC dc, const COLORREF& row_color) {¤			HBRUSH backBrush= (HBRUSH)(row_color);				¤			// Save old brush¤			HBRUSH pOldBrush = (HBRUSH)::SelectObject(dc, backBrush);¤			¤			RECT rect;¤			::GetClipBox(dc, &rect);     // Erase the area needed¤			¤			//paint the given rectangle using the brush that is currently selected ¤			//into the specified device context¤			::PatBlt(dc, rect.left, rect.top, abs(rect.left - rect.right),abs(rect.top-rect.bottom ),PATCOPY);¤¤			//Select back the old brush¤			::SelectObject(dc,pOldBrush);¤			DeleteObject (backBrush);¤		}¤		static HBITMAP add_rows (CBitmap* src, const long row_count,  const COLORREF& row_color) {	¤			HBITMAP ret = NULL;¤			if (src) {¤				HDC dc = ::GetDC(NULL);¤				BITMAP bmp = {0};¤				src->GetBitmap (&bmp);¤				const long width = bmp.bmWidth; ¤				const long height = bmp.bmHeight + row_count;¤¤				HDC src_dc = CreateCompatibleDC (dc);¤				HGDIOBJ old_obj = SelectObject (src_dc, (HBITMAP)*src);¤¤				HDC dst_dc = CreateCompatibleDC(dc);¤				HGDIOBJ objReserve;¤				ret = CreateCompatibleBitmap(src_dc, width, height);¤				objReserve = SelectObject(dst_dc, ret);¤				fill_dc (dst_dc, row_color);¤				BitBlt (dst_dc, 0, 0, bmp.bmWidth, bmp.bmHeight, src_dc, 0, 0, SRCCOPY);¤				¤				SelectObject (dst_dc, objReserve);¤				SelectObject (src_dc, old_obj);¤¤				DeleteDC (dst_dc);¤				DeleteDC (src_dc);¤				ReleaseDC (NULL, dc);¤			}¤			return ret;¤		}¤	};¤	int idx = -1;¤	CBitmap* bmp = CBitmap::FromHandle (image);¤	if (bmp) {					¤		BITMAP bmBitmap;¤		bmp->GetBitmap (&bmBitmap);¤		RGBTRIPLE* rgb = (RGBTRIPLE*)(bmBitmap.bmBits);¤		COLORREF rgb_mask = RGB(rgb[0].rgbtRed, rgb[0].rgbtGreen, rgb[0].rgbtBlue);¤		HBITMAP new_bitmap = NULL;¤		if (m_cy > 0 && bmBitmap.bmHeight < m_cy) {¤			new_bitmap = _local::add_rows (bmp, m_cy - bmBitmap.bmHeight, rgb_mask);¤			if (new_bitmap != NULL) {				¤				if (count > 1) {¤					//нарезаем на большую картинку на маленькие¤					CxImage full_img;¤					if (full_img.CreateFromHBITMAP (new_bitmap)) {¤						for (int i = 0; i < count; ++i) {¤							long cx = m_cx != -1 ? m_cx : 16;¤							long cy = m_cy != -1 ? m_cy : 16;¤							CxImage one_image (m_cx, m_cy, full_img.GetBpp ());¤							long left = i*cx;¤							long right = left + cx;¤							full_img.Crop (left, 0, right, cy, &one_image);¤							HBITMAP bitmap = one_image.MakeBitmap ();¤							if (bitmap != NULL) {¤								CBitmap* bmp = CBitmap::FromHandle (bitmap);¤								idx = this->Add (bmp, rgb_mask);			¤								bmp->Detach ();¤								DeleteObject (bitmap);¤							}¤						}¤					}¤				} else {¤					CBitmap* new_bmp = CBitmap::FromHandle (new_bitmap);¤					idx = this->Add (new_bmp, rgb_mask);¤					new_bmp->Detach();¤				}				¤				DeleteObject (new_bitmap);¤			}¤		} else {¤			idx = this->Add (bmp, rgb_mask);¤		}¤		¤		bmp->Detach();				¤	}¤	return idx;¤	//#UC END# *469C8E2301C5*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659774761"))
		    quid       	"469C8E2301C5"
		    documentation 	
|добавляет в список картинку
|возвращает индекс первой добавленной картинки в список
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "image"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45D2F9890138")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659775055"))
			    quid       	"469C903A0251"
			    type       	"HBITMAP"
			    quidu      	"45D2F9890138")
			(object Parameter "count"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"450A61050251")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659775405"))
			    quid       	"469F61C00167"
			    type       	"integer"
			    quidu      	"450A61050251"))
		    result     	"integer"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0
		    quidu      	"450A61050251"))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "cx"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659768995"))
		    quid       	"469C89D300BB"
		    documentation 	"размер по Х каждого изображения в списке"
		    type       	"integer"
		    quidu      	"450A61050251"
		    Containment 	"By Value")
		(object ClassAttribute "cy"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A61050251")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659769353"))
		    quid       	"469C89EC0148"
		    documentation 	"размер по Y каждого изображения в списке"
		    type       	"integer"
		    quidu      	"450A61050251"
		    Containment 	"By Value"))
	    language   	"MDA Generator"
	    nestedClasses 	(list nestedClasses
		(object Class "ImagePathToIndex"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16663690238"))
		    quid       	"46960BC80119"
		    documentation 	
|мапа: "путь к файлу с изображением" -> индекс в ImageList'е
		    
		    stereotype 	"Map")))
	(object Class "ETSLayout"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"final")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local helper"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/ETSLayout.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/ETSLayout.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*46A88BDA035B_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *46A88BDA035B_CUSTOM_INCLUDES*¤//#UC END# *46A88BDA035B_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*46A88BDA035B*"
		    value      	(value Text 
|//#UC START# *46A88BDA035B*¤////////////////////////////////////////////¤//         ___ ____ _________________     //¤//        / _/_  _// _______________/     //¤//       / _/ / / / /  ___ ___ ____       //¤//      /__/ /_/ / / /   // _/_  _/       //¤//     _________/ / / / // _/ / /         //¤// (c) 1998-2000_/ /___//_/  /_/          //¤//                                        //¤////////////////////////////////////////////¤//          all rights reserved           //¤////////////////////////////////////////////¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutDialog¤//¤// A class for smart layouting of Dialogs and such¤//¤// USAGE: See LayoutMgr.html¤//¤// AUTHOR: Erwin Tratar <tr@et-soft.de>¤//¤// DISCLAIMER:¤//¤// This Sourcecode and all accompaning material is й1998-1999 Erwin Tratar. ¤// All rights reserved.¤//¤// The source code may be used in compiled form in any way you desire ¤// (including usage in commercial applications), providing that your ¤// application adds essential code (i.e. it is not only a wrapper) to the ¤// functionality found here¤//¤// Redistribution of the sourcecode itself, publication in any media or ¤// inclusion in a library requires the authors expressed written consent.¤// You may not sale this code for profit.¤//¤// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY. USE IT ¤// AT YOUR OWN RISK! THE AUTHOR ACCEPTS NO LIABILITY FOR ANY DAMAGE/LOSS OF ¤// BUSINESS THAT THIS PRODUCT MAY CAUSE.¤//¤//¤// HISTORY: ¤// 1998/05/1	Initial Release¤// 1998/05/13	Added ability to have a Pane with a control¤// 1998/05/13	Added better support for TabControls¤// 1998/05/14	automatically set Icon to IDR_MAINFRAME¤// 1998/05/19	no flicker on restoring position in OnInitialUpdate¤//				Changed procedure for load/save, see constructor¤// 1998/10/02	Added support for Maximum (tracking) size¤// 1998/10/02	Much improved handling regarding RELATIVE/GREEDY¤//              /w critical minimum size¤// 1998/10/02	turn on/off gripper at lower right corner¤// 1998/10/05   Support for user defined minimum size for items¤//              (was hardcoded 5 before)¤// 1998/10/07   Fix for FormViews¤// 1998/10/31	Support for SECDialogBar/CDialogBar¤// 1998/10/31	simplified interface¤// 1998/10/31	Advanced positioning options¤// 1998/10/31	Added paneNull for empty Pane (former: NULL)¤// 1998/11/20	Swapped ETSLayoutDialog constructor parameters¤// 1998/11/20	Added Pane::addItemSpaceBetween ¤//				[Leo Zelevinsky]¤// 1998/11/24	Added fixup for greedy panes¤// 1998/11/24	addItemSpaceBetween now subtracts 2*nDefaultBorder¤// 1998/11/24	addGrowing() added as a shortcut for a paneNull¤// 1998/11/24	simplified interface: no more PaneBase:: / Pane:: ¤//				needed¤// 1998/11/24	added FILL_* Modes¤// 1998/11/24	improved maximum size handling for greedy panes¤// 1998/11/25	Fixup of greedy panes caused infinite loop in some ¤//				cases¤// 1999/01/07	addItemSpaceLike() added¤// 1999/04/03   Fixed ETSLayoutFormView memory leak¤// 1999/04/07   Fixed ALIGN_xCENTER¤// 1999/04/08   New simple stream-interface added¤// 1999/04/09   Added support for an empty Status-Bar for resizing ¤//              instead of a gripper in the lower right corner¤//              [Andreas Kapust]¤// 1999/04/11   New code for much less flickering, OnEraseBkgnd()¤//              overidden for this task¤// 1999/05/12   Split Layout code into understandable pieces and adding¤//              a lot of comments¤// 1999/06/20   ABSOLUTE_X + ALIGN_FILL_X expands item if there is any¤//              left space (after all Abs/Rel/Greedy processing is done)¤// 1999/10/06   Changed Load() and Save() to use WINDOWPLACEMENT¤//              [Keith Bussell]¤// 1999/11/18   Added possibility to add panes of the same orientation¤//              to another pane. This merges both panes in one big¤//              pane with the same orientation¤// 1999/11/18   Added support for BCGDialogBar (only with BCG > 4.52!)¤// 1999/11/25   Addes support for PropertyPages/Sheets. Uses some code¤//              of a code submission from Anreas Kapust¤// 1999/11/25   Renamed classes to ETSLayoutXXX¤// 1999/11/25   Use CreateRoot() and Root() instead of m_pRootPane in¤//              derived class.¤// 1999/11/26   Added autopointer support. No need to use normal pointers¤//              when defining layout anymore. Changed m_pRootPane to ¤//              m_RootPane¤// 1999/11/26   Bug in Fixup Greedy II with multiple GREEDY panes and one¤//              of them min/max limited¤// 1999/11/28   Fixed PaneTab::getConstrainVert() for ABSOLUTE_VERT¤// 1999/11/28   Fixed itemFixed()¤// 1999/11/28   Changed DWORD modeResize Arguments to layModeResize for ¤//              better type safety. Added typesafe operator|¤// 1999/12/04   Don't reposition window in UpdateLayout if it's a child¤//              (as a child Dialog or PropertyPage)¤// 1999/12/04   Erase Backgroung with GCL_HBRBACKGROUND (if available) ¤// 1999/12/04   itemSpaceXXX() adds a NORESIZE item instead of ABSOLUTE_XXX¤//              this will fix unwanted growing in secondary direction¤//¤// Version: 1.0 [1999/12/04] Initial Article on CodeProject¤//¤// 1999/12/10   Erase Backgroung within TabCtrl was 'fixed' badly. Reverted to¤//              old working code¤// 2000/02/02   When the Dialog is child of a View the class works correctly¤//              now [Didier BULTIAUW]¤// 2000/02/15   Combo-Boxes were not working correctly (in all modes!)¤// 2000/02/17   aligned SpinButton Controls (with buddy) now handled ¤//              automatically¤//              !! do not add such a control to the layout !! it is always¤//              reattached to its buddy.¤// 2000/02/17   changed some cotrol class names to the defined constants¤//¤// Version: 1.1 [2000/02/17]¤//¤// 2000/02/25   Fixed auto alignment of SpinButton Controls to only affect ¤//              visible ones¤// 2000/02/27   Put all the classes into the namespace 'ETSLayout'¤// 2000/03/07   Fixed growing Dialog after minimizing and restoring¤// 2000/05/22   Whole Statusbar (Gripper) is not excluded anymore in EraseBkgnd()¤//              instead only the triangular Gripper is excluded¤// 2000/05/31   Fix for PropertySheets with PSH_WIZARDHASFINISH [ThЎmmi]¤// 2000/05/31   Fix for UpDown-Controls with EditCtrl Buddy in PropertyPages.¤//              These were not repositioned every time the page is being show¤//              until the first resize¤// 2000/07/28   Problems with resizing ActiveX Controls fixed [Micheal Chapman]¤// 2000/07/28   Some strings were not properly wrapped with _T()¤// 2000/08/03   Check for BS_GROUPBOX was not correct as BS_GROUPBOX is more than one Bit¤// 2000/08/03   New override AddMainArea added to ETSLayoutPropertySheet in order to ¤//              have a hook for additional controls in a PropertySheet (besides the Tab)¤// 2000/08/03   New override AddButtons added to ETSLayoutPropertySheet in order to ¤//              have a hook for additional controls in the bottem pane of a PropertySheet¤// 2000/08/03   Removed the need for DECLARE_LAYOUT¤//¤// Version: 1.2 [2000/08/05]¤¤#define OEMRESOURCE¤¤using namespace WinGUI::ETSLayout;¤#pragma warning(disable: 4097 4610 4510 4100)¤¤¤#ifndef OBM_SIZE¤#define	OBM_SIZE		32766¤// taken from WinresRc.h¤// if not used for any reason¤#endif¤¤#ifdef _DEBUG¤#define new DEBUG_NEW¤#undef THIS_FILE¤static char THIS_FILE[] = __FILE__;¤#endif¤¤static UINT auIDStatusBar[] = ¤{ ¤  ID_SEPARATOR¤};¤¤const int ERASE_GROUP_BORDER	= 10;¤const int FIXUP_CUTOFF	= 5;¤const int TAB_SPACE = 5;¤¤// the _NULL-Pane¤CWnd* ETSLayoutMgr::paneNull = 0;¤¤void ETSLayoutMgr::Layout(CRect& rcClient)¤{¤	if(rcClient.Height() && rcClient.Width()  && m_RootPane.IsValid())	\¤		m_RootPane->resizeTo(rcClient);									\¤}¤¤¤ETSLayoutMgr::CPane ETSLayoutMgr::pane( layOrientation orientation, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, ¤									   int sizeBorder /*=nDefaultBorder*/, int sizeExtraBorder /*=0*/, ¤									   int sizeSecondary /*=0*/)¤{¤	Pane* pPane = new Pane ( this, orientation, sizeBorder, sizeExtraBorder );¤	pPane->m_sizeSecondary = sizeSecondary;¤	pPane->m_modeResize    = modeResize;¤¤	return CPane(pPane);¤}¤¤ETSLayoutMgr::CPane ETSLayoutMgr::paneTab( CTabCtrl* pTab, layOrientation orientation, ¤										  ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeBorder /*=nDefaultBorder*/, ¤										  int sizeExtraBorder /*=0*/, int sizeSecondary /*=0*/)¤{¤	Pane* pPane = new PaneTab ( pTab, this, orientation, sizeBorder, sizeExtraBorder );¤	pPane->m_sizeSecondary = sizeSecondary;¤	pPane->m_modeResize    = modeResize;¤¤	return CPane(pPane);¤}¤¤¤ETSLayoutMgr::CPane ETSLayoutMgr::paneCtrl( CWnd* pCtrl, layOrientation orientation, ¤										   ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeBorder /*=nDefaultBorder*/, ¤										   int sizeExtraBorder /*=0*/, int sizeTopExtra /*=0*/, ¤										   int sizeSecondary /*=0*/)¤{¤	Pane* pPane = new PaneCtrl ( pCtrl, this, orientation, sizeBorder, sizeExtraBorder, sizeTopExtra );¤	pPane->m_sizeSecondary = sizeSecondary;¤	pPane->m_modeResize    = modeResize;¤¤	return CPane(pPane);¤}¤¤ETSLayoutMgr::CPane ETSLayoutMgr::paneCtrl( UINT nID, layOrientation orientation, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, ¤										   int sizeBorder /*=nDefaultBorder*/, int sizeExtraBorder /*=0*/,¤										   int sizeTopExtra /*=0*/, int sizeSecondary /*=0*/)¤{¤	Pane* pPane = new PaneCtrl ( nID, this, orientation, sizeBorder, sizeExtraBorder, sizeTopExtra );¤	pPane->m_sizeSecondary = sizeSecondary;¤	pPane->m_modeResize    = modeResize;¤¤	return CPane(pPane);¤}¤¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::item(UINT nID, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeX /*=0*/, int sizeY /*=0*/, ¤										   int sizeXMin /*=-1*/, int sizeYMin /*=-1*/)¤{¤	return new PaneItem( nID, this, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);¤}¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::item(CWnd* pWnd, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/,¤										   int sizeX /*=0*/, int sizeY /*=0*/, int sizeXMin /*=-1*/, ¤										   int sizeYMin /*=-1*/)¤{¤	return new PaneItem( pWnd, this, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);¤}¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemFixed(layOrientation orientation, int sizePrimary)¤{¤	CPaneBase p = new PaneItem(paneNull, this, NORESIZE, (orientation==HORIZONTAL)?sizePrimary:0, (orientation==VERTICAL)?sizePrimary:0);¤	return p;¤}¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemGrowing(layOrientation orientation)¤{¤	return new PaneItem(paneNull, this, (orientation==HORIZONTAL)?ABSOLUTE_VERT:ABSOLUTE_HORZ, 0, 0, -nDefaultBorder, -nDefaultBorder);¤}¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceBetween( layOrientation orientation, CWnd* pWndFirst, CWnd* pWndSecond )¤{¤	if( orientation == HORIZONTAL ) {¤		// I'm interested in horizontal spacing¤¤		CRect rLeft, rRight;¤		pWndFirst->GetWindowRect(&rLeft);¤		pWndSecond->GetWindowRect(&rRight);¤¤		int sizeX = rRight.left - rLeft.right;¤	¤		if( sizeX < 0 ) {¤			// compare top to top¤			sizeX = rRight.left - rLeft.left;¤		}¤		else {¤			sizeX -= 2*nDefaultBorder;¤		}¤¤		return new PaneItem(paneNull, this, NORESIZE, sizeX, 0);¤	}¤	else {¤		// I'm interested in vertical spacing¤		CRect rTop, rBot;¤		pWndFirst->GetWindowRect(&rTop);¤		pWndSecond->GetWindowRect(&rBot);¤¤		int sizeY = rBot.top - rTop.bottom;¤¤		if( sizeY < 0 ) {¤			// compare top to top¤			sizeY = sizeY = rBot.top - rTop.top;¤		}¤		else {¤			sizeY -= 2*nDefaultBorder;¤		}¤¤		return new PaneItem(paneNull, this, NORESIZE, 0, sizeY);¤	}¤}¤¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceBetween( layOrientation orientation, UINT nIDFirst, UINT nIDSecond )¤{¤	CWnd *pFirst	= GetWnd()->GetDlgItem(nIDFirst);¤	CWnd *pSecond	= GetWnd()->GetDlgItem(nIDSecond);¤¤	ASSERT( pFirst && pSecond );¤¤	return itemSpaceBetween( orientation, pFirst, pSecond );¤}¤¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceLike( layOrientation orientation, CWnd* pWnd )¤{¤	CRect rRect;¤	pWnd->GetWindowRect(&rRect);¤¤	if( orientation == HORIZONTAL ) {¤		// I'm interested in horizontal spacing¤		return new PaneItem(paneNull, this, NORESIZE, rRect.Width(), 0);¤	}¤	else {¤		// I'm interested in vertical spacing¤		return new PaneItem(paneNull, this, NORESIZE, 0, rRect.Height() );¤	}¤¤}¤¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::itemSpaceLike( layOrientation orientation, UINT nID )¤{¤	CWnd *pWnd	= GetWnd()->GetDlgItem(nID);¤	ASSERT( pWnd );¤¤	return itemSpaceLike( orientation, pWnd );¤}¤¤¤¤ETSLayoutMgr::~ETSLayoutMgr()¤{¤}¤¤void ETSLayoutMgr::UpdateLayout()¤{¤	if(!m_RootPane)¤		return;¤¤	// Check constraints¤	CRect rcClient = GetRect();¤¤	if( m_pWnd->IsKindOf( RUNTIME_CLASS( CDialog ) ) && !(m_pWnd->GetStyle()&WS_CHILD) ) {¤		CRect rcWindow;¤		m_pWnd->GetWindowRect(rcWindow);¤¤		// Added by Didier BULTIAUW¤        CWnd* parentWnd = m_pWnd->GetParent();¤        if( (parentWnd != 0) && parentWnd->IsKindOf(RUNTIME_CLASS(CView)) )¤        {¤			CRect rcParent;¤            parentWnd->GetWindowRect(rcParent);¤            rcWindow.OffsetRect(-rcParent.left,-rcParent.top);¤        }¤		// end add¤¤		CRect rcBorder = rcWindow;¤		rcBorder -= rcClient;¤¤		// Min and Max info¤		int minWidth	= m_RootPane->getMinConstrainHorz() + rcBorder.Width()  + 2*m_sizeRootBorders.cx;¤		int minHeight	= m_RootPane->getMinConstrainVert() + rcBorder.Height() + 2*m_sizeRootBorders.cy;¤		int maxWidth	= m_RootPane->getMaxConstrainHorz();¤		if(maxWidth != -1) {¤			maxWidth += rcBorder.Width()  + 2*m_sizeRootBorders.cx;¤			maxWidth = std::max(maxWidth, minWidth);¤		}¤		int maxHeight	= m_RootPane->getMaxConstrainVert();¤		if(maxHeight != -1) {¤			maxHeight += rcBorder.Height() + 2*m_sizeRootBorders.cy;¤			maxHeight = std::max(maxHeight, minHeight);¤		}¤¤		if(rcWindow.Width() < minWidth)¤			rcWindow.right = rcWindow.left + minWidth;¤		if(rcWindow.Height() < minHeight)¤			rcWindow.bottom = rcWindow.top + minHeight;¤¤		if(maxWidth != -1  && rcWindow.Width() > maxWidth)¤			rcWindow.right = rcWindow.left + maxWidth;¤		if(maxHeight != -1 && rcWindow.Height() > maxHeight)¤			rcWindow.bottom = rcWindow.top + maxHeight;¤¤		m_pWnd->MoveWindow(rcWindow);¤	}¤	// Do the Layout¤	rcClient = GetRect();¤¤	// Add a Border around the rootPane¤	rcClient.top	+= m_sizeRootBorders.cy;¤	rcClient.bottom -= m_sizeRootBorders.cy;¤	rcClient.left	+= m_sizeRootBorders.cx;¤	rcClient.right	-= m_sizeRootBorders.cx;¤¤	if(GetWnd()->IsWindowVisible()) {¤		// Avoid ugly artifacts¤		//GetWnd()->SetRedraw(FALSE);¤		Layout(rcClient);¤		//GetWnd()->SetRedraw(TRUE);¤	}¤	else¤		Layout(rcClient);¤¤	// Take special care of SpinButtons (Up-Down Controls) with Buddy set, enumerate¤	// all childs:¤	CWnd* pWndChild = GetWnd()->GetWindow(GW_CHILD);¤	TCHAR szClassName[ MAX_PATH ];¤	while(pWndChild)¤	{¤		::GetClassName( pWndChild->GetSafeHwnd(), szClassName, MAX_PATH );¤		DWORD dwStyle = pWndChild->GetStyle();¤¤		// is it a SpinButton?¤		if( _tcscmp(szClassName, UPDOWN_CLASS)==0 && ::IsWindowVisible(pWndChild->GetSafeHwnd()) ) {¤			HWND hwndBuddy = (HWND)::SendMessage( pWndChild->GetSafeHwnd(), UDM_GETBUDDY, 0, 0);¤			if( hwndBuddy != 0 && (dwStyle&(UDS_ALIGNRIGHT|UDS_ALIGNLEFT)) != 0 )¤			{¤				// reset Buddy¤				::SendMessage( pWndChild->GetSafeHwnd(), UDM_SETBUDDY, (WPARAM)hwndBuddy, 0);¤			}¤		}¤		¤¤		pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);¤	}¤¤¤	GetWnd()->Invalidate();¤}¤¤¤bool ETSLayoutMgr::Save(LPCTSTR lpstrRegKey)¤{¤    CRect rcWnd;¤¤    if(IsWindow(GetWnd()->m_hWnd))¤    {¤        WINDOWPLACEMENT wp;¤        if(GetWnd()->GetWindowPlacement(&wp))¤        {¤            // Make sure we don't pop up ¤            // minimized the next time¤            if(wp.showCmd != SW_SHOWMAXIMIZED)¤                wp.showCmd = SW_SHOWNORMAL;¤¤            AfxGetApp()->WriteProfileBinary(lpstrRegKey, ¤                _T("WindowPlacement"), ¤                reinterpret_cast<LPBYTE>(&wp), sizeof(wp));¤        }¤    }¤    return true;¤}¤¤bool ETSLayoutMgr::Load(LPCTSTR lpstrRegKey)¤{¤    LPBYTE pbtData = 0;¤    UINT nSize = 0;¤    if(AfxGetApp()->GetProfileBinary(lpstrRegKey,¤        _T("WindowPlacement"), &pbtData, &nSize))¤    {¤        WINDOWPLACEMENT* pwp = ¤            reinterpret_cast<WINDOWPLACEMENT*>(pbtData);¤		¤        ASSERT(nSize == sizeof(WINDOWPLACEMENT));¤        if(nSize == sizeof(WINDOWPLACEMENT))¤            GetWnd()->SetWindowPlacement(reinterpret_cast<WINDOWPLACEMENT*>(pbtData));¤¤        delete [] pbtData;¤    }¤    return true;¤}¤¤¤void ETSLayoutMgr::EraseBkgnd(CDC* pDC)¤{¤	CRect	rcClient;¤	GetWnd()->GetClientRect( rcClient );¤¤	CRgn	rgn;¤	rgn.CreateRectRgnIndirect(rcClient);¤    TRACE("CreateRgn (%d,%d,%d,%d)\n", rcClient.left, rcClient.top, rcClient.right, rcClient.bottom );¤¤	CRgn    rgnRect;¤	rgnRect.CreateRectRgn(0,0,0,0);¤¤	CRect	rcChild;¤	CWnd* pWndChild = GetWnd()->GetWindow( GW_CHILD );¤¤	TCHAR szClassName[ MAX_PATH ];¤¤    pDC->SelectClipRgn(NULL);¤    ¤	while( pWndChild ) {¤		¤		pWndChild->GetWindowRect(rcChild);¤		GetWnd()->ScreenToClient( rcChild );¤¤		rgnRect.SetRectRgn( rcChild );¤	¤		::GetClassName( pWndChild->GetSafeHwnd(), szClassName, MAX_PATH );¤		DWORD dwStyle = pWndChild->GetStyle();¤¤		// doesn't make sense for hidden children¤		if( dwStyle & WS_VISIBLE ) {¤¤            // Fix: BS_GROUPBOX is more than one Bit, extend check to (dwStyle & BS_GROUPBOX)==BS_GROUPBOX [ET]¤			if( _tcscmp(szClassName,_T("Button"))==0 && (dwStyle & BS_GROUPBOX)==BS_GROUPBOX ) {¤				// it is a group-box, ignore completely¤			}¤			else if( _tcscmp(szClassName,WC_TABCONTROL )==0 ) {¤				// ignore Tab-Control's inside rect¤				static_cast<CTabCtrl*>(pWndChild)->AdjustRect(FALSE,rcChild);¤¤				CRgn rgnContent;¤				rgnContent.CreateRectRgnIndirect(rcChild);¤¤				rgnRect.CombineRgn( &rgnRect, &rgnContent, RGN_DIFF );¤				rgn.CombineRgn( &rgn, &rgnRect, RGN_DIFF );¤			}¤			else if( _tcscmp(szClassName,STATUSCLASSNAME)==0 ) {¤¤				CPoint ptTriangleGrip[3];¤				ptTriangleGrip[0] = CPoint(rcChild.right,rcChild.top);¤				ptTriangleGrip[1] = CPoint(rcChild.right,rcChild.bottom);¤				ptTriangleGrip[2] = CPoint(rcChild.right-rcChild.Height(),rcChild.bottom);¤¤				CRgn rgnGripper;¤				rgnGripper.CreatePolygonRgn(ptTriangleGrip,3, WINDING);¤¤				rgn.CombineRgn( &rgn, &rgnGripper, RGN_DIFF );¤¤			}¤			else {¤				rgn.CombineRgn( &rgn, &rgnRect, RGN_DIFF );¤			}¤		}¤¤		pWndChild = pWndChild->GetNextWindow();¤	}¤¤¤	HBRUSH hBrBack = (HBRUSH) ::GetClassLong(GetWnd()->GetSafeHwnd(), GCL_HBRBACKGROUND) ;¤	if( hBrBack == 0 )¤		hBrBack = ::GetSysColorBrush(COLOR_BTNFACE);¤¤	pDC->FillRgn( &rgn, ¤		CBrush::FromHandle( hBrBack )¤		);¤	¤}¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutMgr::PaneItem implementation¤¤¤ETSLayoutMgr::PaneItem::PaneItem(CWnd* pWnd, ETSLayoutMgr* pMgr, ETSLayoutMgr::layResizeMode modeResize/*=GREEDY*/¤								 , int sizeX/*=0*/, int sizeY/*=0*/¤								 , int sizeXMin/*=-1*/, int sizeYMin/*=-1*/ ) : PaneBase( pMgr )¤{¤	m_modeResize	= modeResize;¤	m_hwndCtrl		= pWnd->GetSafeHwnd();¤¤	m_sizeX			= 0;¤	m_sizeY			= 0;¤¤	m_bComboSpecial = false;¤¤	m_sizeXMin		= sizeXMin;¤	m_sizeYMin		= sizeYMin;¤¤	if(!m_hwndCtrl) {			// only Dummy!¤		m_sizeX = sizeX;¤		m_sizeY = sizeY;¤	}¤	else {¤		CRect rcControl;¤		::GetWindowRect(m_hwndCtrl, &rcControl);¤¤		if(sizeX == 0) {¤			m_sizeX			= rcControl.Width();¤		}¤		else {¤			m_sizeX = sizeX;¤		}¤		if( m_sizeXMin == -1 ) {¤			// do not make smaller than current size¤			m_sizeXMin		= rcControl.Width();¤		}¤¤		if(sizeY == 0) {¤			m_sizeY			= rcControl.Height();¤		}¤		else {¤			m_sizeY = sizeY;¤		}¤		if( m_sizeYMin == -1 ) {¤			// do not make smaller than current size¤			m_sizeYMin		= rcControl.Height();¤		}¤¤		TCHAR szClassName[ MAX_PATH ];¤		::GetClassName( m_hwndCtrl, szClassName, MAX_PATH );¤¤		// special treatment for combo-boxes¤		if( _tcscmp(szClassName,_T("ComboBox"))==0 || _tcscmp(szClassName,WC_COMBOBOXEX)==0) {¤			m_bComboSpecial = true;¤		}¤	}¤}¤¤ETSLayoutMgr::PaneItem::PaneItem( UINT nID, ETSLayoutMgr* pMgr, ETSLayoutMgr::layResizeMode modeResize/*=GREEDY*/¤								 , int sizeX/*=0*/, int sizeY/*=0*/¤								 , int sizeXMin/*=-1*/, int sizeYMin/*=-1*/ ) : PaneBase( pMgr )¤{¤	CWnd* pWnd		= pMgr->GetWnd()->GetDlgItem(nID);¤	m_hwndCtrl		= pWnd->GetSafeHwnd();¤¤	m_sizeX			= 0;¤	m_sizeY			= 0;¤¤	m_bComboSpecial = false;¤¤	m_modeResize	= modeResize;¤¤	m_sizeXMin = sizeXMin;¤	m_sizeYMin = sizeYMin;¤¤	if(!m_hwndCtrl) {			// only Dummy!¤		m_sizeX = sizeX;¤		m_sizeY = sizeY;¤	}¤	else {¤		CRect rcControl;¤		::GetWindowRect(m_hwndCtrl, &rcControl);¤¤		if(sizeX == 0) {¤			m_sizeX			= rcControl.Width();¤		}¤		else {¤			m_sizeX = sizeX;¤		}¤		if( m_sizeXMin == -1 ) {¤			// do not make smaller than current size¤			m_sizeXMin		= rcControl.Width();¤		}¤¤		if(sizeY == 0) {¤			m_sizeY			= rcControl.Height();¤		}¤		else {¤			m_sizeY = sizeY;¤		}¤		if( m_sizeYMin == -1 ) {¤			// do not make smaller than current size¤			m_sizeYMin		= rcControl.Height();¤		}¤¤		TCHAR szClassName[ MAX_PATH ];¤		::GetClassName( m_hwndCtrl, szClassName, MAX_PATH );¤¤		// special treatment for combo-boxes¤		if( _tcscmp(szClassName,_T("ComboBox"))==0 || _tcscmp(szClassName,WC_COMBOBOXEX)==0) {¤			m_bComboSpecial = true;¤		}¤	}¤}¤¤int ETSLayoutMgr::PaneItem::getConstrainHorz(int sizeParent) ¤{¤	if( m_modeResize & ABSOLUTE_HORZ) {¤		return m_sizeX;	¤	}¤	if(m_modeResize & RELATIVE_HORZ) {¤		return (sizeParent * m_sizeX) / 100;	¤	}¤	return -1;¤}¤¤int ETSLayoutMgr::PaneItem::getConstrainVert(int sizeParent) ¤{¤	if(m_modeResize & ABSOLUTE_VERT) {¤		return m_sizeY;	¤	}¤	if(m_modeResize & RELATIVE_VERT) {¤		return (sizeParent * m_sizeY) / 100;	¤	}¤	return -1;¤}¤¤int ETSLayoutMgr::PaneItem::getMinConstrainHorz() ¤{¤	if(m_modeResize & ABSOLUTE_HORZ) {¤		return m_sizeX;	¤	}¤	return std::max(nMinConstrain,m_sizeXMin);¤}¤¤int ETSLayoutMgr::PaneItem::getMinConstrainVert() ¤{¤	if(m_modeResize & ABSOLUTE_VERT) {¤		return m_sizeY;	¤	}¤	return std::max(nMinConstrain,m_sizeYMin);¤}¤¤int ETSLayoutMgr::PaneItem::getMaxConstrainHorz() ¤{¤	if(m_modeResize & ABSOLUTE_HORZ) {¤		return m_sizeX;	¤	}¤	return -1;¤}¤¤int ETSLayoutMgr::PaneItem::getMaxConstrainVert() ¤{¤	if(m_modeResize & ABSOLUTE_VERT) {¤		return m_sizeY;	¤	}¤	return -1;	¤}¤¤bool ETSLayoutMgr::PaneItem::resizeTo(CRect& rcNewArea) ¤{¤	if(m_hwndCtrl) {¤¤		CRect rcWnd;¤		::GetWindowRect( m_hwndCtrl, rcWnd );¤¤		if( !(m_modeResize & ALIGN_FILL_HORZ) && m_modeResize & ABSOLUTE_HORZ ) {¤¤¤			if( (m_modeResize & ALIGN_HCENTER) == ALIGN_HCENTER ) {¤				rcNewArea.OffsetRect( (rcNewArea.Width() - rcWnd.Width())/2, 0 ); ¤			}¤			else if( m_modeResize & ALIGN_RIGHT ) {¤				rcNewArea.OffsetRect( rcNewArea.Width() - rcWnd.Width(), 0 ); ¤			}¤¤			rcNewArea.right = rcNewArea.left + rcWnd.Width();¤		}¤		if( !(m_modeResize & ALIGN_FILL_VERT) && m_modeResize & ABSOLUTE_VERT ) {¤¤¤			if( (m_modeResize & ALIGN_VCENTER) == ALIGN_VCENTER ) {¤				rcNewArea.OffsetRect( 0, (rcNewArea.Height()-rcWnd.Height())/2 ); ¤			}¤			else if( m_modeResize & ALIGN_BOTTOM ) {¤				rcNewArea.OffsetRect( 0, rcNewArea.Height() - rcWnd.Height()); ¤			}¤¤			rcNewArea.bottom = rcNewArea.top + rcWnd.Height();¤¤		}¤¤		DWORD dwStyle = ::GetWindowLong( m_hwndCtrl, GWL_STYLE );¤¤		// special treatment for combo-boxes¤		if( m_bComboSpecial && (dwStyle & CBS_DROPDOWN) ) {¤			// keep height (though only fully visible when dropped down)¤			rcNewArea.bottom = rcNewArea.top + rcWnd.Height();¤		}¤¤    // FIX: ::MoveWindow would case problems with some ActiveX Controls [Micheal Chapman]¤    CWnd* pTempWnd = CWnd::FromHandle( m_hwndCtrl );¤    pTempWnd->MoveWindow( rcNewArea.left, rcNewArea.top, rcNewArea.Width(), rcNewArea.Height() );¤¤		if( m_bComboSpecial && !(dwStyle & CBS_DROPDOWN) && !(dwStyle & CBS_NOINTEGRALHEIGHT) ) {¤¤			// Keep CB Size = Edit + LB ( if not CBS_NOINTEGRALHEIGHT)¤¤			::GetWindowRect( m_hwndCtrl, rcWnd );¤¤			CRect rcListBox;¤			HWND hwndListBox = ::GetDlgItem(m_hwndCtrl, 1000); // ListBox of CB¤			if( hwndListBox != 0 )¤			{¤				::GetWindowRect( hwndListBox, rcListBox );¤				rcWnd.bottom = rcListBox.bottom;¤¤				rcNewArea.bottom = rcNewArea.top + rcWnd.Height();¤¤        // FIX: ::MoveWindow would case problems with some ActiveX Controls [Micheal Chapman]¤        CWnd* pTempWnd = CWnd::FromHandle( m_hwndCtrl );¤        pTempWnd->MoveWindow( rcNewArea.left, rcNewArea.top, rcNewArea.Width(), rcNewArea.Height(), true );¤			}¤		}¤¤		::RedrawWindow(m_hwndCtrl,0,0, RDW_INVALIDATE | RDW_UPDATENOW ); ¤¤	}¤	return true;¤}¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutMgr::PaneTab implementation¤¤¤ETSLayoutMgr::PaneTab::PaneTab( CTabCtrl* pTab, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /*= nDefaultBorder*/, int sizeExtraBorder /*= 0*/ )¤: ETSLayoutMgr::Pane(pMgr, orientation, sizeBorder, sizeExtraBorder) ¤{¤	ASSERT(pTab);¤	m_pTab = pTab;¤}¤¤int ETSLayoutMgr::PaneTab::getConstrainHorz(int sizeParent)¤{¤	CRect rcTab;¤	m_pTab->AdjustRect(TRUE, &rcTab);¤¤	if(rcTab.Width() > sizeParent)¤		return rcTab.Width();¤¤	return Pane::getConstrainHorz(sizeParent /*- rcTab.Width()*/);¤}¤¤int ETSLayoutMgr::PaneTab::getConstrainVert(int sizeParent)¤{¤	CRect rcTab;¤	m_pTab->AdjustRect(TRUE, &rcTab);¤¤	if( m_modeResize & ABSOLUTE_VERT ) {¤		return m_sizeSecondary + rcTab.Height();¤	}¤¤	if(rcTab.Height() > sizeParent)¤		return rcTab.Height();¤¤	return Pane::getConstrainVert(sizeParent /*- rcTab.Height()*/);¤}¤¤int ETSLayoutMgr::PaneTab::getMinConstrainHorz()¤{¤	CRect rcTab(0,0,0,0);¤	m_pTab->AdjustRect(TRUE, &rcTab);¤¤	return Pane::getMinConstrainHorz() + rcTab.Width() ;¤}¤¤int ETSLayoutMgr::PaneTab::getMinConstrainVert()¤{¤	CRect rcTab(0,0,0,0);¤	m_pTab->AdjustRect(TRUE, &rcTab);¤¤	return Pane::getMinConstrainVert() + rcTab.Height();¤}¤¤int ETSLayoutMgr::PaneTab::getMaxConstrainHorz()¤{¤	CRect rcTab(0,0,0,0);¤	m_pTab->AdjustRect(TRUE, &rcTab);¤¤	int paneMax = Pane::getMaxConstrainHorz();¤	return (paneMax != -1) ? paneMax + rcTab.Width() : -1;¤}¤¤int ETSLayoutMgr::PaneTab::getMaxConstrainVert()¤{¤	CRect rcTab(0,0,0,0);¤	m_pTab->AdjustRect(TRUE, &rcTab);¤¤	int paneMax = Pane::getMaxConstrainVert();¤	return (paneMax != -1) ? paneMax + rcTab.Height() : -1;¤}¤¤bool ETSLayoutMgr::PaneTab::resizeTo(CRect& rcNewArea)¤{¤	m_pTab->MoveWindow(rcNewArea);¤	m_pTab->AdjustRect(FALSE,rcNewArea);¤¤	return Pane::resizeTo(rcNewArea);¤}¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutMgr::PaneCtrl implementation¤¤¤ETSLayoutMgr::PaneCtrl::PaneCtrl( CWnd* pCtrl, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /*= nDefaultBorder*/, int sizeExtraBorder /*= 0*/, int sizeTopExtra /*= 0*/ )¤: ETSLayoutMgr::Pane(pMgr, orientation, sizeBorder, sizeExtraBorder)¤{¤	m_sizeTopExtra = sizeTopExtra;¤¤	ASSERT(pCtrl);¤	m_hwndCtrl = pCtrl->GetSafeHwnd();¤}¤¤ETSLayoutMgr::PaneCtrl::PaneCtrl( UINT nID, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /*= nDefaultBorder*/, int sizeExtraBorder /*= 0*/, int sizeTopExtra /*= 0*/ )¤: ETSLayoutMgr::Pane(pMgr, orientation, sizeBorder, sizeExtraBorder)¤{¤	m_sizeTopExtra = sizeTopExtra;¤¤	m_hwndCtrl = ::GetDlgItem(pMgr->GetWnd()->GetSafeHwnd(), nID);¤	ASSERT(m_hwndCtrl);¤}¤¤int ETSLayoutMgr::PaneCtrl::getConstrainHorz(int sizeParent)¤{¤	return Pane::getConstrainHorz(sizeParent) ;¤}¤¤int ETSLayoutMgr::PaneCtrl::getConstrainVert(int sizeParent)¤{¤	return Pane::getConstrainVert(sizeParent);¤}¤¤int ETSLayoutMgr::PaneCtrl::getMinConstrainHorz()¤{¤	return Pane::getMinConstrainHorz();¤}¤¤int ETSLayoutMgr::PaneCtrl::getMinConstrainVert()¤{¤	return Pane::getMinConstrainVert() + m_sizeTopExtra;¤}¤¤int ETSLayoutMgr::PaneCtrl::getMaxConstrainHorz()¤{¤	int paneMax = Pane::getMaxConstrainHorz();¤	return ( paneMax == -1) ? -1 : paneMax ;¤}¤¤int ETSLayoutMgr::PaneCtrl::getMaxConstrainVert()¤{¤	int paneMax = Pane::getMaxConstrainVert();¤	return ( paneMax == -1) ? -1 : paneMax + m_sizeTopExtra;¤}¤¤bool ETSLayoutMgr::PaneCtrl::resizeTo(CRect& rcNewArea)¤{¤  // FIX: ::MoveWindow would case problems with some ActiveX Controls [Micheal Chapman]¤  CWnd* pTempWnd = CWnd::FromHandle( m_hwndCtrl );¤  pTempWnd->MoveWindow( rcNewArea.left, rcNewArea.top, rcNewArea.Width(), rcNewArea.Height(), true );¤¤  ::RedrawWindow(m_hwndCtrl,0,0, RDW_INVALIDATE | RDW_UPDATENOW |RDW_ERASE); ¤	rcNewArea.top	+= m_sizeTopExtra;¤	return Pane::resizeTo(rcNewArea);¤}¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutMgr::Pane implementation¤¤ETSLayoutMgr::Pane::Pane( ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder /* = nDefaultBorder */, int sizeExtraBorder /*= 0*/) ¤: PaneBase(pMgr)¤{¤	m_Orientation	= orientation;¤	m_sizeBorder	= sizeBorder;¤	m_sizeSecondary	= 0;¤	m_modeResize	= 0;¤	m_sizeExtraBorder= sizeExtraBorder;¤}¤¤¤ETSLayoutMgr::Pane::~Pane() ¤{¤}¤¤¤bool ETSLayoutMgr::Pane::addItem( CWnd* pWnd, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeX /*=0*/, int sizeY /*=0*/, int sizeXMin /*=0*/, int sizeYMin /*=0*/)¤{¤	CPaneBase pItem = new PaneItem( pWnd, m_pMgr, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);¤	return addPane( pItem );¤}¤¤bool ETSLayoutMgr::Pane::addItem( UINT nID, ETSLayoutMgr::layResizeMode modeResize /*=GREEDY*/, int sizeX /*=0*/, int sizeY /*=0*/, int sizeXMin /*=0*/, int sizeYMin /*=0*/)¤{¤	CPaneBase pItem = new PaneItem( nID, m_pMgr, modeResize, sizeX, sizeY, sizeXMin, sizeYMin);¤	return addPane( pItem );¤}¤¤bool ETSLayoutMgr::Pane::addItemFixed(int size)¤{¤	CPaneBase pNewItem = m_pMgr->itemFixed(m_Orientation, size);¤	return addPane( pNewItem );¤}¤¤bool ETSLayoutMgr::Pane::addItemGrowing()¤{¤	CPaneBase pNewItem = m_pMgr->itemGrowing(m_Orientation);¤	return addPane( pNewItem );¤}¤¤bool ETSLayoutMgr::Pane::addItemSpaceBetween( CWnd* pWndFirst, CWnd* pWndSecond )¤{¤	CPaneBase pNewItem = m_pMgr->itemSpaceBetween(m_Orientation, pWndFirst, pWndSecond);¤	return addPane( pNewItem );¤}¤¤bool ETSLayoutMgr::Pane::addItemSpaceBetween( UINT nIDFirst, UINT nIDSecond )¤{¤	CPaneBase pNewItem = m_pMgr->itemSpaceBetween(m_Orientation, nIDFirst, nIDSecond);¤	return addPane( pNewItem );¤}¤¤bool ETSLayoutMgr::Pane::addItemSpaceLike( CWnd* pWnd )¤{¤	CPaneBase pNewItem = m_pMgr->itemSpaceLike(m_Orientation, pWnd);¤	return addPane( pNewItem );¤}¤¤bool ETSLayoutMgr::Pane::addItemSpaceLike( UINT nID )¤{¤	CPaneBase pNewItem = m_pMgr->itemSpaceLike(m_Orientation, nID);¤	return addPane( pNewItem );¤}¤¤bool ETSLayoutMgr::Pane::addPane( CPane pSubpane, ETSLayoutMgr::layResizeMode modeResize, int sizeSecondary /* = 0 */) ¤{¤	if( pSubpane->getOrientation() == m_Orientation)¤	{¤		// wrap in subpane of opposite orientation¤		CPane pPaneWrap = new Pane(m_pMgr, m_Orientation==HORIZONTAL?VERTICAL:HORIZONTAL,0,0);¤		pPaneWrap->addPane( pSubpane  );¤¤		addPane( pPaneWrap, modeResize, sizeSecondary );¤	}¤	else¤	{¤		pSubpane->m_modeResize = modeResize;¤¤		if(m_Orientation==HORIZONTAL && (modeResize & ABSOLUTE_HORZ) ) {¤			if(sizeSecondary == 0) {¤				pSubpane->m_sizeSecondary = pSubpane->getMinConstrainHorz();¤			}¤		}¤		else if(m_Orientation==HORIZONTAL && (modeResize & RELATIVE_HORZ) ) {¤			pSubpane->m_sizeSecondary = sizeSecondary;¤		}¤		else if(m_Orientation==VERTICAL && (modeResize & ABSOLUTE_VERT) ) {¤			if(sizeSecondary == 0) {¤				pSubpane->m_sizeSecondary = pSubpane->getMinConstrainVert();¤			}¤		}¤		else if(m_Orientation==VERTICAL && (modeResize & RELATIVE_VERT) ) {¤			pSubpane->m_sizeSecondary = sizeSecondary;¤		}¤¤		m_paneItems.Add(pSubpane);¤	}¤¤	return true;¤}¤¤bool ETSLayoutMgr::Pane::addPane( CPaneBase pItem ) ¤{¤	m_paneItems.Add(pItem);¤	return true;¤}¤¤int ETSLayoutMgr::Pane::getConstrainHorz(int sizeParent) ¤{¤	ASSERT( m_Orientation == VERTICAL);¤¤	if( m_modeResize & RELATIVE_HORZ ) {¤		return (sizeParent * m_sizeSecondary) / 100;¤	}¤	else if( m_modeResize & ABSOLUTE_HORZ ){¤		return m_sizeSecondary;¤	}¤	else¤		return 0;¤}¤¤¤int ETSLayoutMgr::Pane::getConstrainVert(int sizeParent) ¤{¤	ASSERT( m_Orientation == HORIZONTAL);¤¤	if( m_modeResize & RELATIVE_VERT ) {¤		return (sizeParent * m_sizeSecondary) / 100;¤	}¤	else if( m_modeResize & ABSOLUTE_VERT ) {¤		return m_sizeSecondary;¤	}¤	else {¤		return 0;¤	}¤}¤¤int ETSLayoutMgr::Pane::getMaxConstrainHorz() ¤{¤	if(m_Orientation == HORIZONTAL) {¤		int nMaxConstr = -1;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤¤			int nConstrain = pItem->getMaxConstrainHorz();¤			if(nConstrain == -1)¤				return -1;¤¤			nMaxConstr += nConstrain;¤		}¤		return (nMaxConstr == -1) ? -1 : nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;¤	}¤	else if( m_modeResize & ABSOLUTE_HORZ && m_sizeSecondary!=0) {¤		return m_sizeSecondary; // + 2*m_sizeExtraBorder;¤	}¤	else {¤		int nMaxConstr = -1;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤¤			int nConstrain = pItem->getMaxConstrainHorz();¤¤			if( nConstrain == -1)¤				return -1;¤			else¤				nMaxConstr = std::max(nMaxConstr, nConstrain);¤¤		}¤		return (nMaxConstr == -1) ? -1 : nMaxConstr + 2*m_sizeExtraBorder;¤	}¤}¤¤int ETSLayoutMgr::Pane::getMaxConstrainVert() ¤{¤	if(m_Orientation == VERTICAL) {¤		int nMaxConstr = -1;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤¤			int nConstrain = pItem->getMaxConstrainVert();¤			if(nConstrain == -1)¤				return -1;¤¤			nMaxConstr += nConstrain;¤		}¤		return (nMaxConstr == -1) ? -1 : nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;¤	}¤	else if( m_modeResize & ABSOLUTE_VERT && m_sizeSecondary!=0) {¤		return m_sizeSecondary; // + 2*m_sizeExtraBorder;¤	}¤	else {¤		int nMaxConstr = -1;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤¤			int nConstrain = pItem->getMaxConstrainVert();¤¤			if( nConstrain == -1)¤				return -1;¤			else¤				nMaxConstr = std::max(nMaxConstr, nConstrain);¤¤		}¤		return (nMaxConstr == -1) ? -1 : nMaxConstr + 2*m_sizeExtraBorder;¤	}¤}¤¤int ETSLayoutMgr::Pane::getMinConstrainHorz() ¤{¤	if(m_Orientation == HORIZONTAL) {¤		int nMaxConstr = 0;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤			nMaxConstr += std::max(nMinConstrain, pItem->getMinConstrainHorz());¤		}¤		return nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;¤	}¤	else if( m_modeResize & ABSOLUTE_HORZ && m_sizeSecondary!=0) {¤		return m_sizeSecondary; // + 2*m_sizeExtraBorder;¤	}¤	else {¤		int nMaxConstr = 0;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤			int nConstrain = pItem->getMinConstrainHorz();¤			nMaxConstr = std::max(nMaxConstr, nConstrain);¤		}¤		return nMaxConstr + 2*m_sizeExtraBorder;¤	}¤}¤¤int ETSLayoutMgr::Pane::getMinConstrainVert() ¤{¤	if(m_Orientation == VERTICAL) {¤		int nMaxConstr = 0;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤			nMaxConstr += std::max(nMinConstrain, pItem->getMinConstrainVert());¤		}¤		return nMaxConstr + (m_paneItems.GetUpperBound()*m_sizeBorder) + 2*m_sizeExtraBorder;¤	}¤	else if( m_modeResize & ABSOLUTE_VERT && m_sizeSecondary!=0) {¤		return m_sizeSecondary; // + 2*m_sizeExtraBorder;¤	}¤	else {¤		int nMaxConstr = 0;¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤			int nConstrain = pItem->getMinConstrainVert();¤			nMaxConstr = std::max(nMaxConstr, nConstrain);¤		}¤		return nMaxConstr + 2*m_sizeExtraBorder;¤	}¤}¤¤¤int ETSLayoutMgr::Pane::resizeToAbsolute(int& availSpace, CArray<int,int>& sizePrimary, ¤										 CArray<int,int>& sizeMin, CArray<int,int>& sizeMax)¤{¤	// count all greedy items as returnvalue¤	int nGreedy = 0;¤¤	// first, subtract all absoulute items from available space¤	for(int i=0; i<m_paneItems.GetSize(); ++i) {¤		CPaneBase pItem = m_paneItems[i];¤¤		if( m_Orientation == HORIZONTAL ) {¤¤			// for absolute items subtract their size from available space¤			if(pItem->modeResize() & ABSOLUTE_HORZ) {¤				availSpace -= (sizePrimary[i] = pItem->getConstrainHorz(0));¤			}¤¤			// count Greedy items for later¤			if(!(pItem->modeResize() & ABSOLUTE_HORZ) && !(pItem->modeResize() & RELATIVE_HORZ)) {¤				nGreedy++;¤			}¤¤			sizeMin[i] = pItem->getMinConstrainHorz();¤			sizeMax[i] = pItem->getMaxConstrainHorz();¤		}¤		else {¤¤			// for absolute items subtract their size from available space¤			if(pItem->modeResize() & ABSOLUTE_VERT) {¤				availSpace -= (sizePrimary[i] = pItem->getConstrainVert(0));¤			}¤¤			// count Greedy items for later¤			if(!(pItem->modeResize() & ABSOLUTE_VERT) && !(pItem->modeResize() & RELATIVE_VERT)) {¤				nGreedy++;¤			}¤¤			sizeMin[i] = pItem->getMinConstrainVert();¤			sizeMax[i] = pItem->getMaxConstrainVert();¤		}¤¤	}¤¤	// Must not be negative !!¤	availSpace = std::max(availSpace, 0);¤¤	return nGreedy;¤}¤¤bool ETSLayoutMgr::Pane::resizeToRelative(int& availSpace, CArray<int,int>& sizePrimary,¤										 CArray<int,int>& sizeMin, CArray<int,int>& sizeMax)¤{¤	// Then all relative items as percentage of left space (as of now after¤	// all absolute items are subtracted¤¤	int availRel = availSpace;	// At the beginning all of remaining space is available. We want all¤								// operation to be relative to the left space at this moment, so we¤								// save this amount here. Then we safly can lower availSpace¤¤	int relDiff = 0;			// The cumulated difference between first proposed size and¤								// eventual maximum/minimum size. This amount has to be¤								// saved in some other place (i.e. where relativ items/subpane¤								// are not limited by min/max¤	¤	int relLeft = 0;			// The cumulated amout of space that can be saved by¤								// shrinking the items/panes up to the minimum¤	¤	int relCount = 0;			// Actually allocated item/subpane's cumulated primary sizes ¤								// of non-limited items/subpanes (these can be modified in fixup)¤								// needed for equally distribution of differences amoung non-limited¤								// relative items/subpanes¤¤	for(int i=0; i<m_paneItems.GetSize(); ++i) {¤		CPaneBase pItem = m_paneItems[i];¤¤		// For all relative items in primary direction¤		if( (m_Orientation==HORIZONTAL && pItem->modeResize() & RELATIVE_HORZ)¤			||¤			(m_Orientation==VERTICAL   && pItem->modeResize() & RELATIVE_VERT) )¤		{¤			// minimum item/subpane size in primary direction (pixels)¤			int nSizeRelMin = sizeMin[i];¤¤			// maximum item/subpane size in primary direction (pixels)¤			int nSizeRelMax = sizeMax[i];¤¤			// Relative size in primary direction (pixels)¤			int nSizeRel	= (m_Orientation==HORIZONTAL) ¤									? ¤									(pItem->getConstrainHorz(availRel)) ¤									:¤									(pItem->getConstrainVert(availRel));¤¤			if( nSizeRel < nSizeRelMin) {¤				// The item/pane is shrinked too small!¤				// We will grow it to it's minimum-size. In order not to modify¤				// this item later when fixing up set the size to the negative¤				// minimum size¤				sizePrimary[i]	= -nSizeRelMin;¤¤				// As we grew one item/subpane we have to shrink another one.¤				// We keep count on how much space we needed to grow the item¤				// to it's minimum size¤				relDiff += ( nSizeRelMin - nSizeRel );¤			}¤			else if(  nSizeRelMax != -1 && nSizeRel > nSizeRelMax) {¤				// if there's a maximum size (nSizeRelMax != -1) and our item/subpane¤				// is to be resized over that amount correct it.  In order not to modify¤				// this item later when fixing up set the size to the negative¤				// maximum size¤				sizePrimary[i]	= -nSizeRelMax;¤¤				// As we shrinked one item/subpane we have to grow another one.¤				// We keep count on how much space we needed to grow the item¤				// to it's maximum size.¤				relDiff += ( nSizeRelMax - nSizeRel );¤			}¤			else {¤				// this is the normal case: neither are we minimum limited nor maximum¤				// limited¤¤				// As this item/subpane is larger that it's minimum we could later (if¤				// necessary for fixup) shrink it for the difference amount of pixels¤				relLeft	+= ( nSizeRel - nSizeRelMin );¤¤				// Set the primary size of this item/pane. Can later be modified by fixup¤				sizePrimary[i]	= nSizeRel;¤¤				// Add this item/subpane's primary size to the count of already allocated¤				// cumulated size of non-limited items/subpanes (these can be modified in fixup)¤				relCount	+= nSizeRel;¤			}¤¤			// decrease available space by used space in this step¤			availSpace	-= nSizeRel;¤		}¤	}¤¤	// We now have the situation that some items/subpanes had to be adjusted for cumulated¤	// relDiff pixels (positive value means more space taken than indicated by percentage of¤	// left space). On the other hand we have some items/subpanes which were not limited (in ¤	// their current dimensions) but could be if necessary up to relLeft pixels. ¤	if(relLeft < relDiff && availSpace >= (relDiff-relLeft) ){		¤¤		// If it's not possible to shrink other (relative) panes in order to distribute the¤		// difference because the left for shrinking (relLeft) is too small we need to aquire¤		// more space from the globally left space (if available at all)¤		availSpace -= (relDiff-relLeft);¤		relDiff = relLeft;¤	}¤¤	// At this point we should have some space left (at least not be negative with the leftover¤	// space) and on the other hand there's enough space for the limit-difference to be distributed¤//	ASSERT( availSpace >= 0 && relLeft >= relDiff);¤¤	// Fixup Relative:¤	// Distribute (if anecessary) relDiff on other (not limited) relative items/subpanes ¤	// (if available - if not later just grow the limited panes)¤	while( relDiff != 0 && relCount >= 0 ) {¤¤		// in every iteration there must be some space distributed (of the difference) or it could ¤		// come to endless looping. Save the amount of space actually distributed in this iteration¤		int relDist = 0;¤¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			¤			CPaneBase pItem = m_paneItems[i];¤¤¤			// For all relative items in primary direction which were NOT limited¤			if( (m_Orientation==HORIZONTAL && (pItem->modeResize() & RELATIVE_HORZ) && sizePrimary[i] > 0)¤				||¤				(m_Orientation==VERTICAL   && (pItem->modeResize() & RELATIVE_VERT) && sizePrimary[i] > 0) )¤			{¤				// keep a flag for termination of this iteration¤				bool bLast = false;¤¤				// the difference should be distributed amoung all non-limited items/subpanes equally.¤				// nDiff is the amount for the current item/subpane¤				int nDiff = (relDiff * sizePrimary[i]) / relCount;¤¤				// if it's a too small value just add it to the current pane and break iteration¤				if( abs(relDiff) <= FIXUP_CUTOFF ) {¤					// take it all in this step¤					nDiff = relDiff;¤¤					// set break flag¤					bLast = true;¤				}¤¤				// calculate the new size for the current item/subpane¤				int nNewSize = sizePrimary[i] - nDiff;¤			¤				if( nNewSize < sizeMin[i] ) {¤					// oh, we are limited here. Revise our plan:¤¤					// Not all of the space could be saved, add the actually possible space¤					// to the sum¤					relDist += ( sizePrimary[i] - sizeMin[i] );¤¤					// set it to the minimum possible size¤					sizePrimary[i] = -sizeMin[i];¤¤					// as this item/subpane is now limited it's occupied space doesn't count¤					// for relCount anymore¤					relCount-= ( sizePrimary[i] );¤				}¤				else {¤					// account the difference of the sizes in relDist and set new size¤					relDist += ( sizePrimary[i] - nNewSize );¤					sizePrimary[i] = nNewSize;¤¤					// if it's the last one break now¤					if(bLast)¤						break;¤				}¤			}¤		}¤		// Distributed some relDiff-space in every iteration¤//		ASSERT(relDist != 0);	¤		relDiff -= relDist;¤¤		if( relDist == 0 )¤			break;¤	}¤¤	// Fixup Relative: invert all negative (limited) sized to correct value¤	for(int i=0; i<m_paneItems.GetSize(); ++i) {¤		CPaneBase pItem = m_paneItems[i];¤		if( (m_Orientation==HORIZONTAL && (pItem->modeResize() & RELATIVE_HORZ) && sizePrimary[i] < 0)¤			||¤			(m_Orientation==VERTICAL   && (pItem->modeResize() & RELATIVE_VERT) && sizePrimary[i] < 0) )¤		{¤			sizePrimary[i] *= -1;¤		}¤	}¤¤	return true;¤}¤¤bool ETSLayoutMgr::Pane::resizeToGreedy(int& availSpace, int nGreedy, CArray<int,int>& sizePrimary, ¤									   CArray<int,int>& sizeMin, CArray<int,int>& sizeMax)¤{¤	// Now resize all Greedy items/subpanes equally among the remaining space¤	int greedyDiff = 0;			// The cumulated difference between first proposed size and¤								// eventual maximum/minimum size. This amount has to be¤								// saved in some other place (i.e. where items/subpane¤								// are not limited by min/max¤	¤	int greedyLeft = 0;			// The cumulated amount of space that can be saved by¤								// shrinking the items/panes up to the minimum¤	¤	int greedyCount = 0;		// Actually allocated item/subpane's cumulated primary sizes ¤								// of non-limited items/subpanes (these can be modified in fixup)¤								// needed for equally distribution of differences amoung non-limited¤								// items/subpanes¤¤	for(int i=0; i<m_paneItems.GetSize(); ++i) {¤		CPaneBase pItem = m_paneItems[i];¤¤¤		if( (m_Orientation==HORIZONTAL ¤				&& !(pItem->modeResize()&ABSOLUTE_HORZ) ¤				&& !(pItem->modeResize()&RELATIVE_HORZ)¤			)¤			||¤			(m_Orientation==VERTICAL   ¤				&& !(pItem->modeResize()&ABSOLUTE_VERT) ¤				&& !(pItem->modeResize()&RELATIVE_VERT)¤			) ¤		)¤		{¤¤			// All greedy items get an equal portion of the left space¤			int nSize		= availSpace / nGreedy;¤¤			// minimum item/subpane size in primary direction (pixels)¤			int nSizeMin	= sizeMin[i];¤¤			// maximum item/subpane size in primary direction (pixels)¤			int nSizeMax	= sizeMax[i];¤¤¤			// the last gets the all of the remaining space¤			if( nGreedy == 1 )¤				nSize = availSpace;						¤¤			if( nSize < nSizeMin) {¤				// The item/pane is shrinked too small!¤				// We will grow it to it's minimum-size. In order not to modify¤				// this item later when fixing up set the size to the negative¤				// minimum size¤				sizePrimary[i]	= -nSizeMin;¤¤				// As we grew one item/subpane we have to shrink another one.¤				// We keep count on how much space we needed to grow the item¤				// to it's minimum size¤				greedyDiff		+= ( nSizeMin - nSize );¤			}¤			else if( nSizeMax != -1 && nSize > nSizeMax) {¤				// if there's a maximum size (nSizeRelMax != -1) and our item/subpane¤				// is to be resized over that amount correct it.  In order not to modify¤				// this item later when fixing up set the size to the negative¤				// maximum size¤				sizePrimary[i]	= -nSizeMax;¤¤				// As we shrinked one item/subpane we have to grow another one.¤				// We keep count on how much space we needed to grow the item¤				// to it's maximum size.¤				greedyDiff		+= ( nSizeMax - nSize );¤			}¤			else {¤¤				// this is the normal case: neither are we minimum limited nor maximum¤				// limited¤¤				// As this item/subpane is larger that it's minimum we could later (if¤				// necessary for fixup) shrink it for the difference amount of pixels¤				greedyLeft		+= ( nSize - nSizeMin );¤¤				// Set the primary size of this item/pane. Can later be modified by fixup¤				sizePrimary[i]	= nSize;¤¤				// Add this item/subpane's primary size to the count of already allocated¤				// cumulated size of non-limited items/subpanes (these can be modified in fixup)¤				greedyCount		+= nSize;¤			}¤¤			// decrease available space by used space in this step¤			availSpace	-= nSize;¤¤			// one greedy item/subpane complete¤			--nGreedy;¤		}¤	}¤¤¤	// Fixup Greedy I¤	// Distribute (if anecessary) greedyDiff on other (not limited) greedy items/subpanes ¤	// (if available - if not later just grow the limited panes)¤¤	// at least on not limited item present¤	bool bAtLeastOne = true;¤¤	while( bAtLeastOne && greedyDiff != 0 && greedyCount > 0) {¤¤		// in every iteration there must be some space distributed (of the difference) or it could ¤		// come to endless looping. Save the amount of space actually distributed in this iteration¤		int greedyDist = 0;¤¤		// at least on not limited item present¤		bAtLeastOne = false;¤¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤¤¤			if( (m_Orientation==HORIZONTAL ¤					&& !(pItem->modeResize()&ABSOLUTE_HORZ) ¤					&& !(pItem->modeResize()&RELATIVE_HORZ)¤					&& sizePrimary[i] > 0¤				)	¤				||¤				(m_Orientation==VERTICAL   ¤					&& !(pItem->modeResize()&ABSOLUTE_VERT) ¤					&& !(pItem->modeResize()&RELATIVE_VERT)¤					&& sizePrimary[i] > 0 ¤				)¤			)¤			{¤	 			// keep a flag for termination of this iteration¤				bool bLast = false;¤¤				// the difference should be distributed among all non-limited items/subpanes equally.¤				// nDiff is the amount for the current item/subpane¤				int nDiff = (greedyDiff * sizePrimary[i]) / greedyCount;¤¤				// if it's a too small value just add it to the current pane and break iteration¤				if( abs(greedyDiff) <= FIXUP_CUTOFF || nDiff == 0) {¤					// take it all in this step¤					nDiff = greedyDiff;¤¤					// set break flag¤					bLast = true;¤				}¤¤				// calculate the new size for the current item/subpane¤				int nNewSize = sizePrimary[i] - nDiff;¤			¤				if( nNewSize < sizeMin[i] ) {¤					// oh, we are limited here. Revise our plan:¤¤					if( sizePrimary[i] != sizeMin[i] )¤						bAtLeastOne = true;¤¤					// Not all of the space could be saved, add the actually possible space¤					// to the sum¤					greedyDist += ( sizePrimary[i] - sizeMin[i] );¤¤					// set it to the minimum possible size¤					sizePrimary[i] = sizeMin[i];¤¤					// as this item/subpane is now limited its occupied space doesn't count¤					// for relCount anymore¤					greedyCount -= ( sizePrimary[i] );¤				}¤				else {¤					// yes, there is one¤					bAtLeastOne = true;¤¤					// account the difference of the sizes in relDist and set new size¤					greedyDist += ( sizePrimary[i] - nNewSize );¤					sizePrimary[i] = nNewSize;¤¤					// if it's the last one break now¤					if(bLast)¤						break;¤				}¤			}¤		}¤		// Distributed some greedyDiff-space in every iteration¤		ASSERT(!bAtLeastOne || greedyDist != 0 || greedyCount<=0);¤		greedyDiff -= greedyDist;¤	}¤¤¤	// Fixup Greedy II¤	if( greedyDiff < 0 ) {¤		// still difference, some space left¤¤		// are there any items which are minimum-limited where we can give more space?¤		for(int i=0; i<m_paneItems.GetSize() && greedyDiff!=0; ++i) {¤			CPaneBase pItem = m_paneItems[i];¤¤			if( (m_Orientation==HORIZONTAL ¤					&& !(pItem->modeResize()&ABSOLUTE_HORZ) ¤					&& !(pItem->modeResize()&RELATIVE_HORZ)¤				)	¤				||¤				(m_Orientation==VERTICAL   ¤					&& !(pItem->modeResize()&ABSOLUTE_VERT) ¤					&& !(pItem->modeResize()&RELATIVE_VERT)¤				)¤			)¤			{¤				if( sizePrimary[i] == -sizeMin[i] ) {¤					// fill this one up as much as possible¤					if( sizeMax[i] == -1) {¤						// all fits in¤						sizePrimary[i] += greedyDiff;¤						greedyDiff = 0;¤					}¤					else {¤						sizePrimary[i] += -std::min( -greedyDiff, sizeMax[i]-sizeMin[i]);¤						greedyDiff     -= -std::min( -greedyDiff, sizeMax[i]-sizeMin[i]);¤					}¤				}¤			}¤		}¤	}¤¤¤	// Fixup Greedy III: invert all negative (limited) sized to correct value¤	for(int i=0; i<m_paneItems.GetSize(); ++i) {¤		CPaneBase pItem = m_paneItems[i];¤¤		if( (m_Orientation==HORIZONTAL ¤				&& !(pItem->modeResize() & ABSOLUTE_HORZ) ¤				&& !(pItem->modeResize() & RELATIVE_HORZ) ¤				&& sizePrimary[i] < 0¤				&& sizeMin[i] >= 0¤			)¤			||¤			(m_Orientation==VERTICAL   ¤				&& !(pItem->modeResize() & ABSOLUTE_VERT) ¤				&& !(pItem->modeResize() & RELATIVE_VERT) ¤				&& sizePrimary[i] < 0¤				&& sizeMin[i] >= 0¤			) ¤		)¤		{¤			if(sizePrimary[i] < 0)¤				sizePrimary[i] *= -1;¤		}¤	}¤¤	return true;¤}¤¤¤bool ETSLayoutMgr::Pane::resizeTo(CRect& rcNewArea) ¤{¤	// There must be some items or subpanes¤	ASSERT(m_paneItems.GetSize());¤¤	// This Array holds the size in primary direction for each item/subpane¤	CArray<int,int>	sizePrimary;¤	sizePrimary.SetSize(m_paneItems.GetSize());¤¤	// This Array holds information about the minimum size in primary direction¤	CArray<int,int>	sizeMin;¤	sizeMin.SetSize(m_paneItems.GetSize());¤¤	// This Array holds information about the maximum size in primary direction¤	CArray<int,int>	sizeMax;¤	sizeMax.SetSize(m_paneItems.GetSize());¤¤¤	// How much space is actually available, subtract all borders between items¤	int availSpace = (m_Orientation == HORIZONTAL ? rcNewArea.Width() : rcNewArea.Height() ) - (m_paneItems.GetUpperBound()*m_sizeBorder);¤	¤	// If there is some Extra border (on top/bottem resp. left/right) subtract it too¤	availSpace -= 2*m_sizeExtraBorder;¤¤	// Add the extra Border to top/bottem resp. left/right¤	if(m_Orientation == HORIZONTAL) {¤		rcNewArea.top		+= m_sizeExtraBorder;¤		rcNewArea.bottom	-= m_sizeExtraBorder;¤	}¤	else {¤		rcNewArea.left		+= m_sizeExtraBorder;¤		rcNewArea.right		-= m_sizeExtraBorder;¤	}¤¤	// Counts the number of greedy items/subpanes¤	int nGreedy = resizeToAbsolute(availSpace, sizePrimary, sizeMin, sizeMax );¤¤	if(nGreedy == -1)¤		return false;¤¤	if(! resizeToRelative(availSpace, sizePrimary, sizeMin, sizeMax ) )¤		return false;¤¤	if(! resizeToGreedy(availSpace, nGreedy, sizePrimary, sizeMin, sizeMax ) )¤		return false;¤¤¤	// If there is any left space and there are ALIGN_FILL_* Items to assign it¤	// equally among them¤	if( availSpace > 0 ) {¤		// Count possible Items¤		int nFillItems = 0;¤¤		for(int i=0; i<m_paneItems.GetSize(); ++i) {¤			CPaneBase pItem = m_paneItems[i];¤			if( m_Orientation == HORIZONTAL ¤				&& (pItem->modeResize() & ABSOLUTE_HORZ ) ¤				&& (pItem->modeResize() & ALIGN_FILL_HORZ)¤			¤				||¤				¤				(pItem->modeResize() & ABSOLUTE_VERT ) ¤				&& (pItem->modeResize() & ALIGN_FILL_VERT) ¤			)¤			{¤				++nFillItems;¤			}¤		}¤¤		if( nFillItems > 0 ) {¤			// okay, there are nFillItems, make them all availSpace/nFillItems bigger¤			for(int i=0; i<m_paneItems.GetSize(); ++i) {¤				CPaneBase pItem = m_paneItems[i];¤¤				if( m_Orientation == HORIZONTAL ¤					&& (pItem->modeResize() & ABSOLUTE_HORZ ) ¤					&& (pItem->modeResize() & ALIGN_FILL_HORZ)¤				¤					||¤					¤					(pItem->modeResize() & ABSOLUTE_VERT ) ¤					&& (pItem->modeResize() & ALIGN_FILL_VERT) ¤				)¤				{¤¤					if( nFillItems == 1 ) {¤						// the last one gets all the rest¤						sizePrimary[i]	+= availSpace;¤						availSpace		= 0;¤						--nFillItems;¤					}¤					else {¤						sizePrimary[i]	+= availSpace/nFillItems;¤						availSpace		-= availSpace/nFillItems;¤						--nFillItems;¤					}¤¤				}¤			}¤		}¤¤	}¤¤	// Now reposition all items:¤¤	// starting offset¤	int nOffset = (m_Orientation==HORIZONTAL ? rcNewArea.left : rcNewArea.top ) + m_sizeExtraBorder;¤	for(int i=0; i<m_paneItems.GetSize(); ++i) {¤		CPaneBase pItem = m_paneItems[i];¤¤		// Calculate rect of item/subpane¤		CRect rcPane;¤		¤		if( m_Orientation==HORIZONTAL ) {¤			rcPane.SetRect(nOffset, rcNewArea.top, nOffset+sizePrimary[i], rcNewArea.bottom);¤		}¤		else {¤			rcPane.SetRect(rcNewArea.left, nOffset, rcNewArea.right, nOffset+sizePrimary[i]);¤		}¤¤		// do the resizing!¤		pItem->resizeTo( rcPane );¤¤		// go to the next position (old pos + size + border)¤		ASSERT(sizePrimary[i] >= 0);¤		nOffset += m_sizeBorder + sizePrimary[i];¤	}				¤¤¤	return true;			¤}¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutDialog dialog¤¤#pragma warning(disable: 4355)¤ETSLayoutDialog::ETSLayoutDialog(UINT nID, CWnd* pParent /*=NULL*/, LPCTSTR strName /*=NULL*/, bool bGripper /*=true*/)¤	: CBaseDialog(nID, pParent), ETSLayoutMgr( this )¤{¤	//{{AFX_DATA_INIT(ETSLayoutDialog)¤		// NOTE: the ClassWizard will add member initialization here¤	//}}AFX_DATA_INIT¤	m_bGripper	= bGripper;¤¤	if(strName)¤		m_strRegStore = strName;¤}¤#pragma warning(default: 4355)¤¤BEGIN_MESSAGE_MAP(ETSLayoutDialog, CBaseDialog)¤	//{{AFX_MSG_MAP(ETSLayoutDialog)¤	ON_WM_SIZE()¤	ON_WM_GETMINMAXINFO()¤	ON_WM_ERASEBKGND()¤	ON_WM_DESTROY()¤	//}}AFX_MSG_MAP¤END_MESSAGE_MAP()¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutDialog message handlers¤¤BOOL ETSLayoutDialog::OnEraseBkgnd(CDC* pDC) ¤{¤	EraseBkgnd(pDC);¤	return true;¤}¤¤void ETSLayoutDialog::OnSize(UINT nType, int cx, int cy) ¤{¤	CBaseDialog::OnSize(nType, cx, cy);¤¤	if( abs(cx) + abs(cy) > 0) ¤	{¤		// Reposition Size Marker¤		// Re-Layout all controls¤		UpdateLayout();¤		RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);¤	}¤¤}¤¤void ETSLayoutDialog::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) ¤{¤	if(m_RootPane.IsValid()) {¤¤		CRect rcClient = GetRect();¤		if( rcClient.Height() > 0 || rcClient.Width() > 0 )¤		{¤¤			CRect rcWnd;¤			GetWindowRect(rcWnd);¤			¤			// How much do Window and Client differ¤			int nDiffHorz = rcWnd.Width() - rcClient.Width();¤			int nDiffVert = rcWnd.Height() - rcClient.Height();¤¤			// Take into account that there is a border around the rootPane¤			lpMMI->ptMinTrackSize = CPoint(m_RootPane->getMinConstrainHorz() + nDiffHorz + 2*m_sizeRootBorders.cx,¤				m_RootPane->getMinConstrainVert() + nDiffVert + 2*m_sizeRootBorders.cy);¤¤			int maxWidth = m_RootPane->getMaxConstrainHorz();¤			int maxHeight = m_RootPane->getMaxConstrainVert();¤¤			if( maxWidth != -1 ) {¤				lpMMI->ptMaxTrackSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;¤				lpMMI->ptMaxSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;¤			}¤¤			if( maxHeight != -1 ) {¤				lpMMI->ptMaxTrackSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;¤				lpMMI->ptMaxSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;¤			}¤		}¤	}¤}¤¤¤CRect ETSLayoutDialog::GetRect() ¤{ ¤	CRect r; ¤	GetClientRect(r);¤¤	if( m_bGripper ) ¤	{¤		if( ::IsWindow(m_StatusBar.GetSafeHwnd()) ) ¤		{¤			CRect rcSizeIcon;¤			m_StatusBar.GetWindowRect( rcSizeIcon);¤			r.bottom -= (rcSizeIcon.Height() - m_sizeRootBorders.cy - 5);¤		}¤	}¤¤	return r; ¤}¤¤¤BOOL ETSLayoutDialog::OnInitDialog() ¤{¤	CBaseDialog::OnInitDialog();¤¤    // Ensure that the dialog is resizable¤    this->ModifyStyle(0, WS_THICKFRAME);¤¤	if(!m_strRegStore.IsEmpty()) {¤		Load(m_strRegStore);¤	}	¤¤#ifdef _AUTO_SET_ICON¤	POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition();¤	if(pos) {¤¤		class ETSPseudoDocTemplate : public CDocTemplate¤		{¤			friend class ETSLayoutDialog;¤		};¤¤		ETSPseudoDocTemplate* pDocT = (ETSPseudoDocTemplate*) AfxGetApp()->GetNextDocTemplate(pos);¤		SetIcon( AfxGetApp()->LoadIcon(pDocT->m_nIDResource) ,FALSE);¤	}¤#endif¤	¤	// Sizing icon¤	if(m_bGripper)¤	{¤		if(m_StatusBar.Create(m_pWnd))¤		{                           ¤			m_StatusBar.SetIndicators(auIDStatusBar, sizeof(auIDStatusBar) / sizeof(UINT));¤			m_StatusBar.SetWindowText(_T(""));		¤			m_StatusBar.SetPaneStyle( 0, SBPS_STRETCH | SBPS_NOBORDERS );¤			m_pWnd -> RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);¤		}             ¤		else¤			AfxMessageBox(_T("Error - Statusbar"));¤¤	}¤	return TRUE;  // return TRUE unless you set the focus to a control¤	              // EXCEPTION: OCX Property Pages should return FALSE¤}¤¤void ETSLayoutDialog::OnDestroy() ¤{¤	// Store size/position¤	if(!m_strRegStore.IsEmpty()) {¤		Save(m_strRegStore);¤	}	¤¤	// manually delete layout definition if object is reused¤	m_RootPane = 0;¤¤	CBaseDialog::OnDestroy();¤}¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutDialog dialog¤¤#pragma warning(disable: 4355)¤#ifdef CS_HELP¤ETSLayoutDialogBar::ETSLayoutDialogBar(UINT nID )¤	: CBaseDialogBar( nID ), ETSLayoutMgr( this )¤#else¤ETSLayoutDialogBar::ETSLayoutDialogBar()¤	: ETSLayoutMgr( this )¤#endif¤{¤	//{{AFX_DATA_INIT(ETSLayoutDialogBar)¤		// NOTE: the ClassWizard will add member initialization here¤	//}}AFX_DATA_INIT¤	m_bInitialized = false;¤	setRootBorders(0,0);¤}¤#pragma warning(default: 4355)¤¤BEGIN_MESSAGE_MAP(ETSLayoutDialogBar, CBaseDialogBar)¤	//{{AFX_MSG_MAP(ETSLayoutDialogBar)¤	ON_WM_SIZE()¤	ON_WM_GETMINMAXINFO()¤	ON_WM_DESTROY()¤	ON_WM_ERASEBKGND()¤	ON_MESSAGE(WM_INITDIALOG, OnInitDialog)¤	//}}AFX_MSG_MAP¤END_MESSAGE_MAP()¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutDialogBar message handlers¤¤LRESULT ETSLayoutDialogBar::OnInitDialog(WPARAM, LPARAM)¤{¤	Default();¤	Initialize();¤	return TRUE;¤}¤¤void ETSLayoutDialogBar::UpdateLayout()¤{¤	ETSLayoutMgr::UpdateLayout();¤¤	if(m_RootPane.IsValid()) {¤		CRect rcClient = GetRect();¤¤		CRect rcWnd;¤		GetWindowRect(rcWnd);¤			¤		// How much do Window and Client differ¤		CSize sizeDiff( rcWnd.Width() - rcClient.Width(), rcWnd.Height() - rcClient.Height());¤¤		// Take into account that there is a border around the rootPane¤//		m_szMin = CSize(m_RootPane->getMinConstrainHorz() + sizeDiff.cx + 2*m_sizeRootBorders.cx,¤//			m_RootPane->getMinConstrainVert() + sizeDiff.cy + 2*m_sizeRootBorders.cy);¤	}¤}¤¤CSize ETSLayoutDialogBar::CalcDynamicLayout(int nLength, DWORD dwMode)¤{¤	CSize sizeRet =  CBaseDialogBar::CalcDynamicLayout(nLength, dwMode);¤¤	CSize sizeMin = sizeRet;¤	CSize sizeMax = sizeRet;¤¤	if(m_RootPane.IsValid()) {¤		CRect rcClient = GetRect();¤¤		CRect rcWnd;¤		GetWindowRect(rcWnd);¤			¤		// How much do Window and Client differ¤		CSize sizeDiff( rcWnd.Width() - rcClient.Width(), rcWnd.Height() - rcClient.Height());¤¤		// Take into account that there is a border around the rootPane¤//		sizeMin = CSize(m_RootPane->getMinConstrainHorz() + sizeDiff.cx + 2*m_sizeRootBorders.cx,¤//			m_RootPane->getMinConstrainVert() + sizeDiff.cy + 2*m_sizeRootBorders.cy);¤¤¤		int maxWidth = m_RootPane->getMaxConstrainHorz();¤		int maxHeight = m_RootPane->getMaxConstrainVert();¤¤		if( maxWidth != -1 ) {¤			sizeMax.cx = maxWidth + sizeDiff.cy + 2*m_sizeRootBorders.cx;¤		}¤¤		if( maxHeight != -1 ) {¤			sizeMax.cy = maxHeight + sizeDiff.cy + 2*m_sizeRootBorders.cy;¤		}¤	}¤¤	if( IsFloating() || !(dwMode&LM_HORZ))¤	{¤		sizeRet.cx = std::min( sizeRet.cx, sizeMax.cx );¤	}¤	if( IsFloating() || (dwMode&LM_HORZ))¤	{¤		sizeRet.cy = std::min( sizeRet.cy, sizeMax.cy );¤	}¤¤	sizeRet.cx = std::max( sizeRet.cx, sizeMin.cx );¤	sizeRet.cy = std::max( sizeRet.cy, sizeMin.cy );¤¤	return sizeRet;¤}¤¤BOOL ETSLayoutDialogBar::OnEraseBkgnd(CDC* pDC) ¤{¤	EraseBkgnd(pDC);¤	return true;¤}¤¤¤void ETSLayoutDialogBar::OnSize(UINT nType, int cx, int cy) ¤{¤	CBaseDialogBar::OnSize(nType, cx, cy);¤¤	if( abs(cx) + abs(cy) > 0)¤	{¤		// Re-Layout all controls¤		UpdateLayout();¤	}¤	RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);¤¤}¤¤¤CRect ETSLayoutDialogBar::GetRect() ¤{ ¤	CRect r; ¤	GetClientRect(r);¤¤	if( IsFloating() )¤		r.DeflateRect(4,4);¤¤	return r; ¤}¤¤¤void ETSLayoutDialogBar::OnDestroy() ¤{¤	// Store size/position on your own!¤	CBaseDialogBar::OnDestroy();¤}¤¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutFormView dialog¤¤IMPLEMENT_DYNAMIC(ETSLayoutFormView, CFormView)¤¤#pragma warning(disable: 4355)¤ETSLayoutFormView::ETSLayoutFormView(UINT nID, LPCTSTR strName /*=NULL*/)¤	: CBaseFormView(nID), ETSLayoutMgr( this )¤{¤	if(strName)¤		m_strRegStore = strName;¤}¤#pragma warning(default: 4355)¤¤BEGIN_MESSAGE_MAP(ETSLayoutFormView, CBaseFormView)¤	//{{AFX_MSG_MAP(ETSLayoutFormView)¤	ON_WM_SIZE()¤	ON_WM_GETMINMAXINFO()¤	ON_WM_ERASEBKGND()¤	//}}AFX_MSG_MAP¤END_MESSAGE_MAP()¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutFormView message handlers¤¤BOOL ETSLayoutFormView::OnEraseBkgnd(CDC* pDC) ¤{¤	EraseBkgnd(pDC);¤	return true;¤}¤¤¤void ETSLayoutFormView::OnSize(UINT nType, int cx, int cy) ¤{¤//	CBaseFormView::OnSize(nType, cx, cy);¤	SetScrollSizes(MM_TEXT, CSize(cx,cy));¤	if( abs(cx) + abs(cy) > 0) {¤		// Re-Layout all controls¤		UpdateLayout();¤	}¤//	MoveWindow(0,0,cx,cy);¤}¤¤/*¤void ETSLayoutFormView::UpdateLayout()¤{¤	ETSLayoutMgr::UpdateLayout();¤¤	if(m_RootPane.IsValid()) {¤		// Force MainFrame to re-layout¤		CFrameWnd* pFrame = static_cast<CFrameWnd*>(GetParent());¤		if(pFrame) {¤¤			CRect rcWnd;¤			pFrame->GetWindowRect(rcWnd);¤			pFrame->MoveWindow(rcWnd);¤			pFrame->RecalcLayout();¤¤		}¤		return;¤	}¤}¤*/¤¤void ETSLayoutFormView::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) ¤{¤	// To use this you'll have to modify your CMainFrame:¤	//¤	// 1) Add a handler for WM_GETMINMAXINFO()¤	// 2) Let this handler be:¤	// void CMainFrame::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) ¤	// {¤	// 	CFrameWnd::OnGetMinMaxInfo(lpMMI);¤	// ¤	// 	if( GetActiveView() && GetActiveView()->IsKindOf( RUNTIME_CLASS(ETSLayoutFormView) ) ) {¤	// 		GetActiveView()->SendMessage( WM_GETMINMAXINFO, 0, (LPARAM) lpMMI );¤	// 	}¤	// }¤	// 3) Add "#include "dialogmgr.h" to MainFrm.cpp¤¤	if(m_RootPane.IsValid()) {¤		CRect rcClient = GetRect();¤¤		CRect rcWnd;¤		GetParent()->GetWindowRect(rcWnd);¤	¤		// How much do Window and Client differ¤		rcWnd-=rcClient;¤¤		// Take into account that there is a border around the rootPane¤		lpMMI->ptMinTrackSize = CPoint(m_RootPane->getMinConstrainHorz() + rcWnd.Width() + 2*m_sizeRootBorders.cx,¤			m_RootPane->getMinConstrainVert() + rcWnd.Height() + 2*m_sizeRootBorders.cy);¤¤		int maxWidth = m_RootPane->getMaxConstrainHorz();¤		int maxHeight = m_RootPane->getMaxConstrainVert();¤¤		if( maxWidth != -1 ) {¤			lpMMI->ptMaxTrackSize.x = maxWidth + rcWnd.Width()+ 2*m_sizeRootBorders.cx;¤			lpMMI->ptMaxSize.x = maxWidth + rcWnd.Width()+ 2*m_sizeRootBorders.cx;¤		}¤¤		if( maxHeight != -1 ) {¤			lpMMI->ptMaxTrackSize.y = maxHeight + rcWnd.Height() + 2*m_sizeRootBorders.cy;¤			lpMMI->ptMaxSize.y = maxHeight + rcWnd.Height() + 2*m_sizeRootBorders.cy;¤		}¤	}¤}¤¤ETSLayoutFormView::~ETSLayoutFormView() ¤{¤	// Cleanup¤}¤¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutPropertyPage¤¤#ifdef CS_HELP¤	IMPLEMENT_DYNCREATE(ETSLayoutPropertyPage, ETSCSHelpPropPage)¤#else¤	IMPLEMENT_DYNCREATE(ETSLayoutPropertyPage, CPropertyPage)¤#endif¤¤#pragma warning(disable: 4355)¤ETSLayoutPropertyPage::ETSLayoutPropertyPage( ) : ETSLayoutMgr( this )¤{¤	m_bLockMove = false;¤	m_bResetBuddyOnNextTimeVisible = true;¤}¤¤ETSLayoutPropertyPage::ETSLayoutPropertyPage( UINT nIDTemplate, UINT nIDCaption /*= 0*/ )¤	: CBasePropertyPage(nIDTemplate, nIDCaption), ETSLayoutMgr( this )¤{¤	m_bLockMove = false;¤	m_bResetBuddyOnNextTimeVisible = true;¤}¤¤ETSLayoutPropertyPage::ETSLayoutPropertyPage( LPCTSTR lpszTemplateName, UINT nIDCaption /*= 0*/ )¤	: CBasePropertyPage(lpszTemplateName, nIDCaption), ETSLayoutMgr( this )¤{¤	m_bLockMove = false;¤	m_bResetBuddyOnNextTimeVisible = true;¤}¤#pragma warning(default: 4355)¤¤ETSLayoutPropertyPage::~ETSLayoutPropertyPage()¤{¤}¤¤¤BEGIN_MESSAGE_MAP(ETSLayoutPropertyPage, CBasePropertyPage)¤	//{{AFX_MSG_MAP(ETSLayoutPropertyPage)¤	ON_WM_SIZE()¤	ON_WM_GETMINMAXINFO()¤	ON_WM_ERASEBKGND()¤	ON_WM_WINDOWPOSCHANGING()¤	ON_WM_DESTROY()¤	ON_WM_WINDOWPOSCHANGED()¤	//}}AFX_MSG_MAP¤END_MESSAGE_MAP()¤¤¤/////////////////////////////////////////////////////////////////////////////¤// Behandlungsroutinen f№r Nachrichten ETSLayoutPropertyPage ¤¤¤¤void ETSLayoutPropertyPage::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) ¤{¤	CBasePropertyPage::OnWindowPosChanged(lpwndpos);¤	¤	// This code is needed in order to reset the buddy after this page has¤	// been activated. At least on Win2k this is not done thru normal resizing,¤	// as the page is not visible when first layouted. And without the page¤	// being visible it's not possible to tell if the attached buddy is visible¤	// or not (at least I don't know any way to do so)¤¤	if( ::IsWindowVisible( GetWnd()->GetSafeHwnd() ) )¤	{¤		if( m_bResetBuddyOnNextTimeVisible ) ¤		{¤			// Take special care of SpinButtons (Up-Down Controls) with Buddy set, enumerate¤			// all childs:¤			CWnd* pWndChild = GetWnd()->GetWindow(GW_CHILD);¤			TCHAR szClassName[ MAX_PATH ];¤			while(pWndChild)¤			{¤				::GetClassName( pWndChild->GetSafeHwnd(), szClassName, MAX_PATH );¤				DWORD dwStyle = pWndChild->GetStyle();¤¤				// is it a SpinButton?¤				if( _tcscmp(szClassName, UPDOWN_CLASS)==0 && ::IsWindowVisible(pWndChild->GetSafeHwnd()) ) {¤					HWND hwndBuddy = (HWND)::SendMessage( pWndChild->GetSafeHwnd(), UDM_GETBUDDY, 0, 0);¤					if( hwndBuddy != 0 && (dwStyle&(UDS_ALIGNRIGHT|UDS_ALIGNLEFT)) != 0 )¤					{¤						// reset Buddy¤						::SendMessage( pWndChild->GetSafeHwnd(), UDM_SETBUDDY, (WPARAM)hwndBuddy, 0);¤					}¤				}¤				¤¤				pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);¤			}¤¤			m_bResetBuddyOnNextTimeVisible = false;¤		}¤	}	¤	else¤	{¤		// has been hidden again¤		m_bResetBuddyOnNextTimeVisible = true;¤	}¤}¤¤void ETSLayoutPropertyPage::OnWindowPosChanging( WINDOWPOS* lpwndpos )¤{¤	// In WizardMode the System calls SetWindowPos with the ¤	// original size at every activation. This could cause¤	// some flicker in certain circumstances. Therefore we lock¤	// moving the page and unlock it only if _we_ move the page¤	if( m_bLockMove)¤	{¤		lpwndpos->flags |= SWP_NOMOVE | SWP_NOSIZE;¤	}¤	CBasePropertyPage::OnWindowPosChanging( lpwndpos );¤}¤¤BOOL ETSLayoutPropertyPage::OnEraseBkgnd(CDC* pDC) ¤{¤	EraseBkgnd(pDC);¤	return true;¤}¤¤void ETSLayoutPropertyPage::OnDestroy() ¤{¤	// manually delete layout definition if object is reused¤	m_RootPane = 0;¤¤	CBasePropertyPage::OnDestroy();¤}¤¤void ETSLayoutPropertyPage::OnSize(UINT nType, int cx, int cy) ¤{¤	CBasePropertyPage::OnSize(nType, cx, cy);¤	¤	if( abs(cx) + abs(cy) > 0) ¤	{¤		// Re-Layout all controls¤		UpdateLayout();¤	}	¤}¤¤void ETSLayoutPropertyPage::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) ¤{¤	if(m_RootPane.IsValid()) {¤		CRect rcClient = GetRect();¤¤		CRect rcWnd;¤		GetWindowRect(rcWnd);¤		¤		// How much do Window and Client differ¤		int nDiffHorz = rcWnd.Width() - rcClient.Width();¤		int nDiffVert = rcWnd.Height() - rcClient.Height();¤¤		// Take into account that there is a border around the rootPane¤		lpMMI->ptMinTrackSize = CPoint(m_RootPane->getMinConstrainHorz() + nDiffHorz + 2*m_sizeRootBorders.cx,¤			m_RootPane->getMinConstrainVert() + nDiffVert + 2*m_sizeRootBorders.cy);¤¤		int maxWidth = m_RootPane->getMaxConstrainHorz();¤		int maxHeight = m_RootPane->getMaxConstrainVert();¤¤		if( maxWidth != -1 ) {¤			lpMMI->ptMaxTrackSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;¤			lpMMI->ptMaxSize.x = maxWidth + nDiffHorz + 2*m_sizeRootBorders.cx;¤		}¤¤		if( maxHeight != -1 ) {¤			lpMMI->ptMaxTrackSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;¤			lpMMI->ptMaxSize.y = maxHeight + nDiffVert + 2*m_sizeRootBorders.cy;¤		}¤	}¤}¤¤¤CRect ETSLayoutPropertyPage::GetRect() ¤{ ¤	CRect r; ¤	GetClientRect(r);¤	return r; ¤}¤¤¤BOOL ETSLayoutPropertyPage::OnInitDialog() ¤{¤	CBasePropertyPage::OnInitDialog();¤	UpdateLayout();¤¤	ETSLayoutPropertySheet* pSheet = (ETSLayoutPropertySheet*) GetParent();¤¤	//ASSERT_KINDOF( ETSLayoutPropertySheet, pSheet);¤	if(pSheet)¤	{¤		if(pSheet->IsWizard())¤		{¤			m_bLockMove = true;¤		}¤	}¤¤	return TRUE;¤}¤¤BOOL ETSLayoutPropertyPage::OnSetActive() ¤{¤	ETSLayoutPropertySheet* pSheet = (ETSLayoutPropertySheet*) GetParent();¤¤	//ASSERT_KINDOF( ETSLayoutPropertySheet, pSheet);¤	if(pSheet)¤	{¤		if(pSheet->IsWizard())¤		{¤			// In WizardMode the System calls SetWindowPos with the ¤			// original size on Page Activation. This will position the¤			// page at the correct position¤			m_bLockMove = false;¤			MoveWindow(pSheet->m_rcPage);¤			m_bLockMove = true;¤		}¤	}¤¤	UpdateLayout();	¤¤	return CBasePropertyPage::OnSetActive();¤}¤¤/////////////////////////////////////////////////////////////////////////////¤// ETSLayoutPropertySheet¤¤IMPLEMENT_DYNAMIC(ETSLayoutPropertySheet, CPropertySheet)¤¤#pragma warning(disable: 4355)¤ETSLayoutPropertySheet::ETSLayoutPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage, ¤											   LPCTSTR strName /*=NULL*/, bool bGripper/*=true*/)¤	: CPropertySheet(nIDCaption, pParentWnd, iSelectPage), ETSLayoutMgr( this )¤{¤	Init(strName, bGripper);¤}¤¤ETSLayoutPropertySheet::ETSLayoutPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage, ¤											   LPCTSTR strName /*=NULL*/, bool bGripper/*=true*/)¤	: CPropertySheet(pszCaption, pParentWnd, iSelectPage), ETSLayoutMgr( this )¤{¤	Init(strName, bGripper);¤}¤#pragma warning(default: 4355)¤¤void ETSLayoutPropertySheet::Init(LPCTSTR strName, bool bGripper)¤{¤	m_bGripper	= bGripper;¤	if(strName)¤		m_strRegStore = strName;¤¤	m_bAutoDestroy	= false;¤	m_bAutoDestroyPages	= false;¤	m_bModelessButtons = false;¤}¤¤ETSLayoutPropertySheet::~ETSLayoutPropertySheet()¤{¤}¤¤¤BEGIN_MESSAGE_MAP(ETSLayoutPropertySheet, CPropertySheet)¤	//{{AFX_MSG_MAP(ETSLayoutPropertySheet)¤	ON_WM_CREATE()¤	ON_WM_SIZE()¤	ON_WM_GETMINMAXINFO()¤	ON_WM_DESTROY()¤	ON_WM_ERASEBKGND()¤	//}}AFX_MSG_MAP¤END_MESSAGE_MAP()¤¤/////////////////////////////////////////////////////////////////////////////¤// Behandlungsroutinen f№r Nachrichten ETSLayoutPropertySheet ¤¤BOOL ETSLayoutPropertySheet::OnEraseBkgnd(CDC* pDC) ¤{¤	EraseBkgnd(pDC);¤	return true;¤}¤¤¤int ETSLayoutPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct) ¤{¤	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)¤		return -1;¤¤	ModifyStyle(0,WS_THICKFRAME| WS_SYSMENU);¤	return 0;¤}¤¤¤void ETSLayoutPropertySheet::Resize(int cx, int cy)¤{¤	if( abs(cx) + abs(cy) > 0 && m_RootPane.IsValid() ) ¤	{¤		UpdateLayout();¤¤		// Fix for PSH_WIZARDHASFINISH [ThЎmmi]¤		if (IsWizard() && !(m_psh.dwFlags & PSH_WIZARDHASFINISH) )¤		{¤			// manual reposition of the FINISH button¤			// can not be done with normaly layouting because it¤			// shares position with the NEXT button¤			CWnd *pWndFinish;¤			pWndFinish=GetDlgItem(ID_WIZFINISH);¤¤			if(pWndFinish)¤			{¤				CRect rcWnd;¤				GetDlgItem(ID_WIZNEXT)->GetWindowRect(&rcWnd);¤				ScreenToClient(&rcWnd);¤				pWndFinish->MoveWindow(rcWnd);¤				pWndFinish->RedrawWindow(0,0, RDW_INVALIDATE | RDW_UPDATENOW );¤			}¤		}¤¤		// reposition Gripper¤		if(m_bGripper)¤			RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);¤¤		CPropertyPage* pPage = (CPropertyPage*)GetActivePage();¤¤		if(pPage)¤		{¤			CRect rcWnd;¤			GetTabControl()->GetWindowRect(&rcWnd);¤			ScreenToClient(&rcWnd);¤¤			if(!IsWizard()) {¤				// get inside of tab¤				GetTabControl()->AdjustRect(FALSE, &rcWnd);¤			}¤			else¤			{¤				rcWnd.bottom += 5;¤			}¤¤			// we need this size in WizardMode in order to ¤			// reposition newly activated page correctly¤			m_rcPage = rcWnd;¤			¤			if( IsWizard() && pPage->IsKindOf(RUNTIME_CLASS(ETSLayoutPropertyPage)) )¤			{¤				ETSLayoutPropertyPage* pEtsPage = reinterpret_cast<ETSLayoutPropertyPage*>(pPage);¤¤				pEtsPage->m_bLockMove = false;¤				pEtsPage->MoveWindow(m_rcPage);¤				pEtsPage->m_bLockMove = true;¤			}¤			else ¤			{¤				pPage->MoveWindow(m_rcPage);¤			}¤			¤		}¤¤		if(IsWindowVisible())¤		{¤			RedrawWindow(0,0, RDW_INVALIDATE|RDW_UPDATENOW );¤¤			if(!IsWizard())¤				GetTabControl()->RedrawWindow(0,0, RDW_INVALIDATE|RDW_UPDATENOW );¤		}¤	}¤}¤¤void ETSLayoutPropertySheet::OnSize(UINT nType, int cx, int cy) ¤{¤	CPropertySheet::OnSize(nType, cx, cy);¤	Resize(cx,cy);¤}¤¤// IDs of all PropertySheet controls¤long _PropertySheetIDs[] =¤{¤	ID_WIZBACK,¤	ID_WIZNEXT, ¤	ID_WIZFINISH,¤	IDOK, ¤	IDCANCEL,¤	ID_APPLY_NOW, ¤	IDHELP¤};¤¤void ETSLayoutPropertySheet::AddMainArea(CPane paneRoot, CPaneBase itemTab)¤{¤    // the default is: Whole main Area is covered by the TabCtrl¤    paneRoot << itemTab;¤}¤¤void ETSLayoutPropertySheet::AddButtons(CPane paneBottom)¤{¤	// first item greedy to keep others right¤	paneBottom->addItem (paneNull, GREEDY);¤¤¤	// add all Controls to the layouting¤	bool bFirst = true;¤	for(int i = 0; i < (sizeof(_PropertySheetIDs) / sizeof(long)) ; i++)¤	{¤		// Prevent movement of finish button, if it is not shown explicitly [ThЎmmi]¤		if( IsWizard() ¤			&& _PropertySheetIDs[i] == ID_WIZFINISH ¤			&& !(m_psh.dwFlags & PSH_WIZARDHASFINISH) ) ¤		{¤			continue;¤		}¤¤		CWnd* pWnd = GetDlgItem(_PropertySheetIDs[i]);¤¤		if(pWnd)¤		{¤¤			if(!(m_psh.dwFlags & PSH_HASHELP) && _PropertySheetIDs[i] == IDHELP)¤			{¤				// don't insert¤				continue;¤			}¤¤			if((m_psh.dwFlags & PSH_NOAPPLYNOW) && _PropertySheetIDs[i] == ID_APPLY_NOW)¤			{¤				// don't insert¤				continue;¤			}¤¤			// space before first one and between BACK & NEXT¤			if( IsWizard() )¤			{¤				if( !bFirst && !(_PropertySheetIDs[i]==ID_WIZNEXT) )¤				{¤					paneBottom->addItem(paneNull, NORESIZE,12,0,0,0);¤				}¤			}¤¤			pWnd->ShowWindow(true);¤			paneBottom->addItem(_PropertySheetIDs[i], NORESIZE);			¤			bFirst = false;¤		}¤	}¤¤}¤¤BOOL ETSLayoutPropertySheet::OnInitDialog() ¤{¤	BOOL bRet = CPropertySheet::OnInitDialog();¤¤	//ASSERT(!m_RootPane);¤¤	// Save initial rect¤	GetWindowRect(&m_rcStart);¤¤	CPropertyPage* pPage = CPropertySheet::GetActivePage();¤	ASSERT(pPage);¤¤	CRect rcPage;¤	pPage->GetClientRect(&rcPage);¤¤	CreateRoot(VERTICAL);¤	//ASSERT(m_RootPane);¤¤	// Add Tabcontrol to root pane¤	m_ItemTab = item( GetTabControl(), GREEDY, 0, 0, 0, 0);¤    AddMainArea(m_RootPane, m_ItemTab);¤¤	// Tabcontrol is invisible in WizardMode¤	if(IsWizard())¤	{¤		GetTabControl()->ShowWindow(false);¤	}¤¤	// add horizontal line in WizardMode¤	if(IsWizard() && GetDlgItem(ID_WIZFINISH+1))¤	{¤		m_RootPane << item(ID_WIZFINISH+1, ABSOLUTE_VERT, 0, 0, 0, 0);¤	}¤¤	if( IsWizard() || !m_bModeless || m_bModelessButtons )¤	{¤		// No spaces in WizardMode in order to keep BACK & NEXT together¤		CPane bottomPane = pane(HORIZONTAL, ABSOLUTE_VERT, IsWizard() ? 0 : 5);¤¤        AddButtons(bottomPane);¤		// add bottom (button) pane if any controls were added¤        if(bottomPane->m_paneItems.GetSize() > 0) {¤    		m_RootPane << bottomPane;¤        }¤	}¤¤¤¤	// some Space between Buttons und Gripper¤	if(m_bGripper)¤	{¤		m_RootPane->addItem(paneNull, ABSOLUTE_VERT,0,2);¤¤		if(m_StatusBar.Create(m_pWnd))¤		{                           ¤			m_StatusBar.SetIndicators(auIDStatusBar,¤				sizeof(auIDStatusBar) / sizeof(UINT));¤			m_StatusBar.SetWindowText(_T(""));		¤			RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);¤		}             ¤		else¤		{¤			AfxMessageBox(_T("Error - Statusbar"));¤		}¤	}¤¤	if(!m_strRegStore.IsEmpty())¤	{¤		Load(m_strRegStore);¤	}	¤¤	Resize(1,1); // Fix. for 95/98/NT difference¤¤	CRect rcWnd;¤	GetWindowRect( & rcWnd );¤	MoveWindow( rcWnd );¤¤	return bRet;¤}¤¤¤void ETSLayoutPropertySheet::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) ¤{¤	if(m_RootPane.IsValid() && GetTabControl() != 0 ) ¤	{¤		CRect rcWnd;¤		GetWindowRect(rcWnd);		¤¤		CRect rcClient = GetRect();¤		rcWnd-=rcClient;¤¤		// ask for MinMax of all pages¤		CSize sizePageMax(0,0);¤		CSize sizePageMin(0,0);¤		for( int nPage=0; nPage<GetPageCount(); ++nPage)¤		{¤			CPropertyPage* pPage = GetPage(nPage);¤			ASSERT(pPage);¤			if( pPage )¤			{¤				MINMAXINFO mmi;¤				memset(&mmi, 0, sizeof(mmi));¤¤				if( IsWindow(pPage->GetSafeHwnd()) )¤				{¤					pPage->SendMessage(WM_GETMINMAXINFO, 0, (LPARAM) &mmi);¤¤					if(mmi.ptMaxTrackSize.x != 0)¤					{¤						sizePageMax.cx = std::min(sizePageMax.cx, mmi.ptMaxTrackSize.x);¤					}¤					if(mmi.ptMaxTrackSize.y != 0)¤					{¤						sizePageMax.cy = std::min(sizePageMax.cy, mmi.ptMaxTrackSize.y);¤					}¤					if(mmi.ptMinTrackSize.x != 0)¤					{¤						sizePageMin.cx = std::max(sizePageMin.cx, mmi.ptMinTrackSize.x);¤					}¤					if(mmi.ptMinTrackSize.y != 0)¤					{¤						sizePageMin.cy = std::max(sizePageMin.cy, mmi.ptMinTrackSize.y);¤					}¤				}¤			}¤		}¤		static_cast<PaneItem*>( m_ItemTab.GetPaneBase() )->m_sizeXMin = sizePageMin.cx;¤		static_cast<PaneItem*>( m_ItemTab.GetPaneBase() )->m_sizeYMin = sizePageMin.cy;¤¤		// calculate the needed size of the tabctrl in non-wizard-mode¤		CRect rcItem(0,0,0,0);¤		if(!IsWizard())¤		{¤			GetTabControl()->AdjustRect( TRUE, rcItem );¤		}¤¤		lpMMI->ptMinTrackSize.x = m_RootPane->getMinConstrainHorz() + rcWnd.Width() + 2*m_sizeRootBorders.cx¤					+ rcItem.Width();¤¤		lpMMI->ptMinTrackSize.y = m_RootPane->getMinConstrainVert() + rcWnd.Height() + 2*m_sizeRootBorders.cy ¤				+ rcItem.Height();¤¤		// never smaller than inital size!¤		lpMMI->ptMinTrackSize.x = std::max((long)lpMMI->ptMinTrackSize.x, (long)m_rcStart.Width() );¤		lpMMI->ptMinTrackSize.y = std::max((long)lpMMI->ptMinTrackSize.y, (long)m_rcStart.Height() );¤¤		// Rest like ETSLayoutMgr¤¤		int maxWidth = m_RootPane->getMaxConstrainHorz();¤		int maxHeight = m_RootPane->getMaxConstrainVert();¤¤		if( maxWidth != -1 ) ¤		{¤			lpMMI->ptMaxSize.x = sizePageMax.cx + rcWnd.Width()+ 2*m_sizeRootBorders.cx + rcItem.Width() ;¤		}¤¤		if( maxHeight != -1 ) ¤		{¤			lpMMI->ptMaxSize.y = sizePageMax.cy + rcWnd.Height() + 2*m_sizeRootBorders.cy + rcItem.Width() ;¤		}¤¤		lpMMI->ptMaxTrackSize = lpMMI->ptMaxSize;¤¤	}¤}¤¤¤void ETSLayoutPropertySheet::OnDestroy() ¤{¤	// Store size/position¤	if(!m_strRegStore.IsEmpty()) ¤	{¤		Save(m_strRegStore);¤	}	¤	m_RootPane = 0;¤¤	CPropertySheet::OnDestroy();¤}¤¤void ETSLayoutPropertySheet::PostNcDestroy()¤{¤	if(m_bAutoDestroyPages)¤	{¤		// walk all pages and destry them¤		for( int nPage=0; nPage<GetPageCount(); ++nPage)¤		{¤			CPropertyPage* pPage = GetPage(nPage);¤			ASSERT(pPage);¤			if( pPage )¤			{¤				delete pPage;¤			}¤		}¤	}¤¤	if(m_bAutoDestroy)¤		delete this;¤}¤¤¤¤/**¤ * CPane represents an autopointer to a PaneBase. Use this and you won't have to worry¤ * about cleaning up any Panes. Also this autopointer lets you return Pane objects¤ * from function without using pointers (at least you won't see them :) )¤ */¤ETSLayoutMgr::PaneHolder::PaneHolder(PaneBase* pPane )¤{¤¤	ASSERT( pPane );¤	m_pPane = pPane;¤¤	// Implicitly AddRef()¤	m_nRefCount = 1;¤}¤¤ETSLayoutMgr::PaneHolder::~PaneHolder()¤{¤	ASSERT( m_pPane );¤	ASSERT( m_nRefCount == 0 );¤¤	delete m_pPane;¤}¤¤void ETSLayoutMgr::PaneHolder::AddRef()¤{¤	InterlockedIncrement( &m_nRefCount );¤}¤¤void ETSLayoutMgr::PaneHolder::Release()¤{¤	if( InterlockedDecrement( &m_nRefCount ) <= 0 )¤	{¤		// no more references on me, so destroy myself¤		delete this;¤	}¤}¤¤ETSLayoutMgr::CPaneBase::CPaneBase( )¤{¤	// MUST be initialized later¤	m_pPaneHolder = 0;¤}¤¤ETSLayoutMgr::CPaneBase::CPaneBase( PaneBase* pPane )¤{¤	m_pPaneHolder = 0;¤	¤	if( pPane != 0)¤		operator=( pPane );¤}¤¤ETSLayoutMgr::CPaneBase::CPaneBase( const CPaneBase& other )¤{¤	m_pPaneHolder = 0;¤	operator=(other);¤}¤¤ETSLayoutMgr::CPaneBase::~CPaneBase()¤{¤	if(m_pPaneHolder)¤		m_pPaneHolder->Release();¤}¤¤void ETSLayoutMgr::CPaneBase::operator=( PaneBase* pPane )¤{¤	if(m_pPaneHolder)¤	{¤		m_pPaneHolder->Release();¤		m_pPaneHolder = 0;¤	}¤¤	if( pPane != 0 )¤		m_pPaneHolder = new PaneHolder( pPane );¤}¤¤void ETSLayoutMgr::CPaneBase::operator=( const CPaneBase& other )¤{¤	ASSERT( other.m_pPaneHolder );¤¤	if(m_pPaneHolder)¤	{¤		m_pPaneHolder->Release();¤		m_pPaneHolder = 0;¤	}¤¤	other.m_pPaneHolder->AddRef();¤	m_pPaneHolder = other.m_pPaneHolder;¤}¤¤ETSLayoutMgr::PaneBase* ETSLayoutMgr::CPaneBase::operator->() const¤{¤	ASSERT(m_pPaneHolder);¤¤	if(!m_pPaneHolder)¤		return 0;¤¤	return (m_pPaneHolder->m_pPane);¤}¤¤¤¤ETSLayoutMgr::CPane::CPane( )¤{¤}¤¤ETSLayoutMgr::CPane::CPane( Pane* pPane ) : ETSLayoutMgr::CPaneBase( static_cast<PaneBase*>(pPane) )¤{¤}¤¤ETSLayoutMgr::CPane::CPane( const CPane& other )¤{¤	operator=(other);¤}¤¤ETSLayoutMgr::CPane::~CPane()¤{¤}¤¤void ETSLayoutMgr::CPane::operator=( Pane* pPane )¤{¤	CPaneBase::operator=(pPane);¤}¤¤void ETSLayoutMgr::CPane::operator=( const ETSLayoutMgr::CPane& other )¤{¤	ASSERT( other.m_pPaneHolder );¤¤	if(m_pPaneHolder)¤	{¤		m_pPaneHolder->Release();¤		m_pPaneHolder = 0;¤	}¤¤	other.m_pPaneHolder->AddRef();¤	m_pPaneHolder = other.m_pPaneHolder;¤}¤¤ETSLayoutMgr::Pane* ETSLayoutMgr::CPane::operator->() const¤{¤	ASSERT(m_pPaneHolder);¤¤	if(!m_pPaneHolder)¤		return 0;¤¤	return reinterpret_cast<Pane*>(m_pPaneHolder->m_pPane);¤}¤¤ETSLayoutMgr::CPaneBase ETSLayoutMgr::CPane::ConvertBase() const¤{¤	ASSERT(m_pPaneHolder);¤	return CPaneBase( m_pPaneHolder->m_pPane );¤}¤¤ETSLayoutMgr::CPane& ETSLayoutMgr::CPane::operator<< ( const ETSLayoutMgr::CPane pPane )¤{¤	GetPane()->addPane( pPane, (ETSLayoutMgr::layResizeMode)pPane->m_modeResize, pPane->m_sizeSecondary);¤	return (*this);¤}¤¤ETSLayoutMgr::CPane& ETSLayoutMgr::CPane::operator<< ( const ETSLayoutMgr::CPaneBase pItem )¤{¤	GetPane()->addPane( pItem );¤	return (*this);¤}¤¤//#UC END# *46A88BDA035B*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*46A88BDA035B_USER_INCLUDES*"
		    value      	(value Text 
|//#UC START# *46A88BDA035B_USER_INCLUDES*¤#include <afxtempl.h>¤#include <windows.h>¤#include <afxwin.h>         // MFC-Kern- und -Standardkomponenten¤#include <afxext.h>         // MFC-Erweiterungen¤#include <afxdisp.h>        // MFC Automatisierungsklassen¤#ifndef _AFX_NO_AFXCMN_SUPPORT¤#include <afxcmn.h>			// MFC-Unterst№tzung f№r gфngige Windows-Steuerelemente¤#endif // _AFX_NO_AFXCMN_SUPPORT¤//#UC END# *46A88BDA035B_USER_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*46A88BDA035B_USER_DEFINITION*"
		    value      	(value Text 
|//#UC START# *46A88BDA035B_USER_DEFINITION*¤namespace ETSLayout¤{¤¤#ifdef CS_HELP¤	typedef ETSCSHelpDialog		CBaseDialog;¤	typedef ETSCSHelpFormView	CBaseFormView;¤	typedef ETSCSHelpDlgBar		CBaseDialogBar;¤	typedef ETSCSHelpPropPage	CBasePropertyPage;¤#else¤	typedef CDialog CBaseDialog;¤	typedef CFormView CBaseFormView;¤	typedef CDialogBar CBaseDialogBar;¤	typedef CPropertyPage CBasePropertyPage;¤#endif¤}¤¤// Support for CBCGDialogBar instead of CDialogBar available:¤// you just have to change the typedef to CBaseDialogBar¤¤#ifndef ETSGUI_EXT_CLASS¤#define ETSGUI_EXT_CLASS¤#endif¤¤¤// Support for CBCGDialogBar instead of CDialogBar¤¤/**¤ * Controls whether the Icon is automatically set to IDR_MAINFRAME¤ */¤#define _AUTO_SET_ICON¤¤/**¤ * Forward class declarations¤ */¤class ETSLayoutDialog;¤class ETSLayoutDialogBar;¤class ETSLayoutFormView;¤class ETSLayoutMgr;¤class ETSLayoutPropertyPage;¤class ETSLayoutPropertySheet;¤¤¤/**¤ * These are NOOPs now¤ */¤#define DECLARE_LAYOUT()¤#define IMPLEMENT_LAYOUT()¤¤/**¤ * This is the default border size between the panes. You¤ * may override it in Pane constructor, but it is the¤ * fixed border around the root pane¤ */¤const int nDefaultBorder	= 5;¤¤/**¤ * The minimum size for not ABSOLUTE_XXX items¤ */¤const int nMinConstrain = 5;¤¤class ETSGUI_EXT_CLASS ETSLayoutMgr¤{¤public:¤	¤	enum layResizeMode {¤		GREEDY				= 0,		// Will eat up as much as it can¤		ABSOLUTE_HORZ		= 1 << 0,	// Horizontal size is absolute¤		RELATIVE_HORZ		= 1 << 1,	// Horizontal size in percent¤		ABSOLUTE_VERT		= 1 << 2,	// Vertical size is absolute¤		RELATIVE_VERT		= 1 << 3,	// Vertical size in percent¤¤		NORESIZE			= ABSOLUTE_HORZ | ABSOLUTE_VERT,¤¤		SIZE_MASK			= NORESIZE,¤¤		ALIGN_LEFT			= 1 << 4,   // following only for NORESIZE¤		ALIGN_RIGHT			= 1 << 5,¤		ALIGN_TOP			= 1 << 6,¤		ALIGN_BOTTOM		= 1 << 7,¤¤		ALIGN_HCENTER		= ALIGN_LEFT    | ALIGN_RIGHT,	¤		ALIGN_VCENTER		= ALIGN_TOP     | ALIGN_BOTTOM,¤¤		ALIGN_CENTER		= ALIGN_HCENTER | ALIGN_VCENTER,¤¤		ALIGN_FILL_HORZ		= 1 << 8,¤		ALIGN_FILL_VERT		= 1 << 9,¤		ALIGN_FILL			= ALIGN_FILL_HORZ | ALIGN_FILL_VERT,¤	¤/*		TRACKER_LEFT		= 1 << 10,	// not yet. May allow tracking of borders¤		TRACKER_RIGHT		= 1 << 11,  // between items in the future¤		TRACKER_TOP			= 1 << 12,¤		TRACKER_BOTTOM		= 1 << 13,¤*/¤	};¤¤	enum layOrientation {¤		HORIZONTAL,¤		VERTICAL¤	};¤¤	/**¤	 * This is the base class for all kind of panes. ¤	 */¤	class ETSGUI_EXT_CLASS PaneBase {¤		friend class ETSLayoutMgr;¤		friend class CPaneBase;¤		friend class CPane;¤¤	public:¤¤		/**¤		 * Informs the caller how much of the given space this pane would¤		 * like to receive in horizontal direction¤		 */¤		virtual int		getConstrainHorz(int sizeParent) = 0;¤¤¤		/**¤		 * Informs the caller how much of the given space this pane would¤		 * like to receive in vertical direction¤		 */¤		virtual int		getConstrainVert(int sizeParent) = 0;¤¤		/**¤		 * Informs the caller how much of the given space this pane¤		 * minimally need. This would be an absolute Value if ¤		 * the mode contains ABSOLUTE_HORZ or an explicit minimum¤		 * value, else nMinConstrain¤		 */¤		virtual int		getMinConstrainHorz() = 0;¤		/**¤		 * Informs the caller if there is an restriction for maximum¤		 * space this pane needs. Return -1 for unrestricted (GREEDY¤		 * or RELATIVE)¤		 */¤		virtual int		getMaxConstrainHorz() = 0;¤¤		/**¤		 * Informs the caller how much of the given space this pane¤		 * minimally need. This would be an absolute Value if ¤		 * the mode contains ABSOLUTE_VERT or an explicit minimum¤		 * value, else nMinConstrain¤		 */¤		virtual int		getMinConstrainVert() = 0;¤¤		/**¤		 * Informs the caller if there is an restriction for maximum¤		 * space this pane needs. Return -1 for unrestricted (GREEDY¤		 * or RELATIVE)¤		 */¤		virtual int		getMaxConstrainVert() = 0;¤¤		/**¤		 * This will do the actual resize operation after the¤		 * caller computed a new area for this pane¤		 */¤		virtual bool	resizeTo(CRect& rcNewArea) = 0;¤¤		/**¤		 * Constructor needed pointer to LayoutManager¤		 */¤		PaneBase( ETSLayoutMgr* pMgr )		{ m_pMgr = pMgr; };¤¤		/**¤		 * Virtual destructor needed in Container operations¤		 */¤		virtual ~PaneBase() {};¤¤		/**¤		 * Returs the Resize Mode of this pane¤		 */¤		DWORD	modeResize() { return m_modeResize; };¤¤	protected:¤		/**¤		 * How this Item will be resized, a combination of the flags above¤		 */¤		DWORD	m_modeResize;¤¤		/**¤		 * A pointer to the holding LayoutManager derivate¤		 */¤		ETSLayoutMgr*		m_pMgr;¤	};¤¤	/**¤	 * CPaneBase represents an autopointer to a PaneBase. Use this and you won't have to worry¤	 * about cleaning up any Panes. Also this autopointer lets you return Pane objects¤	 * from function without using pointers (at least you won't see them :) )¤	 */¤	struct ETSGUI_EXT_CLASS PaneHolder¤	{¤		PaneHolder(PaneBase* pPane );¤		~PaneHolder();¤¤		void	AddRef();¤		void	Release();¤¤		PaneBase*	m_pPane;¤		long		m_nRefCount;¤	};¤¤	class ETSGUI_EXT_CLASS CPaneBase¤	{¤	protected:¤		PaneHolder*		m_pPaneHolder;¤¤	public:¤		// Standardconstructor¤		CPaneBase( );¤		CPaneBase( PaneBase* pPane );¤		CPaneBase( const CPaneBase& other );¤¤		~CPaneBase();¤¤		void operator=( PaneBase* pPane );¤		void operator=( const CPaneBase& other );¤		PaneBase* operator->() const;¤		PaneBase* GetPaneBase()	{ return operator->(); }¤¤		bool IsValid()			{ return (m_pPaneHolder != 0); }¤		bool operator !()			{ return (m_pPaneHolder == 0); }¤¤	};¤¤	class Pane;¤	class ETSGUI_EXT_CLASS CPane : public CPaneBase¤	{¤	public:¤		// Standardconstructor¤		CPane( );¤		CPane( Pane* pPane );¤		CPane( const CPane& other );¤¤		~CPane();¤¤		void operator=( Pane* pPane );¤		void operator=( const CPane& other );¤		Pane* operator->() const;¤		Pane* GetPane()			{ return operator->(); }¤¤		CPaneBase ConvertBase() const;¤¤		CPane& operator<< ( const CPane pPane );¤		CPane& operator<< ( const CPaneBase pItem );¤	};¤¤¤¤	/**¤	 * PaneItem represents a single control¤	 */¤	class ETSGUI_EXT_CLASS PaneItem : public PaneBase {¤		friend class ETSLayoutMgr;¤		friend class Pane;¤	protected:¤		/**¤		 * Creates a new PaneItem from an Control. If sizeX or sizeY are 0¤		 * and modeResize is ABSOLUTE will copy the current dimensions of¤		 * the control to m_sizeX/Y. So the appearance does not change¤		 * from the Dialog Editor¤		 */¤		PaneItem( CWnd* pWnd, ETSLayoutMgr* pMgr, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=0, int sizeYMin=0);¤¤		/**¤		 * If your control is not mapped you can name it by its ChildID. Pass¤		 * the pMgr to receive the CWnd* of nID. ¤		 * The rest as stated above¤		 */¤		PaneItem( UINT nID, ETSLayoutMgr* pMgr, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=0, int sizeYMin=0);¤¤¤	public:¤		/**¤		 * see PaneBase¤		 */¤		virtual int getConstrainHorz(int sizeParent);¤		virtual int getConstrainVert(int sizeParent);¤		virtual int getMinConstrainHorz();¤		virtual int getMinConstrainVert();¤		virtual int	getMaxConstrainHorz();¤		virtual int	getMaxConstrainVert();¤		virtual bool resizeTo(CRect& rcNewArea);¤¤		bool	isDummy()				{ return (m_hwndCtrl == 0);	}¤¤	protected:¤		friend class ETSLayoutPropertySheet;¤¤		/**¤		 * The horizontal size of the control (see m_modeResize)¤		 */¤		int				m_sizeX;¤		int				m_sizeXMin;¤¤		/**¤		 * The vertical size of the control (see m_modeResize)¤		 */¤		int				m_sizeY;¤		int				m_sizeYMin;¤¤		/**¤		 * Child Control pointer¤		 */¤		HWND			m_hwndCtrl;¤¤		/**¤		 * Combo box needs special treatment¤		 */¤		bool			m_bComboSpecial;¤	};¤¤¤	/**¤	 * This class encapsulates a Subpane (and indeed the root Pane too)¤	 * it is a container of PaneBase* which it will recursivly resize¤	 */¤	class ETSGUI_EXT_CLASS Pane : public PaneBase {¤		friend class ETSLayoutMgr;¤		friend class CPaneBase;¤		friend class CPane;¤        friend class ETSLayoutPropertySheet;¤        ¤	protected:¤		/**¤		 * Tell the pane in which direction it is positioned. A HORIZONTAL pane¤		 * arranges it's subpanes from left to right, a VERTICAL from top to bottom¤		 */¤		Pane( ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0 );¤¤	public:¤		/**¤		 * If your control is not mapped you can name it by its ChildID. Pass¤		 * the pMgr to receive the CWnd* of nID. ¤		 * The rest as stated above¤		 */¤		bool addItem( UINT nID, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=-1, int sizeYMin=-1);¤¤		/**¤		 * Creates a new PaneItem from an Control. If sizeX or sizeY are 0¤		 * and modeResize is ABSOLUTE will copy the current dimensions of¤		 * the control to m_sizeX/Y. So the appearance does not change¤		 * from the Dialog Editor¤		 */¤		bool addItem( CWnd* pWnd, layResizeMode modeResize = GREEDY, int sizeX=0, int sizeY=0, int sizeXMin=-1, int sizeYMin=-1);¤¤¤		/**¤		 * Add a whitespace Item (paneNull) of variable size with¤		 * a minimum size of 0¤		 */¤		bool addItemGrowing();¤¤		/**¤		 * Add a whitespace Item (paneNull) with fixed size¤		 */¤		bool addItemFixed(int size);¤¤		/**¤		 * Add a whitespace Item (paneNull) of fixed size based on the¤		 * current layout (as in the dialog template). Based on the layout¤		 * of the pane vertical or horizontal spacing is considered¤		 *¤		 * First argument is the left (top) item for a HORIZONTAL (VERTICAL) pane¤		 */¤		bool addItemSpaceBetween( CWnd* pWndFirst, CWnd* pWndSecond );¤		bool addItemSpaceBetween( UINT nIDFirst, UINT nIDSecond );¤¤¤		/**¤		 * Add a whitespace Item (paneNull) of fixed size based on the¤		 * size of another item¤		 */¤		bool addItemSpaceLike( CWnd* pWnd );¤		bool addItemSpaceLike( UINT nID );¤¤¤		/**¤		 * Add an item to the pane, appending at the end. This may be either obtained¤		 * by a call to ETSLayoutMgr::item() or one of the ETSLayoutMgr::paneXXX() calls¤		 */¤		bool addPane( CPaneBase pItem );¤		bool addPane( CPane pSubpane, layResizeMode modeResize, int sizeSecondary /* = 0 */);¤¤		virtual int		getConstrainHorz(int sizeParent);¤		virtual int		getConstrainVert(int sizeParent);¤		virtual int		getMinConstrainHorz();¤		virtual int		getMinConstrainVert();¤		virtual int		getMaxConstrainHorz();¤		virtual int		getMaxConstrainVert();¤		virtual bool	resizeTo(CRect& rcNewArea);¤¤		/**¤		 * The destructor takes care of destroying all Subpanes and items¤		 */¤		virtual ~Pane();¤¤		/**¤		 * Access to the orientation of this pane¤		 */¤		layOrientation	getOrientation() { return m_Orientation; };¤¤¤	protected:¤¤		int		resizeToAbsolute(int& availSpace, CArray<int,int>& sizePrimary, ¤									CArray<int,int>& sizeMin, CArray<int,int>& sizeMax);¤		¤		bool	resizeToRelative(int& availSpace, CArray<int,int>& sizePrimary, ¤									CArray<int,int>& sizeMin, CArray<int,int>& sizeMax);¤¤		bool	resizeToGreedy(  int& availSpace, int nGreedy, CArray<int,int>& sizePrimary, ¤									CArray<int,int>& sizeMin, CArray<int,int>& sizeMax);¤¤		/**¤		 * The orientation of the pane. Keep in mind that all subpanes¤		 * must have the complementary orientation, i.e. a VERTICAL¤		 * pane must have all HORIZONTAL SubPanes (or normal Items¤		 * of course)¤		 */¤		layOrientation					m_Orientation;¤¤		/**¤		 * This array holds the pointers to the Items/SubPanes¤		 */¤		CArray<CPaneBase, CPaneBase>	m_paneItems;¤¤		/**¤		 * The secondary constrain¤		 */¤		int				m_sizeSecondary;¤¤		/** ¤		 * Size of gap between childs¤		 */¤		int				m_sizeBorder;¤		int				m_sizeExtraBorder;¤	};¤¤¤	/**¤	 * This class encapsulates a Subpane which is a Tab¤	 * it will use calls to AdjustRect to position it's¤	 * childs¤	 */¤	class ETSGUI_EXT_CLASS PaneTab : public Pane¤	{¤		friend class ETSLayoutMgr;¤¤	protected:¤		/**¤		 * Tell the pane in which direction it is positioned. A HORIZONTAL pane¤		 * arranges it's subpanes from left to right, a VERTICAL from top to bottom¤		 */¤		PaneTab( CTabCtrl* pTab, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0 );¤¤	public:¤		virtual int		getConstrainHorz(int sizeParent);¤		virtual int		getConstrainVert(int sizeParent);¤		virtual int		getMinConstrainHorz();¤		virtual int		getMinConstrainVert();¤		virtual int		getMaxConstrainHorz();¤		virtual int		getMaxConstrainVert();¤		virtual bool	resizeTo(CRect& rcNewArea);¤¤	private:¤		CTabCtrl* m_pTab;¤	};¤¤	/**¤	 * This class encapsulates a Subpane which is a Static¤	 * it will use calls to AdjustRect to position it's¤	 * childs¤	 */¤	class ETSGUI_EXT_CLASS PaneCtrl : public Pane¤	{¤		friend class ETSLayoutMgr;¤	protected:¤		/**¤		 * Tell the pane in which direction it is positioned. A HORIZONTAL pane¤		 * arranges it's subpanes from left to right, a VERTICAL from top to bottom¤		 */¤		PaneCtrl( CWnd* pCtrl, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0);¤		PaneCtrl( UINT nID, ETSLayoutMgr* pMgr, layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0 );¤¤	public:¤¤		virtual int		getConstrainHorz(int sizeParent);¤		virtual int		getConstrainVert(int sizeParent);¤		virtual int		getMinConstrainHorz();¤		virtual int		getMinConstrainVert();¤		virtual int		getMaxConstrainHorz();¤		virtual int		getMaxConstrainVert();¤		virtual bool	resizeTo(CRect& rcNewArea);¤¤	private:¤		HWND			m_hwndCtrl;¤		int				m_sizeTopExtra;¤	};¤¤¤¤¤	ETSLayoutMgr(CWnd* pWnd)	{ m_pWnd = pWnd; m_sizeRootBorders = CSize(5,5); };¤	virtual ~ETSLayoutMgr();¤¤	virtual CRect GetRect() { CRect r; m_pWnd->GetClientRect(r); return r; };¤	CWnd*	m_pWnd;¤	CWnd*	GetWnd()		{ return m_pWnd; };¤	void	setRootBorders(int cx, int cy)	{ m_sizeRootBorders = CSize(cx,cy); };¤¤	/**¤	 * Pass this for a pseudo Pane with no content¤	 */¤	static CWnd*	paneNull;¤¤	/**¤	 * Loads the current position and size from the registry using a supplied¤	 * key. Will be loaded with AfxGetApp()->WriteProfileXXX(). You may¤	 * specify a subfolder (e.g. Load( _T("MyDialog\\Layout") ); ). Will¤	 * load the following keys:¤	 *¤	 * - lpstrRegKey+"SizeX";¤	 * - lpstrRegKey+"SizeY";¤	 * - lpstrRegKey+"PosX";¤	 * - lpstrRegKey+"PosY";¤	 *¤	 * Is automatically called during OnActivate() if key specified in¤	 * constructor.¤	 */¤	bool Load(LPCTSTR lpstrRegKey);¤¤	/**¤	 * Store the current position and size to the registry using a supplied¤	 * key. Will be stored with AfxGetApp()->WriteProfileXXX(). You may¤	 * specify a subfolder (e.g. Save( _T("MyDialog\\Layout") ); ). Will¤	 * create the following keys:¤	 *¤	 * - lpstrRegKey+"SizeX";¤	 * - lpstrRegKey+"SizeY";¤	 * - lpstrRegKey+"PosX";¤	 * - lpstrRegKey+"PosY";¤	 *¤	 * Is automatically called during DestroyWindow() if key specified in¤	 * constructor.¤	 */¤	bool Save(LPCTSTR lpstrRegKey);¤¤	/**¤	 * Updates the layout after you specify the new¤	 * layout¤	 */¤	virtual void UpdateLayout();¤	virtual void UpdateLayout(CPane p) {¤		if(m_RootPane.IsValid())¤		{¤			// free old root¤			m_RootPane = 0;¤		}¤		m_RootPane = p;¤		UpdateLayout();¤	}¤¤	/**¤	 * Does the actual Layout, called from OnSize()¤	 * Default implementation does nothing, use¤	 * IMPLEMENT_LAYOUT in your derived class (see above)¤	 */¤	virtual void Layout(CRect& rcClient);¤¤¤	/**¤	 * Erasing only the these parts of the client area where¤	 * there is no child window. Extra-code for group-boxes ¤	 * included!¤	 */¤	void EraseBkgnd(CDC* pDC);¤¤	/**¤	 * Helperfunctions for the stream-interface. For usage see sample Application¤	 * and/or documentation.¤ 	 */¤¤	/**¤	 * Create a new Pane. You may specify the resize¤	 * mode for both directions. If you add modes for the secondary direction¤	 * (i.e. *_VERT for a HORIZONTAL pane) then sizeSecondary is used as it's¤	 * size. If you do not specify sizeSecondary and the mode is ABSOLUTE_VERT¤	 * it will be computed as the maximum Height of all SubPanes (the same is¤	 * true for VERTICAL panes and subpanes with *_HORZ)¤	 */¤	CPane pane( layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeSecondary = 0);¤¤	/**¤	 * Create one of the special control panes. Parameter are like pane(). For¤	 * additional information see documentation¤	 */¤	CPane paneTab( CTabCtrl* pTab, layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeSecondary = 0);¤	CPane paneCtrl( UINT nID, layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0, int sizeSecondary = 0);¤	CPane paneCtrl( CWnd* pCtrl, layOrientation orientation, layResizeMode modeResize = GREEDY, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0, int sizeTopExtra = 0, int sizeSecondary = 0);¤¤	/**¤	 * Creates a new PaneItem for an Control. If sizeX or sizeY are 0¤	 * and modeResize is ABSOLUTE will copy the current dimensions of¤	 * the control to m_sizeX/Y. So the appearance does not change¤	 * from the Dialog Editor. size*Min = -1 means: do not make smaller¤	 * than in Dialog Template.¤	 */¤	CPaneBase item(UINT nID, layResizeMode modeResize = GREEDY, int sizeX =0, int sizeY =0, int sizeXMin =-1, int sizeYMin =-1);¤	CPaneBase item(CWnd* pWnd, layResizeMode modeResize = GREEDY, int sizeX =0, int sizeY =0, int sizeXMin =-1, int sizeYMin =-1);¤¤¤	/**¤	 * Add a whitespace Item (paneNull) of variable size with¤	 * a minimum size of 0¤	 */¤	CPaneBase itemGrowing(layOrientation orientation);¤¤	/**¤	 * Add a whitespace Item (paneNull) with fixed size¤	 */¤	CPaneBase itemFixed(layOrientation orientation, int sizePrimary);¤¤	/**¤	 * Add a whitespace Item (paneNull) of fixed size based on the¤	 * current layout (as in the dialog template). Based on the layout¤	 * of the pane vertical or horizontal spacing is considered¤	 *¤	 * First argument is the left (top) item for a HORIZONTAL (VERTICAL) pane¤	 */¤	CPaneBase itemSpaceBetween( layOrientation orientation, CWnd* pWndFirst, CWnd* pWndSecond );¤	CPaneBase itemSpaceBetween( layOrientation orientation, UINT nIDFirst, UINT nIDSecond );¤¤	/**¤	 * Add a whitespace Item (paneNull) of fixed size based on the¤	 * size of another item¤	 */¤	CPaneBase itemSpaceLike( layOrientation orientation, CWnd* pWnd );¤	CPaneBase itemSpaceLike( layOrientation orientation, UINT nID );¤¤protected:¤	/**¤	 * This holds the root pane. Fill in InitDialog()¤	 */¤	CPane m_RootPane;¤¤	/**¤ 	 * Create a root pane¤	 */¤	CPane CreateRoot(layOrientation orientation, int sizeBorder = nDefaultBorder, int sizeExtraBorder = 0 )¤	{¤		if(m_RootPane.IsValid())¤		{¤			// free old root¤			m_RootPane = 0;¤		}¤		m_RootPane = new Pane( this, orientation, sizeBorder, sizeExtraBorder);¤		return m_RootPane;¤	}¤¤	/**¤	 * Key in Registry where to store Size¤	 */¤	CString m_strRegStore;¤¤	/**¤	 * Borders around root¤	 */¤	CSize	m_sizeRootBorders;¤};¤¤inline ETSLayoutMgr::layResizeMode operator|(const ETSLayoutMgr::layResizeMode m1, ¤											 const ETSLayoutMgr::layResizeMode m2)¤	{ return (ETSLayoutMgr::layResizeMode)( (DWORD)m1|(DWORD)m2); }¤¤¤/**¤ * Base class for the Layout function. Derive your own class¤ * from this or derive it from CDialog and modify _all_¤ * references to CDialog to ETSLayoutDialog¤ */¤class ETSGUI_EXT_CLASS ETSLayoutDialog : public ETSLayout::CBaseDialog, protected ETSLayoutMgr¤{¤// Construction¤public:¤	ETSLayoutDialog(UINT nID, CWnd* pParent = NULL, LPCTSTR strName = NULL, bool bGripper = true);   // standard constructor¤¤// Dialog Data¤	//{{AFX_DATA(ETSLayoutDialog)¤	//}}AFX_DATA¤¤¤// Overrides¤	// ClassWizard generated virtual function overrides¤	//{{AFX_VIRTUAL(ETSLayoutDialog)¤	//}}AFX_VIRTUAL¤¤// Implementation¤protected:¤	// Generated message map functions¤	//{{AFX_MSG(ETSLayoutDialog)¤	afx_msg void OnSize(UINT nType, int cx, int cy);¤	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);¤	afx_msg BOOL OnEraseBkgnd(CDC* pDC);¤	virtual BOOL OnInitDialog();¤	afx_msg void OnDestroy();¤	//}}AFX_MSG¤	DECLARE_MESSAGE_MAP()¤¤	virtual CRect GetRect();¤¤	bool		m_bGripper;¤	CStatusBar	m_StatusBar;¤};¤¤¤/**¤ * Base class for the Layout function. Derive your own class¤ * from this or derive it from CDialog and modify _all_¤ * references to CFormView to ETSLayoutFormView¤ */¤class ETSGUI_EXT_CLASS ETSLayoutFormView : public ETSLayout::CBaseFormView, public ETSLayoutMgr¤{¤// Construction¤	DECLARE_DYNAMIC(ETSLayoutFormView)¤public:¤	ETSLayoutFormView(UINT nID, LPCTSTR strName = NULL);   // standard constructor¤	virtual ~ETSLayoutFormView();¤¤//	virtual void UpdateLayout();¤¤¤// Overrides¤	// ClassWizard generated virtual function overrides¤	//{{AFX_VIRTUAL(ETSLayoutDialog)¤	//}}AFX_VIRTUAL¤¤// Implementation¤protected:¤¤	// Generated message map functions¤	//{{AFX_MSG(ETSLayoutDialog)¤	afx_msg void OnSize(UINT nType, int cx, int cy);¤	afx_msg BOOL OnEraseBkgnd(CDC* pDC);¤	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);¤	//}}AFX_MSG¤	DECLARE_MESSAGE_MAP()¤};¤¤¤/**¤ * Base class for the Layout function. Derive your own class¤ * from this or derive it from CBCGDialogBar/CDialogBar and ¤ * modify _all_  references to CBCGDialogBar/CDialogBar to ¤ * ETSLayoutDialogBar¤ */¤class ETSGUI_EXT_CLASS ETSLayoutDialogBar : public ETSLayout::CBaseDialogBar, protected ETSLayoutMgr¤{¤// Construction¤public:¤#ifdef CS_HELP¤	ETSLayoutDialogBar(UINT nID);¤#else¤	ETSLayoutDialogBar();¤#endif¤¤¤// Overrides¤	// ClassWizard generated virtual function overrides¤	//{{AFX_VIRTUAL(ETSLayoutDialogBar)¤	virtual CSize CalcDynamicLayout(int nLength, DWORD dwMode);¤	//}}AFX_VIRTUAL¤¤	/**¤	 * Override this to define Layout¤	 */¤	virtual BOOL Initialize() { return false; };¤	virtual void UpdateLayout();¤¤// Implementation¤protected:¤	// Generated message map functions¤	//{{AFX_MSG(ETSLayoutDialogBar)¤	afx_msg void OnSize(UINT nType, int cx, int cy);¤	afx_msg void OnDestroy();¤	afx_msg BOOL OnEraseBkgnd(CDC* pDC);¤	//}}AFX_MSG¤	LRESULT OnInitDialog(WPARAM, LPARAM);¤	DECLARE_MESSAGE_MAP()¤¤	virtual CRect GetRect();¤	bool	m_bInitialized;¤};¤¤¤¤/**************************************************¤ ** ! the code is only tested for modal sheets ! **¤ **************************************************/¤¤¤/**¤ * Resizable PropertySheet. Use this class standalone¤ * or as your base class (instead CProptertySheet)¤ */¤class ETSGUI_EXT_CLASS ETSLayoutPropertySheet : public CPropertySheet, protected ETSLayoutMgr¤{¤	DECLARE_DYNAMIC(ETSLayoutPropertySheet)¤¤// Construction¤public:¤	ETSLayoutPropertySheet(UINT nIDCaption, CWnd *pParentWnd = NULL, UINT iSelectPage = 0, LPCTSTR strName=NULL, bool bGripper=true);¤	ETSLayoutPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd = NULL, UINT iSelectPage = 0, LPCTSTR strName=NULL, bool bGripper=true);¤¤// Operationen¤public:¤	void	SetAutoDestroy()		{ m_bAutoDestroy = true; }¤	void	SetAutoDestroyPages()	{ m_bAutoDestroyPages = true; }¤	void	ModelessWithButtons()	{ m_bModelessButtons = true; }¤// Overrides¤    virtual void AddMainArea(CPane paneRoot, CPaneBase itemTab);¤    virtual void AddButtons(CPane paneBottom);¤    ¤	// ClassWizard generated virtual function overrides¤	//{{AFX_VIRTUAL(ETSLayoutPropertySheet)¤	public:¤	virtual BOOL OnInitDialog();¤	virtual void PostNcDestroy();¤	//}}AFX_VIRTUAL¤¤// Implementation¤public:¤	virtual ~ETSLayoutPropertySheet();¤¤	// Generated message map functions¤protected:¤	//{{AFX_MSG(ETSLayoutPropertySheet)¤	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);¤	afx_msg void OnSize(UINT nType, int cx, int cy);¤	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);¤	afx_msg void OnDestroy();¤	afx_msg BOOL OnEraseBkgnd(CDC* pDC);¤	//}}AFX_MSG¤	DECLARE_MESSAGE_MAP()¤¤	void Resize(int cx, int cy);¤¤friend class ETSLayoutPropertyPage;¤¤	void		Init(LPCTSTR strName, bool bGripper);¤	CRect		m_rcStart;¤	CRect		m_rcPage;¤	bool		m_bGripper;¤	CStatusBar	m_StatusBar;¤	CPaneBase	m_ItemTab;¤	bool		m_bAutoDestroy;¤	bool		m_bAutoDestroyPages;¤	bool		m_bModelessButtons;¤};¤¤/**¤ * Base class for the Layout function. Derive your own class¤ * from this or derive it from CPropertyPage and ¤ * modify _all_  references to CPropertyPage to ¤ * ETSLayoutPropertyPage¤ */¤class ETSGUI_EXT_CLASS ETSLayoutPropertyPage : public ETSLayout::CBasePropertyPage, protected ETSLayoutMgr¤{¤friend class ETSLayoutPropertySheet;¤¤	DECLARE_DYNCREATE(ETSLayoutPropertyPage)¤¤// Konstruktion¤public:¤	ETSLayoutPropertyPage( );¤	ETSLayoutPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0 );¤	ETSLayoutPropertyPage( LPCTSTR lpszTemplateName, UINT nIDCaption = 0 );¤¤	~ETSLayoutPropertyPage();¤¤¤// Overrides¤	// ClassWizard generated virtual function overrides¤	//{{AFX_VIRTUAL(ETSLayoutPropertyPage)¤	public:¤	virtual BOOL OnSetActive();¤	//}}AFX_VIRTUAL¤¤// Implementation¤protected:¤	// Generated message map functions¤	//{{AFX_MSG(ETSLayoutPropertyPage)¤	afx_msg void OnSize(UINT nType, int cx, int cy);¤	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);¤	virtual BOOL OnInitDialog();¤	afx_msg BOOL OnEraseBkgnd(CDC* pDC);¤	afx_msg void OnWindowPosChanging( WINDOWPOS* lpwndpos );¤	afx_msg void OnDestroy();¤	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);¤	//}}AFX_MSG¤	DECLARE_MESSAGE_MAP()¤¤	virtual CRect GetRect();¤	bool m_bLockMove;¤	bool m_bResetBuddyOnNextTimeVisible;¤};¤//#UC END# *46A88BDA035B_USER_DEFINITION*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/ETSLayout|46A88BDA035B
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659776435"))
	    quid       	"46A88BDA035B"
	    documentation 	"набор классов и контролов для поддержки ресайза"
	    stereotype 	"UtilityPack"
	    language   	"MDA Generator")
	(object Class "CPPToolTip"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CPPToolTip.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CPPToolTip.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B6AC00CB_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB_CUSTOM_INCLUDES*¤#define TIMER_HIDE		0x101 //the identifier of the timer for hide the tooltip¤#define TIMER_SHOWING	0x102 //the identifier of the timer for tooltip's fade in¤#define TIMER_SHOW		0x100 //the identifier of the timer for show the tooltip¤#define TIMER_HIDING	0x103 //the identifier of the timer for tooltip's fade out¤#define TIMER_ANIMATION 0x104 //the identifier of the timer for animation¤¤#define PERCENT_STEP_FADEIN		20 //How mush percent will adding during fade in¤#define PERCENT_STEP_FADEOUT	20 //How mush percent will adding during fade out¤#define PERCENT_MAX_TRANSPARENCY 100 //How mush percent by maximum transparency¤#define PERCENT_MIN_TRANSPARENCY 0 //How mush percent by minimum transparency¤¤#define MAX_LENGTH_DEBUG_STRING 25 //¤//#UC END# *4700B6AC00CB_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B6AC00CB*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB*¤//////////////////¤// Note that windows are enumerated in top-down Z-order, so the menu¤// window should always be the first one found.¤//¤static BOOL CALLBACK MyEnumProc(HWND hwnd, LPARAM lParam)¤{¤	TCHAR buf[16];¤	GetClassName(hwnd, buf, sizeof(buf) / sizeof(TCHAR));¤	if (_tcscmp(buf, _T("#32768")) == 0)  // special classname for menus¤	{¤		*((HWND*)lParam) = hwnd;	 // found it¤		return FALSE;¤	}¤	return TRUE;¤}¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPToolTip¤¤CPPToolTip::CPPToolTip()¤{¤	// Default values¤	m_dwTimeAutoPop = 5000;¤	m_dwTimeInitial = 500;¤	m_dwTimeFadeIn = 500;¤	m_dwTimeFadeOut = 500;¤	m_dwBehaviour = 0; //PPTOOLTIP_CLOSE_LEAVEWND | PPTOOLTIP_NOCLOSE_OVER;	 //The tooltip's behaviour¤	m_dwEffectBk = 0;¤	m_dwDirection = 0;¤	m_dwStyles = 0;¤	m_nGranularity = 0;¤	m_nTransparency = 0;¤	m_bDelayNextTool = FALSE;¤	m_dwShowEffect = SHOWEFFECT_FADEINOUT;¤	m_dwHideEffect = SHOWEFFECT_FADEINOUT;¤¤	m_nTooltipState = PPTOOLTIP_STATE_HIDEN;¤	m_nTooltipType = PPTOOLTIP_NORMAL;¤	m_nNextTooltipType = PPTOOLTIP_NORMAL;¤¤	m_ptOriginal.x = m_ptOriginal.y = 0;¤¤	m_rcCurTool.SetRectEmpty();¤¤	m_hwndDisplayedTool = NULL;¤	m_last_dynamic_tool = 0;¤	m_next_dynamic_tool = 0;¤¤	m_hBitmapBk = NULL;¤	m_hUnderTooltipBk = NULL;¤¤	m_hbrBorder = NULL;¤	m_hrgnTooltip = NULL;¤¤	SetColorBk(::GetSysColor(COLOR_INFOBK));¤	SetBorder(::GetSysColor(COLOR_INFOTEXT));¤	EnableHyperlink();¤	SetNotify(FALSE);¤	SetDefaultSizes();¤	SetDirection();¤	SetBehaviour();¤	SetDebugMode(FALSE);¤	SetMaxTipWidth(0);¤//	EnableTextWrap(FALSE);¤	SetDelayTime(PPTOOLTIP_TIME_INITIAL, 500);¤	SetDelayTime(PPTOOLTIP_TIME_AUTOPOP, 5000);¤	SetDelayTime(PPTOOLTIP_TIME_FADEIN, 0);¤	SetDelayTime(PPTOOLTIP_TIME_FADEOUT, 0);¤	SetTooltipShadow(6, 6);¤¤#ifdef PPTOOLTIP_USE_MENU¤	MenuToolPosition();¤#endif //PPTOOLTIP_USE_MENU¤	¤	// Register the window class if it has not already been registered.¤	WNDCLASS wndcls;¤	HINSTANCE hInst = AfxGetInstanceHandle();¤	if(!(::GetClassInfo(hInst, PPTOOLTIP_CLASSNAME, &wndcls)))¤	{¤		// otherwise we need to register a new class¤		wndcls.style			= CS_SAVEBITS;¤		wndcls.lpfnWndProc		= ::DefWindowProc;¤		wndcls.cbClsExtra		= wndcls.cbWndExtra = 0;¤		wndcls.hInstance		= hInst;¤		wndcls.hIcon			= NULL;¤		wndcls.hCursor			= LoadCursor(hInst, IDC_ARROW);¤		wndcls.hbrBackground	= NULL;¤		wndcls.lpszMenuName		= NULL;¤		wndcls.lpszClassName	= PPTOOLTIP_CLASSNAME;¤		¤		if (!AfxRegisterClass(&wndcls))¤			AfxThrowResourceException();¤	} //if¤}¤¤BEGIN_MESSAGE_MAP(CPPToolTip, CWnd)¤	//{{AFX_MSG_MAP(CPPToolTip)¤	ON_WM_PAINT()¤	ON_WM_TIMER()¤	ON_WM_SETCURSOR()¤	ON_WM_ACTIVATEAPP()¤	//}}AFX_MSG_MAP¤	ON_MESSAGE(UDM_TOOLTIP_REPAINT, OnRepaintWindow)¤END_MESSAGE_MAP()¤¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPToolTip message handlers¤BOOL CPPToolTip::Create(CWnd* pParentWnd, BOOL bBalloon /* = TRUE */) ¤{¤	TRACE(_T("CPPToolTip::Create\n"));¤	¤	ASSERT_VALID(pParentWnd);¤	¤	DWORD dwStyle = WS_POPUP; ¤	DWORD dwExStyle = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;¤	m_hParentWnd = pParentWnd->GetSafeHwnd();¤	¤	if (!CreateEx(dwExStyle, PPTOOLTIP_CLASSNAME, NULL, dwStyle, 0, 0, 0, 0, pParentWnd->GetSafeHwnd(), NULL, NULL))¤		return FALSE;¤¤	//¤	SetDefaultSizes(bBalloon);¤	m_drawer.SetCallbackRepaint(this->GetSafeHwnd(), UDM_TOOLTIP_REPAINT);¤	SetDelayTime(PPTOOLTIP_TIME_ANIMATION, 100);¤¤	return TRUE;¤} //End of Create¤¤BOOL CPPToolTip::DestroyWindow() ¤{¤	Pop();¤	SetDelayTime(PPTOOLTIP_TIME_ANIMATION, 0);¤	return CWnd::DestroyWindow();¤} //End of DestroyWindow¤¤/////////////////////////////////////////////////////////////////////¤//		A tooltip with PPTOOLTIP_DISABLE_AUTOPOP behaviour don't hide on ¤//	change active application¤//-------------------------------------------------------------------¤// Fixed by vanhoopy (July 10, 2003)¤/////////////////////////////////////////////////////////////////////¤#if _MSC_VER < 1300¤void CPPToolTip::OnActivateApp(BOOL bActive, HTASK hTask)¤#else¤void CPPToolTip::OnActivateApp(BOOL bActive, DWORD hTask)¤#endif //_MSC_VER¤{¤	CWnd::OnActivateApp(bActive, hTask);¤	¤	if (!bActive) ¤		Pop();¤} //End of the WM_ACTIVATEAPP handler¤¤LRESULT CPPToolTip::SendNotify(LPPOINT pt, PPTOOLTIP_INFO & ti) ¤{ ¤	TRACE(_T("CPPToolTip::SendNotify()\n")); ¤	// Make sure this is a valid window  ¤	if (!IsWindow(GetSafeHwnd())) ¤		return 0L; ¤	// See if the user wants to be notified  ¤	if (!IsNotify()) ¤		return 0L; ¤	¤	NM_PPTOOLTIP_DISPLAY lpnm; ¤	lpnm.hwndTool = m_hwndNextTool;¤	lpnm.pt = pt;  ¤	lpnm.ti = &ti; ¤	lpnm.hdr.hwndFrom = m_hWnd; ¤	lpnm.hdr.idFrom   = GetDlgCtrlID(); ¤	lpnm.hdr.code     = UDM_TOOLTIP_DISPLAY; ¤	¤	::SendMessage(m_hNotifyWnd, WM_NOTIFY, lpnm.hdr.idFrom, (LPARAM)&lpnm);  ¤¤	return 0L;¤} //End of SendNotify¤¤/////////////////////////////////////////////////////////////////////¤// CPPToolTip::IsNotify()¤//		This function determines will be send the notification messages from ¤//	the control or not before display.¤//-------------------------------------------------------------------¤// Return value:¤//	TRUE if the control will be notified the specified window¤///////////////////////////////////////////////////////////////////////¤BOOL CPPToolTip::IsNotify()¤{¤	TRACE(_T("CPPToolTip::IsNotify\n"));¤	¤	return (BOOL)(m_hNotifyWnd != NULL);¤}  //End of IsNotify¤¤BOOL CPPToolTip::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) ¤{¤	CPoint ptClient;¤	::GetCursorPos(&ptClient);¤	ScreenToClient(&ptClient);¤	TRACE (_T("CPPToolTip::OnSetCursor(x=%d, y=%d)\n"), ptClient.x, ptClient.y);¤	if (m_drawer.OnSetCursor(&ptClient))¤		return TRUE; //The cursor over the hyperlink¤	¤	::SetCursor(::LoadCursor(NULL, IDC_ARROW));¤¤//	return CWnd::OnSetCursor(pWnd, nHitTest, message);¤	return TRUE;¤} //End of the WM_SETCURSOR handler¤¤LRESULT CPPToolTip::OnRepaintWindow(WPARAM wParam, LPARAM lParam)¤{¤	TRACE (_T("CPPToolTip::OnRepaintWindow()\n"));¤	if (m_bHyperlinkEnabled)¤	{¤		//Window's repaint enabled¤		CDC * pDC = GetDC();¤		OnRedrawTooltip(pDC->GetSafeHdc(), m_dwCurTransparency);¤		ReleaseDC(pDC);¤	}¤    return TRUE;¤} //End of the UDM_TOOLTIP_REPAINT handler¤¤void CPPToolTip::OnDrawBorder(HDC hDC, HRGN hRgn)¤{¤	ASSERT (hDC);¤	ASSERT (hRgn);¤¤	::FrameRgn(hDC, hRgn, m_hbrBorder, m_szBorder.cx, m_szBorder.cy);¤} //End OnDrawBorder¤¤////////////////////////////////////////////////////////////////////////¤//¤//      +-----------------+    +-------------------+   +-----------------+  ¤//   +->|     Screen      +--->| m_hUnderTooltipBk |   |   m_hBitmapBk   |¤//   |  +--------+--------+    +-------------------+   +--------+--------+¤//   |           |                                            |¤//   |  +--------V--------+                          +--------V--------+¤//   |  |                 |     +--------------+     |                 |¤//   |  |                 |     |   DrawHTML   |---->|                 |¤//   |  |                 |     +--------------+     |                 |¤//   |  |                 |                          |     MemDC       |¤//   |  |                 |     +--------------+     |                 |¤//   |  |                 |     | OnDrawBorder |---->|                 |¤//   |  |     TempDC      |     +--------------+     +--------+--------+¤//   |  |                 |                                   |         ¤//   |  |                 |     +--------------+              |         ¤//   |  |                 |<----+  DrawShadow  |              |         ¤//   |  |                 |     +--------------+              |         ¤//   |  |                 |                                   |         ¤//   |  |                 |<--------ALPHA---------------------+         ¤//   |  |                 |¤//   |  +--------+--------+¤//   |           |          ¤//   +-----------+¤//¤////////////////////////////////////////////////////////////////////////¤void CPPToolTip::OnRedrawTooltip(HDC hDC, BYTE nTransparency /* = 0 */)¤{¤	TRACE (_T("CPPToolTip::OnRedrawTooltip(Transparency = %d)\n"), nTransparency);¤¤	//ENG: If a transparency more then max value¤	//RUS: Если значение прозрачности больше максимально допустимого¤	if (nTransparency > PERCENT_MAX_TRANSPARENCY)¤		nTransparency = PERCENT_MAX_TRANSPARENCY;¤¤	//ENG: If device context not passed¤	//RUS: Если контекст устройства не передавался, то получаем его и устанавливаем признак автоматического удаления¤	BOOL bAutoReleaseDC = FALSE;¤	if (NULL == hDC)¤	{¤		hDC = ::GetDC(this->GetSafeHwnd());¤		bAutoReleaseDC = TRUE;¤	} //if¤¤	//ENG: Creates memory context¤	//RUS: Создаем контекст устройства в памяти¤	HDC hMemDC = ::CreateCompatibleDC(hDC);¤	HDC hBkDC = ::CreateCompatibleDC(hDC);¤	HDC hTempDC = ::CreateCompatibleDC(hDC);¤	HBITMAP hOldBkBitmap = (HBITMAP)::SelectObject(hBkDC, m_hBitmapBk);¤	HBITMAP hBitmap = ::CreateCompatibleBitmap(hDC, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());¤	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hMemDC, hBitmap);¤	HBITMAP hTempBitmap = ::CreateCompatibleBitmap(hDC, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());¤	HBITMAP hOldTempBitmap = (HBITMAP)::SelectObject(hTempDC, hTempBitmap);¤¤	//ENG: Gets the rectangle of the tooltip without a shadow¤	//RUS: Получаем размер тултипа без тени¤	CRect rect = m_rcBoundsTooltip;¤	rect.DeflateRect(0, 0, m_szOffsetShadow.cx, m_szOffsetShadow.cy);¤	¤	//ENG: Copy background to the temporary bitmap¤	//RUS: Копируем фон под тултипом в память¤	::BitBlt(hMemDC, 0, 0, rect.Width(), rect.Height(),¤		hBkDC, 0, 0, SRCCOPY);¤	¤	//ENG: Draw HTML string¤	//RUS: Отображаем HTML строку¤	m_drawer.DrawPreparedOutput(hMemDC, &m_rcTipArea);¤¤	//ENG: Gets a region of a window¤	//RUS: Получаем регион окна¤//	HRGN hrgn = ::CreateRectRgn(0, 0, 0, 0);¤//	GetWindowRgn(hrgn);¤¤	//ENG: Draw border of the tooltip¤	//RUS: Отображаем контур тултипа¤	if ((NULL != m_hbrBorder) && (m_szBorder.cx) && (m_szBorder.cy))¤		OnDrawBorder(hMemDC, m_hrgnTooltip);¤¤	if (NULL == m_hUnderTooltipBk)¤	{¤		//ENG: Stores a background under the tooltip to a bitmap¤		//RUS: Сохраняем фон под тултипом в битмап¤		m_hUnderTooltipBk = ::CreateCompatibleBitmap(hDC, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());¤		::SelectObject(hBkDC, m_hUnderTooltipBk);¤		::BitBlt(hBkDC, 0, 0, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height(),¤				 hDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, SRCCOPY);¤	}¤	else¤	{¤		//ENG: Restores a background from a bitmap¤		//RUS: Восстанавливаем фон из битмапа¤		::SelectObject(hBkDC, m_hUnderTooltipBk);¤	} //if¤¤	//ENG: Copy a original background bitmap to the temporary DC¤	//RUS: Копируем оригинальный битмап во временный контекст памяти¤	::BitBlt(hTempDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height(),¤		hBkDC, 0, 0, SRCCOPY);¤¤	//ENG: Draws a shadow¤	//RUS: Выводим тень¤	if (m_szOffsetShadow.cx || m_szOffsetShadow.cy)¤	{¤		//ENG: Creates a mask of the tooltip for shadow¤		//RUS: Создаем маску тултипа для вывода тени¤		HBITMAP hMask = ::CreateCompatibleBitmap(hDC, rect.Width(), rect.Height());¤		HDC hMaskDC = ::CreateCompatibleDC(hDC);¤		//ENG: Creates a mask of the tooltip¤		//RUS: Создание маски тултипа¤		BYTE nColor = LOBYTE(::MulDiv(255, 100 - m_nDarkenShadow, 100));¤		nColor += ((255 - nColor) * nTransparency) / 100;¤		HBRUSH hBrush = ::CreateSolidBrush(RGB(nColor, nColor, nColor));¤		HBITMAP hOldMask = (HBITMAP)::SelectObject(hMaskDC, hMask);¤		::BitBlt(hMaskDC, 0, 0, rect.Width(), rect.Height(), NULL, 0, 0, WHITENESS);¤		::FillRgn(hMaskDC, m_hrgnTooltip, hBrush);¤		::DeleteObject(hBrush);¤		::SelectObject(hMaskDC, hOldMask);¤		::DeleteDC(hMaskDC);¤		¤		//HBITMAP hTempBmp = m_drawer.GetDrawManager()->CreateImageEffect(m_hTooltipMask, rect.Width(), rect.Height(), IMAGE_EFFECT_LIGHTEN, )¤		m_drawer.GetDrawManager()->DrawShadow(hTempDC, ¤											  m_szOffsetShadow.cx, ¤											  m_szOffsetShadow.cy,¤										      rect.Width(), rect.Height(), hMask,¤			   							      m_bGradientShadow, ¤											  m_szDepthShadow.cx, m_szDepthShadow.cy);¤		::DeleteObject(hMask);¤	} //if¤¤	//ENG: Merges a tooltip on with the client area ¤	//RUS: Накладываем тултип на клиентскую часть с альфа-наложением¤	::SelectClipRgn(hTempDC, m_hrgnTooltip);¤	m_drawer.GetDrawManager()->AlphaBitBlt(hTempDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top,¤											rect.Width(), rect.Height(),¤											hMemDC, 0, 0, 100 - nTransparency);¤	::SelectClipRgn(hTempDC, NULL);¤¤	//ENG: Output a tooltip to the screen¤	//RUS: Выводим тултип на экран¤	::BitBlt(hDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top,¤		m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height(),¤		hTempDC, 0, 0, SRCCOPY);¤	¤	//ENG: Free resources¤	//RUS: Освобождаем задействованные ресурсы¤	::SelectObject(hBkDC, hOldBkBitmap);¤	::SelectObject(hMemDC, hOldBitmap);¤	::SelectObject(hTempDC, hOldTempBitmap);¤	::DeleteObject(hBitmap);¤	::DeleteObject(hTempBitmap);¤	::DeleteDC(hBkDC);¤	::DeleteDC(hMemDC);¤	::DeleteDC(hTempDC);¤¤	//ENG: Releases device context if needed¤	//RUS: Освобождаем контекст устройства если это необходимо¤	if (bAutoReleaseDC)¤		::ReleaseDC(this->GetSafeHwnd(), hDC);¤} //End of OnRedrawWindow¤¤void CPPToolTip::OnPaint() ¤{¤	TRACE(_T("CPPToolTip::OnPaint()\n"));¤	CPaintDC dc(this); // device context for painting¤	¤	//Copying info about current tool to displayed¤	m_hwndDisplayedTool = m_hwndNextTool;¤	m_last_dynamic_tool = m_next_dynamic_tool;¤	m_tiDisplayed = m_tiNextTool;¤	m_nTooltipType = m_nNextTooltipType;¤¤	OnRedrawTooltip(dc.GetSafeHdc(), m_dwCurTransparency);¤} //End of the WM_PAINT handler¤¤BOOL CPPToolTip::PreTranslateMessage(MSG* pMsg) ¤{¤	RelayEvent(pMsg);¤	¤	return CWnd::PreTranslateMessage(pMsg);¤}¤¤BOOL CPPToolTip::RelayEvent(MSG* pMsg)¤{¤	//ENG: Disables a message translation if object was't created (thanks to Stoil Todorov)¤	//RUS: Запрет обработки сообщений если объект не создан¤	if (NULL == GetSafeHwnd())  ¤		return FALSE;¤¤	ASSERT(m_hParentWnd);¤¤	HWND hWnd = NULL;¤	POINT pt;¤	CRect rect;¤	PPTOOLTIP_INFO ti;¤	CString strTemp;¤¤	switch(pMsg->message)¤	{¤	case WM_SETFOCUS:¤		rect.left = 0;¤		break;¤	case WM_LBUTTONDOWN:¤		TRACE(_T("CPPToolTip::WM_LBUTTONDOWN\n"));¤		if (IsCursorOverTooltip())¤		{¤			//Left Button was pressed over the tooltip¤			pt = pMsg->pt;¤			ScreenToClient(&pt);¤			m_drawer.OnLButtonDown(&pt); //¤		} //if¤	case WM_LBUTTONDBLCLK:¤	case WM_RBUTTONDOWN:¤	case WM_RBUTTONDBLCLK:¤	case WM_MBUTTONDOWN:¤	case WM_MBUTTONDBLCLK:¤	case WM_NCLBUTTONDOWN:¤	case WM_NCLBUTTONDBLCLK:¤	case WM_NCRBUTTONDOWN:¤	case WM_NCRBUTTONDBLCLK:¤	case WM_NCMBUTTONDOWN:¤	case WM_NCMBUTTONDBLCLK:¤	case WM_KEYDOWN:¤	case WM_SYSKEYDOWN:¤	case WM_MOUSEWHEEL:¤//		// The user has interrupted the current tool - dismiss it¤//		if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_NOCLOSE_MOUSEDOWN))¤		Pop();¤		break;¤	case WM_MOUSEMOVE:¤		if ((PPTOOLTIP_HELP == m_nTooltipType) || (PPTOOLTIP_HELP == m_nNextTooltipType))¤			return FALSE;¤		if ((m_ptOriginal.x != pMsg->pt.x) || (m_ptOriginal.y != pMsg->pt.y))¤		{¤			// The mouse pointer's position was changed¤¤			//Initialize values¤			rect.SetRectEmpty();¤			m_ptOriginal = pt = pMsg->pt;¤			::ScreenToClient(m_hParentWnd, &pt);¤			if (m_bDebugMode)¤			{¤				//Debug mode¤				ti.sTooltip = GetDebugInfoTool(&pt);¤				ti.nMask = 0;¤				m_hwndDisplayedTool = NULL;¤				SetNewTooltip(this->GetSafeHwnd(), 0, ti);¤			}¤			else if (IsCursorOverTooltip() && !(m_tiDisplayed.nBehaviour & PPTOOLTIP_TRACKING_MOUSE)) ¤			{¤				OnSetCursor (this, 0, 0);¤				//ENG: Mouse over a tooltip and tracking mode was disabled¤				//RUS: Курсор над тултипом при выключенном режиме "тракинга"¤				if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_NOCLOSE_OVER))¤				{¤					//ENG: A tooltip don't hides when mouse over him¤					//RUS: Если не установлен стиль не закрывания тултипа если курсор над ним¤					HideTooltip();¤				}¤				else¤				{¤					//ENG: Resetup autopop timer¤					//RUS: Переустанавливаем таймер автозакрытия тултипа¤					SetAutoPopTimer();¤				} //if¤			}¤			else¤			{¤				//ENG: Searching a toolbar's item¤				//RUS: Ищем элемент на панели инструментов¤				hWnd = FindToolBarItem(pMsg->pt, ti);¤				if (NULL == hWnd)¤				{¤					//ENG: Searching a hot area of the tooltip¤					//RUS: Ищем предопределенную горячую зону тултипа¤					hWnd = FindTool(&pt, ti);¤				} //if¤				TRACE ("Временное окно = 0x%08X\n", hWnd);¤				if (NULL == hWnd)¤				{¤					//ищём среди динамических элементов¤					CallBackMap::iterator it = m_dynamic_tools.begin ();¤					CallBackMap::iterator it_end = m_dynamic_tools.end ();¤					DynamicToolID finded_tool = 0;¤¤					for (; it != it_end && finded_tool == 0; ++it) {¤						if (it->second (ti)) {¤							finded_tool = it->first;¤						}¤					}¤¤					if (finded_tool != 0) {¤						if (¤							(finded_tool != m_last_dynamic_tool) ¤							|| (ti.rectBounds != m_tiDisplayed.rectBounds/* m_rcDisplayedTool*/)¤						) {¤							//если новый элемент¤							SetNewTooltip(hWnd, finded_tool, ti);¤						} else {¤							//элемент не поменялся¤							if (m_tiDisplayed.nBehaviour & PPTOOLTIP_TRACKING_MOUSE) {¤								//ENG: If sets tracking mode¤								//RUS: Если установлен режим "тракинга"¤								SetAutoPopTimer();¤								OutputTooltipOnScreen(&pMsg->pt);¤							} else if (¤								(finded_tool == m_last_dynamic_tool) && ¤								!(m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)¤							) {¤								//ENG: A tooltip must hide at anything mouse move¤								//RUS: Если должен прятаться прилюбом движении мыши¤								if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW))¤								{¤									//ENG: "Multiple show" mode was disabled¤									//RUS: Если не установлен режим множественного показа тултипа¤									HideTooltip();¤								}¤								else¤								{¤									//ENG: "Multiple show" mode was enabled¤									//RUS: Если установлен режим множественного показа тултипа¤									SetNewTooltip(hWnd, finded_tool, ti);¤								} //if¤							}¤							else¤							{¤								//ENG: A tooltip don't must when a mouse is over window¤								//RUS: Тултип не должен прятаться пока находится над окном¤								SetAutoPopTimer();¤							} //if¤						}¤¤					} else {¤						//ENG: An item with a tooltip wasn't found¤						//RUS: Ни один элемент, отображающий тултип, не найден¤						m_hwndDisplayedTool = NULL;¤¤						m_last_dynamic_tool = 0;¤¤						m_tiDisplayed.rectBounds.SetRectEmpty();¤						KillTimer(TIMER_SHOW);¤						HideTooltip();¤					}¤				}¤				else ¤				{¤					if ((hWnd != m_hwndDisplayedTool) || (ti.rectBounds != m_tiDisplayed.rectBounds/* m_rcDisplayedTool*/))¤					{¤						//ENG: Sets new tooltip for the new window or for the new window's item¤						//RUS: Если новое окно или новый элемент окна, то установить новый тултип¤						SetNewTooltip(hWnd, 0, ti);¤					}¤					else¤					{¤						//ENG: Nothing was changed¤						//RUS: Если ни окно, ни элемент окна не изменялись¤						if (m_tiDisplayed.nBehaviour & PPTOOLTIP_TRACKING_MOUSE)¤						{¤							//ENG: If sets tracking mode¤							//RUS: Если установлен режим "тракинга"¤							SetAutoPopTimer();¤							OutputTooltipOnScreen(&pMsg->pt);¤						}¤						else if (!(m_tiDisplayed.nBehaviour & PPTOOLTIP_CLOSE_LEAVEWND))¤						{¤							//ENG: A tooltip must hide at anything mouse move¤							//RUS: Если должен прятаться прилюбом движении мыши¤							if ((hWnd == m_hwndDisplayedTool) && ¤								!(m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW))¤							{¤								//ENG: "Multiple show" mode was disabled¤								//RUS: Если не установлен режим множественного показа тултипа¤								HideTooltip();¤							}¤							else¤							{¤								//ENG: "Multiple show" mode was enabled¤								//RUS: Если установлен режим множественного показа тултипа¤								SetNewTooltip(hWnd, 0, ti);¤							} //if¤						}¤						else¤						{¤							//ENG: A tooltip don't must when a mouse is over window¤							//RUS: Тултип не должен прятаться пока находится над окном¤							SetAutoPopTimer();¤						} //if¤					} //if¤				} //if¤			} //if¤		} //if¤		break;¤	} //switch¤¤	return FALSE;¤} //End RelayEvent¤¤void CPPToolTip::SetNewTooltip(HWND hWnd, DynamicToolID toolID, const PPTOOLTIP_INFO & ti, BOOL bDisplayWithDelay /* = TRUE */, TooltipType type /* = PPTOOLTIP_NORMAL */)¤{¤	TRACE (_T("CPPToolTip::SetNewTooltip(hWnd=0x%08X, CRect(left=%d, top=%d, right=%d, bottom=%d), nID=%d)\n"), ¤		hWnd, ti.rectBounds.left, ti.rectBounds.top, ti.rectBounds.right, ti.rectBounds.bottom, ti.nIDTool);¤	¤	m_bNextToolExist = FALSE;¤¤	//ENG: Hides a tooltip¤	//RUS: Прячем тултип если он показан или показывается¤	if ((PPTOOLTIP_STATE_SHOWING == m_nTooltipState) || ¤		(PPTOOLTIP_STATE_SHOWN == m_nTooltipState))¤		HideTooltip();¤¤	//ENG: If a tooltip wasn't hidden¤	//RUS: Если тултип еще не спрятан, ждем ...¤	m_nNextTooltipType = type;¤	m_hwndNextTool = hWnd;¤	m_next_dynamic_tool = toolID;¤	m_tiNextTool = ti;¤	if (PPTOOLTIP_STATE_HIDEN != m_nTooltipState)¤	{¤		TRACE(_T("SetNewTooltip2(%d)\n"), m_nNextTooltipType);¤		m_bNextToolExist = TRUE;¤		if (bDisplayWithDelay && m_dwTimeInitial)¤			m_bDelayNextTool = TRUE;¤		else ¤			m_bDelayNextTool = FALSE;¤		return;¤	} //if¤¤	//ENG: Start the show timer¤	//RUS: Начинаем показ нового тултипа¤	if (bDisplayWithDelay && m_dwTimeInitial)¤		SetTimer(TIMER_SHOW, m_dwTimeInitial, NULL);¤	else¤		OnTimer(TIMER_SHOW);¤} //End of SetNewTooltip¤¤void CPPToolTip::OnTimer(UINT nIDEvent) ¤{¤	POINT pt;¤	switch (nIDEvent)¤	{¤	case TIMER_SHOW:¤		TRACE(_T("OnTimerShow(%d)\n"), m_nNextTooltipType);¤		//ENG: Kill SHOW timer ¤		//RUS: Убить таймер ожидания показа тултипа¤		KillTimer(TIMER_SHOW);¤		//ENG: Get current mouse coordinates¤		//RUS: Получить текущее положение тултипа¤		if ((PPTOOLTIP_HELP == m_nNextTooltipType) || ¤			(PPTOOLTIP_MENU == m_nNextTooltipType))¤			pt = m_ptOriginal;¤		else GetCursorPos(&pt);¤¤		if ((pt.x != m_ptOriginal.x) || (pt.y != m_ptOriginal.y))¤		{¤			//ENG: If mouse coordinates was changed¤			//RUS: Если курсор сдвинулся, то уничтожить тултип¤			TRACE(_T("OnTimerShow(HideTooltip)\n"));¤			HideTooltip();¤		}¤		else if (PPTOOLTIP_STATE_HIDEN == m_nTooltipState)¤		{¤			TRACE(_T("OnTimerShow(Showing)\n"));¤			m_nTooltipState = PPTOOLTIP_STATE_SHOWING;¤			//Display first step¤			PrepareDisplayTooltip(&m_ptOriginal);¤			¤			//Fade In effect¤			if ((SHOWEFFECT_FADEINOUT == m_dwShowEffect) && m_dwTimeFadeIn)¤			{¤				TRACE(_T("OnTimerShow(FadeIn)\n"));¤				SetTimer(TIMER_SHOWING, m_dwTimeFadeIn, NULL); //Fade in showing was enabled¤			}¤			else¤			{¤				TRACE(_T("OnTimerShow(Shown)\n"));¤				m_nTooltipState = PPTOOLTIP_STATE_SHOWN; //Tooltip is already show¤				if (m_dwTimeAutoPop && !(m_tiNextTool.nBehaviour & PPTOOLTIP_DISABLE_AUTOPOP))¤					SetTimer(TIMER_HIDE, m_dwTimeAutoPop, NULL); //Hiding by timer was enabled¤			} //if¤		} //if¤		break;¤	case TIMER_SHOWING:¤		TRACE(_T("OnTimerFadeIn(Current Transparency=%d )\n"), m_dwCurTransparency);¤		//ENG: If fade-in effect was finished then sets minimum transparency¤		//RUS: Если шаги эффекта плавного показа исчерпаны, то установить минимальную прозрачность¤		if (m_dwCurTransparency > (PERCENT_MIN_TRANSPARENCY + PERCENT_STEP_FADEIN))¤			m_dwCurTransparency -= PERCENT_STEP_FADEIN;¤		else m_dwCurTransparency = PERCENT_MIN_TRANSPARENCY;¤¤		if (m_dwCurTransparency <= m_tiDisplayed.nTransparency)¤		{¤			//ENG: Kills showing timer and sets a tooltip's state as SHOWN¤			//RUS: Убиваем таймер плавного показа и устанавливаем состояние тултипа как SHOWN¤			m_dwCurTransparency = m_tiDisplayed.nTransparency;¤			KillTimer(TIMER_SHOWING);¤			m_nTooltipState = PPTOOLTIP_STATE_SHOWN;¤			//ENG: Starts timer to auto pop of the tooltip¤			//RUS: Запуск таймера на автоматическое сокрытие тултипа¤			SetAutoPopTimer();¤		} //if¤		//ENG: Redraw tooltip with new transparency factor¤		//RUS: Перерисовать текущий тултип с новым коэффициентом прозрачности¤		OnRedrawTooltip(NULL, m_dwCurTransparency);¤		break;	¤	case TIMER_HIDE:¤		TRACE(_T("OnTimerHide()\n"));¤		//ENG: Kill all timers except HIDING timer¤		//RUS: Убиваем все таймеры за исключением таймера HIDING¤		KillTimer(TIMER_SHOW);¤		KillTimer(TIMER_SHOWING);¤		KillTimer(TIMER_HIDE);¤		//ENG: If hiding timer don't start¤		//RUS: Проверяем запущен ли таймер сокрытия тултипа¤		if (PPTOOLTIP_STATE_HIDING != m_nTooltipState)¤		{¤			m_nTooltipState = PPTOOLTIP_STATE_HIDING;¤			if ((SHOWEFFECT_FADEINOUT == m_dwHideEffect) && m_dwTimeFadeOut)¤			{¤				//ENG: If fade-out effect enabled and setted fade-out timestep¤				//RUS: Если эффект плавного сокрытия разрешен и указано время шага сокрытия¤				SetTimer(TIMER_HIDING, m_dwTimeFadeOut, NULL);¤			}¤			else¤			{¤				//ENG: Sets a maximum transparency and to stops a hiding of a tooltip¤				//RUS: Устанавливаем максимальную прозрачность и останавливаем сокрытие¤				m_dwCurTransparency = PERCENT_MAX_TRANSPARENCY;¤				OnTimer(TIMER_HIDING);¤			} //if¤		} //if¤		break;¤	case TIMER_HIDING:¤		TRACE(_T("OnTimerFadeOut(Current Transparency=%d)\n"), m_dwCurTransparency);¤		//ENG: If fade-out effect was finished then sets maximum transparency¤		//RUS: Если шаги эффекта плавного сокрытия исчерпаны, то установить максимальную прозрачность¤		if (m_dwCurTransparency < (PERCENT_MAX_TRANSPARENCY - PERCENT_STEP_FADEOUT))¤			m_dwCurTransparency += PERCENT_STEP_FADEOUT;¤		else m_dwCurTransparency = PERCENT_MAX_TRANSPARENCY;¤		¤		if (PERCENT_MAX_TRANSPARENCY == m_dwCurTransparency)¤		{¤			//ENG: Kills hiding timer and hides a tooltip¤			//RUS: Убиваем таймер плавного сокрытия и прячем окно тултипа¤			KillTimer(TIMER_HIDING);¤			if (m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)¤			{¤				//If for tool to set a multiple show then reset last window¤				m_hwndDisplayedTool = NULL;¤				m_last_dynamic_tool = 0;¤¤				m_tiDisplayed.rectBounds.SetRectEmpty();¤			} //if¤			ShowWindow(SW_HIDE);¤			m_nTooltipState = PPTOOLTIP_STATE_HIDEN;¤			if (m_bNextToolExist)¤			{¤				//ENG: If next tooltip is exist then starts show¤				//RUS: Если существует подготовленный тултип, то начать его отображение¤				m_bNextToolExist = FALSE;¤//				m_nTooltipType = m_nNextTooltipType;¤//				m_nNextTooltipType = PPTOOLTIP_NORMAL;¤				if (m_bDelayNextTool) SetTimer(TIMER_SHOW, m_dwTimeInitial, NULL);¤				else OnTimer(TIMER_SHOW);¤			}¤			else¤			{¤				//ENG: If next tooltip wasn't exist¤				//RUS: Если подготовленный тултип не существует¤				m_nTooltipType = PPTOOLTIP_NORMAL;¤				m_nNextTooltipType = PPTOOLTIP_NORMAL;¤			} //if¤		}¤		else ¤		{¤			//ENG: Redraw tooltip with new transparency factor¤			//RUS: Перерисовать текущий тултип с новым коэффициентом прозрачности¤			OnRedrawTooltip(NULL, m_dwCurTransparency);¤		} //if¤		break;	¤	case TIMER_ANIMATION:¤		if (IsVisible() && (PPTOOLTIP_STATE_SHOWN == m_nTooltipState))¤		{¤			if(m_drawer.OnTimer())¤				OnRedrawTooltip(NULL, m_dwCurTransparency);¤		} //if¤		break;¤	default:¤		CWnd::OnTimer(nIDEvent);¤		break;¤	} //switch¤} //End of the WM_TIMER handler¤¤void CPPToolTip::HideTooltip()¤{¤	TRACE (_T("CPPToolTip::HideTooltip(CurState=%d)\n"), m_nTooltipState);¤	switch(m_nTooltipState)¤	{¤	case PPTOOLTIP_STATE_SHOWING:¤		//ENG: Kill showing tooltip¤		//RUS: Если тултип только отбражается, то прекращаем его отображать¤		KillTimer(TIMER_SHOWING);¤	case PPTOOLTIP_STATE_SHOWN:¤		//ENG: Hiding a tooltip¤		//RUS: Прячем тултип¤		OnTimer(TIMER_HIDE);¤		break;¤	} //switch¤} //End of HideTooltip¤¤void CPPToolTip::SetAutoPopTimer()¤{¤	TRACE (_T("CPPToolTip::SetAutoPopTimer()\n"));¤	if (m_dwTimeAutoPop && !(m_tiDisplayed.nBehaviour & PPTOOLTIP_DISABLE_AUTOPOP))¤		SetTimer(TIMER_HIDE, m_dwTimeAutoPop, NULL);¤} //End of SetAutoPopTimer¤¤void CPPToolTip::KillTimers(DWORD dwIdTimer /* = NULL */)¤{¤	TRACE (_T("CPPToolTip::KillTimers()\n"));¤	if (dwIdTimer == NULL)¤	{¤		KillTimer(TIMER_SHOW);¤		KillTimer(TIMER_HIDE);¤		KillTimer(TIMER_SHOWING);¤		KillTimer(TIMER_HIDING);¤	}¤	else ¤	{¤		KillTimer(dwIdTimer);¤	} //if¤} //End KillTimers¤¤void CPPToolTip::Pop()¤{¤	TRACE (_T("CPPToolTip::Pop()\n"));¤	m_nTooltipState = PPTOOLTIP_STATE_HIDEN;¤	m_nTooltipType = PPTOOLTIP_NORMAL;¤	m_nNextTooltipType = PPTOOLTIP_NORMAL;¤	KillTimers();¤	if (IsVisible())¤	{¤		if (m_tiDisplayed.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)¤		{¤			//If for tool to set a multiple show then reset last window¤			m_hwndDisplayedTool = NULL;¤			m_last_dynamic_tool = 0;¤			m_tiDisplayed.rectBounds.SetRectEmpty();¤		} //if¤		ShowWindow(SW_HIDE);¤	} //if¤} //End of Pop¤¤void CPPToolTip::PrepareDisplayTooltip(LPPOINT lpPoint)¤{¤	TRACE (_T("CPPToolTip::PrepareDisplayTooltip()\n"));¤	¤	//Fills default members¤	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_STYLES))¤		m_tiNextTool.nStyles = m_dwStyles;¤¤	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_EFFECT))¤	{¤		m_tiNextTool.nEffect = m_dwEffectBk;¤		m_tiNextTool.nGranularity = m_nGranularity;¤	} //if¤¤	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_COLORS))¤	{¤		m_tiNextTool.crBegin = m_clrBeginBk;¤		m_tiNextTool.crMid = m_clrMidBk;¤		m_tiNextTool.crEnd = m_clrEndBk;¤	} //if¤¤	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_DIRECTION))¤		m_tiNextTool.nDirection = m_dwDirection;¤¤	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_BEHAVIOUR))¤		m_tiNextTool.nBehaviour = m_dwBehaviour;¤¤	if (!(m_tiNextTool.nMask & PPTOOLTIP_MASK_TRANSPARENCY))¤		m_tiNextTool.nTransparency = m_nTransparency;¤	¤	//Send notify¤	POINT pt = *lpPoint; //Pointer in screen coordinates¤	SendNotify(&pt, m_tiNextTool);¤	¤	//If string and icon are not exist then exit¤	if (m_tiNextTool.sTooltip.IsEmpty())¤		return;¤	¤	//calculate the width and height of the box dynamically¤	CDC * pDC = GetDC();¤	ASSERT(pDC->GetSafeHdc());¤	¤	CSize sz (0, 0);¤	m_drawer.PrepareOutput(pDC->GetSafeHdc(), m_tiNextTool.sTooltip, &sz);¤¤	m_rcTipArea.SetRect(0, 0, sz.cx, sz.cy);¤	m_rcTooltip = m_rcTipArea;¤¤	//Inflates on MARGIN_CX and MARGIN_CY sizes¤	m_rcTipArea.OffsetRect(m_nSizes[PPTTSZ_MARGIN_CX], m_nSizes[PPTTSZ_MARGIN_CY]);¤	m_rcTooltip.InflateRect(0, 0, 2 * m_nSizes[PPTTSZ_MARGIN_CX], 2 * m_nSizes[PPTTSZ_MARGIN_CY]);¤¤	//Inflates on ¤	//Gets tooltip's rect with anchor¤	CPoint ptAnchor;¤	m_dwCurDirection = GetTooltipDirection(m_tiNextTool.nDirection, pt, ptAnchor, m_rcTooltip, m_rcBoundsTooltip, m_rcTipArea);¤¤	//ENG: Clears resources¤	//RUS: Очищаем ресурсы¤	FreeResources();¤¤	//ENG: Creates a new region of the window¤	//RUS: Создаем новый регион окна¤	m_hrgnTooltip = GetTooltipRgn(m_dwCurDirection, ptAnchor.x, ptAnchor.y, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.Height());¤¤	CRect rect = m_rcBoundsTooltip;¤	¤	//ENG: Creates a background bitmap¤	//RUS: Создаем битмап фона тултипа¤	m_hBitmapBk = ::CreateCompatibleBitmap(pDC->GetSafeHdc(), rect.Width(), rect.Height());¤	HDC hMemDC = ::CreateCompatibleDC(pDC->GetSafeHdc());¤	¤	//ENG: Creates a background of the tooltip's body¤	//RUS: Создание фона тела тултипа¤	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hMemDC, m_hBitmapBk);¤	m_drawer.GetDrawManager()->FillEffect(hMemDC, ¤								m_tiNextTool.nEffect, ¤								m_rcTooltip,¤								m_tiNextTool.crBegin,¤								m_tiNextTool.crMid,¤								m_tiNextTool.crEnd,¤								m_tiNextTool.nGranularity,¤								5);¤	//ENG: Fills an anchor¤	//RUS: Заполняем якорь тултипа¤	switch (m_dwCurDirection)¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, m_rcTooltip.left - m_rcBoundsTooltip.left, m_rcBoundsTooltip.Height(),¤					 hMemDC, m_rcTooltip.left + 1, m_rcBoundsTooltip.top, 1, m_rcBoundsTooltip.Height());¤		break;¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcTooltip.right, m_rcBoundsTooltip.top, m_rcBoundsTooltip.right - m_rcTooltip.right, m_rcBoundsTooltip.Height(),¤					 hMemDC, m_rcTooltip.right - 1, m_rcBoundsTooltip.top, 1, m_rcBoundsTooltip.Height());¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcBoundsTooltip.left, m_rcTooltip.bottom, m_rcBoundsTooltip.Width(), m_rcBoundsTooltip.bottom - m_rcTooltip.bottom,¤					 hMemDC, m_rcBoundsTooltip.left, m_rcTooltip.bottom - 1, m_rcBoundsTooltip.Width(), 1);¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		m_drawer.GetDrawManager()->MultipleCopy(hMemDC, m_rcBoundsTooltip.left, m_rcBoundsTooltip.top, m_rcBoundsTooltip.Width(), m_rcTooltip.top - m_rcBoundsTooltip.top,¤					 hMemDC, m_rcBoundsTooltip.left, m_rcTooltip.top + 1, m_rcBoundsTooltip.Width(), 1);¤		break;¤	} //switch¤¤	::SelectObject(hMemDC, hOldBitmap);¤	::DeleteDC(hMemDC);¤	¤	ReleaseDC(pDC);¤	¤	//ENG: Calculate the tooltip's placement on the screen¤	//RUS: Вычисление положения тултипа на экране¤	rect.left = pt.x - ptAnchor.x;¤	rect.top = pt.y - ptAnchor.y;¤	rect.right = rect.left + m_rcBoundsTooltip.Width();¤	rect.bottom = rect.top + m_rcBoundsTooltip.Height();¤¤	//ENG: If fade-in effect ia available¤	//RUS: Если плавное отображение доступно¤	if ((SHOWEFFECT_FADEINOUT == m_dwShowEffect) && m_dwTimeFadeIn)¤		m_dwCurTransparency = 100;¤	else¤		m_dwCurTransparency = m_tiNextTool.nTransparency;¤¤	HRGN hrgnWindow = ::CreateRectRgn(0, 0, 0, 0);¤	if (m_szOffsetShadow.cx || m_szOffsetShadow.cy)¤	{¤		//ENG: If shadow will drawn¤		//RUS: Если тень будет отображаться¤		HRGN hrgnShadow = ::CreateRectRgn(0, 0, 0, 0);¤		::CombineRgn(hrgnShadow, m_hrgnTooltip, hrgnShadow, RGN_COPY);¤		::OffsetRgn(hrgnShadow, m_szOffsetShadow.cx, m_szOffsetShadow.cy);¤		::CombineRgn(hrgnWindow, m_hrgnTooltip, hrgnShadow, RGN_OR);¤		::DeleteObject(hrgnShadow);¤¤		//ENG: Increments the sizes of tooltip to drawing a shadow¤		//RUS: Увеличиваем размеры тултипа для рисования тени¤		m_rcBoundsTooltip.right += m_szOffsetShadow.cx;¤		m_rcBoundsTooltip.bottom += m_szOffsetShadow.cy;¤	}¤	else¤	{¤		//ENG: The current window has not a shadow¤		//RUS: Текущее окно не имеет тени¤		::CombineRgn(hrgnWindow, m_hrgnTooltip, NULL, RGN_COPY);¤	}//if¤¤	//ENG: Applies a region¤	//RUS: Применяем регион¤	SetWindowRgn(hrgnWindow, FALSE);¤	¤	//ENG: Sets a tooltip on the screen¤	//RUS: Устанавливаем тултип на экране¤	if (PPTOOLTIP_MENU == m_nTooltipType) ¤	{¤		SetWindowPos(NULL, ¤			rect.left, rect.top,¤			m_rcBoundsTooltip.Width(), ¤			m_rcBoundsTooltip.Height(),¤			SWP_SHOWWINDOW|SWP_NOACTIVATE|SWP_NOZORDER/*|SWP_NOCOPYBITS*/);¤	}¤	else¤	{¤		SetWindowPos(NULL, ¤			rect.left, rect.top,¤			m_rcBoundsTooltip.Width(), ¤			m_rcBoundsTooltip.Height(),¤			SWP_SHOWWINDOW|SWP_NOACTIVATE/*|SWP_NOCOPYBITS*/);¤	}¤} //End of PrepareDisplayTooltip¤¤void CPPToolTip::FreeResources()¤{¤	if (NULL != m_hrgnTooltip)¤	{¤		::DeleteObject(m_hrgnTooltip);¤		m_hrgnTooltip = NULL;¤	} //if¤¤	if (NULL != m_hBitmapBk)¤	{¤		::DeleteObject(m_hBitmapBk);¤		m_hBitmapBk = NULL;¤	} //if¤¤	if (NULL != m_hUnderTooltipBk)¤	{¤		::DeleteObject(m_hUnderTooltipBk);¤		m_hUnderTooltipBk = NULL;¤	} //if¤} //End of FreeResources¤¤void CPPToolTip::OutputTooltipOnScreen(LPPOINT lpPoint, HDC hDC /* = NULL */)¤{¤	TRACE(_T("OutputTooltipOnScreen()\n"));¤	CRect rect = m_rcBoundsTooltip;¤	rect.OffsetRect(*lpPoint);¤	//m_dwCurDirection = GetTooltipDirection(m_tiNextTool.nDirection, &pt, &ptAnchor, m_rcTooltip, m_rcBoundsTooltip, m_rcTipArea);¤	MoveWindow(rect);¤} //End OutputTooltipOnScreen¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::GetTooltipDirection()¤//		Gets a real direction of a tooltip.¤//------------------------------------------------------------------¤// Parameters:¤//		dwDirection		- A default direction of a tooltip. ¤//		lpPoint			- A mouse position in the screen coordinates.¤//		lpAnchor		- An anchor position in the client coordinates¤//      rcBody			- A rectangle of a tooltip's body in the client coordinates¤//		rcFull			- A rectangle of a full tooltip in the client coordinates¤//		rcTipArea		- A rectangle of a tooltip's info area in the client coordinates¤// Return values:¤//		A real direction of a tooltip¤//------------------------------------------------------------------¤// Explanation:¤//    0¤//  0 +------------------------------------+¤//    |                                    |¤//    |             rcBody                 |¤//    |                                    |¤//    |  +------------------------------+  |¤//    |  |                              |  |¤//    |  |         rcTipArea            |  |¤//    |  |                              |  |¤//    |  +------------------------------+  |¤//    |                                    |¤//    +--+...------------------------------+¤//    :  |  /                              :¤//    :  | /        rcFull                 :¤//    :..|/................................:¤//       +- lpAnchor¤//¤////////////////////////////////////////////////////////////////////¤DWORD CPPToolTip::GetTooltipDirection(DWORD dwDirection, const CPoint & ptPoint, CPoint & ptAnchor, CRect & rcBody, CRect & rcFull, CRect & rcTipArea)¤{¤	//ENG: Get Window's rectangle. The whole virtual desktop .... not only the primary screen.JFN¤	//RUS: Получаем полный прямоугольник экрана Windows¤	CRect rWindow;¤    rWindow.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);¤    rWindow.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);¤	rWindow.right   = rWindow.left + ::GetSystemMetrics(SM_CXVIRTUALSCREEN);¤    rWindow.bottom  = rWindow.top + ::GetSystemMetrics(SM_CYVIRTUALSCREEN);¤¤	//-------------------------------------------¤	//ENG: Initializing size of the bounds rect¤	//RUS: Инициализация полного размера ограничивающего тултип прямоугольника¤	rcFull = rcBody;¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤		rcFull.right += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		break;¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		rcFull.right += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤		rcFull.bottom += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		rcFull.bottom += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		break;¤	} //switch¤	¤	//---------------------------------------------------¤	//ENG: If needed change a horizontal direction¤	//RUS: Проверка горизонтальных размеров на попадание в экран¤	CPoint pt(ptPoint);¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤		pt.x += rcFull.right;¤		if (pt.x > rWindow.right)¤			dwDirection ^= 0x10;¤		break;¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		pt.x -= rcFull.right;¤		if (pt.x < rWindow.left)¤			dwDirection ^= 0x10;¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_LEFT:¤		pt.x += rcFull.right;¤		pt.x -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		if (pt.x > rWindow.right)¤		{¤			pt.x = ptPoint.x - rcFull.right;¤			pt.x += m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤			if (pt.x < rWindow.left)¤				dwDirection |= 0x02;¤			else¤				dwDirection ^= 0x01;¤		} //if¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		pt.x -= rcFull.right;¤		pt.x += m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		if (pt.x < rWindow.left)¤		{¤			pt.x = ptPoint.x + rcFull.right;¤			pt.x -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤			if (pt.x > rWindow.right)¤				dwDirection ^= 0x03;¤			else¤				dwDirection ^= 0x01;¤		} //if¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤		if ((ptPoint.x - rWindow.left) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])¤			dwDirection ^= 0x02;¤		else if ((rWindow.right - ptPoint.x) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])¤			dwDirection ^= 0x03;¤		break;¤	} //switch¤¤	//---------------------------------------------------¤	//ENG: If needed change a vertical direction¤	//RUS: Проверка вертикальных размеров на попадание в экран¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤		pt.y += rcFull.bottom;¤		pt.y -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		if (pt.y > rWindow.bottom)¤		{¤			pt.y = ptPoint.y - rcFull.bottom;¤			pt.y += m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤			if (pt.y < rWindow.top)¤				dwDirection |= 0x02;¤			else¤				dwDirection ^= 0x01;¤		} //if¤		break;¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		pt.y -= rcFull.bottom;¤		pt.y += m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		if (pt.y < rWindow.top)¤		{¤			pt.y = ptPoint.y + rcFull.bottom;¤			pt.y -= m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤			if (pt.y > rWindow.bottom)¤				dwDirection ^= 0x03;¤			else¤				dwDirection ^= 0x01;¤		} //if¤		break;¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤		if ((ptPoint.y - rWindow.top) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])¤			dwDirection ^= 0x02;¤		else if ((rWindow.bottom - ptPoint.y) <= m_nSizes [PPTTSZ_MARGIN_ANCHOR])¤			dwDirection ^= 0x03;¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤		pt.y -= rcFull.bottom;¤		if (pt.y < rWindow.top)¤			dwDirection ^= 0x10;¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		pt.y += rcFull.bottom;¤		if (pt.y > rWindow.bottom)¤			dwDirection ^= 0x10;¤		break;¤	} //switch¤¤	//---------------------------------------------------¤	//ENG: Set the anchor's point¤	//RUS: Установка координаты кончика¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤		ptAnchor.x = rcFull.left;¤		break;¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		ptAnchor.x = rcFull.right;¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤		ptAnchor.y = rcFull.bottom;¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		ptAnchor.y = rcFull.top;¤		break;¤	} //switch¤	¤	//¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤		ptAnchor.y = rcFull.top + m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		break;¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		ptAnchor.y = rcFull.bottom - m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		break;¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤		ptAnchor.y = rcFull.bottom / 2;¤		if ((ptPoint.y + rcFull.bottom / 2) <= rWindow.bottom)¤		{¤			if ((ptPoint.y - rcFull.bottom / 2) < rWindow.top)¤				ptAnchor.y -= (rcFull.bottom / 2 - ptPoint.y + rWindow.top);¤		}¤		else if ((ptPoint.y - rcFull.bottom / 2) >= rWindow.top)¤		{¤			if ((ptPoint.y + rcFull.bottom / 2) > rWindow.bottom)¤				ptAnchor.y += (ptPoint.y + rcFull.bottom / 2 - rWindow.bottom);¤		} //if¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_LEFT:¤		ptAnchor.x = rcFull.left + m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		ptAnchor.x = rcFull.right - m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤		ptAnchor.x = rcFull.right / 2;¤		if ((ptPoint.x + rcFull.right / 2) <= rWindow.right)¤		{¤			if ((ptPoint.x - rcFull.right / 2) < rWindow.left)¤				ptAnchor.x -= (rcFull.right / 2 - ptPoint.x + rWindow.left);¤		}¤		else if ((ptPoint.x - rcFull.right / 2) >= rWindow.left)¤		{¤			if ((ptPoint.x + rcFull.right / 2) > rWindow.right)¤				ptAnchor.x += (ptPoint.x + rcFull.right / 2 - rWindow.right);¤		} //if¤		break;¤	} //switch¤¤	//---------------------------------------------------¤	//If needed offset anchor¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤		if ((ptPoint.y - ptAnchor.y) < rWindow.top)¤			ptAnchor.y = ptPoint.y - rWindow.top;¤		break;¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		if ((ptPoint.y + rcFull.bottom - ptAnchor.y) > rWindow.bottom)¤			ptAnchor.y = rcFull.bottom - rWindow.bottom + ptPoint.y;¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤		if ((ptPoint.x - ptAnchor.x) < rWindow.left)¤			ptAnchor.x = ptPoint.x - rWindow.left;¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		if ((ptPoint.x + rcFull.right - ptAnchor.x) > rWindow.right)¤			ptAnchor.x = rcFull.right - rWindow.right + ptPoint.x;¤		break;¤	} //switch¤¤	//*!* I don't know why but without following lines application fails in Release mode!!!!¤	CString str;¤	str.Format("0x%08X", dwDirection);¤¤	//---------------------------------------------¤	// Offset the body rectangle¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤		rcTipArea.OffsetRect(m_nSizes [PPTTSZ_HEIGHT_ANCHOR], 0);¤		rcBody.OffsetRect(m_nSizes [PPTTSZ_HEIGHT_ANCHOR], 0);¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		rcTipArea.OffsetRect(0, m_nSizes [PPTTSZ_HEIGHT_ANCHOR]);¤		rcBody.OffsetRect(0, m_nSizes [PPTTSZ_HEIGHT_ANCHOR]);¤		break;¤	} //switch¤¤	return dwDirection;¤} //End of GetTooltipDirection¤¤HRGN CPPToolTip::GetTooltipRgn(DWORD dwDirection, int x, int y, int nWidth, int nHeight)¤{¤	HRGN hRgn = NULL;¤	¤	HRGN hrgnBody = NULL;¤	CRect rcBody(0, 0, nWidth, nHeight);¤¤	HRGN hrgnAnchor = NULL;¤	POINT ptAnchor [3];¤	ptAnchor [0].x = x;¤	ptAnchor [0].y = y;¤	¤	HRGN hrgnRect = NULL;¤	¤	//------------------------------¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤		rcBody.left += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		ptAnchor [1].x = ptAnchor [2].x = rcBody.left;¤		break;¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		rcBody.right -= m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		ptAnchor [1].x = ptAnchor [2].x = rcBody.right;¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤		rcBody.top += m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		ptAnchor [1].y = ptAnchor [2].y = rcBody.top;¤		break;¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤		rcBody.bottom -= m_nSizes [PPTTSZ_HEIGHT_ANCHOR];¤		ptAnchor [1].y = ptAnchor [2].y = rcBody.bottom;¤		break;¤	} //switch¤¤	//------------------------------¤	switch(dwDirection) ¤	{¤	case PPTOOLTIP_LEFTEDGE_TOP:¤	case PPTOOLTIP_RIGHTEDGE_TOP:¤		ptAnchor [1].y = rcBody.top + m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		ptAnchor [2].y = ptAnchor [1].y + m_nSizes [PPTTSZ_WIDTH_ANCHOR];¤		break;¤	case PPTOOLTIP_LEFTEDGE_BOTTOM:¤	case PPTOOLTIP_RIGHTEDGE_BOTTOM:¤		ptAnchor [1].y = rcBody.bottom - m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		ptAnchor [2].y = ptAnchor [1].y - m_nSizes [PPTTSZ_WIDTH_ANCHOR];¤		break;¤	case PPTOOLTIP_LEFTEDGE_VCENTER:¤	case PPTOOLTIP_RIGHTEDGE_VCENTER:¤		ptAnchor [1].y = ptAnchor [0].y - m_nSizes [PPTTSZ_WIDTH_ANCHOR] / 2;¤//		ptAnchor [1].y = rcBody.top + (rcBody.Height() - m_nSizes [PPTTSZ_WIDTH_ANCHOR]) / 2;¤		ptAnchor [2].y = ptAnchor [1].y + m_nSizes [PPTTSZ_WIDTH_ANCHOR];¤		break;¤	case PPTOOLTIP_TOPEDGE_LEFT:¤	case PPTOOLTIP_BOTTOMEDGE_LEFT:¤		ptAnchor [1].x = rcBody.left + m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		ptAnchor [2].x = ptAnchor [1].x + m_nSizes [PPTTSZ_WIDTH_ANCHOR];¤		break;¤	case PPTOOLTIP_TOPEDGE_RIGHT:¤	case PPTOOLTIP_BOTTOMEDGE_RIGHT:¤		ptAnchor [1].x = rcBody.right - m_nSizes [PPTTSZ_MARGIN_ANCHOR];¤		ptAnchor [2].x = ptAnchor [1].x - m_nSizes [PPTTSZ_WIDTH_ANCHOR];¤		break;¤	case PPTOOLTIP_TOPEDGE_CENTER:¤	case PPTOOLTIP_BOTTOMEDGE_CENTER:¤		ptAnchor [1].x = ptAnchor [0].x - m_nSizes [PPTTSZ_WIDTH_ANCHOR] / 2;¤//		ptAnchor [1].x = rcBody.left + (rcBody.Width() - m_nSizes [PPTTSZ_WIDTH_ANCHOR]) / 2;¤		ptAnchor [2].x = ptAnchor [1].x + m_nSizes [PPTTSZ_WIDTH_ANCHOR];¤		break;¤	} //switch¤¤	//------------------------------¤	//Gets the tooltip body's region¤	hrgnBody = ::CreateRoundRectRgn(rcBody.left, rcBody.top, rcBody.right + 1, rcBody.bottom + 1, ¤			m_nSizes[PPTTSZ_ROUNDED_CX], m_nSizes[PPTTSZ_ROUNDED_CY]);¤¤	//Gets the tooltip anchor's region¤	if (m_nSizes [PPTTSZ_HEIGHT_ANCHOR] && m_nSizes [PPTTSZ_WIDTH_ANCHOR])¤		hrgnAnchor = ::CreatePolygonRgn(ptAnchor, 3, ALTERNATE);¤	else¤		hrgnAnchor = ::CreateRectRgn(0, 0, 0, 0);¤¤	hRgn = ::CreateRectRgn(0, 0, 0, 0);¤	::CombineRgn(hRgn, hrgnBody, hrgnAnchor, RGN_OR);¤¤	if (NULL != hrgnBody)¤		::DeleteObject(hrgnBody);¤	if (NULL != hrgnAnchor)¤		::DeleteObject(hrgnAnchor);¤¤	return hRgn;¤} //End GetTooltipRgn¤¤BOOL CPPToolTip::IsCursorOverTooltip() const¤{¤    ASSERT(m_hParentWnd);¤	¤    // Is tooltip visible?¤    if (!IsVisible() || !IsWindow(m_hWnd))¤		return FALSE;¤	¤    POINT pt;¤    GetCursorPos(&pt);¤	¤	CPPToolTip * pWnd = (CPPToolTip*)WindowFromPoint(pt);¤	¤	return (pWnd == this);¤}¤¤HWND CPPToolTip::GetWndFromPoint(const LPPOINT lpPoint, PPTOOLTIP_INFO & ti, BOOL bCheckTool /* = TRUE */)¤{¤	// the default implementation of tooltips just calls WindowFromPoint¤	// which does not work for certain kinds of combo boxes¤	CPoint pt = *lpPoint;¤	::ClientToScreen(m_hParentWnd, &pt);¤	HWND hWnd = ::WindowFromPoint(pt);¤	if (NULL != hWnd)¤	{¤		// try to hit combobox instead of edit control for CBS_DROPDOWN styles¤		HWND hWndTemp = ::GetParent(hWnd);¤		if (NULL != hWndTemp)¤		{¤			if (!IsComboBoxControl(hWndTemp, CBS_DROPDOWN))¤			{¤				// handle special case of disabled child windows¤				::ScreenToClient(hWnd, &pt);¤				hWndTemp = ::ChildWindowFromPoint(hWnd, pt);¤				if (NULL == hWndTemp)¤					return NULL;¤				if ((!::IsWindowEnabled(hWndTemp)) && bCheckTool)¤					return NULL;¤			} //if¤			¤			if (FindTool(hWndTemp, &pt, ti) || !bCheckTool)¤				return hWndTemp;¤		} //if¤	} //if¤¤	return NULL;¤} //End GetWndFromPoint¤¤BOOL CPPToolTip::IsComboBoxControl(HWND hWnd, UINT nStyle)¤{¤	if (hWnd == NULL)¤		return FALSE;¤	// do cheap style compare first¤	if ((UINT)(::GetWindowLong(hWnd, GWL_STYLE) & 0x0F) != nStyle)¤		return FALSE;¤¤	// do expensive classname compare next¤	TCHAR szCompare[9];¤	::GetClassName(hWnd, szCompare, 9);¤	return lstrcmpi(szCompare, _T("combobox")) == 0;¤}¤¤CString CPPToolTip::GetDebugInfoTool(LPPOINT lpPoint)¤{¤	PPTOOLTIP_INFO ti;¤	HWND hWnd = GetWndFromPoint(lpPoint, ti, FALSE);¤	HWND hParent = ::GetParent (hWnd);¤¤	_TCHAR ch[128];¤	CString str, strTemp;¤	CString strOutput = _T("<table>");¤	¤	///////////////////////////////////////////////////////////////////¤	//Table of a window¤	strOutput += _T("<tr><td><font color=darkblue>Window</font><table border=1>");¤¤	//1. Window's class name and Window Owner's class name¤	::GetClassName (hWnd, ch, 128);¤	strOutput += CreateDebugCell(_T("Class name"), ch);¤	¤	//2. Window's title and Window Owner's title¤	::GetWindowText (hWnd, ch, 128);¤	strOutput += CreateDebugCell(_T("Title"), ch);¤	¤	//3. Window's handle and Window Owner's handle¤	str.Format(_T("0x%08X"), hWnd);¤	strOutput += CreateDebugCell(_T("Handle"), str);¤	¤	//4. Window's ID¤	str.Format(_T("%d"), GetWindowLong(hWnd, GWL_ID));¤	strOutput += CreateDebugCell(_T("Control ID"), str);¤¤	//5. Window's styles¤	str.Format(_T("0x%08X"), (DWORD)::GetWindowLong (hWnd, GWL_STYLE));¤	strOutput += CreateDebugCell(_T("Styles"), str);¤	¤	//6. Window's rect¤	RECT rc; ¤	::GetWindowRect(hWnd, &rc);¤	str.Format(_T("(%d, %d)-(%d, %d)"), rc.left, rc.top, rc.right, rc.bottom);¤	strOutput += CreateDebugCell(_T("RECT"), str);¤¤	//7. Window's width¤	str.Format(_T("%d"), rc.right - rc.left);¤	strOutput += CreateDebugCell(_T("Width"), str);¤	¤	//8. Window's height¤	str.Format(_T("%d"), rc.bottom - rc.top);¤	strOutput += CreateDebugCell(_T("Height"), str);¤¤	//9. Window's has tooltip¤	HWND hwndTool = FindTool(lpPoint, ti);¤	str = (NULL != hwndTool) ? _T("Yes") : _T("No");¤	strOutput += CreateDebugCell(_T("Has Tooltip"), str);¤¤	strOutput += _T("</table></td>");¤¤	///////////////////////////////////////////////////////////////////¤	//Table of a window owner¤	strOutput += _T("<td><font color=darkblue>Window Owner</font><table border=1>");¤	¤	//1. Window's class name and Window Owner's class name¤	if (NULL != hParent)¤	{¤		::GetClassName (hParent, ch, 128);¤		str = GetMaxDebugString((CString)ch);¤	} //if¤	else str = _T("N/A");¤	strOutput += CreateDebugCell(_T("Class name"), str);¤	¤	//2. Window's title and Window Owner's title¤	if (NULL != hParent)¤	{¤		::GetWindowText (hParent, ch, 128);¤		str = GetMaxDebugString((CString)ch);¤	} //if¤	else str = _T("N/A");¤	strOutput += CreateDebugCell(_T("Title"), str);¤	¤	//3. Window's handle and Window Owner's handle¤	str.Format(_T("0x%08X"), hParent);¤	strOutput += CreateDebugCell(_T("Handle"), str);¤¤	strOutput += _T("</table>");¤	¤	///////////////////////////////////////////////////////////////////¤	//Table of a window owner¤	strOutput += _T("<br><font color=darkblue>Mouse Cursor</font><table border=1>");¤	¤	//1.¤	str.Format(_T("%d"), lpPoint->x);¤	strOutput += CreateDebugCell(_T("X"), str);¤	¤	//2.¤	str.Format(_T("%d"), lpPoint->y);¤	strOutput += CreateDebugCell(_T("Y"), str);¤¤	strOutput += _T("</table></td></tr></table>");¤¤	///////////////////////////////////////////////////////////////////////////¤	return strOutput;¤}¤¤CString CPPToolTip::CreateDebugCell(CString sTitle, LPCTSTR lpszDescription)¤{¤	CString str;¤	str.Format(_T("<tr><td width=70 bgcolor=buttonface>%s</td><td width=130 bgcolor=window>%s</td></tr>"), ¤		sTitle, GetMaxDebugString(lpszDescription));¤	return str;¤} //End of CreateDebugCell¤¤CString CPPToolTip::GetMaxDebugString(LPCTSTR lpszText)¤{¤	CString str = (CString)lpszText;¤	str.Replace(_T("<"), _T("?")); //Replaces the begins of the tags¤	if (str.GetLength() > MAX_LENGTH_DEBUG_STRING)¤	{¤		str = str.Left(MAX_LENGTH_DEBUG_STRING - 4);¤		str += _T(" ...");¤	} //if¤¤	return str;¤} //End of GetMaxDebugString¤¤HWND CPPToolTip::FindTool(const LPPOINT lpPoint, PPTOOLTIP_INFO & ti)¤{¤	return GetWndFromPoint(lpPoint, ti, TRUE);¤} //End of FindTool¤¤¤BOOL CPPToolTip::FindTool(HWND hWnd, const LPPOINT lpPoint, PPTOOLTIP_INFO & ti)¤{¤	//ENG: Searching a specified HWND¤	//RUS: Ищем указанный HWND¤	mapIter item = m_ToolMap.find(hWnd);¤	if (item == m_ToolMap.end())¤	{¤		//ENG: Specified HWND wasn't found¤		//RUS: Указанный HWND не найден¤		return FALSE; ¤	} //if¤	¤	//ENG: Gets the array with the hotarea's parameters¤	//RUS: Получаем массив с параметрами горячих зон указаного окна¤	arHotArea & hotarea = item->second;¤	if ((hotarea.size() == 1) && hotarea[0].rectBounds.IsRectEmpty())¤	{¤		//ENG: If a bounding rectangle of a hotarea wasn't define¤		//RUS: Если ограничивающий прямоугольник горячей зоны не определен¤		ti = hotarea[0];¤		return TRUE;¤	} //if¤¤	POINT ptClient = *lpPoint;¤	if (hWnd != m_hParentWnd)¤	{¤		//ENG: If HWND specified window isn't a parent¤		//RUS: Если HWND не относится к родительскому окну, то преобразуем координаты¤		::ScreenToClient(hWnd, &ptClient);¤	} //if¤	¤	CScrollView * pScroll = (CScrollView*)CScrollView::FromHandle(hWnd);¤	if (pScroll->IsKindOf(RUNTIME_CLASS(CScrollView))) ¤	{¤		//ENG: If HWND of CScrollView or derived class then corrects the coordinates¤		//RUS: Если HWND принадлежит CScrollView или производному от него классу, то корректируем координаты¤		CPoint ptScroll = pScroll->GetScrollPosition();¤		ptClient.x += ptScroll.x;¤		ptClient.y += ptScroll.y;¤	} //if¤	¤	//ENG: Search a hotarea under the mouse¤	//RUS: Ищем горячую зону под курсором¤	arHotArea::iterator iter;¤	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)¤	{¤		ti = *iter;¤		if (ti.rectBounds.PtInRect(ptClient))¤		{¤			//ENG: A hotarea was found¤			//RUS: Зона найдена¤			return TRUE;¤		} //if¤	} //for¤	¤	return FALSE;¤} //End of FindTool¤¤HWND CPPToolTip::FindToolBarItem(POINT point, PPTOOLTIP_INFO & ti)¤{¤	//ENG: Toolbar control was disabled¤	//RUS: Контроль за подсказками к панелям инструментов отключен¤	if (!m_wndToolBars.size())¤		return NULL;¤¤	//ENG: Gets a window under mouse¤	//RUS: Определяем окно под курсором¤	HWND hWnd = ::WindowFromPoint(point);¤	if (NULL != hWnd)¤	{¤		//ENG: A window was found. Searching a coincidence with toolbar windows¤		//RUS: Окно обнаружено. Поиск совпадения с окнами панелей инструментов¤		for (int i = 0; i < (int)m_wndToolBars.size(); i++)¤		{¤			if (m_wndToolBars[i] == hWnd)¤			{¤				//ENG: A toolbar under mouse¤				//RUS: Панель инструментов под курсором¤				CToolBar * pBar = (CToolBar*)CToolBar::FromHandle(hWnd);¤				pBar->ScreenToClient(&point);¤				//ENG: Gets a item's count of the toolbar¤				//RUS: Получаем количество элементов панели инструментов¤				int count = pBar->GetCount();¤				CRect rect;¤				//ENG: Searching an toolbar's item under mouse¤				//RUS: Поиск элемента панели инструментов находящегося под курсором¤				for (int i = 0; i < count; i++)¤				{¤					pBar->GetItemRect(i, rect);¤					if (rect.PtInRect(point))¤					{¤						//ENG: Toolbar's item was found¤						//RUS: Элемент панели инструментов обнаружен¤						ti.nIDTool = pBar->GetItemID(i);¤						ti.rectBounds = rect;¤						ti.nMask = 0;¤						ti.sTooltip = m_drawer.GetResCommandPrompt(ti.nIDTool, 1);¤						return hWnd;¤					} //if¤				} //for¤				return NULL;¤			} //if¤		} //for¤	} //if¤	return NULL;¤} //End of FindToolBarItem¤¤¤////////////////////////////////////////////////////////////////////////////////////////////¤// *** public methods ***¤////////////////////////////////////////////////////////////////////////////////////////////¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::AddTool()¤// Registers a tool with the tooltip control.¤//------------------------------------------------------------------¤// Parameters:¤//		pWnd			- Pointer to the window that contains the tool.  ¤//		lpszString		- Pointer to the text for the tool. ¤//      dwIdString		- ID of string resource¤//		hIcon			- Handle of the icon¤//		dwIdIcon		- ID of icon resource¤//		szIcon			- Specifies the width and the height, in pixels, of the icon to load.¤//		lpRectBounds	- Pointer to a RECT structure containing coordinates of the tool's bounding rectangle. ¤//						  The coordinates are relative to the upper-left corner of the client area of the window identified by pWnd. ¤//					      NULL if bounding rectangle don't uses for specified window¤//		dwIdTool		- ID of the tool¤//		ti				- Reference to PPTOOLTIP_INFO structure containing the parameters of the tooltip ¤//¤// Remarks:¤//		  A tooltip control can be associated with more than one tool. Call this function to register a tool ¤//		with the tooltip control, so that the information stored in the tooltip is displayed when the cursor is on the tool.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::AddTool(CWnd * pWnd, DWORD dwIdString, HICON hIcon, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)¤{¤	CString str;¤	str.LoadString(dwIdString);¤	AddTool(pWnd, (LPCTSTR)str, hIcon, lpRectBounds, dwIDTool);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString, HICON hIcon, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)¤{¤	CString str;¤	str.Format(_T("<table><tr><td><icon handle=0x%X></td><td>%s</td></tr></table>"), ¤		hIcon, lpszString);¤	AddTool(pWnd, str, lpRectBounds, dwIDTool);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, DWORD dwIdString, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)¤{¤	CString str;¤	str.LoadString(dwIdString);¤	AddTool(pWnd, (LPCTSTR)str, dwIdIcon, szIcon, lpRectBounds, dwIDTool);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)¤{¤	CString str;¤	str.Format(_T("<table><tr><td><icon idres=%d width=%d height=%d></td><td>%s</td></tr></table>"), ¤		dwIdIcon, szIcon.cx, szIcon.cy, lpszString);¤	AddTool(pWnd, str, lpRectBounds, dwIDTool);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdBitmap, COLORREF crMask, CSize & szBitmap /*= CSize(0, 0)*/, LPCRECT lpRectBounds /*= NULL*/, DWORD dwIDTool /*= 0*/)¤{¤	CString str;¤	str.Format(_T("<table><tr><td><bmp idres=%d mask=0x%X width=%d height=%d></td><td>%s</td></tr></table>"), ¤		dwIdBitmap, crMask, szBitmap.cx, szBitmap.cy, lpszString);¤	AddTool(pWnd, str, lpRectBounds, dwIDTool);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, DWORD dwIdString, LPCRECT lpRectBounds /* = NULL */, DWORD dwIDTool /* = 0 */)¤{¤	CString str;¤	str.LoadString(dwIdString);¤	AddTool(pWnd, (LPCTSTR)str, lpRectBounds, dwIDTool);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, LPCTSTR lpszString /* = NULL */, LPCRECT lpRectBounds /* = NULL */, DWORD dwIDTool /* = 0 */)¤{¤	PPTOOLTIP_INFO ti;¤¤	ti.nIDTool = dwIDTool;¤	if (NULL != lpRectBounds)¤		ti.rectBounds = *lpRectBounds;¤	else ¤		ti.rectBounds.SetRectEmpty();¤	ti.sTooltip = (CString)lpszString;¤	ti.nMask = 0;¤	ti.nStyles = 0;¤	ti.nDirection = 0;¤	ti.nEffect = 0;¤	ti.nBehaviour = 0;¤	ti.nGranularity = 0;¤	ti.crBegin = RGB(0, 0, 0);¤	ti.crMid = RGB(0, 0, 0);¤	ti.crEnd = RGB(0, 0, 0);¤¤	AddTool(pWnd, ti);¤}¤¤void CPPToolTip::AddTool(CWnd * pWnd, PPTOOLTIP_INFO & ti)¤{¤	TRACE(_T("CPPToolTip::AddTool(hWnd=0x%08X)\n"), pWnd->GetSafeHwnd());¤	ASSERT (pWnd);¤¤	//ENG: Gets HWND of a window¤	//RUS: Получаем HWND окна¤	HWND hWnd = pWnd->GetSafeHwnd();¤	¤	//ENG: Searching a specified HWND¤	//RUS: Ищем указанный HWND¤	mapIter item = m_ToolMap.find(hWnd);¤	¤	if (item == m_ToolMap.end())¤	{¤		//ENG: A tooltip for a specified HWND wasn't found therefore create it¤		//RUS: Тултип для указанного HWND не обнаружен, поэтому создаем его¤		arHotArea hotarea;¤		hotarea.push_back(ti);¤		m_ToolMap.insert(std::make_pair(hWnd, hotarea));¤		return;¤	} //if¤¤	//ENG: Gets parameters of the tooltip¤	//RUS: Получаем параметры тултипа¤	arHotArea & hotarea = item->second;¤¤	//ENG: A tooltip has more one rectangle areas. Check all theirs¤	//RUS: Тултип содержит более одной прямоугольной области, проверим всех их¤	arHotArea::iterator iter;¤	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)¤	{¤		if (ti.rectBounds == (*iter).rectBounds)¤		{¤			//ENG: Specified window's rect already exist and so updates him¤			//RUS: Указанный прямоугольник окна уже существует, поэтому просто обновляем его параметры¤			*iter = ti;¤			return;¤		} //if¤	} //for¤	¤	//ENG: Adds a new tool ¤	//RUS: Добавляем новый инструмент¤	hotarea.push_back(ti);¤} //End of AddTool¤¤void CPPToolTip::AddDynamicTool (DynamicToolID tool, const ExternalFindCallback& callback) {¤	m_dynamic_tools[tool] = callback;¤}¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::RemoveTool()¤//   Removes the tool specified by pWnd and lpRectBounds from the collection of ¤// tools supported by a tooltip control.¤//------------------------------------------------------------------¤// Parameters:¤//		pWnd			- Pointer to the window that contains the tool.  ¤//		lpRectBounds	- Pointer to a RECT structure containing coordinates of the tool's bounding rectangle. ¤//						  The coordinates are relative to the upper-left corner of the client area of the window identified by pWnd. ¤//					      NULL if bounding rectangle don't uses for specified window¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::RemoveTool(CWnd * pWnd, LPCRECT lpRectBounds /* = NULL */)¤{¤	TRACE (_T("CPPToolTip::RemoveTool(hWnd=0x%08X)\n"), pWnd->GetSafeHwnd());¤	ASSERT(pWnd);¤	¤	//ENG: Gets HWND of a window¤	//RUS: Получаем HWND окна¤	HWND hWnd = pWnd->GetSafeHwnd();¤¤	//ENG: Searching a specified HWND¤	//RUS: Ищем указанный HWND¤	mapIter item = m_ToolMap.find(hWnd);¤¤	if (item == m_ToolMap.end())¤	{¤		//ENG: Specified HWND wasn't found¤		//RUS: Указанный HWND не найден¤		return; ¤	} //if¤¤	if (NULL == lpRectBounds)¤	{¤		//ENG: Removes all tools for the specified window¤		//RUS: Удаляются все инструменты для указанного окна¤		m_ToolMap.erase(item);¤	}¤	else¤	{¤		//ENG: Search the tool to remove¤		//RUS: Поиск инструмента для удаления¤		arHotArea & hotarea = item->second;¤		arHotArea::iterator iter;¤		for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)¤		{¤			if ((*iter).rectBounds == *lpRectBounds)¤			{¤				//ENG: The tool was found¤				//RUS: Инструмент найден¤				if (hotarea.size() > 1)¤				{¤					//ENG: If the specified window has more one rectangle areas then removes the specified area only¤					//RUS: Если указанное окно содержит более одной области, то удаляем только указанную область¤					hotarea.erase(iter);¤				}¤				else¤				{¤					//ENG: If the specified window has one rectangle area only then removes the tool for specified window¤					//RUS: Если указанное окно имеет только одну прямоугольную область, то удалить весь инструмент¤					m_ToolMap.erase(item);¤				} //if¤				return;¤			} //if¤		} //for¤	} //if¤} //End of RemoveTool¤¤void CPPToolTip::RemoveDynamicTool(DynamicToolID tool) {¤	CallBackMap::iterator it = m_dynamic_tools.find (tool);¤	if (it != m_dynamic_tools.end ()) {¤		m_dynamic_tools.erase (it);¤	}¤}¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::RemoveAllTools()¤//   Removes all tools from the collection of tools supported by a tooltip control.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::RemoveAllTools()¤{¤	TRACE (_T("CPPToolTip::RemoveAllTools()\n"));¤¤	//ENG: Removes all tools¤	//RUS: Удаляем все инструменты¤	if (m_ToolMap.size())¤		m_ToolMap.clear();¤¤	//ENG: Removes all toolbars¤	//RUS: Удаляем все панели инструментов¤	if (m_wndToolBars.size())¤		m_wndToolBars.clear();¤¤	m_dynamic_tools.clear ();¤} //End of RemoveAllTools¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::AddToolBar()¤// Registers a toolbar to the tooltip control.¤//------------------------------------------------------------------¤// Parameters:¤//		pBar			- Pointer to the toolbar window.  ¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::AddToolBar(CToolBar * pBar)¤{¤	TRACE (_T("CPPToolTip::AddToolBar(hWnd=0x%08X)\n"), pBar->GetSafeHwnd());¤	ASSERT(pBar);¤¤	//ENG: Gets HWND toolbar's window¤	//RUS: Получаем HWND окна панели инструментов¤	HWND hWnd = pBar->GetSafeHwnd();¤¤	//ENG: Searching a clone of a toolbar¤	//RUS: Поиск дубликата указанной панели инструментов¤	arToolBarWnd::iterator iter;¤	for (iter = m_wndToolBars.begin(); iter != m_wndToolBars.end(); ++iter)¤	{¤		if (*iter == hWnd)¤		{¤			//ENG: A clone was found¤			//RUS: Дубликат найден¤			return;¤		} //if¤	} //for¤¤	//ENG: Stores HWND toolbar's window¤	//RUS: Запоминаем HWND окна панели инструментов¤	m_wndToolBars.push_back(hWnd);¤¤	//ENG: Disables a standard tooltip for the specified toolbar¤	//RUS: Запрещаем стандартные подсказки для указаной панели инструментов¤	DWORD dwStyles = pBar->GetBarStyle();¤	dwStyles &= ~CBRS_TOOLTIPS;¤	pBar->SetBarStyle(dwStyles);¤} //End of AddToolBar¤¤¤BOOL CPPToolTip::GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, LPCRECT lpRectBounds /* = NULL */)¤{¤	ASSERT(pWnd);¤¤	//ENG: Gets HWND of a window¤	//RUS: Получаем HWND окна¤	HWND hWnd = pWnd->GetSafeHwnd();	¤	//ENG: Searching a specified HWND¤	//RUS: Ищем указанный HWND¤	mapIter item = m_ToolMap.find(hWnd);	¤	if (item == m_ToolMap.end())¤	{¤		//ENG: Specified HWND wasn't found¤		//RUS: Указанный HWND не найден¤		return FALSE; ¤	} //if¤¤	//ENG: Gets parameters of the tooltip¤	//RUS: Получаем параметры тултипа¤	arHotArea & hotarea = item->second;¤¤	//ENG: A tooltip has more one rectangle areas. Check all theirs¤	//RUS: Тултип содержит более одной прямоугольной области, проверим всех их¤	arHotArea::iterator iter;¤	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)¤	{¤		if (lpRectBounds == (*iter).rectBounds)¤		{¤			//ENG: Specified window's rect already exist and so updates him¤			//RUS: Указанный прямоугольник окна уже существует, поэтому просто обновляем его параметры¤			ti = *iter;¤			return TRUE ;¤		} //if¤	} //for¤	¤	return FALSE;¤}¤¤BOOL CPPToolTip::GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, DWORD dwIDTool /* = 0 */)¤{¤	ASSERT(pWnd);¤¤	//ENG: Gets HWND of a window¤	//RUS: Получаем HWND окна¤	HWND hWnd = pWnd->GetSafeHwnd();	¤	//ENG: Searching a specified HWND¤	//RUS: Ищем указанный HWND¤	mapIter item = m_ToolMap.find(hWnd);	¤	if (item == m_ToolMap.end())¤	{¤		//ENG: Specified HWND wasn't found¤		//RUS: Указанный HWND не найден¤		return FALSE; ¤	} //if¤¤	//ENG: Gets parameters of the tooltip¤	//RUS: Получаем параметры тултипа¤	arHotArea & hotarea = item->second;¤¤	arHotArea::iterator iter;¤	for (iter = hotarea.begin(); iter != hotarea.end(); ++iter)¤	{¤		if (dwIDTool == (*iter).nIDTool)¤		{¤			ti = *iter;¤			return TRUE ;¤		} //if¤	} //for¤	¤	return FALSE;¤}¤¤void CPPToolTip::UpdateTipText(LPCTSTR lpszText, CWnd * pWnd, DWORD dwIDTool /* = 0 */)¤{¤	PPTOOLTIP_INFO ti;¤	if (GetToolInfo(ti, pWnd, dwIDTool))¤	{¤		ti.sTooltip = lpszText;¤		AddTool(pWnd, ti);¤	}¤}¤¤void CPPToolTip::DelTool(CWnd * pWnd, DWORD dwIDTool)¤{¤	PPTOOLTIP_INFO ti;¤	if (GetToolInfo(ti, pWnd, dwIDTool))¤	{¤		RemoveTool(pWnd, ti.rectBounds);¤	}¤}¤¤void CPPToolTip::SetToolRect(CWnd * pWnd, DWORD dwIDTool, LPCRECT lpRectBounds)¤{¤	PPTOOLTIP_INFO ti;¤	if (GetToolInfo(ti, pWnd, dwIDTool))¤	{¤		ti.rectBounds = *lpRectBounds;¤		AddTool(pWnd, ti);¤	}¤}¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::EnableHyperlink()¤// Enables redrawing hyperlinks and hot areas.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::EnableHyperlink(BOOL bEnable /* = TRUE */)¤{¤	m_bHyperlinkEnabled = bEnable;¤} //End of EnableHyperlink¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetCallbackHyperlink()¤//   Sets the callback message that will be sent to the specified window ¤// if user clicks a hyperlink or hotareas with a msg parameter.¤//------------------------------------------------------------------¤// Parameters:¤//		hWnd			- Handle of the window that will receive the callback message.¤//						  Pass NULL to remove any previously specified callback message.¤//		nMessage		- Callback message to send to window.¤//		lParam			- A 32 bits user specified value that will be passed to the callback function.¤//¤// Remarks:¤//    The callback function must be in the form:¤//  LRESULT On_MenuCallback(WPARAM wParam, LPARAM lParam)¤//		wParam			- Pointer to the string specified as parameter in <a msg=> tag.¤//		lParam			- The 32 bits user specified value.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam /* = 0 */)¤{¤	TRACE(_T("CPPToolTip::SetCallbackHyperlink()\n"));¤	¤	m_drawer.SetCallbackHyperlink(hWnd, nMessage, lParam);¤} //End of SetCallbackHyperlink¤¤/////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetNotify()¤// This function sets or removes the notification messages from the control before display.¤//-------------------------------------------------------------------¤// Parameters:¤//		bParentNotify	- If TRUE the tooltip will be send the notification to parent window¤//						  Else the notification will not send¤//		hWnd			- If non-NULL the tooltip will be send the notification to specified window¤//						  Else the notification will not send¤///////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetNotify(BOOL bParentNotify /* = TRUE */)¤{¤	HWND hWnd = NULL;¤	¤	if (bParentNotify)¤		hWnd = m_hParentWnd;¤	¤	SetNotify(hWnd);¤} //End of SetNotify¤¤void CPPToolTip::SetNotify(HWND hWnd)¤{¤	TRACE(_T("CPPToolTip::SetNotify\n"));¤	¤	m_hNotifyWnd = hWnd;¤} //End of SetNotify¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetSize()¤//    Sets the specified size¤//---------------------------------------------------------------------------¤//  Parameters :¤//		nSizeIndex		- index of the size. This parameter can be one ¤//						  of the following values:¤//							PPTTSZ_ROUNDED_CX - The width of the ellipse used ¤//												to draw the rounded corners, in logical units.¤//							PPTTSZ_ROUNDED_CY - The height of the ellipse used ¤//												to draw the rounded corners, in logical units.¤//							PPTTSZ_MARGIN_CX  - The left and right margins of the tooltip's ¤//												text from the tooltip's edges. ¤//							PPTTSZ_MARGIN_CY  - The top and bottom margins of the tooltip's ¤//												text from the tooltip's edges.¤//							PPTTSZ_WIDTH_ANCHOR - The width of the tooltip's anchor¤//							PPTTSZ_HEIGHT_ANCHOR - The height of the tooltip's anchor ¤//							PPTTSZ_MARGIN_ANCHOR - The margin of the tooltip's anchor from ¤//												   his edge.¤//							PPTTSZ_OFFSET_ANCHOR_CX - The horizontal offset of the tooltip's anchor¤//													  from the hot spot of a cursor¤//							PPTTSZ_OFFSET_ANCHOR_CY - The vertical offset of the tooltip's anchor¤//													  from the hot spot of a cursor¤//		nValue			- size's value¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetSize(int nSizeIndex, int nValue)¤{¤	TRACE(_T("CPPToolTip::SetSize(nSizeIndex = %d, nValue = %d)\n"), nSizeIndex, nValue);¤	if (nSizeIndex >= PPTTSZ_MAX_SIZES)¤		return;¤¤	m_nSizes [nSizeIndex] = nValue;¤} //End of SetSize¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPTootTip::GetSize()¤//    Gets the specified size¤//---------------------------------------------------------------------------¤//  Parameters :¤//		nSizeIndex		- An index of the sizes. See CPPToolTip::SetSize for a ¤//						  description of the valid values.¤//  Returns :¤//		size's value¤//¤/////////////////////////////////////////////////////////////////////////////¤int CPPToolTip::GetSize(int nSizeIndex)¤{¤	TRACE(_T("CPPToolTip::GetSize(nSizeIndex = %d)\n"), nSizeIndex);¤	if (nSizeIndex >= PPTTSZ_MAX_SIZES)¤		return 0;¤¤	return m_nSizes [nSizeIndex];¤} //End of GetSize¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetDefaultSizes()¤//    Sets all sizes to default values¤//---------------------------------------------------------------------------¤//  Parameters:¤//		bBalloonSize	- If TRUE all sizes will be sets for balloon tooltip¤//						  otherwise tooltip will look as standard ¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetDefaultSizes(BOOL bBalloonSize /* = TRUE */)¤{¤	TRACE(_T("CPPToolTip::SetDefaultSizes()\n"));¤¤	if (bBalloonSize)¤	{¤		SetSize(PPTTSZ_ROUNDED_CX, 16);¤		SetSize(PPTTSZ_ROUNDED_CY, 16);¤		SetSize(PPTTSZ_MARGIN_CX, 12);¤		SetSize(PPTTSZ_MARGIN_CY, 12);¤		SetSize(PPTTSZ_WIDTH_ANCHOR, 12);¤		SetSize(PPTTSZ_HEIGHT_ANCHOR, 16);¤		SetSize(PPTTSZ_MARGIN_ANCHOR, 16);¤		SetSize(PPTTSZ_OFFSET_ANCHOR_CX, 0);¤		SetSize(PPTTSZ_OFFSET_ANCHOR_CY, 0);¤	}¤	else¤	{¤		SetSize(PPTTSZ_ROUNDED_CX, 0);¤		SetSize(PPTTSZ_ROUNDED_CY, 0);¤		SetSize(PPTTSZ_MARGIN_CX, 3);¤		SetSize(PPTTSZ_MARGIN_CY, 1);¤		SetSize(PPTTSZ_WIDTH_ANCHOR, 0);¤		SetSize(PPTTSZ_HEIGHT_ANCHOR, 0);¤		SetSize(PPTTSZ_MARGIN_ANCHOR, 0);¤		SetSize(PPTTSZ_OFFSET_ANCHOR_CX, 0);¤		SetSize(PPTTSZ_OFFSET_ANCHOR_CY, 0);¤	} //if¤} //End of SetDefaultSizes¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetColorBk()¤//   Sets background's colors ¤//---------------------------------------------------------------------------¤//  Parameters:¤//		color			- A solid color for background's effect ¤//		clrBegin		- A begin color for background's effect¤//		clrMid			- A middle color for background's effect¤//		clrEnd			- A end color for background's effect¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetColorBk(COLORREF color)¤{¤	SetColorBk(color, color, color);¤} //End of SetColorBk¤¤void CPPToolTip::SetColorBk(COLORREF clrBegin, COLORREF clrEnd)¤{¤	SetColorBk(clrBegin, clrBegin, clrEnd);¤} //End of SetColorBk¤¤void CPPToolTip::SetColorBk(COLORREF clrBegin, COLORREF clrMid, COLORREF clrEnd)¤{¤	m_clrBeginBk = clrBegin;¤	m_clrMidBk = clrMid;¤	m_clrEndBk = clrEnd;¤} //End of SetColorBk¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetEffectBk()¤//   Sets a background's effect ¤//---------------------------------------------------------------------------¤//  Parameters:¤//		dwEffect		- A background's effect ¤//		nGranularity	- Adds an uniform noise to the effect. ¤//						  A good value is from 5 to 20; 0 to disable the effect. ¤//						  The noise has a positive effect because it hides the palette steps.¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetEffectBk(DWORD dwEffect, BYTE nGranularity /* = 5 */)¤{¤	m_dwEffectBk = dwEffect;¤	m_nGranularity = nGranularity;¤} //End of SetEffectBk¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetBehaviour()¤//   Sets a tooltip's behaviour ¤//---------------------------------------------------------------------------¤//  Parameters:¤//		dwBehaviour		- A tooltip's behaviour. 0 for normal tooltip without ¤//						  specific behaviours. This parameter can be any combination ¤//						  of CPPToolTip behaviours:¤//							PPTOOLTIP_MULTIPLE_SHOW		- Multiple show for single control¤//							PPTOOLTIP_TRACKING_MOUSE	- Tracking for mouse¤//							PPTOOLTIP_CLOSE_LEAVEWND	- Close tooltip if mouse leave the control¤//							PPTOOLTIP_NOCLOSE_OVER		- No close tooltip if mouse over him¤//							PPTOOLTIP_DISABLE_AUTOPOP	- Disables autopop tooltip from timer¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetBehaviour(DWORD dwBehaviour /* = 0 */)¤{¤	m_dwBehaviour = dwBehaviour;¤} //End of SetBehaviour¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPToolTip::GetBehaviour()¤//   Gets a tooltip's behaviour ¤//---------------------------------------------------------------------------¤// Return value:¤//		A tooltip's behaviour. See CPPToolTip::SetBehaviour for a description of the ¤//	valid values.¤/////////////////////////////////////////////////////////////////////////////¤DWORD CPPToolTip::GetBehaviour()¤{¤	return m_dwBehaviour;¤} //End of GetBehaviour¤¤/////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetDelayTime()¤//   Call this function to set the delay time for a tooltip control. ¤// The delay time is the length of time the cursor must remain on a tool ¤// before the tooltip window appears. The default delay time is 500 milliseconds.¤//-------------------------------------------------------------------¤// Parameters:¤//		dwDuration		- Flag that specifies which duration value will be retrieved. ¤//						  This parameter can be one of the following values:¤//							PPTOOLTIP_TIME_AUTOPOP  - Retrieve the length of time the tooltip ¤//													  window remains visible if the pointer is ¤//													  stationary within a tool's bounding rectangle. ¤//							PPTOOLTIP_TIME_INITIAL  - Retrieve the length of time the pointer ¤//			 										  must remain stationary within a tool's bounding ¤//													  rectangle before the tool tip window appears. ¤//							PPTOOLTIP_TIME_FADEIN	- Retrieve the length of time for each step of¤//													  fade-in effect¤//							PPTOOLTIP_TIME_FADEOUT	- Retrieve the length of time for each step of¤//													  fade-out effect¤//							PPTOOLTIP_TIME_ANIMATION  Retrieve the speed for the animation¤//						  For compatibility with 1.x versions of CPPToolTip a following values¤//						  are available also:¤//							TTDT_AUTOPOP			- Same PPTOOLTIP_TIME_AUTOPOP ¤//							TTDT_INITIAL			- Same PPTOOLTIP_TIME_INITIAL ¤//		nTime			- The specified delay time, in milliseconds.¤/////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetDelayTime(DWORD dwDuration, DWORD dwTime)¤{¤	switch (dwDuration)¤	{¤	case PPTOOLTIP_TIME_AUTOPOP:¤		m_dwTimeAutoPop = dwTime;¤		break;¤	case PPTOOLTIP_TIME_INITIAL:¤		m_dwTimeInitial = dwTime;¤		break;¤	case PPTOOLTIP_TIME_FADEIN:¤		m_dwTimeFadeIn = dwTime;¤		break;¤	case PPTOOLTIP_TIME_FADEOUT:¤		m_dwTimeFadeOut = dwTime;¤		break;¤	case PPTOOLTIP_TIME_ANIMATION:¤		KillTimer(TIMER_ANIMATION);¤		if (dwTime)¤			SetTimer(TIMER_ANIMATION, dwTime, NULL);¤		break;¤	}¤} //End of SetDelayTime¤¤/////////////////////////////////////////////////////////////////////¤// CPPToolTip::GetDelayTime()¤// Retrieves the initial, pop-up, and reshow durations currently set ¤// for a CPPToolTip control¤//-------------------------------------------------------------------¤// Parameters:¤//		dwDuration		- Flag that specifies which duration value will be retrieved. ¤//						  See CPPToolTip::SetDelayTime for a description of the valid values. ¤// Return value:¤//	The specified delay time, in milliseconds¤///////////////////////////////////////////////////////////////////////¤DWORD CPPToolTip::GetDelayTime(DWORD dwDuration) const¤{¤	DWORD dwTime = 0;¤	switch (dwDuration)¤	{¤	case PPTOOLTIP_TIME_AUTOPOP:¤		dwTime = m_dwTimeAutoPop;¤		break;¤	case PPTOOLTIP_TIME_INITIAL:¤		dwTime = m_dwTimeInitial;¤		break;¤	case PPTOOLTIP_TIME_FADEIN:¤		dwTime = m_dwTimeFadeIn;¤		break;¤	case PPTOOLTIP_TIME_FADEOUT:¤		dwTime = m_dwTimeFadeOut;¤		break;¤	}¤¤	return dwTime;¤} //End of GetDelayTime¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetDirection()¤//    Sets a placement of the tooltip's anchor¤//---------------------------------------------------------------------------¤//  Parameters :¤//		dwDirection		- A placement of the tooltip's anchor. This parameter ¤//					      can be one of the following values:¤//							PPTOOLTIP_TOPEDGE_LEFT			- A left corner of the top edge¤//							PPTOOLTIP_TOPEDGE_RIGHT			- A right corner of the top edge¤//							PPTOOLTIP_TOPEDGE_CENTER		- By center of the top edge¤//							PPTOOLTIP_BOTTOMEDGE_LEFT		- A left corner of the bottom edge¤//							PPTOOLTIP_BOTTOMEDGE_RIGHT		- A right corner of the bottom edge¤//							PPTOOLTIP_BOTTOMEDGE_CENTER		- By center of the bottom edge¤//							PPTOOLTIP_LEFTEDGE_TOP			- A top corner of the left edge¤//							PPTOOLTIP_LEFTEDGE_BOTTOM		- A bottom corner of the left edge¤//							PPTOOLTIP_LEFTEDGE_VCENTER		- By center of the left edge¤//							PPTOOLTIP_RIGHTEDGE_TOP			- A top corner of the right edge¤//							PPTOOLTIP_RIGHTEDGE_BOTTOM		- A bottom corner of the right edge¤//							PPTOOLTIP_RIGHTEDGE_VCENTER		- By center of the right edge¤//						  For compatibility with 1.x versions of CPPToolTip a following values¤//						  are available also:¤//							PPTOOLTIP_LEFT_TOP				- Same PPTOOLTIP_TOPEDGE_LEFT¤//							PPTOOLTIP_RIGHT_TOP				- Same PPTOOLTIP_TOPEDGE_RIGHT¤//							PPTOOLTIP_LEFT_BOTTOM			- Same PPTOOLTIP_BOTTOMEDGE_LEFT¤//							PPTOOLTIP_RIGHT_BOTTOM			- Same PPTOOLTIP_BOTTOMEDGE_RIGHT¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetDirection(DWORD dwDirection /* = PPTOOLTIP_BOTTOMEDGE_LEFT */)¤{¤	TRACE(_T("CPPToolTip::SetDirection(nDirection = %d)\n"), dwDirection);¤¤	m_dwDirection = dwDirection;¤} //End of SetDirection	¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::GetDirection()¤//    Gets a placement of the tooltip's anchor¤//---------------------------------------------------------------------------¤//  Returns :¤//	  A placement of the tooltip's anchor. See CPPToolTip::SetDirection for a description of ¤//	the valid values.¤/////////////////////////////////////////////////////////////////////////////¤DWORD CPPToolTip::GetDirection()¤{¤	TRACE(_T("CPPToolTip::GetDirection()\n"));¤¤	return m_dwDirection;¤} //End of GetDirection¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetTextStyles()¤//    Applies a CSS-like style for the tooltip's HTML¤//---------------------------------------------------------------------------¤//  Parameters:¤//		lpszStyleName	- Pointer to a null-terminated string that specifies¤//						  a name of CSS style¤//		lpszStyleValue  - Pointer to a null-terminated string that specifies ¤//						  CSS-lite style for drawing a tooltip text.¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue)¤{¤	m_drawer.SetTextStyle(lpszStyleName, lpszStyleValue);¤}¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetCssStyles()¤//    Applies a CSS-like styles for the tooltip's HTML¤//---------------------------------------------------------------------------¤//  Parameters:¤//		lpszCssStyles	- Pointer to a null-terminated string that specifies ¤//						  CSS-lite styles for drawing a tooltip text.¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetCssStyles(LPCTSTR lpszCssStyles /* = NULL */)¤{¤	m_drawer.SetCssStyles(lpszCssStyles);¤} //End of SetCssStyles¤¤///////////////////////////////////////////////////////////////////////////// ¤//  CPPToolTip::SetCssStyles() ¤//    Applies a CSS-like styles for the tooltip's HTML ¤//--------------------------------------------------------------------------- ¤//  Parameters: ¤//      dwIdCssStyle    - ID of string resource ¤//      lpszPathDll		- ¤///////////////////////////////////////////////////////////////////////////// ¤void CPPToolTip::SetCssStyles(DWORD dwIdCssStyle, LPCTSTR lpszPathDll /* = NULL */) ¤{ ¤    m_drawer.SetCssStyles(dwIdCssStyle, lpszPathDll); ¤} //End of SetCssStyles¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::GetCssStyles()¤//    Applies a CSS-like styles for the tooltip's HTML¤//---------------------------------------------------------------------------¤//  Return value:¤//		Pointer to a null-terminated string that specifies CSS-lite styles ¤//  for drawing a tooltip text.¤/////////////////////////////////////////////////////////////////////////////¤LPCTSTR CPPToolTip::GetCssStyles()¤{¤	return m_drawer.GetCssStyles();¤} //End of GetCssStyles¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetDebugMode()¤//    Sets a debug mode. In this mode tooltip will display for any control¤// and will contain debug info about control.¤//---------------------------------------------------------------------------¤//  Parameters:¤//		bDebug			- TRUE set a debug mode.¤/////////////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetDebugMode(BOOL bDebug /* = TRUE */)¤{¤	m_bDebugMode = bDebug;¤} //End of SetDebugMode¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::ShowHelpTooltip()¤// Shows the help tooltip in any place of screen.¤//------------------------------------------------------------------¤// Parameters:¤//		pt				- Pointer to a POINT structure that receives the screen coordinates of the tooltip's anchor  ¤//		lpszString		- Pointer to the text for the help tooltip. ¤//      dwIdString		- ID of string resource¤//		hIcon			- Handle of the icon¤//		dwIdIcon		- ID of icon resource¤//		szIcon			- Specifies the width and the height, in pixels, of the icon to load.¤//		ti				- Reference to PPTOOLTIP_INFO structure containing the parameters of the tooltip ¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::ShowHelpTooltip(LPPOINT pt, DWORD dwIdText, HICON hIcon /* = NULL */)¤{¤	CString str;¤	str.LoadString(dwIdText);¤	ShowHelpTooltip(pt, (LPCTSTR)str, hIcon);¤} //End ShowHelpTooltip¤¤void CPPToolTip::ShowHelpTooltip(LPPOINT pt, DWORD dwIdText, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */)¤{¤	CString str;¤	str.LoadString(dwIdText);¤	ShowHelpTooltip(pt, (LPCTSTR)str, dwIdIcon, szIcon);¤} //End ShowHelpTooltip¤¤void CPPToolTip::ShowHelpTooltip(LPPOINT pt, LPCTSTR lpszString, HICON hIcon /* = NULL */)¤{¤	PPTOOLTIP_INFO ti;¤	if (NULL == hIcon)¤	{¤		ti.sTooltip = (CString)lpszString;¤	}¤	else¤	{¤		ti.sTooltip.Format(_T("<table><tr><td><icon handle=0x%X></td><td>%s</td></tr></table>"), ¤							hIcon, lpszString);¤	} //if¤	¤	ti.nMask = 0;¤	ShowHelpTooltip(pt, ti);¤} //End ShowHelpTooltip¤¤void CPPToolTip::ShowHelpTooltip(LPPOINT pt, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon /* = CSize(0, 0) */)¤{¤	CString str;¤	str.Format(_T("<table><tr><td><icon idres=%d width=%d height=%d></td><td>%s</td></tr></table>"), ¤		dwIdIcon, szIcon.cx, szIcon.cy, lpszString);¤	ShowHelpTooltip(pt, (LPCTSTR)str);¤} //End ShowHelpTooltip¤¤void CPPToolTip::ShowHelpTooltip(LPPOINT pt, PPTOOLTIP_INFO & ti)¤{¤	TRACE(_T("CPPToolTip::ShowHelpTooltip\n"));¤¤	m_ptOriginal = CPoint(pt->x, pt->y);¤	ti.nBehaviour = m_dwBehaviour | PPTOOLTIP_DISABLE_AUTOPOP;¤	ti.nMask = PPTOOLTIP_MASK_BEHAVIOUR;¤	SetNewTooltip(NULL, 0, ti, FALSE, PPTOOLTIP_HELP);¤} //End ShowHelpTooltip¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetBorder()¤// Sets a border of the tooltip.¤//------------------------------------------------------------------¤// Parameters:¤//		color			- Color of the tooltip's border¤//		hbr				- Brush for drawing tooltip's border¤//      nWidth			- A width of the brush¤//		nHeight			- A height of the brush¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetBorder(COLORREF color, int nWidth /* = 1 */, int nHeight /* = 1 */)¤{¤	HBRUSH hbr = ::CreateSolidBrush(color);¤	SetBorder(hbr, nWidth, nHeight);¤} //End of SetBorder¤¤void CPPToolTip::SetBorder(HBRUSH hbr, int nWidth /* = 1 */, int nHeight /* = 1 */)¤{¤	HideBorder();¤	if (nWidth && nHeight && (NULL != hbr))¤	{¤		m_hbrBorder = hbr;¤		m_szBorder.cx = nWidth;¤		m_szBorder.cy = nHeight;¤	} //if¤} //End of SetBorder¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::HideBorder()¤// Hides border of the tooltip.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::HideBorder()¤{¤	if (NULL != m_hbrBorder)¤	{¤		::DeleteObject(m_hbrBorder);¤		m_hbrBorder = NULL;¤	} //if¤	m_szBorder.cx = 0;¤	m_szBorder.cy = 0;¤} //End of HideBorder¤¤////////////////////////////////////////////////////////////////////////////////¤// Begin of the menu methods block. Build-in support for menu¤#ifdef PPTOOLTIP_USE_MENU¤//////////////////¤// Need to handle WM_ENTERIDLE to cancel the tip if the user ¤// moved the mouse off the popup menu. For main menus, Windows ¤// will send a WM_MENUSELECT message for the parent menu when ¤// this happens, but for context menus there's no other way to ¤// know the user moved the mouse off the menu.¤//¤void CPPToolTip::OnEnterIdle(UINT nWhy, CWnd* pWho)¤{¤	if ((MSGF_MENU == nWhy))¤	{¤		if (m_nTooltipType == PPTOOLTIP_MENU)¤		{¤			if (PPTOOLTIP_STATE_SHOWN == m_nTooltipState)¤			{¤				CPoint pt;¤				GetCursorPos(&pt);¤				if (pWho->GetSafeHwnd() != ::WindowFromPoint(pt)) ¤				{¤					HideTooltip();¤				} //if¤			} //if¤		} //if¤	} //if¤} //End of OnEnterIdle¤¤void CPPToolTip::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSubMenu)¤{¤	if (((nFlags & 0xFFFF) == 0xFFFF) || (nFlags & MF_POPUP) || (nFlags & MF_SEPARATOR))¤	{¤		//HideTooltip();¤		Pop();¤	} ¤	else if (nItemID && hSubMenu) ¤	{¤		HWND hwndMenu = GetRunningMenuWnd(); //CWnd::WindowFromPoint(pt);¤		if (NULL != hwndMenu)¤		{¤			CRect rcMenu;¤			::GetWindowRect(hwndMenu, rcMenu); // whole menu rect¤			¤			// find Item Rectangle and position¤			int count = ::GetMenuItemCount(hSubMenu);¤			int cy = rcMenu.top + GetSystemMetrics(SM_CYEDGE) + 1;¤			for(int nItem = 0; nItem < count; nItem++) ¤			{¤				CRect rect;¤				::GetMenuItemRect(m_hParentWnd, hSubMenu, nItem, &rect);¤				if(nItemID == ::GetMenuItemID(hSubMenu, nItem)) ¤				{¤					UINT nState = GetMenuState(hSubMenu, nItemID, MF_BYCOMMAND);¤					CString str;¤					if (MF_DISABLED & nState)¤						str = m_drawer.GetResCommandPrompt(nItemID, 2); //String for disabled item¤					else¤						str = m_drawer.GetResCommandPrompt(nItemID, 0);¤¤					CPoint pt;¤					// found menu item: adjust rectangle to right and down¤					pt.x = rcMenu.left;¤					pt.y = cy;¤					if (m_dwMenuToolPos & PPTOOLTIP_MENU_CENTER)¤						pt.x += rect.Width() / 2;¤					else if (m_dwMenuToolPos & PPTOOLTIP_MENU_RIGHT)¤						pt.x += rect.Width();¤					¤					if (m_dwMenuToolPos & PPTOOLTIP_MENU_VCENTER)¤						pt.y += rect.Height() / 2;¤					else if (m_dwMenuToolPos & PPTOOLTIP_MENU_BOTTOM)¤						pt.y += rect.Height();¤¤					PPTOOLTIP_INFO ti;¤					ti.rectBounds = rect;¤					ti.nMask = 0;¤					ti.sTooltip = str;¤					m_nNextTooltipType = PPTOOLTIP_MENU;¤					m_ptOriginal = pt;¤					SetNewTooltip(hwndMenu, 0, ti, TRUE, PPTOOLTIP_MENU);¤¤					return;¤				} //if¤				cy += rect.Height(); // add height¤			} //for¤		} //if¤		//ENG: Menu item was not found¤		//RUS: Элемент меню не найден.¤		Pop();¤	} //if¤} //End of OnMenuSelect¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::GetRunningMenuWnd()¤// Get running menu window.¤////////////////////////////////////////////////////////////////////¤HWND CPPToolTip::GetRunningMenuWnd()¤{¤	HWND hwnd = NULL;¤	EnumWindows(MyEnumProc,(LPARAM)&hwnd);¤	return hwnd;¤} //End of GetRunningMenuWnd¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::MenuToolPosition()¤// Sets a position of the tooltip's anchor about menu item.¤//------------------------------------------------------------------¤// Parameters:¤//		nPos			- A tooltip's position. This parameter can be any combination ¤//						  of single horizontal value and single vertical value of CPPToolTip:¤//							--- Horizontal position ---¤//							PPTOOLTIP_MENU_LEFT		0x00¤//							PPTOOLTIP_MENU_RIGHT	0x01¤//							PPTOOLTIP_MENU_CENTER	0x02¤//							--- Vertical position ---¤//							PPTOOLTIP_MENU_TOP		0x00¤//							PPTOOLTIP_MENU_BOTTOM	0x10¤//							PPTOOLTIP_MENU_VCENTER  0x20¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::MenuToolPosition(DWORD nPos /* = PPTOOLTIP_MENU_LEFT | PPTOOLTIP_MENU_TOP */)¤{¤	m_dwMenuToolPos = nPos;¤} //End of MenuToolPosition¤¤// End of menu methods block¤///////////////////////////////////////////////////////////¤#endif //PPTOOLTIP_USE_MENU¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::EnableEscapeSequences()¤//		Enables the escape sequences. If the escape sequences was disabled¤//	HTML-lite compiler will ignore the codes less then 0x20 (such \n, \r, \t).¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::EnableEscapeSequences(BOOL bEnable)¤{¤	m_drawer.EnableEscapeSequences(bEnable);¤} //End of EnableEscapeSequences¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetImageList()¤//		Sets an image list for using it into the HTML string with <ilst> tag.¤//------------------------------------------------------------------¤// Parameters:¤//		nIdBitmap		- Resource IDs of the bitmap to be associated with the image list.¤//		hBitmap			- Handle of the bitmap to be associated with the image list.¤//      cx				- Dimensions of each image, in pixels.¤//		cy				- Dimensions of each image, in pixels.¤//		nCount			- The number of images in the image list¤//		crMask			- Color used to generate a mask. Each pixel of this color in ¤//						  the specified bitmap is changed to transparent, and the ¤//						  corresponding bit in the mask is set to one.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)¤{¤	m_drawer.SetImageList(nIdBitmap, cx, cy, nCount, crMask);¤} //End of SetImageList¤¤void CPPToolTip::SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)¤{¤	m_drawer.SetImageList(hBitmap, cx, cy, nCount, crMask);¤} //End of SetImageList¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetTransparency()¤//		Sets a transparency of the tooltip.¤//------------------------------------------------------------------¤// Parameters:¤//		nTransparency	- A transparency value to be used on the tooltip. ¤//						  The default 0 assumes that your tooltip is opaque and 0xFF (255) ¤//						  for full transparency of the tooltip.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetTransparency(BYTE nTransparency /* = 0 */) ¤{¤	if (nTransparency <= PERCENT_MAX_TRANSPARENCY)¤		m_nTransparency = nTransparency;¤} //End of SetTransparency¤¤////////////////////////////////////////////////////////////////////¤// CPPToolTip::SetTooltipShadow()¤//		Sets a tooltip's shadow.¤//------------------------------------------------------------------¤// Parameters:¤//		nOffsetX, ¤//		nOffsetY		- The offsets of the tooltip's shadow from the tooltip's window.¤//		nDarkenPercent	- So far as colors under the shadow will be darken (0 - 100)¤//      bGradient		- TRUE to use a gradient shadow.¤//		nDepthX,¤//		nDepthY			- The gradient depths of the tooltip's shadow.¤////////////////////////////////////////////////////////////////////¤void CPPToolTip::SetTooltipShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent /* = 50 */, ¤								  BOOL bGradient /* = TRUE */, int nDepthX /* = 7 */, int nDepthY /* = 7 */)¤{¤	m_szOffsetShadow.cx = nOffsetX;¤	m_szOffsetShadow.cy = nOffsetY;¤	m_szDepthShadow.cx = nDepthX;¤	m_szDepthShadow.cy = nDepthY;¤	m_nDarkenShadow = std::min(100, (int)nDarkenPercent);¤	m_bGradientShadow = bGradient;¤} //End of SetTooltipShadow¤¤void CPPToolTip::SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent /* = 50 */, ¤					BOOL bGradient /* = TRUE */, int nDepthX /* = 7 */, int nDepthY /* = 7 */)¤{¤	m_drawer.SetImageShadow(nOffsetX, nOffsetY, nDarkenPercent, bGradient, nDepthX, nDepthY);¤} //End of SetImageShadow¤¤//#UC END# *4700B6AC00CB*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B6AC00CB_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB_DESTR_BODY*¤	FreeResources();¤	RemoveAllTools();¤	HideBorder();¤	//#UC END# *4700B6AC00CB_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B6AC00CB_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB_CUSTOM_INCLUDES*¤#include "shared/WinGUI/Controls/CPPHtmlDrawer.h"¤#include <vector>¤#include <map>¤#include <afxext.h>¤#include "boost/function.hpp"¤//ENG: Comments a next line if you never use a tooltip for a menu¤//RUS: Закоментируйте следующую строку, если вы не планируете использовать тултип для элементов меню¤#define PPTOOLTIP_USE_MENU¤¤#define PPTOOLTIP_CLASSNAME    _T("CPPToolTip")  // Window class name¤¤//The ¤#define UDM_TOOLTIP_FIRST		   (WM_USER + 100)¤#define UDM_TOOLTIP_DISPLAY		   (UDM_TOOLTIP_FIRST) //User was changed the data¤#define UDM_TOOLTIP_REPAINT		   (UDM_TOOLTIP_FIRST + 1)¤#define UDM_TOOLTIP_HIDING		   (UDM_TOOLTIP_FIRST + 2)¤¤//The behaviours¤#define PPTOOLTIP_MULTIPLE_SHOW			0x00000001 //Multiple show for single control¤#define PPTOOLTIP_TRACKING_MOUSE		0x00000002 //Tracking for mouse¤#define PPTOOLTIP_CLOSE_LEAVEWND		0x00000004 //Close tooltip if mouse leave the control¤#define PPTOOLTIP_NOCLOSE_OVER			0x00000008 //No close tooltip if mouse over him¤#define PPTOOLTIP_DISABLE_AUTOPOP		0x00000010 //Disables autopop tooltip from timer¤//#define PPTOOLTIP_NOCLOSE_MOUSEDOWN		0x00000020 //Disables autopop tooltip from timer¤¤//The masks¤#define PPTOOLTIP_MASK_STYLES			0x0001	// The styles for the tooltip gets from the structures¤#define PPTOOLTIP_MASK_EFFECT			0x0002	// The background's type for the tooltip gets from the structures¤#define PPTOOLTIP_MASK_COLORS			0x0004	// The background's colors for the tooltip gets from the structures¤#define PPTOOLTIP_MASK_DIRECTION		0x0008  // The align for the tooltip gets from the structures¤#define PPTOOLTIP_MASK_BEHAVIOUR		0x0010  // The behaviour for the tooltip gets from the structures¤#define PPTOOLTIP_MASK_TRANSPARENCY		0x0020  // ¤¤//The constants of the timers¤#define PPTOOLTIP_TIME_INITIAL			TTDT_INITIAL¤#define PPTOOLTIP_TIME_AUTOPOP			TTDT_AUTOPOP¤#define PPTOOLTIP_TIME_FADEIN			4¤#define PPTOOLTIP_TIME_FADEOUT			5¤#define PPTOOLTIP_TIME_ANIMATION		6¤¤//Tooltip's directions¤#define PPTOOLTIP_TOPEDGE_LEFT			0x00¤#define PPTOOLTIP_TOPEDGE_RIGHT			0x01¤#define PPTOOLTIP_TOPEDGE_CENTER		0x02¤#define PPTOOLTIP_BOTTOMEDGE_LEFT		0x10¤#define PPTOOLTIP_BOTTOMEDGE_RIGHT		0x11¤#define PPTOOLTIP_BOTTOMEDGE_CENTER		0x12¤#define PPTOOLTIP_LEFTEDGE_TOP			0x20¤#define PPTOOLTIP_LEFTEDGE_BOTTOM		0x21¤#define PPTOOLTIP_LEFTEDGE_VCENTER		0x22¤#define PPTOOLTIP_RIGHTEDGE_TOP			0x30¤#define PPTOOLTIP_RIGHTEDGE_BOTTOM		0x31¤#define PPTOOLTIP_RIGHTEDGE_VCENTER		0x32¤//----- Old version (1.x) ---------¤#define PPTOOLTIP_LEFT_TOP				PPTOOLTIP_TOPEDGE_LEFT¤#define PPTOOLTIP_RIGHT_TOP				PPTOOLTIP_TOPEDGE_RIGHT¤#define PPTOOLTIP_LEFT_BOTTOM			PPTOOLTIP_BOTTOMEDGE_LEFT¤#define PPTOOLTIP_RIGHT_BOTTOM			PPTOOLTIP_BOTTOMEDGE_RIGHT¤¤#ifdef PPTOOLTIP_USE_MENU¤//ENG: Anchor's position about a menu item¤//RUS: Выравнивание кончика тултипа относительно элемента меню¤#define PPTOOLTIP_MENU_LEFT		0x00¤#define PPTOOLTIP_MENU_RIGHT	0x01¤#define PPTOOLTIP_MENU_CENTER	0x02¤#define PPTOOLTIP_MENU_TOP		0x00¤#define PPTOOLTIP_MENU_BOTTOM	0x10¤#define PPTOOLTIP_MENU_VCENTER  0x20¤¤#define PPTOOLTIP_MENU_HMASK	0x0F¤#define PPTOOLTIP_MENU_VMASK	0xF0¤#endif //PPTOOLTIP_USE_MENU¤¤// This info structure¤typedef struct tagPPTOOLTIP_INFO¤{¤    UINT		nIDTool;		// ID of tool   ¤    CRect		rectBounds;		// Bounding rect for toolinfo to be displayed¤	CString		sTooltip;		// The string of the tooltip¤	UINT        nMask;			// The mask ¤	UINT		nStyles;		// The tooltip's styles¤	UINT        nDirection;		// Direction display the tooltip relate cursor point¤	UINT		nEffect;		// The color's type or effects¤	UINT        nBehaviour;		// The tooltip's behaviour¤	BYTE        nGranularity;	// The effect's granularity¤	BYTE        nTransparency;	// The factor of the window's transparency (0-100)¤	COLORREF	crBegin;		// Begin Color¤	COLORREF    crMid;			// Mid Color¤	COLORREF	crEnd;			// End Color¤} PPTOOLTIP_INFO;¤¤// This structure sent to PPTooltip parent in a WM_NOTIFY message¤typedef struct tagNM_PPTOOLTIP_DISPLAY {¤    NMHDR hdr;¤	HWND hwndTool;¤	LPPOINT pt;¤	PPTOOLTIP_INFO * ti;¤} NM_PPTOOLTIP_DISPLAY;¤//#UC END# *4700B6AC00CB_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B6AC00CB*"
		    value      	(value Text 
|//#UC START# *4700B6AC00CB*¤public:¤	BOOL Create(CWnd* pParentWnd, BOOL bBalloon = TRUE);¤¤	CPPToolTip();¤¤// Attributes¤public:¤	enum {	PPTTSZ_ROUNDED_CX = 0,¤			PPTTSZ_ROUNDED_CY,¤			PPTTSZ_MARGIN_CX,¤			PPTTSZ_MARGIN_CY,¤			PPTTSZ_WIDTH_ANCHOR,¤			PPTTSZ_HEIGHT_ANCHOR,¤			PPTTSZ_MARGIN_ANCHOR,¤			PPTTSZ_OFFSET_ANCHOR_CX,¤			PPTTSZ_OFFSET_ANCHOR_CY,¤¤			PPTTSZ_MAX_SIZES¤		};¤¤	enum {	SHOWEFFECT_NONE = 0,¤			SHOWEFFECT_FADEINOUT,¤			¤			SHOWEFFECT_MAX¤		};¤	¤	typedef boost::function<bool (PPTOOLTIP_INFO & ti)> ExternalFindCallback;¤	typedef void* DynamicToolID;¤	// Operations¤protected:¤	enum TooltipState {  ¤			PPTOOLTIP_STATE_HIDEN = 0,¤			PPTOOLTIP_STATE_SHOWING,¤			PPTOOLTIP_STATE_SHOWN,¤			PPTOOLTIP_STATE_HIDING¤		};¤¤	enum TooltipType {¤			PPTOOLTIP_NORMAL = 0,¤			PPTOOLTIP_HELP,¤			PPTOOLTIP_MENU¤		};¤¤	CPPHtmlDrawer m_drawer; //HTML drawer object¤	¤	HWND m_hParentWnd; // The handle of the parent window¤	HWND m_hNotifyWnd; // The handle of the notified window¤¤	BOOL m_bHyperlinkEnabled;¤	BOOL m_bDebugMode;¤¤	POINT m_ptOriginal;¤¤	// Info about last displayed tool¤	HWND  m_hwndDisplayedTool;¤	DynamicToolID m_last_dynamic_tool;¤¤	TooltipType m_nTooltipType;¤	PPTOOLTIP_INFO m_tiDisplayed; //Info about displayed tooltip¤¤	// Info about last displayed tool¤	BOOL  m_bDelayNextTool;¤	BOOL  m_bNextToolExist;¤	HWND  m_hwndNextTool;¤	DynamicToolID  m_next_dynamic_tool;¤¤	TooltipType m_nNextTooltipType;¤	PPTOOLTIP_INFO m_tiNextTool; //Info about next tooltip¤	¤	// Info about current tool¤	CRect m_rcCurTool;¤	DWORD m_dwCurDirection;¤	BYTE  m_dwCurTransparency;¤	TooltipState  m_nTooltipState;¤¤	//Colors¤	COLORREF m_clrBeginBk;¤	COLORREF m_clrMidBk;¤	COLORREF m_clrEndBk;¤¤	//Background¤	HBITMAP m_hBitmapBk; //A bitmap with tooltip's background only¤	HBITMAP m_hUnderTooltipBk;¤¤	//Border of the tooltip¤	HBRUSH m_hbrBorder;¤	SIZE m_szBorder;¤¤	//Shadow of the tooltip¤	BOOL m_bGradientShadow;¤	SIZE m_szOffsetShadow;¤	SIZE m_szDepthShadow;¤	BYTE m_nDarkenShadow;¤¤	HRGN m_hrgnTooltip;¤¤	//Default values for the window¤	DWORD m_dwTimeAutoPop; //Retrieve the length of time the tool tip window remains visible if the pointer is stationary within a tool's bounding rectangle¤	DWORD m_dwTimeInitial; //Retrieve the length of time the pointer must remain stationary within a tool's bounding rectangle before the tool tip window appears¤	DWORD m_dwTimeFadeIn;¤	DWORD m_dwTimeFadeOut;¤¤	DWORD m_dwBehaviour;   //The tooltip's behaviour¤	DWORD m_dwEffectBk;¤	DWORD m_dwDirection;   //The default tooltip's direction¤	DWORD m_dwStyles;¤	BYTE  m_nGranularity;¤	BYTE  m_nTransparency; //The current value of transparency¤	DWORD m_dwShowEffect; //¤	DWORD m_dwHideEffect;¤	int  m_nSizes [PPTTSZ_MAX_SIZES]; //All sizes ¤¤#ifdef PPTOOLTIP_USE_MENU¤	DWORD m_dwMenuToolPos;¤#endif //PPTOOLTIP_USE_MENU¤¤	//¤	CRect m_rcTipArea; //The bound rect around the tip's area in the client coordinates.¤	CRect m_rcTooltip; //The bound rect around the body of the tooltip in the client coordinates.¤	CRect m_rcBoundsTooltip; //The bound rect around a tooltip include an anchor¤	CRect m_rcUnderTooltip;  //The bound rect of the window under the tooltip in the screen coordinates¤¤	//Initialize tools¤	typedef std::vector<PPTOOLTIP_INFO>	arHotArea; // array of Tips rectangular spots¤	typedef std::map<HWND, arHotArea>::iterator	mapIter;	// simplify reading¤	std::map<HWND, arHotArea>	m_ToolMap;¤¤	//Initialize list of toolbars¤	typedef std::vector<HWND>	arToolBarWnd;¤	arToolBarWnd m_wndToolBars;  // array of HWND of the toolbars¤¤	//Initializes external tools¤	typedef std::map<DynamicToolID, ExternalFindCallback> CallBackMap;¤	CallBackMap m_dynamic_tools; //dynamic tools - определяют возможность показа¤								  //тултипа на основе callback'а¤¤// Overrides¤	// ClassWizard generated virtual function overrides¤	//{{AFX_VIRTUAL(CPPToolTip)¤	public:¤	virtual BOOL PreTranslateMessage(MSG* pMsg);¤	virtual BOOL DestroyWindow();¤	//}}AFX_VIRTUAL¤¤// Implementation¤public:¤	BOOL RelayEvent(MSG* pMsg);¤¤	//Tools¤	void AddToolBar(CToolBar * pBar);¤	void AddTool(CWnd * pWnd, DWORD dwIdString, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	void AddTool(CWnd * pWnd, LPCTSTR lpszString = NULL, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	void AddTool(CWnd * pWnd, PPTOOLTIP_INFO & ti);¤	//To compatible with old version of CPPToolTip¤	void AddTool(CWnd * pWnd, DWORD dwIdString, HICON hIcon, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	void AddTool(CWnd * pWnd, DWORD dwIdString, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0), LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	void AddTool(CWnd * pWnd, LPCTSTR lpszString, HICON hIcon, LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	void AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0), LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	void AddTool(CWnd * pWnd, LPCTSTR lpszString, DWORD dwIdBitmap, COLORREF crMask, CSize & szBitmap = CSize(0, 0), LPCRECT lpRectBounds = NULL, DWORD dwIDTool = 0);¤	//add external tools¤	void AddDynamicTool(DynamicToolID tool, const ExternalFindCallback& callback);¤¤	void RemoveTool(CWnd * pWnd, LPCRECT lpRectBounds = NULL);¤	void RemoveDynamicTool(DynamicToolID tool);¤	void RemoveAllTools();¤¤	BOOL GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, LPCRECT lpRectBounds = NULL);¤	BOOL GetToolInfo(PPTOOLTIP_INFO & ti, CWnd * pWnd, DWORD dwIDTool = 0);¤	void UpdateTipText(LPCTSTR lpszText, CWnd * pWnd, DWORD dwIDTool = 0);¤	void DelTool(CWnd * pWnd, DWORD dwIDTool = 0);¤	void SetToolRect(CWnd * pWnd, DWORD dwIDTool, LPCRECT lpRectBounds);¤¤	//Help tooltip¤	void ShowHelpTooltip (LPPOINT pt, DWORD dwIdText, HICON hIcon = NULL);¤	void ShowHelpTooltip (LPPOINT pt, DWORD dwIdText, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0));¤	void ShowHelpTooltip (LPPOINT pt, LPCTSTR lpszString, HICON hIcon = NULL);¤	void ShowHelpTooltip (LPPOINT pt, LPCTSTR lpszString, DWORD dwIdIcon, CSize & szIcon = CSize(0, 0));¤	void ShowHelpTooltip (LPPOINT pt, PPTOOLTIP_INFO & ti);¤	void HideTooltip();¤¤	// color's functions¤	void SetColorBk(COLORREF color);¤	void SetColorBk(COLORREF clrBegin, COLORREF clrEnd);¤	void SetColorBk(COLORREF clrBegin, COLORREF clrMid, COLORREF clrEnd);¤	void SetEffectBk(DWORD dwEffect, BYTE nGranularity = 5);¤¤	//behaviour's methods¤	void SetBehaviour(DWORD dwBehaviour = 0);¤	DWORD GetBehaviour();¤¤	void SetDelayTime(DWORD dwDuration, DWORD dwTime);¤	DWORD GetDelayTime(DWORD dwDuration) const;¤¤	void SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));¤	void SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));¤¤	//functions for sizes¤	void SetSize(int nSizeIndex, int nValue);¤	int GetSize(int nSizeIndex);¤	void SetDefaultSizes(BOOL bBalloonSize = TRUE);¤¤	//functions for direction¤	void SetDirection (DWORD dwDirection = PPTOOLTIP_BOTTOMEDGE_LEFT);¤	DWORD GetDirection();¤¤	void SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam = 0);¤	¤	void EnableHyperlink(BOOL bEnable = TRUE);¤	void SetDebugMode(BOOL bDebug = TRUE);¤¤//	void EnableTextWrap(BOOL bEnable = TRUE){m_drawer.EnableTextWrap(bEnable);};¤	void SetMaxTipWidth(int nWidth = 0){m_drawer.SetMaxWidth(nWidth);};¤¤	//functions for¤	void  SetNotify(HWND hWnd);¤	void  SetNotify(BOOL bParentNotify = TRUE);¤¤	void SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue);¤	void SetCssStyles(LPCTSTR lpszCssStyles = NULL);¤	void SetCssStyles(DWORD dwIdCssStyle, LPCTSTR lpszPathDll = NULL); //Sets the CSS styles¤	LPCTSTR GetCssStyles();¤¤	void EnableEscapeSequences(BOOL bEnable);¤¤	void HideBorder();¤	void SetBorder(COLORREF color, int nWidth = 1, int nHeight = 1);¤	void SetBorder(HBRUSH hbr, int nWidth = 1, int nHeight = 1);¤¤	//Transparency of tooltip¤	void SetTransparency(BYTE nTransparency = 0);¤	inline BYTE GetTransparency() {return m_nTransparency;};¤¤	//Shadow of the tooltip¤	void SetTooltipShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent = 50, BOOL bGradient = TRUE, int nDepthX = 7, int nDepthY = 7);¤	void SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent = 50, BOOL bGradient = TRUE, int nDepthX = 7, int nDepthY = 7);¤¤#ifdef PPTOOLTIP_USE_MENU¤	//Methods for the menu¤	void MenuToolPosition(DWORD nPos = PPTOOLTIP_MENU_LEFT | PPTOOLTIP_MENU_TOP);¤	inline DWORD GetMenuToolPosition() {return m_dwMenuToolPos;};¤	void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSubMenu);¤    void OnEnterIdle(UINT nWhy, CWnd* pWho);¤	HWND GetRunningMenuWnd();¤#endif //PPTOOLTIP_USE_MENU¤¤	static short GetVersionI()		{return 0x22;}¤	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("2.2 beta");}¤¤private:¤	virtual void OnDrawBorder(HDC hDC, HRGN hRgn);¤¤	// Generated message map functions¤protected:¤	void Pop();¤	void KillTimers(DWORD dwIdTimer = NULL);¤	void SetNewTooltip(HWND hWnd, DynamicToolID toolID, const PPTOOLTIP_INFO & ti, BOOL bDisplayWithDelay = TRUE, TooltipType type = PPTOOLTIP_NORMAL);¤	HWND GetWndFromPoint(LPPOINT lpPoint, PPTOOLTIP_INFO & ti, BOOL bCheckTool = TRUE);¤	LRESULT SendNotify(LPPOINT pt, PPTOOLTIP_INFO & ti);¤¤	BOOL IsCursorOverTooltip() const;¤	inline BOOL IsVisible() const {return ((GetStyle() & WS_VISIBLE) == WS_VISIBLE);}¤	BOOL  IsNotify(); //Is enabled notification¤¤	void PrepareDisplayTooltip(LPPOINT lpPoint);¤	void OnRedrawTooltip(HDC hDC, BYTE nTransparency = 0);¤¤	void OutputTooltipOnScreen(LPPOINT lpPoint, HDC hDC = NULL);¤	void SetAutoPopTimer(); //Sets autopop timer¤¤	void FreeResources();¤	CString GetDebugInfoTool(LPPOINT lpPoint);¤¤	DWORD GetTooltipDirection(DWORD dwDirection, const CPoint & ptPoint, CPoint & ptAnchor, CRect & rcBody, CRect & rcFull, CRect & rcTipArea);¤	HRGN GetTooltipRgn(DWORD dwDirection, int x, int y, int nWidth, int nHeight);¤	¤	CString GetMaxDebugString(LPCTSTR lpszText);¤	CString CreateDebugCell(CString sTitle, LPCTSTR lpszDescription);¤	¤	BOOL FindTool(HWND hWnd, const LPPOINT lpPoint, PPTOOLTIP_INFO & ti);¤	HWND FindTool(const LPPOINT lpPoint, PPTOOLTIP_INFO & ti);¤	HWND FindToolBarItem(POINT point, PPTOOLTIP_INFO & ti);¤	BOOL IsComboBoxControl(HWND hWnd, UINT nStyle);¤¤	//{{AFX_MSG(CPPToolTip)¤	afx_msg void OnPaint();¤	afx_msg void OnTimer(UINT nIDEvent);¤	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);¤	//}}AFX_MSG¤#if _MSC_VER < 1300¤    afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);¤#else¤    afx_msg void OnActivateApp(BOOL bActive, DWORD hTask);¤#endif¤    afx_msg LRESULT OnRepaintWindow(WPARAM wParam, LPARAM lParam);¤	DECLARE_MESSAGE_MAP()¤//#UC END# *4700B6AC00CB*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPToolTip|4700B6AC00CB
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659776950"))
	    quid       	"4700B6AC00CB"
	    documentation 	"расширенный контрол тул-тип"
	    stereotype 	"SimpleClass"
	    superclasses 	(list inheritance_relationship_list
		(object Inheritance_Relationship
		    quid       	"4700C599006D"
		    supplier   	"Logical View::external::MFCTypes::Controls::CWnd"
		    quidu      	"4652B53F01F4"))
	    language   	"MDA Generator")
	(object Class "CPPHtmlDrawer"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CPPHtmlDrawer.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CPPHtmlDrawer.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B81F006D_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B81F006D_CUSTOM_INCLUDES*¤#include "atlconv.h"    // for Unicode conversion - requires #include <afxdisp.h> // MFC OLE automation classes¤#include <shellapi.h>¤#pragma comment(lib, "comctl32.lib")¤¤#define PPHTMLDRAWER_NO_HOVERLINK	-2	//A hot area is not exist under the cursor¤#define PPHTMLDRAWER_BREAK_CHARS	_T(" -.,!:;)}]?") //A set of the chars to break line in the text wrap mode¤¤//#UC END# *4700B81F006D_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B81F006D*"
		    value      	(value Text 
|//#UC START# *4700B81F006D*¤enum {¤	MODE_DRAW = 0,¤	MODE_FIRSTPASS,¤	MODE_SECONDPASS¤};¤¤/*¤#define m_szOffsetShadow.cx		4 //¤#define m_szOffsetShadow.cy		4 //¤#define m_szDepthShadow.cx		7 //¤#define m_szDepthShadow.cy		7 //¤#define PPHTMLDRAWER_SHADOW_COLOR		RGB (64, 64, 64) //A gradient shadow's color¤*/¤¤¤/////////////////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer¤¤CPPHtmlDrawer::CPPHtmlDrawer()¤{¤	m_nNumPass = MODE_FIRSTPASS;¤¤	m_hInstDll = NULL;¤	m_bFreeInstDll = FALSE;¤	m_hDC = NULL;¤	m_hImageList = NULL;¤	¤	m_csCallbackRepaint.hWnd = NULL;¤	m_csCallbackRepaint.nMessage = 0;¤	m_csCallbackRepaint.lParam = 0;¤	m_csCallbackRepaint.wParam = 0;¤	¤	m_csCallbackLink.hWnd = NULL;¤	m_csCallbackLink.nMessage = 0;¤	m_csCallbackLink.lParam = 0;¤	m_csCallbackLink.wParam = 0;¤¤//	m_clrShadow = PPHTMLDRAWER_SHADOW_COLOR;¤¤	m_hLinkCursor = NULL; // No cursor as yet¤	m_nHoverIndexLink = PPHTMLDRAWER_NO_HOVERLINK;¤¤	SetListOfTags();¤	SetListSpecChars();¤    SetTableOfColors();¤	SetDefaultCursor();¤	EnableEscapeSequences();¤	SetMaxWidth(0);¤//	EnableTextWrap(FALSE); //A text warpping was disabled by default¤//	EnableTextWrap(TRUE); //A text warpping was disabled by default¤	SetImageShadow(4, 4);¤	SetTabSize(32);¤	SetDefaultCssStyles();¤	EnableOutput();¤	SetDisabledColor(::GetSysColor(COLOR_BTNSHADOW));¤}¤¤void CPPHtmlDrawer::EnableOutput(BOOL bEnable /* = TRUE */)¤{¤	m_bIsEnable = bEnable;¤} //End of EnableOutput¤¤void CPPHtmlDrawer::SetDisabledColor(COLORREF color)¤{¤	m_crDisabled = color;¤}¤¤HICON CPPHtmlDrawer::GetIconFromResources(DWORD dwID, int nWidth /* = 0 */, int nHeight /* = 0 */) const¤{¤	if (0 == dwID) return NULL;¤¤	// Find correct resource handle¤#ifdef _MFC_VER¤	HINSTANCE hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(dwID), RT_GROUP_ICON);¤#else¤	HINSTANCE hInstResource = ::GetModuleHandle(NULL);¤#endif¤	// Set icon when the mouse is IN the button¤	HICON hIcon = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(dwID), IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR);¤	¤	return hIcon;¤}¤¤HICON CPPHtmlDrawer::GetIconFromFile(LPCTSTR lpszPath, int nWidth /* = 0 */, int nHeight /* = 0 */) const¤{¤	HICON hIcon = (HICON)::LoadImage(NULL, lpszPath, IMAGE_ICON, nWidth, nHeight, LR_LOADFROMFILE | LR_DEFAULTCOLOR);¤	¤	return hIcon;¤}¤¤HICON CPPHtmlDrawer::GetIconFromDll(DWORD dwID, int nWidth /* = 0 */, int nHeight /* = 0 */, LPCTSTR lpszPathDll /* = NULL */) const¤{¤	if (0 == dwID) return NULL;¤¤	HICON hIcon = NULL;¤¤	HINSTANCE hInstDll = NULL;¤	BOOL bNewDll = FALSE;¤¤	if (NULL == lpszPathDll)¤	{¤		if (NULL != m_hInstDll)¤			hInstDll = m_hInstDll;¤	}¤	else¤	{¤		//Load New Library¤		hInstDll = ::LoadLibraryEx(lpszPathDll, NULL, 0);¤		if (NULL != hInstDll)¤			bNewDll = TRUE;	¤	}¤¤	if (NULL != hInstDll)¤	{¤		hIcon = (HICON)::LoadImage(hInstDll, MAKEINTRESOURCE(dwID), IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR);¤¤		if (bNewDll)¤			::FreeLibrary(hInstDll);¤	}¤¤	return hIcon;¤}¤¤HBITMAP CPPHtmlDrawer::GetBitmapFromResources(DWORD dwID) const¤{¤	if (0 == dwID) return NULL;¤¤	// Find correct resource handle¤#ifdef _MFC_VER¤	HINSTANCE hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(dwID), RT_BITMAP);¤#else¤	HINSTANCE hInstResource = ::GetModuleHandle(NULL);¤#endif¤	// Load bitmap¤	HBITMAP hBitmap = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(dwID), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);¤	¤	return hBitmap;¤}¤¤HBITMAP CPPHtmlDrawer::GetBitmapFromFile(LPCTSTR lpszPath) const¤{¤	HBITMAP hBitmap = (HBITMAP)::LoadImage(NULL, lpszPath, IMAGE_BITMAP,¤		0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE);¤¤	return hBitmap;¤}¤¤HBITMAP CPPHtmlDrawer::GetBitmapFromDll(DWORD dwID, LPCTSTR lpszPathDll /* = NULL */) const¤{¤	if (0 == dwID) return NULL;¤¤	HBITMAP hBitmap = NULL;¤¤	HINSTANCE hInstDll = NULL;¤	BOOL bNewDll = FALSE;¤¤	if (NULL == lpszPathDll)¤	{¤		if (NULL != m_hInstDll)¤			hInstDll = m_hInstDll;¤	}¤	else¤	{¤		//Load New Library¤		hInstDll = ::LoadLibraryEx(lpszPathDll, NULL, 0);¤		if (NULL != hInstDll)¤			bNewDll = TRUE;	¤	}¤¤	if (NULL != hInstDll)¤	{¤		hBitmap = (HBITMAP)::LoadImage(hInstDll, MAKEINTRESOURCE(dwID), IMAGE_BITMAP,¤			0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE);¤¤		if (bNewDll)¤			::FreeLibrary(hInstDll);¤	}¤¤	return hBitmap;¤}¤¤CPPString CPPHtmlDrawer::GetStringFromResource(DWORD dwID) const¤{¤	if (0 == dwID) return _T("");¤¤	CPPString str;¤	str.LoadString(dwID);¤¤	return str;¤}¤¤CPPString CPPHtmlDrawer::GetStringFromDll(DWORD dwID, LPCTSTR lpszPathDll /* = NULL */) const¤{¤	if (0 == dwID) return _T("");¤¤	CPPString str = _T("");¤¤	HINSTANCE hInstDll = NULL;¤	BOOL bNewDll = FALSE;¤¤	if (NULL == lpszPathDll)¤	{¤		if (NULL != m_hInstDll)¤			hInstDll = m_hInstDll;¤	}¤	else¤	{¤		//Load New Library¤		hInstDll = ::LoadLibraryEx(lpszPathDll, NULL, 0);¤		if (NULL != hInstDll)¤			bNewDll = TRUE;	¤	}¤¤	if (NULL != hInstDll)¤	{¤#ifdef _UNICODE¤#define CHAR_FUDGE 1    // one TCHAR unused is good enough¤#else¤#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char¤#endif¤		// try fixed buffer first (to avoid wasting space in the heap)¤		TCHAR szTemp[256];¤		¤		DWORD dwLen = ::LoadString(hInstDll, dwID, szTemp, (sizeof(szTemp) * sizeof(TCHAR)));¤		// If resource not found (or ::LoadString failure)¤		if (0 != dwLen) ¤		{¤			if ((sizeof(szTemp) * sizeof(TCHAR)) - dwLen > CHAR_FUDGE)¤			{¤				str = szTemp;¤			} // if¤			else¤			{¤				// try buffer size of 512, then larger size until entire string is retrieved¤				int nSize = 256;¤				do¤				{¤					nSize += 256;¤					dwLen = ::LoadString(hInstDll, dwID, str.GetBuffer(nSize-1), nSize);¤				} while (nSize - dwLen <= CHAR_FUDGE);¤				str.ReleaseBuffer();¤			}¤#undef CHAR_FUDGE¤		}¤¤		if (bNewDll)¤			::FreeLibrary(hInstDll);¤	}¤	return str;¤}¤¤///////////////////////////////////////////////////////////¤// Get tooltip string for menu and toolbar items from the ¤// resources of the application.¤// ¤// Parameters:¤//		nID - Resource ID of the string¤//		nNumParam - Which parameter will gets:¤//					 0=long,¤//					 1=short,¤//					 2=disable¤//¤//¤// Format prompt string:  long prompt \n short prompt \n disable prompt¤////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::GetResCommandPrompt(UINT nID, UINT nNumParam /* = 0 */)¤{¤	CPPString str = GetStringFromResource(nID);¤	if (!str.IsEmpty())¤	{¤		int nFirst = 0;¤		int nLast = nFirst;¤		UINT nCount = 0;¤		while ((nCount <= nNumParam) && (nFirst < str.GetLength()))¤		{¤			nLast = str.Find(_T('\n'), nFirst);¤			if (nLast < 0)¤			{¤				//Char wasn't found¤				if (nCount == nNumParam)¤					str = str.Mid(nFirst, str.GetLength() - nFirst);¤				else¤					str.Empty();¤				¤				return str;¤			}¤			else¤			{¤				//Char was found¤				if (nCount == nNumParam)¤				{¤					str = str.Mid(nFirst, nLast - nFirst);¤					return str;¤				}¤				else¤				{¤					nFirst = nLast + 1;¤				} //if¤			} //if¤			nCount ++;¤		} //while¤	} //if¤¤	return _T("");¤} //End of GetResCommandPrompt¤¤/////////////////////////////////////////////////////////////////////////////¤// ¤void CPPHtmlDrawer::SetListSpecChars()¤{¤	AddSpecChar(_T("&amp;"), _T("&"));			// ampersand¤	AddSpecChar(_T("&bull;"), _T("\x95\0"));	// bullet  NOT IN MS SANS SERIF¤	AddSpecChar(_T("&copy;"), _T("\xA9\0"));	// copyright¤//	AddSpecChar(_T("&euro;"), _T("\x80\0"));	// euro sign IN NOT CYRILLIC FONTS¤	AddSpecChar(_T("&euro;"), _T("\x88\0"));	// euro sign IN CYRILLIC FONTS¤	AddSpecChar(_T("&gt;"), _T(">"));			// greater than¤	AddSpecChar(_T("&iquest;"), _T("\xBF\0"));	// inverted question mark¤	AddSpecChar(_T("&lt;"), _T("<<"));			// less than¤	AddSpecChar(_T("&nbsp;"), _T(" "));			// nonbreaking space¤	AddSpecChar(_T("&para;"), _T("\xB6\0"));	// paragraph sign¤	AddSpecChar(_T("&pound;"), _T("\xA3\0"));	// pound sign¤	AddSpecChar(_T("&quot;"), _T("\""));		// quotation mark¤	AddSpecChar(_T("&reg;"), _T("\xAE\0"));		// registered trademark¤	AddSpecChar(_T("&trade;"), _T("\x99\0"));	// trademark NOT IN MS SANS SERIF¤} //End of SetListSpecChars¤¤void CPPHtmlDrawer::AddSpecChar(LPCTSTR lpszAlias, LPCTSTR lpszValue)¤{¤	iter_mapStyles iter = m_mapSpecChars.find(lpszAlias);¤	¤	if (iter != m_mapSpecChars.end())¤		iter->second = lpszValue;		//Modifies¤	else¤		m_mapSpecChars.insert(std::make_pair(lpszAlias, lpszValue)); //Add new¤} //End of AddSpecialChar¤¤void CPPHtmlDrawer::ReplaceSpecChars()¤{¤	CPPString sAlias, sValue;¤	for (iter_mapStyles iter = m_mapSpecChars.begin(); iter != m_mapSpecChars.end(); ++iter)¤	{¤		sAlias = iter->first;¤		sValue = iter->second;¤		m_csHtmlText.Replace(sAlias, sValue);¤	} //for¤¤	m_csHtmlText.Remove(_T('\r'));¤	if (!m_bEnableEscapeSequences)¤	{¤		//ENG: Remove escape sequences¤		//RUS: Удаляем специальные символы¤		m_csHtmlText.Remove(_T('\n'));¤		m_csHtmlText.Remove(_T('\t'));¤	}¤	else¤	{¤		//ENG: Replace escape sequences to HTML tags¤		//RUS: Заменяем специальные символы HTML тэгами¤		m_csHtmlText.Replace(_T("\n"), _T("<br>"));¤		m_csHtmlText.Replace(_T("\t"), _T("<t>"));¤	} //if¤} //End of ReplaceSpecChars¤¤/////////////////////////////////////////////////////////////////////////////¤// ¤void CPPHtmlDrawer::SetListOfTags()¤{¤	AddTagToList(_T("b"), TAG_BOLD, _T("bold"));¤	AddTagToList(_T("i"), TAG_ITALIC, _T("italic"));¤	AddTagToList(_T("em"), TAG_ITALIC, _T("italic"));¤	AddTagToList(_T("u"), TAG_UNDERLINE, _T("underline"));¤	AddTagToList(_T("s"), TAG_STRIKEOUT, _T("strikeout"));¤	AddTagToList(_T("strike"), TAG_STRIKEOUT, _T("strikeout"));¤	AddTagToList(_T("font"), TAG_FONT, _T("font"));¤	AddTagToList(_T("hr"), TAG_HLINE, _T(""));¤	AddTagToList(_T("br"), TAG_NEWLINE, _T(""));¤	AddTagToList(_T("\n"), TAG_NEWLINE, _T(""));¤	AddTagToList(_T("t"), TAG_TABULATION, _T(""));¤	AddTagToList(_T("\t"), TAG_TABULATION, _T(""));¤	AddTagToList(_T("left"), TAG_LEFT, _T("left"));¤	AddTagToList(_T("center"), TAG_CENTER, _T("center"));¤	AddTagToList(_T("right"), TAG_RIGHT, _T("right"));¤	AddTagToList(_T("justify"), TAG_JUSTIFY, _T("justify"));¤	AddTagToList(_T("baseline"), TAG_BASELINE, _T("baseline"));¤	AddTagToList(_T("top"), TAG_TOP, _T("top"));¤	AddTagToList(_T("vcenter"), TAG_VCENTER, _T("vcenter"));¤	AddTagToList(_T("middle"), TAG_VCENTER, _T("vcenter"));¤	AddTagToList(_T("bottom"), TAG_BOTTOM, _T("vcenter"));¤	AddTagToList(_T("bmp"), TAG_BITMAP, _T(""));¤	AddTagToList(_T("icon"), TAG_ICON, _T(""));¤	AddTagToList(_T("ilst"), TAG_IMAGELIST, _T(""));¤	AddTagToList(_T("string"), TAG_STRING, _T(""));¤	AddTagToList(_T("body"), TAG_NEWSTYLE, _T("body"));¤	AddTagToList(_T("h1"), TAG_NEWSTYLE, _T("h1"));¤	AddTagToList(_T("h2"), TAG_NEWSTYLE, _T("h2"));¤	AddTagToList(_T("h3"), TAG_NEWSTYLE, _T("h3"));¤	AddTagToList(_T("h4"), TAG_NEWSTYLE, _T("h4"));¤	AddTagToList(_T("h5"), TAG_NEWSTYLE, _T("h5"));¤	AddTagToList(_T("h6"), TAG_NEWSTYLE, _T("h6"));¤	AddTagToList(_T("code"), TAG_NEWSTYLE, _T("code"));¤	AddTagToList(_T("pre"), TAG_NEWSTYLE, _T("pre"));¤	AddTagToList(_T("big"), TAG_NEWSTYLE, _T("big"));¤	AddTagToList(_T("small"), TAG_NEWSTYLE, _T("small"));¤	AddTagToList(_T("sub"), TAG_NEWSTYLE, _T("sub"));¤	AddTagToList(_T("sup"), TAG_NEWSTYLE, _T("sup"));¤	AddTagToList(_T("span"), TAG_SPAN, _T("span"));¤	AddTagToList(_T("a"), TAG_HYPERLINK, _T("link"));¤} //End of SetListOfTags¤¤////////////////////////////////////////////////////////////////////////¤// Format for the new tags:¤//		lpszName		- a tag's name in the HTML string¤//		dwTagIndex		- ID of the tag¤//		lpszFullName	- a custom name if tag must be closing. Empty if not.  ¤////////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::AddTagToList(LPCTSTR lpszName, DWORD dwTagIndex, LPCTSTR lpszFullName)¤{¤	STRUCT_TAGPROP tp;¤	tp.dwTagIndex = dwTagIndex;¤	tp.strTagName = lpszFullName;¤¤	iterMapTags iterMap = m_mapTags.find(lpszName);¤	¤	if (iterMap != m_mapTags.end())¤		iterMap->second = tp; //Modifies¤	else¤		m_mapTags.insert(std::make_pair(lpszName, tp)); //Add new¤} //End of AddTagToList¤¤DWORD CPPHtmlDrawer::GetTagFromList(CPPString sTagName, CPPString & strFullName, BOOL & bCloseTag)¤{¤	strFullName.Empty();¤¤	bCloseTag = (sTagName.GetAt(0) == _T('/')) ? TRUE : FALSE;¤	if (bCloseTag)¤		sTagName = sTagName.Mid(1);¤¤	iterMapTags iterMap = m_mapTags.find(sTagName);¤	¤	if (iterMap != m_mapTags.end())¤	{¤		STRUCT_TAGPROP tp = iterMap->second;¤		strFullName = tp.strTagName;¤		¤		return tp.dwTagIndex;¤	} //if¤¤	return TAG_NONE;¤} //End of GetTagFromList¤¤///////////////////////////////////////////////////////¤// ¤///////////////////////////////////////////////////////¤void CPPHtmlDrawer::SetTableOfColors()¤{¤	//Frequency used¤	SetColorName(_T("aqua"), RGB(0x00, 0xFF, 0xFF)); ¤	SetColorName(_T("black"), RGB(0x00, 0x00, 0x00)); ¤	SetColorName(_T("blue"), RGB(0x00, 0x00, 0xFF)); ¤	SetColorName(_T("brown"), RGB(0xA5, 0x2A, 0x2A)); ¤	SetColorName(_T("cyan"), RGB(0x00, 0xFF, 0xFF));¤	SetColorName(_T("gold"), RGB(0xFF, 0xD7, 0x00)); ¤	SetColorName(_T("gray"), RGB(0x80, 0x80, 0x80)); ¤	SetColorName(_T("green"), RGB(0x00, 0x80, 0x00)); ¤	SetColorName(_T("magenta"), RGB(0xFF, 0x00, 0xFF)); ¤	SetColorName(_T("maroon"), RGB(0x80, 0x00, 0x00)); ¤	SetColorName(_T("navy"), RGB(0x00, 0x00, 0x80)); ¤	SetColorName(_T("olive"), RGB(0x80, 0x80, 0x00)); ¤	SetColorName(_T("orange"), RGB(0xFF, 0xA5, 0x00)); ¤	SetColorName(_T("pink"), RGB(0xFF, 0xC0, 0xCB)); ¤	SetColorName(_T("purple"), RGB(0x80, 0x00, 0x80)); ¤	SetColorName(_T("red"), RGB(0xFF, 0x00, 0x00)); ¤	SetColorName(_T("silver"), RGB(0xC0, 0xC0, 0xC0)); ¤	SetColorName(_T("snow"), RGB(0xFF, 0xFA, 0xFA)); ¤	SetColorName(_T("violet"), RGB(0xEE, 0x82, 0xEE)); ¤	SetColorName(_T("white"), RGB(0xFF, 0xFF, 0xFF)); ¤	SetColorName(_T("yellow"), RGB(0xFF, 0xFF, 0x00)); ¤¤	//Common Used¤	SetColorName(_T("aliceblue"), RGB(0xF0, 0xF8, 0xFF)); ¤	SetColorName(_T("antiquewhite"), RGB(0xFA, 0xEB, 0xD7)); ¤	SetColorName(_T("aquamarine"), RGB(0x7F, 0xFF, 0xD4)); ¤	SetColorName(_T("azure"), RGB(0xF0, 0xFF, 0xFF)); ¤	SetColorName(_T("beige"), RGB(0xF5, 0xF5, 0xDC)); ¤	SetColorName(_T("bisque"), RGB(0xFF, 0xE4, 0xC4));¤	SetColorName(_T("blanchedalmond"), RGB(0xFF, 0xEB, 0xCD)); ¤	SetColorName(_T("blueviolet"), RGB(0x8A, 0x2B, 0xE2)); ¤	SetColorName(_T("burlywood"), RGB(0xDE, 0xB8, 0x87)); ¤	SetColorName(_T("cadetblue"), RGB(0x5F, 0x9E, 0xA0)); ¤	SetColorName(_T("chartreuse"), RGB(0x7F, 0xFF, 0x00)); ¤	SetColorName(_T("chocolate"), RGB(0xD2, 0x69, 0x1E)); ¤	SetColorName(_T("coral"), RGB(0xFF, 0x7F, 0x50)); ¤	SetColorName(_T("cornflowerblue"), RGB(0x64, 0x95, 0xED)); ¤	SetColorName(_T("cornsilk"), RGB(0xFF, 0xF8, 0xDC)); ¤	SetColorName(_T("crimson"), RGB(0xDC, 0x14, 0x3C)); ¤	SetColorName(_T("darkblue"), RGB(0x00, 0x00, 0x8B)); ¤	SetColorName(_T("darkcyan"), RGB(0x00, 0x8B, 0x8B)); ¤	SetColorName(_T("darkgoldenrod"), RGB(0xB8, 0x86, 0x0B)); ¤	SetColorName(_T("darkgray"), RGB(0xA9, 0xA9, 0xA9)); ¤	SetColorName(_T("darkgreen"), RGB(0x00, 0x64, 0x00)); ¤	SetColorName(_T("darkkhaki"), RGB(0xBD, 0xB7, 0x6B)); ¤	SetColorName(_T("darkmagenta"), RGB(0x8B, 0x00, 0x8B)); ¤	SetColorName(_T("darkolivegreen"), RGB(0x55, 0x6B, 0x2F)); ¤	SetColorName(_T("darkorange"), RGB(0xFF, 0x8C, 0x00)); ¤	SetColorName(_T("darkorchid"), RGB(0x99, 0x32, 0xCC)); ¤	SetColorName(_T("darkred"), RGB(0x8B, 0x00, 0x00)); ¤	SetColorName(_T("darksalmon"), RGB(0xE9, 0x96, 0x7A)); ¤	SetColorName(_T("darkseagreen"), RGB(0x8F, 0xBC, 0x8B)); ¤	SetColorName(_T("darkslateblue"), RGB(0x48, 0x3D, 0x8B)); ¤	SetColorName(_T("darkslategray"), RGB(0x2F, 0x4F, 0x4F)); ¤	SetColorName(_T("darkturquoise"), RGB(0x00, 0xCE, 0xD1)); ¤	SetColorName(_T("darkviolet"), RGB(0x94, 0x00, 0xD3)); ¤	SetColorName(_T("deeppink"), RGB(0xFF, 0x14, 0x93)); ¤	SetColorName(_T("deepskyblue"), RGB(0x00, 0xBF, 0xFF)); ¤	SetColorName(_T("dimgray"), RGB(0x69, 0x69, 0x69)); ¤	SetColorName(_T("dodgerblue"), RGB(0x1E, 0x90, 0xFF)); ¤	SetColorName(_T("firebrick"), RGB(0xB2, 0x22, 0x22)); ¤	SetColorName(_T("floralwhite"), RGB(0xFF, 0xFA, 0xF0)); ¤	SetColorName(_T("forestgreen"), RGB(0x22, 0x8B, 0x22)); ¤	SetColorName(_T("fuchsia"), RGB(0xFF, 0x00, 0xFF)); ¤	SetColorName(_T("gainsboro"), RGB(0xDC, 0xDC, 0xDC)); ¤	SetColorName(_T("ghostwhite"), RGB(0xF8, 0xF8, 0xFF)); ¤	SetColorName(_T("goldenrod"), RGB(0xDA, 0xA5, 0x20)); ¤	SetColorName(_T("greenyellow"), RGB(0xAD, 0xFF, 0x2F)); ¤	SetColorName(_T("honeydew"), RGB(0xF0, 0xFF, 0xF0)); ¤	SetColorName(_T("hotpink"), RGB(0xFF, 0x69, 0xB4)); ¤	SetColorName(_T("indianred"), RGB(0xCD, 0x5C, 0x5C)); ¤	SetColorName(_T("indigo"), RGB(0x4B, 0x00, 0x82)); ¤	SetColorName(_T("ivory"), RGB(0xFF, 0xFF, 0xF0)); ¤	SetColorName(_T("khaki"), RGB(0xF0, 0xE6, 0x8C)); ¤	SetColorName(_T("lavender"), RGB(0xE6, 0xE6, 0xFA)); ¤	SetColorName(_T("lavenderblush"), RGB(0xFF, 0xF0, 0xF5)); ¤	SetColorName(_T("lawngreen"), RGB(0x7C, 0xFC, 0x00)); ¤	SetColorName(_T("lemonchiffon"), RGB(0xFF, 0xFA, 0xCD)); ¤	SetColorName(_T("lightblue"), RGB(0xAD, 0xD8, 0xE6)); ¤	SetColorName(_T("lightcoral"), RGB(0xF0, 0x80, 0x80)); ¤	SetColorName(_T("lightcyan"), RGB(0xE0, 0xFF, 0xFF));¤	SetColorName(_T("lightgoldenrodyellow"), RGB(0xFA, 0xFA, 0xD2)); ¤	SetColorName(_T("lightgreen"), RGB(0x90, 0xEE, 0x90)); ¤	SetColorName(_T("lightgrey"), RGB(0xD3, 0xD3, 0xD3)); ¤	SetColorName(_T("lightpink"), RGB(0xFF, 0xB6, 0xC1)); ¤	SetColorName(_T("lightsalmon"), RGB(0xFF, 0xA0, 0x7A)); ¤	SetColorName(_T("lightseagreen"), RGB(0x20, 0xB2, 0xAA)); ¤	SetColorName(_T("lightskyblue"), RGB(0x87, 0xCE, 0xFA)); ¤	SetColorName(_T("lightslategray"), RGB(0x77, 0x88, 0x99)); ¤	SetColorName(_T("lightsteelblue"), RGB(0xB0, 0xC4, 0xDE));¤	SetColorName(_T("lightyellow"), RGB(0xFF, 0xFF, 0xE0)); ¤	SetColorName(_T("lime"), RGB(0x00, 0xFF, 0x00)); ¤	SetColorName(_T("limegreen"), RGB(0x32, 0xCD, 0x32)); ¤	SetColorName(_T("linen"), RGB(0xFA, 0xF0, 0xE6)); ¤	SetColorName(_T("mediumaquamarine"), RGB(0x66, 0xCD, 0xAA)); ¤	SetColorName(_T("mediumblue"), RGB(0x00, 0x00, 0xCD)); ¤	SetColorName(_T("mediumorchid"), RGB(0xBA, 0x55, 0xD3)); ¤	SetColorName(_T("mediumpurple"), RGB(0x93, 0x70, 0xDB)); ¤	SetColorName(_T("mediumseagreen"), RGB(0x3C, 0xB3, 0x71)); ¤	SetColorName(_T("mediumslateblue"), RGB(0x7B, 0x68, 0xEE)); ¤	SetColorName(_T("mediumspringgreen"), RGB(0x00, 0xFA, 0x9A)); ¤	SetColorName(_T("mediumturquoise"), RGB(0x48, 0xD1, 0xCC)); ¤	SetColorName(_T("mediumvioletred"), RGB(0xC7, 0x15, 0x85)); ¤	SetColorName(_T("midnightblue"), RGB(0x19, 0x19, 0x70)); ¤	SetColorName(_T("mintcream"), RGB(0xF5, 0xFF, 0xFA)); ¤	SetColorName(_T("mistyrose"), RGB(0xFF, 0xE4, 0xE1)); ¤	SetColorName(_T("moccasin"), RGB(0xFF, 0xE4, 0xB5)); ¤	SetColorName(_T("navajowhite"), RGB(0xFF, 0xDE, 0xAD)); ¤	SetColorName(_T("oldlace"), RGB(0xFD, 0xF5, 0xE6)); ¤	SetColorName(_T("olivedrab"), RGB(0x6B, 0x8E, 0x23)); ¤	SetColorName(_T("orangered"), RGB(0xFF, 0x45, 0x00)); ¤	SetColorName(_T("orchid"), RGB(0xDA, 0x70, 0xD6)); ¤	SetColorName(_T("palegoldenrod"), RGB(0xEE, 0xE8, 0xAA)); ¤	SetColorName(_T("palegreen"), RGB(0x98, 0xFB, 0x98)); ¤	SetColorName(_T("paleturquoise"), RGB(0xAF, 0xEE, 0xEE)); ¤	SetColorName(_T("palevioletred"), RGB(0xDB, 0x70, 0x93)); ¤	SetColorName(_T("papayawhip"), RGB(0xFF, 0xEF, 0xD5));¤	SetColorName(_T("peachpuff"), RGB(0xFF, 0xDA, 0xB9)); ¤	SetColorName(_T("peru"), RGB(0xCD, 0x85, 0x3F)); ¤	SetColorName(_T("plum"), RGB(0xDD, 0xA0, 0xDD)); ¤	SetColorName(_T("powderblue"), RGB(0xB0, 0xE0, 0xE6)); ¤	SetColorName(_T("rosybrown"), RGB(0xBC, 0x8F, 0x8F)); ¤	SetColorName(_T("royalblue"), RGB(0x41, 0x69, 0xE1)); ¤	SetColorName(_T("saddlebrown"), RGB(0x8B, 0x45, 0x13)); ¤	SetColorName(_T("salmon"), RGB(0xFA, 0x80, 0x72)); ¤	SetColorName(_T("sandybrown"), RGB(0xF4, 0xA4, 0x60)); ¤	SetColorName(_T("seagreen"), RGB(0x2E, 0x8B, 0x57)); ¤	SetColorName(_T("seashell"), RGB(0xFF, 0xF5, 0xEE)); ¤	SetColorName(_T("sienna"), RGB(0xA0, 0x52, 0x2D)); ¤	SetColorName(_T("skyblue"), RGB(0x87, 0xCE, 0xEB)); ¤	SetColorName(_T("slateblue"), RGB(0x6A, 0x5A, 0xCD)); ¤	SetColorName(_T("slategray"), RGB(0x70, 0x80, 0x90)); ¤	SetColorName(_T("springgreen"), RGB(0x00, 0xFF, 0x7F)); ¤	SetColorName(_T("steelblue"), RGB(0x46, 0x82, 0xB4)); ¤	SetColorName(_T("tan"), RGB(0xD2, 0xB4, 0x8C)); ¤	SetColorName(_T("teal"), RGB(0x00, 0x80, 0x80)); ¤	SetColorName(_T("thistle"), RGB(0xD8, 0xBF, 0xD8)); ¤	SetColorName(_T("tomato"), RGB(0xFF, 0x63, 0x47)); ¤	SetColorName(_T("turquoise"), RGB(0x40, 0xE0, 0xD0)); ¤	SetColorName(_T("wheat"), RGB(0xF5, 0xDE, 0xB3)); ¤	SetColorName(_T("whitesmoke"), RGB(0xF5, 0xF5, 0xF5)); ¤	SetColorName(_T("yellowgreen"), RGB(0x9A, 0xCD, 0x32));¤¤	//Systems colors¤	SetColorName(_T("activeborder"), ::GetSysColor(COLOR_ACTIVEBORDER)); ¤	SetColorName(_T("activecaption"), ::GetSysColor(COLOR_ACTIVECAPTION)); ¤	SetColorName(_T("appworkspace"), ::GetSysColor(COLOR_APPWORKSPACE)); ¤	SetColorName(_T("background"), ::GetSysColor(COLOR_BACKGROUND)); ¤	SetColorName(_T("buttonface"), ::GetSysColor(COLOR_BTNFACE)); ¤	SetColorName(_T("buttonhighlight"), ::GetSysColor(COLOR_BTNHILIGHT)); ¤	SetColorName(_T("buttonshadow"), ::GetSysColor(COLOR_BTNSHADOW)); ¤	SetColorName(_T("buttontext"), ::GetSysColor(COLOR_BTNTEXT)); ¤	SetColorName(_T("captiontext"), ::GetSysColor(COLOR_CAPTIONTEXT)); ¤	SetColorName(_T("graytext"), ::GetSysColor(COLOR_GRAYTEXT)); ¤	SetColorName(_T("highlight"), ::GetSysColor(COLOR_HIGHLIGHT)); ¤	SetColorName(_T("highlighttext"), ::GetSysColor(COLOR_HIGHLIGHTTEXT)); ¤	SetColorName(_T("inactiveborder"), ::GetSysColor(COLOR_INACTIVEBORDER)); ¤	SetColorName(_T("inactivecaption"), ::GetSysColor(COLOR_INACTIVECAPTION)); ¤	SetColorName(_T("inactivecaptiontext"), ::GetSysColor(COLOR_INACTIVECAPTIONTEXT)); ¤	SetColorName(_T("infobackground"), ::GetSysColor(COLOR_INFOBK)); ¤	SetColorName(_T("infotext"), ::GetSysColor(COLOR_INFOTEXT)); ¤	SetColorName(_T("menu"), ::GetSysColor(COLOR_MENU)); ¤	SetColorName(_T("menutext"), ::GetSysColor(COLOR_MENUTEXT)); ¤	SetColorName(_T("scrollbar"), ::GetSysColor(COLOR_SCROLLBAR)); ¤	SetColorName(_T("threeddarkshadow"), ::GetSysColor(COLOR_3DDKSHADOW)); ¤	SetColorName(_T("threedface"), ::GetSysColor(COLOR_3DFACE)); ¤	SetColorName(_T("threedhighlight"), ::GetSysColor(COLOR_3DHIGHLIGHT)); ¤	SetColorName(_T("threedlightshadow"), ::GetSysColor(COLOR_3DLIGHT)); ¤	SetColorName(_T("threedshadow"), ::GetSysColor(COLOR_3DSHADOW)); ¤	SetColorName(_T("window"), ::GetSysColor(COLOR_WINDOW)); ¤	SetColorName(_T("windowframe"), ::GetSysColor(COLOR_WINDOWFRAME)); ¤	SetColorName(_T("windowtext"), ::GetSysColor(COLOR_WINDOWTEXT)); ¤} //End SetTableOfColors¤¤void CPPHtmlDrawer::SetColorName(LPCTSTR lpszColorName, COLORREF color)¤{¤	iterMapColors iterMap = m_mapColors.find(lpszColorName);¤	¤	if (iterMap != m_mapColors.end())¤		iterMap->second = color; //Modifies¤	else¤		m_mapColors.insert(std::make_pair(lpszColorName, color)); //Add new¤} //End SetColorName¤¤COLORREF CPPHtmlDrawer::GetColorByName(LPCTSTR lpszColorName, COLORREF crDefColor /* = RGB(0, 0, 0) */)¤{¤	if (m_bIsEnable)¤	{¤		iterMapColors iterMap = m_mapColors.find(lpszColorName);¤		¤		if (iterMap != m_mapColors.end())¤			crDefColor = iterMap->second;¤	}¤	else¤	{¤		//For disabled output¤		crDefColor = m_crDisabled;¤	} //if¤	return crDefColor;¤} //End GetColorByName¤¤/////////////////////////////////////////////////////////////////¤// Gets the system tooltip's logfont¤/////////////////////////////////////////////////////////////////¤LPLOGFONT CPPHtmlDrawer::GetSystemToolTipFont() const¤{¤    static LOGFONT lf;¤	¤    NONCLIENTMETRICS ncm;¤    ncm.cbSize = sizeof(NONCLIENTMETRICS);¤    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0))¤        return FALSE;¤	¤    memcpy(&lf, &(ncm.lfStatusFont), sizeof(LOGFONT));¤	¤    return &lf; ¤} //End GetSystemToolTipFont¤¤////////////////////////////////////////////¤// Check a pointer over the hyperlink¤//   In: lpPoint - the coordinates of the mouse pointer ¤//  Out: -1 - hyperlink not found¤//       index of the hyperlink¤////////////////////////////////////////////¤int CPPHtmlDrawer::PtInHyperlink(LPPOINT lpPoint)¤{¤	for (UINT i = 0; i < m_arrLinks.size(); ++i)¤	{¤		STRUCT_HYPERLINK & link = m_arrLinks [i];¤		if ((link.rcArea.left <= lpPoint->x) && (link.rcArea.right >= lpPoint->x) &&¤			(link.rcArea.top <= lpPoint->y) && (link.rcArea.bottom >= lpPoint->y))¤			return i;¤	} //for¤	return -1;¤} //End PtInHyperlink¤¤void CPPHtmlDrawer::JumpToHyperlink(int nLink)¤{¤	STRUCT_HYPERLINK & link = m_arrLinks [nLink];¤//	TRACE(_T("Jump to Hyperlink number = %d\n"), nLink);¤	if (!link.sHyperlink.IsEmpty())¤	{¤		switch (link.nTypeLink)¤		{¤		case LINK_HREF:¤			GotoURL(link.sHyperlink);¤			break;¤		case LINK_MESSAGE:¤			CallbackOnClickHyperlink(link.sHyperlink);¤			break;¤		} //switch¤	} //if¤} //End JumpToHyperlink¤¤void CPPHtmlDrawer::OnLButtonDown(LPPOINT lpClient)¤{¤//	TRACE (_T("CPPHtmlDrawer::OnLButtonDown()\n"));¤	¤	int nLink = PtInHyperlink(lpClient);¤	if (nLink >= 0)¤	{¤		//Hyperlink under the mouse pointer¤		JumpToHyperlink(nLink);¤	} //if¤} //End OnLButtonDown¤¤BOOL CPPHtmlDrawer::OnSetCursor(LPPOINT lpClient)¤{¤	int nLink = PtInHyperlink(lpClient);¤	if (nLink >= 0)¤	{¤		STRUCT_HYPERLINK link = m_arrLinks [nLink];¤		if (m_nHoverIndexLink != link.nIndexLink)¤		{¤			m_nHoverIndexLink = link.nIndexLink;¤			CallbackOnRepaint(m_nHoverIndexLink);¤			//Redraw Window¤		} //if¤		¤		if (!link.sHyperlink.IsEmpty() && (NULL != m_hLinkCursor))¤		{¤			::SetCursor(m_hLinkCursor);¤			return TRUE;¤		} //if¤	}¤	else if (m_nHoverIndexLink != PPHTMLDRAWER_NO_HOVERLINK)¤	{¤		m_nHoverIndexLink = PPHTMLDRAWER_NO_HOVERLINK;¤		CallbackOnRepaint(m_nHoverIndexLink);¤		//Redraw Window¤	} //if¤	¤    return FALSE;¤} //End OnSetCursor¤¤BOOL CPPHtmlDrawer::OnTimer()¤{¤	BOOL bRedraw = FALSE;¤	if (m_arrAni.size() > 0)¤	{¤		for (UINT i = 0; i < m_arrAni.size(); ++i)¤		{¤			STRUCT_ANIMATION & sa = m_arrAni [i];¤			if (sa.nMaxImages > 0)¤			{¤				sa.nTimerCount ++;¤				if (sa.nTimerCount >= sa.nSpeed)¤				{¤					sa.nTimerCount = 0;¤					sa.nIndex ++;¤					if (sa.nIndex >= sa.nMaxImages)¤						sa.nIndex = 0;¤					bRedraw = TRUE;¤				} //if¤				m_arrAni [i] = sa;¤			} //if¤		} //for¤	} //if¤¤	return bRedraw;¤} //End of OnTimer¤¤void CPPHtmlDrawer::CallbackOnRepaint(int nIndexLink)¤{¤//	TRACE(_T("CPPHtmlDrawer::CallbackOnRepaint()\n")); ¤¤	if ((NULL == m_csCallbackRepaint.hWnd) || !m_csCallbackRepaint.nMessage)¤		return; ¤ 	¤	::SendMessage(m_csCallbackRepaint.hWnd, m_csCallbackRepaint.nMessage, (LPARAM)nIndexLink, m_csCallbackRepaint.lParam);  ¤} //End CallbackOnRepaint¤¤void CPPHtmlDrawer::CallbackOnClickHyperlink(LPCTSTR sLink)¤{¤//	TRACE(_T("CPPHtmlDrawer::CallbackOnClickHyperlink()\n")); ¤¤	if ((NULL == m_csCallbackLink.hWnd) || !m_csCallbackLink.nMessage)¤		return; ¤	¤	::SendMessage(m_csCallbackLink.hWnd, m_csCallbackLink.nMessage, (LPARAM)sLink, m_csCallbackLink.lParam);  	¤} //if CallbackOnClickHyperlink¤¤HINSTANCE CPPHtmlDrawer::GotoURL(LPCTSTR url, int showcmd /* = SW_SHOW */)¤{¤	SetHyperlinkCursor(NULL);¤¤    TCHAR key[MAX_PATH + MAX_PATH];¤¤    // First try ShellExecute()¤    HINSTANCE result = ShellExecute(NULL, _T("open"), url, NULL, NULL, showcmd);¤¤    // If it failed, get the .htm regkey and lookup the program¤    if ((UINT)result <= HINSTANCE_ERROR) ¤	{¤¤        if (GetRegKey(HKEY_CLASSES_ROOT, _T(".htm"), key) == ERROR_SUCCESS) ¤		{¤            lstrcat(key, _T("\\shell\\open\\command"));¤¤            if (GetRegKey(HKEY_CLASSES_ROOT,key,key) == ERROR_SUCCESS) ¤			{¤                TCHAR *pos;¤                pos = _tcsstr(key, _T("\"%1\""));¤                if (pos == NULL) ¤				{                     // No quotes found¤                    pos = _tcsstr(key, _T("%1"));      // Check for %1, without quotes ¤                    if (pos == NULL)                   // No parameter at all...¤                        pos = key+lstrlen(key)-1;¤                    else¤                        *pos = '\0';                   // Remove the parameter¤                }¤                else¤                    *pos = '\0';                       // Remove the parameter¤¤                lstrcat(pos, _T(" "));¤                lstrcat(pos, url);¤¤                USES_CONVERSION;¤                result = (HINSTANCE) WinExec(T2A(key),showcmd);¤            } //if¤        } //if¤    } //if¤    return result;¤} //End GotoURL¤¤LONG CPPHtmlDrawer::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)¤{¤    HKEY hkey;¤    LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);¤¤    if (retval == ERROR_SUCCESS) {¤        long datasize = MAX_PATH;¤        TCHAR data[MAX_PATH];¤        RegQueryValue(hkey, NULL, data, &datasize);¤        lstrcpy(retdata,data);¤        RegCloseKey(hkey);¤    } //if¤¤    return retval;¤} //End GetRegKey¤¤/////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::DrawHtml (LPSIZE lpSize, LPCRECT lpRect)¤{¤	//ENG: Bounding rectangle of a current area for output¤	//RUS: Ограничивающей прямоугольник для текущей области вывода¤	RECT rcArea;¤	rcArea.left = lpRect->left;¤	rcArea.right = lpRect->right;¤	rcArea.top = lpRect->top;¤	rcArea.bottom = lpRect->bottom;¤¤	SIZE szArea;¤	szArea.cx = szArea.cy = 0;¤	¤	if (MODE_FIRSTPASS == m_nNumPass)¤	{¤		//ENG: In preparing mode clears an auxiliary tables¤		//RUS: В режиме подготовки очищаем вспомогательные таблицы ¤		m_arrLinks.clear();¤//		m_arrTable.clear();¤		m_arrHtmlLine.clear();¤//		m_arrTableSizes.clear();¤		m_arrAni.clear();¤	} //if¤¤	m_nCurLine = 0;¤	m_nCurTable = -1;¤	m_nNumCurTable = -1;¤	m_nCurIndexLink = -1;¤	m_nCurIndexAni = -1;¤	¤	//ENG: Clear stack of tags¤	//RUS: Очищаем стэк тэгов¤	m_arrStack.clear();¤	¤	int nIndex = 0;¤	int nBegin;¤	CPPString strText;¤	¤	//ENG: Applies a default styles¤	//RUS: Применяем стили по-умолчанию¤	SetDefaultStyles(m_defStyle);¤	SelectNewHtmlStyle(_T("body"), m_defStyle);¤	¤	//ENG: Creates a default font¤	//RUS: Создаем шрифт по умолчанию¤	m_lfDefault.lfHeight = m_defStyle.nSizeFont;¤	m_lfDefault.lfWidth = 0;¤	m_lfDefault.lfOrientation = 0;¤	m_lfDefault.lfEscapement = 0;¤	m_lfDefault.lfWeight = m_defStyle.nWeightFont;¤	m_lfDefault.lfItalic = m_defStyle.bItalicFont;¤	m_lfDefault.lfStrikeOut = m_defStyle.bStrikeOutFont;¤	m_lfDefault.lfUnderline = m_defStyle.bUnderlineFont;¤	m_lfDefault.lfCharSet = DEFAULT_CHARSET;¤	m_lfDefault.lfOutPrecision = OUT_DEFAULT_PRECIS;¤	m_lfDefault.lfClipPrecision = CLIP_DEFAULT_PRECIS;¤	m_lfDefault.lfQuality = DEFAULT_QUALITY;¤	m_lfDefault.lfPitchAndFamily = FF_DONTCARE;¤	_tcscpy (m_lfDefault.lfFaceName, m_defStyle.sFaceFont);¤	m_hFont = ::CreateFontIndirect(&m_lfDefault);¤	¤	//ENG: Remember a current context setting¤	//RUS: Запоминаем текущие настройки контекст устройства¤	m_hOldFont = (HFONT)::SelectObject(m_hDC, m_hFont);¤	m_nOldBkMode = ::SetBkMode(m_hDC, m_defStyle.nBkMode);¤	m_crOldText = ::SetTextColor(m_hDC, m_defStyle.crText);¤	m_crOldBk = ::SetBkColor(m_hDC, m_defStyle.crBkgnd);¤	::GetTextMetrics(m_hDC, &m_tm);¤	¤	while (nIndex < m_csHtmlText.GetLength())¤	{¤		//ENG: Searching a begin of table¤		//RUS: Ищем начало таблицы¤		nBegin = nIndex;¤		BOOL bFoundTable = SearchTag(m_csHtmlText, nIndex, _T("table"));¤¤		//ENG: Gets a text before a table¤		//RUS: Получаем текст до таблицы¤		strText = m_csHtmlText.Mid(nBegin, nIndex - nBegin);¤¤		//ENG: If text before a table is exist¤		//RUS: Если текст перед таблицей существует¤		if (!strText.IsEmpty())¤		{¤			//ENG: Add a tag BODY around of a output text¤			//RUS: Добавляем тэг BODY вокруг выводимого текста¤//			strText = _T("<body>") + strText + _T("</body>");¤¤			//ENG: Output a text before of a table¤			//RUS: Выводим текст перед таблицей¤			szArea = DrawHtmlString(strText, &rcArea);¤¤			//ENG: Updates a output area size¤			//RUS: Обновляем размер области вывода¤			lpSize->cx = std::max(lpSize->cx, szArea.cx);¤			lpSize->cy += szArea.cy;¤			if (MODE_DRAW == m_nNumPass)¤				rcArea.top += szArea.cy;¤		} //if¤		¤		//ENG: If table was found¤		//RUS: Если таблица была найдена¤		if (bFoundTable)¤		{¤			//ENG: Searching an end of the table¤			//RUS: Ищем окончание таблицы¤			nBegin = nIndex;¤			nIndex += 6;¤			SearchEndOfTable(m_csHtmlText, nIndex);¤¤			//ENG: Cuts a text of a table¤			//RUS: Вырезаем текст таблицы¤			strText = m_csHtmlText.Mid(nBegin, nIndex - nBegin);¤¤			//ENG: Output a table¤			//RUS: Вывод таблицы¤			szArea = DrawHtmlTable(strText, &rcArea);¤			¤			//ENG: Updates a output area size¤			//RUS: Обновляем размер области вывода¤			lpSize->cx = std::max(lpSize->cx, szArea.cx);¤			lpSize->cy += szArea.cy;¤			if (MODE_DRAW == m_nNumPass)¤				rcArea.top += szArea.cy;¤		} //if¤	} //while¤	¤	//ENG: Restore context setting¤	//RUS: Восстанавливаем настроки контекста устройства¤	::SetBkMode(m_hDC, m_nOldBkMode);¤	::SetBkColor(m_hDC, m_crOldBk);¤	::SetTextColor(m_hDC, m_crOldText);¤	::SelectObject(m_hDC, m_hOldFont);¤	¤	//ENG: Clear stack of tags¤	//RUS: Очищаем стэк тэгов¤	m_arrStack.clear();¤	¤	//ENG: Delete a font¤	//RUS: Удаляем шрифт¤	::DeleteObject(m_hFont);¤} //End of DrawHtml¤¤¤SIZE CPPHtmlDrawer::DrawHtmlTable (CPPString & sTable, LPCRECT lpRect)¤{¤	//ENG: Jump to the next table¤	//RUS: Начинаем новую таблицу¤	m_nCurTable++;¤¤	int i;¤	UINT pos;¤	SIZE size = {0, 0};¤	SIZE szTable;¤	RECT rcTable = {0, 0, 0, 0};¤	RECT rcRow;¤¤	if (MODE_FIRSTPASS == m_nNumPass) ¤	{¤		//ENG: Get size of the table¤		//RUS: Получаем размеры таблицы¤		szTable = GetTableDimensions(sTable);¤		¤		STRUCT_TABLE st;¤		STRUCT_CELL sc;¤		sc.nRowSpan = 0;¤		sc.nColSpan = 0;¤//		sc.bHeightPercent = FALSE;¤//		sc.bWidthPercent = FALSE;¤//		sc.nHeight = 0;¤//		sc.nWidth = 0;¤		sc.szText.cx = sc.szText.cy = sc.szCell.cx = sc.szCell.cy = 0;¤		sc.bFixedWidth = FALSE;¤	¤		//ENG: Creates a template of an empty table¤		//RUS: Создаем шаблон пустой таблицы¤		vecRow rows;¤		for (i = 0; i < szTable.cx; i++)¤		{¤			rows.push_back(sc);¤			st.width.push_back(0);¤			st.fixed_width.push_back(FALSE);¤		} //for¤		for (i = 0; i < szTable.cy; i++)¤		{¤			st.cells.push_back(rows);¤			st.height.push_back(0);¤		} //for¤		¤		//ENG: Add a new table¤		//RUS: Добавляем новую таблицу¤		m_arrTables.push_back(st);¤	} //if¤¤	//ENG: Gets an info about a current table¤	//RUS: Взять информацию о текущей таблице ¤	int nIndexTable = m_nCurTable;¤	STRUCT_TABLE cur_table = m_arrTables [nIndexTable];¤	¤	szTable.cx = cur_table.width.size();¤	szTable.cy = cur_table.height.size();¤¤	//ENG: Applies styles of <table> tag¤	//RUS: Применяем стили таблицы (тэг <table>)¤	m_defStyle.strTag = _T("table");¤	StoreRestoreStyle(FALSE);¤	SelectNewHtmlStyle(m_defStyle.strTag, m_defStyle);¤	¤	//ENG: Passes a tag body and get a properties of the tag¤	//RUS: Пропускаем тэг начала ячейки и получаем строку свойств тэга¤	int nIndex = 0;¤	CPPString sTag;¤	SearchNextTag(sTable, sTag, nIndex);¤	CPPString sProperties = SplitTag(sTag);¤¤	//ENG: Analyses a properties of the tag¤	//RUS: Анализируем свойства тэга¤	AnalyseCellParam(sProperties, m_defStyle, TRUE);¤	UpdateContext();¤¤	if (MODE_FIRSTPASS != m_nNumPass)¤	{¤		//ENG: Gets a real size of the table¤		//RUS: Получаем реальные размеры таблицы¤		rcTable.left = lpRect->left;¤		rcTable.top = rcTable.bottom = lpRect->top;¤¤		int nWidthTable = m_defStyle.nPadding + cur_table.width.size() - 1;¤		for (pos = 0; pos < cur_table.width.size(); ++pos)¤			nWidthTable += cur_table.width [pos] + m_defStyle.nPadding;¤		rcTable.bottom += m_defStyle.nPadding + cur_table.height.size() - 1;¤		for (pos = 0; pos < cur_table.height.size(); ++pos)¤			rcTable.bottom += cur_table.height [pos] + m_defStyle.nPadding;¤¤		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)¤		{¤			nWidthTable += 6;¤			rcTable.bottom += 6;¤		}¤		else¤		{¤			nWidthTable += m_defStyle.nBorderWidth * 2;¤			rcTable.bottom += m_defStyle.nBorderWidth * 2;¤		} //if¤¤		//ENG: Horizontal align of the table¤		//RUS: Выравнивание таблицы по горизонтали¤		int nRealWidth = lpRect->right - lpRect->left;¤¤		if (nWidthTable < nRealWidth)¤		{¤			//RUS: Попытаемся растянуть таблицу на всю доступную область¤			int nDelta = nRealWidth - nWidthTable;¤			int nNotFixedColumns = 0;¤			for (pos = 0; pos < cur_table.fixed_width.size(); ++pos)¤			{¤				if (!cur_table.fixed_width [pos])¤					nNotFixedColumns++;¤			} //for¤			for (pos = 0; (pos < cur_table.fixed_width.size()) && (nNotFixedColumns > 0); ++pos)¤			{¤				if (!cur_table.fixed_width [pos])¤				{¤					int nStep = nDelta / nNotFixedColumns;¤					cur_table.width [pos] += nStep;¤					nDelta -= nStep;¤					nNotFixedColumns--;¤					nWidthTable += nStep;¤				} //if¤			} //for¤		} //if¤¤		if (nWidthTable < nRealWidth)¤		{¤			switch (m_defStyle.nHorzAlign)¤			{¤			case ALIGN_RIGHT:¤				rcTable.left = lpRect->right - nWidthTable;¤				break;¤			case ALIGN_CENTER:¤				rcTable.left += (nRealWidth - nWidthTable) / 2;¤				break;¤			} //switch¤		} //if¤		rcTable.right = rcTable.left + nWidthTable;¤¤		//Calculate the real column's width and row's height¤//		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)¤//			rcTable.bottom += m_defStyle.nBorderWidth * 6;¤//		else¤//			rcTable.bottom += m_defStyle.nBorderWidth * 2;¤	} //if¤¤	//Draw table border¤	if (MODE_DRAW == m_nNumPass)¤	{¤		if (m_defStyle.nFillBkgnd >= 0)¤		{¤			m_drawmanager.FillEffect(m_hDC, m_defStyle.nFillBkgnd, &rcTable, ¤				m_defStyle.crBkgnd, m_defStyle.crMidBkgnd, m_defStyle.crEndBkgnd,¤				5);¤		}¤		else if (!m_defStyle.strNameResBk.IsEmpty())¤		{¤			DrawBackgroundImage(m_hDC, rcTable.left, rcTable.top, rcTable.right - rcTable.left, rcTable.bottom - rcTable.top, m_defStyle.strNameResBk);¤		} //if¤		if (m_defStyle.nBorderWidth > 0)¤		{¤			if (m_bIsEnable)¤			{¤				m_drawmanager.DrawRectangle(m_hDC, &rcTable, m_defStyle.crBorderLight, m_defStyle.crBorderDark,¤					m_defStyle.nBorderStyle, m_defStyle.nBorderWidth);¤			}¤			else¤			{¤				m_drawmanager.DrawRectangle(m_hDC, &rcTable, m_crDisabled, m_crDisabled,¤					m_defStyle.nBorderStyle, m_defStyle.nBorderWidth);¤			} //if¤		} //if¤	} //if¤¤	rcRow = rcTable;¤¤	if (MODE_FIRSTPASS != m_nNumPass)¤	{¤		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)¤		{¤			rcRow.left += 3;¤			rcRow.top  += 3;¤			rcRow.right -= 3;¤			rcRow.bottom -= 3;¤		}¤		else¤		{¤			rcRow.left += m_defStyle.nBorderWidth;¤			rcRow.top  += m_defStyle.nBorderWidth;¤			rcRow.right -= m_defStyle.nBorderWidth;¤			rcRow.bottom -= m_defStyle.nBorderWidth;¤		}¤	} //if¤¤	if (szTable.cx && szTable.cy)¤	{¤		int nNewRow = 0;¤		int nEndRow;¤		CPPString sTagName, sTagParam, sRow;¤		for (i = 0; i < szTable.cy; ++i)¤		{¤			//ENG: Searching a begin of the row¤			//RUS: Поиск начала строки¤			if (SearchTag(sTable, nNewRow, _T("tr")))¤			{¤				//ENG: The begin of the row was found. Searching end of the row¤				//RUS: Начало строки найдено. Ищем окончание строки¤				nEndRow = nNewRow;¤				SearchEndOfRow(sTable, nEndRow);¤				//ENG: The end of the row was found¤				//RUS: Окончание строки найдено¤				sRow = sTable.Mid(nNewRow, nEndRow - nNewRow);¤				¤				//ENG: Draw a row of the table¤				//RUS: Выводим строку таблицы¤				DrawHtmlTableRow(sRow, &rcRow, cur_table, i);¤				¤				//ENG: Jump to char after the end of the row¤				//RUS: Перемещаемся на символ, следующий за окончанием строки¤				nNewRow = nEndRow + 5;¤			} //if¤		} //for¤	} //if¤¤	if (MODE_DRAW != m_nNumPass)¤	{¤		//ENG: Analysing cell's width¤		//RUS: Анализ ширины ячейки¤		for (i = 1; i <= szTable.cx; i++)¤		{¤			for (int y = 0; y < szTable.cy; y++)¤			{¤				vecRow & row = cur_table.cells [y];¤				for (int x = 0; x < szTable.cx; x++)¤				{¤					STRUCT_CELL & sc = row [x];¤					if (sc.nColSpan == i)¤					{¤						if (i == 1)¤						{¤							cur_table.width [x] = std::max ((long)cur_table.width [x], sc.szCell.cx);¤							if (sc.bFixedWidth)¤								cur_table.fixed_width [x] = TRUE;¤						}¤						else¤						{¤							int span_width = 0;¤							for (int z = 0; z < i; z++)¤							{¤								span_width += cur_table.width [x + z];¤								if (sc.bFixedWidth)¤									cur_table.fixed_width [x + z] = TRUE;¤							} //for¤							¤							if (span_width < sc.szText.cx)¤							{¤								int step = (sc.szCell.cx - span_width) / i;¤								cur_table.width [x + i - 1] += (sc.szCell.cx - span_width) % i;¤								for (int z = 0; z < i; z++)¤									cur_table.width [x + z] += step;¤							} //if¤						} //if¤					} //if¤				} //for¤			} //for¤		} //for¤¤		//ENG: Analysing cell's height¤		//RUS: Анализ высоты ячейки¤		for (i = 1; i <= szTable.cy; i++)¤		{¤			for (int y = 0; y < szTable.cy; y++)¤			{¤				vecRow & row = cur_table.cells [y];¤				for (int x = 0; x < szTable.cx; x++)¤				{¤					STRUCT_CELL & sc = row [x];¤					if (sc.nRowSpan == i)¤					{¤						if (i == 1)¤							cur_table.height [y] = std::max ((long)cur_table.height [y], sc.szCell.cy);¤						else¤						{¤							int span_height = 0;¤							for (int z = 0; z < i; z++)¤								span_height += cur_table.height [y + z];¤							¤							if (span_height < sc.szCell.cy)¤							{¤								int step = (sc.szCell.cy - span_height) / i;¤								cur_table.height [y] += (sc.szCell.cy - span_height) % i;¤								for (int z = 0; z < i; z++)¤									cur_table.height [y + z] += step;¤							} //if¤						} //if¤					} //if¤				} //for¤			} //for¤		} //for¤¤		size.cx += m_defStyle.nPadding + szTable.cx - 1;¤		size.cy += m_defStyle.nPadding + szTable.cy - 1;¤		for (i = 0; i < szTable.cx; i++)¤			size.cx += cur_table.width [i] + m_defStyle.nPadding;¤		for (i = 0; i < szTable.cy; i++)¤			size.cy += cur_table.height [i] + m_defStyle.nPadding;¤		¤		if (CPPDrawManager::PEN_DOUBLE == m_defStyle.nBorderStyle)¤		{¤			size.cx += m_defStyle.nBorderWidth * 6;¤			size.cy += m_defStyle.nBorderWidth * 6;¤		}¤		else¤		{¤			size.cx += m_defStyle.nBorderWidth * 2;¤			size.cy += m_defStyle.nBorderWidth * 2;¤		} //if¤¤//		size.cx = GetTableWidth(strTable, 0, size.cx, TRUE);¤	}¤	else¤	{¤		size.cx = rcTable.right - rcTable.left;¤		size.cy = rcTable.bottom - rcTable.top;¤	} //if¤¤	//ENG: Stores a current table¤	//RUS: Сохраняем текущую таблицу¤	m_arrTables [nIndexTable] = cur_table;¤¤	//ENG: Restore styles before <table> tag¤	//RUS: Восстанавливаем стили до тэга <table>¤	m_defStyle.strTag = _T("table");¤	if (StoreRestoreStyle(TRUE))¤		UpdateContext();¤¤	return size;¤} //End DrawHtmlTable¤¤///////////////////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer::DrawHtmlTableRow¤//	Draw a row of the table¤//-----------------------------------------------------------------------------¤// Parameters:¤//		sRow	- a text of the cell with the tags. For example: "<tr>...</tr>"¤//		lpRect	- a bounding rectangle for the row¤//		st		- the info about current table¤//		nRow	- the current row of the table¤///////////////////////////////////////////////////////////////////////////////¤//¤///////////////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::DrawHtmlTableRow(CPPString & sRow, LPCRECT lpRect, STRUCT_TABLE & st, int nRow)¤{¤	//ENG: Applies styles of <tr> tag¤	//RUS: Применяем стили строки (тэг <tr>)¤	m_defStyle.strTag = _T("tr");¤	StoreRestoreStyle(FALSE);¤	SelectNewHtmlStyle(m_defStyle.strTag, m_defStyle);¤	¤	int nCol = 0;¤	int i;¤	vecRow & row = st.cells [nRow];¤	¤	//ENG: Passes a tag body and get a properties of the tag¤	//RUS: Пропускаем тэг начала ячейки и получаем строку свойств тэга¤	int nIndex = 0;¤	CPPString sTag;¤	SearchNextTag(sRow, sTag, nIndex);¤	CPPString sProperties = SplitTag(sTag);¤¤	//ENG: Analyses a properties of the tag¤	//RUS: Анализируем свойства тэга¤	AnalyseCellParam(sProperties, m_defStyle, FALSE);¤	UpdateContext();¤	¤	while (nIndex < sRow.GetLength())¤	{¤		int nEndRow = nIndex;¤		int nNewCell = nIndex;¤		//ENG: Search an end of the cell or a begin of the nested table¤		//RUS: Ищем конец ячейки или начало вложенной таблицы¤		SearchTag(sRow, nEndRow, _T("/tr"));¤		SearchTag(sRow, nNewCell, _T("td"));¤		if (nNewCell < nEndRow)¤		{¤			//ENG: Search an existing cell¤			//RUS: Поиск существующей ячейки¤			STRUCT_CELL * sc2 = &row [nCol];¤			while ((sc2->nColSpan < 0) && (nCol < (int)row.size())) ¤			{¤				nCol++;¤				sc2 = &row [nCol];¤			} //while¤			STRUCT_CELL & sc = row [nCol];¤			//ENG: Searching the end of the cell¤			//RUS: Ищем окончание ячейки¤			nIndex = nNewCell;¤			SearchEndOfCell(sRow, nIndex);¤			CPPString sCell = sRow.Mid(nNewCell, nIndex - nNewCell);¤¤			RECT rcCell = {0, 0, 0, 0};¤			if (MODE_FIRSTPASS != m_nNumPass)¤			{¤				//ENG: Gets a real rectangle to draw a cell¤				//RUS: Получаем реальный прямоугольник для вывода ячейки¤				rcCell = *lpRect;¤				rcCell.left += m_defStyle.nPadding;¤				for (i = 0; i < nCol; i++)¤					rcCell.left += st.width [i] + m_defStyle.nPadding + 1;¤				rcCell.right = rcCell.left;¤				for (i = 0; i < sc.nColSpan; i++)¤					rcCell.right += st.width [nCol + i];¤				rcCell.right += (sc.nColSpan - 1) * (m_defStyle.nPadding + 1);¤				¤				rcCell.top += m_defStyle.nPadding;¤				for (i = 0; i < nRow; i++)¤					rcCell.top += st.height [i] + m_defStyle.nPadding + 1;¤				rcCell.bottom = rcCell.top;¤				for (i = 0; i < sc.nRowSpan; i++)¤					rcCell.bottom += st.height [nRow + i];¤				rcCell.bottom += (sc.nRowSpan - 1) * (m_defStyle.nPadding + 1);¤¤				//ENG: cellspacing - margins from table's edge to the cell's edge¤				//RUS: cellspacing - отступ от контура таблицы до ячейки ¤//				rcCell.left += m_defStyle.nPadding;¤//				rcCell.top += m_defStyle.nPadding;¤//				rcCell.right -= m_defStyle.nPadding;¤//				rcCell.bottom -= m_defStyle.nPadding;¤			} //if¤¤			DrawHtmlTableCell(sCell, &rcCell, sc);¤¤			if (MODE_DRAW != m_nNumPass)¤			{¤				//ENG: Add a cellspacing¤				//RUS: Добавляем отступ ячейки от¤//				sc.szCell.cx += m_defStyle.nPadding + m_defStyle.nPadding;¤//				sc.szCell.cy += m_defStyle.nPadding + m_defStyle.nPadding;¤				¤				//ENG: Stores a span cells¤				//RUS: Запоминаем объединенные ячейки¤				int nColSpan = sc.nColSpan + nCol;¤				int nRowSpan = sc.nRowSpan + nRow;¤				for (i = nCol + 1; i < nColSpan; i++)¤				{¤					STRUCT_CELL & scTemp = row [i];¤					scTemp.nColSpan = -1;¤					scTemp.nRowSpan = -1;¤				} //for¤				for (i = nRow + 1; i < nRowSpan; i++)¤				{¤					vecRow & rowTemp = st.cells [i];¤					STRUCT_CELL & scTemp = rowTemp [nCol];¤					scTemp.nColSpan = -1;¤					scTemp.nRowSpan = -1;¤				} //for¤			} //if¤			nCol += sc.nColSpan;¤		}¤		else¤		{¤			nIndex = sRow.GetLength();¤		} //if¤	} //while¤¤	//ENG: Restore styles before <tr> tag¤	//RUS: Восстанавливаем стили до тэга <tr>¤	m_defStyle.strTag = _T("tr");¤	if (StoreRestoreStyle(TRUE))¤		UpdateContext();¤¤} //End of DrawHtmlTableRow¤¤///////////////////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer::DrawHtmlTableCell¤//	Draw a table's cell¤//-----------------------------------------------------------------------------¤// Parameters:¤//		sCell	- a text of the cell with the tags. For example: "<td>...</td>"¤//		lpRect	- a bounding rectangle for cell¤//		sc		- the info about current cell¤///////////////////////////////////////////////////////////////////////////////¤//¤///////////////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::DrawHtmlTableCell(CPPString & sCell, LPCRECT lpRect, STRUCT_CELL & sc)¤{¤	if (MODE_DRAW != m_nNumPass)¤	{¤		sc.szText.cx = 0;¤		sc.szText.cy = 0;¤	} //if¤	¤	RECT rcCell = *lpRect;¤	RECT rcText;¤¤	//ENG: Applies styles of <td> tag¤	//RUS: Применяем стили ячейки (тэг <td>)¤	m_defStyle.strTag = _T("td");¤	StoreRestoreStyle(FALSE);¤	SelectNewHtmlStyle(m_defStyle.strTag, m_defStyle);¤¤	//ENG: Passes a tag body and get a properties of the tag¤	//RUS: Пропускаем тэг начала ячейки и получаем строку свойств тэга¤	int nIndex = 0;¤	CPPString sTag;¤	SearchNextTag(sCell, sTag, nIndex);¤	CPPString sProperties = SplitTag(sTag);¤¤	//ENG: Analyses a properties of the tag¤	//RUS: Анализируем свойства тэга¤	m_defStyle.nCellWidth = m_defStyle.nCellHeight = 0;¤	m_defStyle.bCellWidthPercent = m_defStyle.bCellHeightPercent = FALSE;¤	SIZE szSpan = AnalyseCellParam(sProperties, m_defStyle, FALSE);¤¤	if (MODE_FIRSTPASS == m_nNumPass)¤	{¤		//ENG: Stores a cell span info¤		//RUS: Сохраняем информацию об объединении ячеек¤		sc.nColSpan = szSpan.cx;¤		sc.nRowSpan = szSpan.cy;¤		//ENG: Stores an info about the recommended cell sizes¤		//RUS: Сохраняем информацию об рекомендованных размерах ячейки¤//		sc.nWidth = m_defStyle.nCellWidth;¤//		sc.bWidthPercent = m_defStyle.bCellWidthPercent;¤//		sc.nHeight = m_defStyle.nCellHeight;¤//		sc.bHeightPercent = m_defStyle.bCellHeightPercent;¤		//ENG: ¤		//RUS: Если указаны минимальные рaзмеры ячейки, то установить их как начальные¤		sc.szText.cx = m_defStyle.nCellWidth;¤//		sc.szText.cy = m_defStyle.nCellHeight;¤		sc.szText.cy = 0;¤¤		if (m_defStyle.nCellWidth > 0)¤			sc.bFixedWidth = TRUE;¤¤		rcText = rcCell;¤		rcText.right = rcText.left + sc.szText.cx;¤		rcText.bottom = rcText.top + sc.szText.cy;¤	}¤	else if (MODE_DRAW == m_nNumPass)¤	{¤		//ENG: cellspacing - margins from table's edge to the cell's edge¤		//RUS: cellspacing - отступ от контура таблицы до ячейки ¤		rcText = rcCell;¤¤		if (m_defStyle.nFillBkgnd >= 0)¤		{¤			//ENG: Filling cell background¤			//RUS: Заполнение фона ячейки¤			m_drawmanager.FillEffect(m_hDC, m_defStyle.nFillBkgnd, &rcText, ¤				m_defStyle.crBkgnd, m_defStyle.crMidBkgnd, m_defStyle.crEndBkgnd, 5);¤		} //if¤		¤		//Draws the border¤		if (m_bIsEnable) ¤			m_drawmanager.DrawRectangle(m_hDC, &rcText, m_defStyle.crBorderDark, m_defStyle.crBorderLight, m_defStyle.nBorderStyle);¤		else ¤			m_drawmanager.DrawRectangle(m_hDC, &rcText, m_crDisabled, m_crDisabled, m_defStyle.nBorderStyle);¤		¤		//ENG: cellpadding - margin from cell's edge to the inside cell text¤		//RUS: cellpadding - отступ от контура ячейки, до текста внутри ее¤		rcText.left += m_defStyle.nMargin + m_defStyle.nBorderWidth;¤		rcText.top += m_defStyle.nMargin + m_defStyle.nBorderWidth;¤		rcText.right -= m_defStyle.nMargin + m_defStyle.nBorderWidth;¤		rcText.bottom -= m_defStyle.nMargin + m_defStyle.nBorderWidth;¤		¤		//Vertical align¤		switch (m_defStyle.nVertAlign)¤		{¤		case ALIGN_BOTTOM:¤			rcText.top = rcText.bottom - sc.szText.cy;¤			break;¤		case ALIGN_VCENTER:¤			rcText.top += (rcText.bottom - rcText.top - sc.szText.cy) / 2;¤			break;¤		} //switch¤	} //if¤¤	//ENG: Draws a cell¤	//RUS: Вывод ячейки¤	while(nIndex < sCell.GetLength())¤	{¤		int nEndCell = nIndex;¤		int nNewTable = nIndex;¤		//ENG: Search an end of the cell or a begin of the nested table¤		//RUS: Ищем конец ячейки или начало вложенной таблицы¤		SearchTag(sCell, nEndCell, _T("/td"));¤		SearchTag(sCell, nNewTable, _T("table"));¤		//ENG: Gets a nearly index of the tag¤		//RUS: Получаем индекс ближайшего тэга¤		int nNearlyTag = std::min(nEndCell, nNewTable);¤		SIZE szTemp = {0, 0};¤		if (nNearlyTag > nIndex)¤		{¤			//ENG: If between the last index and the current index there is a text¤			//RUS: Если между последним индексом и текущим индексом существует текст¤			CPPString sText = sCell.Mid(nIndex, nNearlyTag - nIndex);¤			szTemp = DrawHtmlString(sText, &rcText);¤			nIndex = nNearlyTag;¤		} //if¤		else if (nNewTable < nEndCell)¤		{¤			//ENG: A nested table was found¤			//RUS: Найдена вложенная таблица¤			nIndex = nNewTable;¤			SearchEndOfTable(sCell, nIndex);¤			CPPString sTable = sCell.Mid(nNewTable, nIndex - nNewTable);¤			szTemp = DrawHtmlTable(sTable, &rcText); ¤		}¤		else¤		{¤			//ENG: Alas, it is the end of the cell¤			//RUS: Конец ячейки¤			nIndex = sCell.GetLength();¤		} //if¤		¤		if (MODE_DRAW != m_nNumPass)¤		{¤			//ENG: On first and second passes we are calculate the dimensions of the cell¤			//RUS: На первом и втором проходах вычисляем размеры ячейки.¤			sc.szText.cx = std::max(szTemp.cx, sc.szText.cx);¤			sc.szText.cy += szTemp.cy;¤		} //if¤		rcText.top += szTemp.cy;¤	} //while¤¤	if (MODE_DRAW != m_nNumPass)¤	{¤		//ENG: On first and second passes we are calculate the dimensions of the cell¤		//RUS: На первом и втором проходах вычисляем размеры ячейки.¤		sc.szCell.cx = std::max((long)m_defStyle.nCellWidth, sc.szText.cx);¤		sc.szCell.cy = std::max((long)m_defStyle.nCellHeight, sc.szText.cy);¤¤		//ENG: Add the margins of the text from the cell's edges¤		//RUS: Добавляем отступы текста от границ ячейки¤		sc.szCell.cx += 2 * (m_defStyle.nMargin + m_defStyle.nBorderWidth);¤		sc.szCell.cy += 2 * (m_defStyle.nMargin + m_defStyle.nBorderWidth);¤	} //if¤		¤	//ENG: Restore styles before <td> tag¤	//RUS: Воостанавливаем стили, которые были до тэга <td>¤	m_defStyle.strTag = _T("td");¤	if (StoreRestoreStyle(TRUE))¤		UpdateContext();¤}¤¤SIZE CPPHtmlDrawer::DrawHtmlString (CPPString & sHtml, LPCRECT lpRect)¤{¤	SIZE szTextArea = {0, 0};¤¤	COLORREF clrShadow = m_bIsEnable ? m_crShadow : GetColorByName("");¤¤	//ENG: For any string we are add a <body> tag as wrapper¤	//RUS: Для любой строки добавляем тэг <body>¤	sHtml = _T("<body>") + sHtml;¤	sHtml += _T("</body>");¤¤	//ENG: Bounding rectangle for a full text¤	//RUS: Ограничивающий прямоугольник для вывода всего текста¤	m_rcOutput.top = lpRect->top;¤	m_rcOutput.left = lpRect->left;¤	m_rcOutput.bottom = lpRect->bottom;¤	m_rcOutput.right = lpRect->right;¤¤	//ENG: The width of the bounding rectangle¤	//RUS: Ширина ограничивающего прямоугольника¤	int nTextWrapWidth = m_rcOutput.right - m_rcOutput.left;¤¤	//ENG: A current position for output¤	//RUS: Текущая позиция для вывода¤	POINT ptOutput;¤	ptOutput.x = lpRect->left;¤	ptOutput.y = lpRect->top;¤¤//	szTextArea.cx = szTextArea.cy = 0;¤//	m_szOutput.cx = m_szOutput.cy = 0;¤¤//	m_szOutput = CSize(0, 0);¤¤	//ENG: If a text is empty¤	//RUS: Если текста для вывода нет¤//	if (str.IsEmpty())¤//	{¤//		szTextArea.cx = szTextArea.cy = 0;¤//		return;¤//	} //if¤¤	int nFirstLine = m_nCurLine;¤¤//	POINT pt;¤//	pt.x = lpRect->left;¤//	pt.y = lpRect->top;¤¤	int y;¤	SIZE sz;¤¤	CPPString sText = _T("");¤	CPPString sTag = _T(""); //String of the tag¤	CPPString sProperties = _T(""); //String of the tag's property¤	CPPString sParameter = _T("");¤	CPPString sValue = _T("");¤¤	BOOL bCloseTag = FALSE; //TRUE if tag have symbol '\'¤¤	//ENG: Initializing a new line¤	//RUS: Инициализация новой строки¤	ptOutput.x = InitNewLine(ptOutput.x);¤	int nBeginLineX = ptOutput.x;¤	int nSpacesInLine = m_hline.nSpaceChars;¤	int nRealWidth = m_hline.nWidthLine;¤¤	int nIndex = 0;¤	int nBegin = 0;¤	int i = 0;¤	while (i < sHtml.GetLength())¤	{¤		//ENG: Searching a first tag¤		//RUS: Поиск первого тэга¤		sText = SearchNextTag(sHtml, sTag, i);¤		sProperties = SplitTag(sTag);¤¤		//ENG: Before a tag was exist a text¤		//RUS: Перед тэгом есть текст для вывода¤		if (!sText.IsEmpty())¤		{¤			//ENG: Transform text¤			//RUS: Преобразуем текст¤			switch (m_defStyle.nTextTransform)¤			{¤			case TEXT_TRANSFORM_UPPERCASE:¤				//ENG: All chars make upper¤				//RUS: Все символы переводим в верхний регистр¤				sText.MakeUpper();¤				break;¤			case TEXT_TRANSFORM_LOWERCASE:¤				//ENG: All chars make lower¤				//RUS: Все символы переводим в нижний регистр¤				sText.MakeLower();¤				break;¤			case TEXT_TRANSFORM_CAPITALIZE:¤				//ENG: Each first char of a word to upper¤				//RUS: Кадый первый символ слова в верхний регистр, остальные в нижний¤				sText.MakeLower();¤				for (nIndex = 0; nIndex < sText.GetLength(); nIndex++)¤				{¤					if ((sText.GetAt(nIndex) >= _T('a')) && (sText.GetAt(nIndex) <= _T('z')))¤					{¤						if ((0 == nIndex) || (_T(' ') == sText.GetAt(nIndex - 1)))¤							sText.SetAt(nIndex, sText.GetAt(nIndex) - _T('a') + _T('A'));¤					} //if¤				} //if¤				break;¤			} //switch¤¤			//RUS: Зацикливаем до тех пор, пока не будет выведен весь текст¤			while (!sText.IsEmpty())¤			{¤				//ENG: Reset an additional interval for space chars¤				//RUS: Сброс дополнительного интервала между словами¤				::SetTextJustification(m_hDC, 0, 0);¤¤				//ENG: Gets a size a output text¤				//RUS: Получаем размер выводимого текста¤				::GetTextExtentPoint32(m_hDC, sText, sText.GetLength(), &sz);¤¤				//ENG: Gets a real top coordinate to output with vertical alignment¤				//RUS: Получаем реальную коодинату верха вывода с учетом вертикального выравнивания¤				y = VerticalAlignText(ptOutput.y, sz.cy);¤¤				CPPString sTemp = sText;¤				int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;¤¤				if (m_nMaxWidth && ((nMaxSize - sz.cx) < 0) && nTextWrapWidth)¤				{¤					//ENG: Text wrap was enabled and text out for a bounding rectangle¤					int nRealSize = nMaxSize;¤					sTemp = GetWordWrap(sText, nTextWrapWidth, nRealSize);¤					sz.cx = nRealSize;¤				}¤				else¤				{¤					sText.Empty();¤				} //if¤¤				if (MODE_DRAW == m_nNumPass)¤				{¤					if (sz.cx)¤					{¤						if ((0 == (nRealWidth - sz.cx)) && (_T(' ') == sTemp.GetAt(sTemp.GetLength() - 1)))¤						{¤							//ENG: Removes the right space chars for the last output in line¤							//RUS: Если это последний вывод в строке, то убираем пробелы справа¤							sTemp.TrimRight();¤							nSpacesInLine = GetCountOfChars(sTemp);¤							SIZE szTemp;¤							::GetTextExtentPoint32(m_hDC, sTemp, sTemp.GetLength(), &szTemp);¤							nRealWidth -= (sz.cx - szTemp.cx);¤						} //if¤¤						if ((ALIGN_JUSTIFY == m_hline.nHorzAlign) && m_hline.bWrappedLine)¤							::SetTextJustification(m_hDC, nMaxSize - nRealWidth, nSpacesInLine);¤						nRealWidth -= sz.cx;¤						¤						//ENG: Gets a size a output text¤						//RUS: Получаем размер выводимого текста¤						::GetTextExtentPoint32(m_hDC, sTemp, sTemp.GetLength(), &sz);¤						¤						//ENG: Stores a current area as a hyperlink area if it available¤						//RUS: Сохранякм текущую область как область гиперлинка если он установлен¤						StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);¤						¤						//ENG: Real output a text¤						//RUS: Вывод текста¤						::TextOut(m_hDC, ptOutput.x, y, sTemp, sTemp.GetLength());¤						nSpacesInLine -= GetCountOfChars(sTemp);¤						¤						//ENG: If sets an overline style then draw a line over the text¤						//RUS: Если установлен стиль overline, то рисуем линию над текстом¤						if (m_defStyle.bOverlineFont)¤						{¤							HPEN hpenOverline = ::CreatePen(PS_SOLID, (m_defStyle.nWeightFont >= FW_BOLD) ? 2 : 1, m_defStyle.crText);¤							HPEN hOldPen = (HPEN)::SelectObject(m_hDC, hpenOverline);¤							::MoveToEx(m_hDC, ptOutput.x, y, NULL);¤							::LineTo(m_hDC, ptOutput.x + sz.cx, y);¤							::SelectObject(m_hDC, hOldPen);¤						} //if¤					} //if¤				}¤				else¤				{¤					//ENG: Stores a last horizontal alignment¤					//RUS: Сохраняем последнее горизонтальное выравнивание¤					m_hline.nHorzAlign = m_defStyle.nHorzAlign;¤¤					//ENG:¤					//RUS:¤					m_hline.nSpaceChars += GetCountOfChars(sTemp);¤				} //if¤¤				//ENG: Moves to a right of the outputed text¤				//RUS: Перемещаемся справа от выведенного текста¤				ptOutput.x += sz.cx;¤				if (!sText.IsEmpty())¤				{¤					//ENG: Not all text was printed (cause text wrap) ¤					//RUS: Не вся строка еще вывелась (в случае переноса текста)¤					m_hline.bWrappedLine = TRUE;¤					Tag_NewLine(&ptOutput, 1, &szTextArea);¤					nBeginLineX = ptOutput.x;¤					nSpacesInLine = m_hline.nSpaceChars;¤					nRealWidth = m_hline.nWidthLine;¤				}¤			} //while¤		} //if¤¤		//ENG: If tag was found then analyzing ...¤		//RUS: Если тэг найден, анализируем ...¤		if (!sTag.IsEmpty())¤		{¤			//ENG: Reset temporary parameters¤			//RUS: Сброс временных параметров¤			m_defStyle.strTag.Empty();¤			bCloseTag = FALSE;¤			¤			//ENG: Get Tag's name¤			//RUS: Получаем имя тэга¤			nIndex = 0;¤			¤			//ENG: Searching a tag's value¤			//RUS: Поиск значения тэга¤			DWORD dwTag = GetTagFromList(sTag, m_defStyle.strTag, bCloseTag);¤			¤			//ENG: If a tag was found in a list of the tags¤			//RUS: Если тэг найден в списке¤			if (TAG_NONE != dwTag)¤			{¤				//ENG: If it is a style tag ¤				//RUS: Если текущий тэг для работы со стилями¤				if (!m_defStyle.strTag.IsEmpty())¤				{¤					//ENG: Checks on permissibility of tag¤					//RUS: Проверяем на допустимость тэга¤					if (StoreRestoreStyle(bCloseTag))¤					{¤						//ENG: If it isn't a close tag¤						//RUS: Если это не окончание тэга¤						if (!bCloseTag)¤						{¤							//ENG: Processing a tag¤							//RUS: Обработка тэга¤							switch (dwTag)¤							{¤							case TAG_BOLD:¤								m_defStyle.nWeightFont <<= 1;¤								if (m_defStyle.nWeightFont > FW_BLACK)¤									m_defStyle.nWeightFont = FW_BLACK;¤								break;¤							case TAG_ITALIC:¤								m_defStyle.bItalicFont = m_defStyle.bItalicFont ? FALSE : TRUE;¤								break;¤							case TAG_UNDERLINE:¤								m_defStyle.bUnderlineFont = m_defStyle.bUnderlineFont ? FALSE : TRUE;¤								break;¤							case TAG_STRIKEOUT:¤								m_defStyle.bStrikeOutFont = m_defStyle.bStrikeOutFont ? FALSE : TRUE;¤								break;¤							case TAG_FONT:¤								//Search parameters¤								while (nIndex < sProperties.GetLength())¤								{¤									//ENG: Searching a parameters of a tag¤									//RUS: Поиск параметров тэга¤									sValue = GetNextProperty(sProperties, nIndex, sParameter);¤									//ENG: If a parameter was found¤									//RUS: Если параметр найден¤									if (!sParameter.IsEmpty())¤									{¤										//ENG: Processing a parameters of a tag¤										//RUS: Обработка параметров тэга¤										if (sParameter == _T("face"))¤											m_defStyle.sFaceFont = GetStyleString(sValue, m_defStyle.sFaceFont);¤										else if (sParameter == _T("size"))¤											m_defStyle.nSizeFont = GetLengthUnit(sValue, m_defStyle.nSizeFont, TRUE);¤										else if (sParameter == _T("color"))¤										{¤											if (m_bIsEnable)¤												m_defStyle.crText = GetStyleColor(sValue, m_defStyle.crText);¤											else¤												m_defStyle.crText = GetColorByName("");¤										}¤										else if (sParameter == _T("style"))¤											GetStyleFontShortForm(sValue);¤										else if (sParameter == _T("weight"))¤											m_defStyle.nWeightFont = GetStyleFontWeight(sValue, m_defStyle.nWeightFont);¤										else if (sParameter == _T("bkgnd"))¤										{¤											if (((sValue == _T("transparent")) && sValue.IsEmpty()) || !m_bIsEnable)¤											{¤												m_defStyle.nBkMode = TRANSPARENT;¤											}¤											else¤											{¤												m_defStyle.nBkMode = OPAQUE;¤												m_defStyle.crBkgnd = GetStyleColor(sValue, m_defStyle.crBkgnd);¤											} //if¤										} //if¤									} //if¤								} //while¤								break;¤							case TAG_LEFT:¤								m_defStyle.nHorzAlign = ALIGN_LEFT;¤								break;¤							case TAG_CENTER:¤								m_defStyle.nHorzAlign = ALIGN_CENTER;¤								break;¤							case TAG_RIGHT:¤								m_defStyle.nHorzAlign = ALIGN_RIGHT;¤								break;¤							case TAG_JUSTIFY:¤								m_defStyle.nHorzAlign = ALIGN_JUSTIFY;¤								break;¤							case TAG_BASELINE:¤								m_defStyle.nVertAlign = ALIGN_BASELINE;¤								break;¤							case TAG_TOP:¤								m_defStyle.nVertAlign = ALIGN_TOP;¤								break;¤							case TAG_VCENTER:¤								m_defStyle.nVertAlign = ALIGN_VCENTER;¤								break;¤							case TAG_BOTTOM:¤								m_defStyle.nVertAlign = ALIGN_BOTTOM;¤								break;¤							case TAG_NEWSTYLE:¤								SelectNewHtmlStyle(sTag, m_defStyle);¤								break;¤							case TAG_SPAN:¤								while (nIndex < sProperties.GetLength())¤								{¤									//ENG: Searching a parameters of a tag¤									//RUS: Поиск параметров тэга¤									sValue = GetNextProperty(sProperties, nIndex, sParameter);¤									//ENG: If a parameter was found¤									//RUS: Если параметр найден¤									if (sParameter == _T("class"))¤										SelectNewHtmlStyle(_T(".") + GetStyleString(sValue, _T("")), m_defStyle);¤								} //while¤								break;¤							case TAG_HYPERLINK:¤								//ENG: A default values¤								//RUS: Значения по умолчанию¤								m_defStyle.nTypeLink = LINK_MESSAGE;¤								m_defStyle.sHyperlink.Empty();¤								while (nIndex < sProperties.GetLength())¤								{¤									//ENG: Searching a parameters of a tag¤									//RUS: Поиск параметров тэга¤									sValue = GetNextProperty(sProperties, nIndex, sParameter);¤									//ENG: If a parameter was found¤									//RUS: Если параметр найден¤									if (!sParameter.IsEmpty())¤									{¤										//ENG: Processing a parameters of a tag¤										//RUS: Обработка параметров тэга¤										if (sParameter == _T("href"))¤										{¤											m_defStyle.nTypeLink = LINK_HREF;¤											m_defStyle.sHyperlink = GetStyleString(sValue, _T(""));¤										} //if¤										if (sParameter == _T("msg"))¤										{¤											m_defStyle.nTypeLink = LINK_MESSAGE;¤											m_defStyle.sHyperlink = GetStyleString(sValue, _T(""));¤										} //if¤									} //if¤								} //while¤								//ENG: Gets a index of a current link¤								//RUS: Получаем индекс текущей гиперссылки¤								m_nCurIndexLink ++;¤								//ENG: If a mouse over this link¤								//RUS: Если мыш над этим тэгом¤								if (m_nCurIndexLink == m_nHoverIndexLink)¤									SelectNewHtmlStyle(_T("a:hover"), m_defStyle);¤								else¤									SelectNewHtmlStyle(_T("a:link"), m_defStyle);¤								break;¤								} //switch¤							} //if¤							//ENG: Update a device context¤							//RUS: Обновление контекста устройства¤							UpdateContext();¤						} //if¤					}¤					else ¤					{¤						BOOL bPercent;¤						BOOL bShadow;¤						BOOL bAutoDelete;¤						int nWidth, nNum;¤						¤						STRUCT_IMAGE si;¤						STRUCT_CHANGESTYLE csTemp; //Temporary structure¤						STRUCT_ANIMATION sa;¤						¤						SIZE szReal;¤						HBITMAP hBitmap = NULL;;¤						HICON hIcon = NULL;¤						¤						DWORD nMaxCol, nMaxRow;¤						UINT nIdRes, nIdDll;¤						//CPPString str;¤						¤						//ENG: Processing a tag¤						//RUS: Обработка тэга¤						switch (dwTag)¤						{¤						case TAG_HLINE:¤							//ENG: Draws the horizontal line¤							//RUS: Рисование горизонтальной линии¤							csTemp = m_defStyle;¤							csTemp.nBorderWidth = 1;¤							//ENG: Applies a new styles for <hr> tag¤							SelectNewHtmlStyle(_T("hr"), csTemp);¤							nWidth = 100;¤							bPercent = TRUE;¤							¤							while (nIndex < sProperties.GetLength())¤							{¤								//ENG: Searching a parameters of a tag¤								//RUS: Поиск параметров тэга¤								sValue = GetNextProperty(sProperties, nIndex, sParameter);¤								//ENG: If a parameter was found¤								//RUS: Если параметр найден¤								if (!sParameter.IsEmpty())¤								{¤									//ENG: Processing a parameters of a tag¤									//RUS: Обработка параметров тэга¤									if (sParameter == _T("width"))¤									{¤										bPercent = IsPercentableValue(sValue);¤										nWidth = GetLengthUnit(sValue, 100);¤									}¤									else if (sParameter == _T("size"))¤										csTemp.nBorderWidth = GetLengthUnit(sValue, csTemp.nBorderWidth);¤									else if (sParameter == _T("color"))¤									{¤										if (m_bIsEnable)¤											csTemp.crText = GetStyleColor(sValue, csTemp.crText);¤										else¤											csTemp.crText = GetColorByName("");¤									}¤								} //if¤							} //while¤							¤							if (bPercent)¤							{¤								if (MODE_FIRSTPASS == m_nNumPass)¤								{¤									m_hline.nAddPercentWidth += nWidth;¤									nWidth = 1;¤								}¤								else nWidth = ::MulDiv(lpRect->right - lpRect->left, nWidth, 100);¤							} //if¤							¤							if (MODE_FIRSTPASS == m_nNumPass)¤							{¤								m_hline.nHeightLine = std::max(m_hline.nHeightLine, csTemp.nBorderWidth + 8);¤								m_hline.nHorzAlign = m_defStyle.nHorzAlign; //Store a last horizontal alignment¤							}¤							else if (MODE_DRAW == m_nNumPass)¤							{¤								m_drawmanager.DrawLine(m_hDC, ptOutput.x, ptOutput.y + m_hline.nHeightLine / 2, ¤									ptOutput.x + nWidth, ptOutput.y + m_hline.nHeightLine / 2, ¤									csTemp.crText, CPPDrawManager::PEN_SOLID, csTemp.nBorderWidth);¤							} //if¤							ptOutput.x += nWidth;¤							break;¤						case TAG_NEWLINE:¤							//ENG: New line¤							//RUS: Новая строка¤							nNum = 1;¤							if (!sProperties.IsEmpty())¤							{¤								sProperties = sProperties.Mid(1);¤								nNum = GetLengthUnit(sProperties, nNum);¤							} //if¤							m_hline.bWrappedLine = FALSE;¤							Tag_NewLine(&ptOutput, nNum, &szTextArea);¤							nBeginLineX = ptOutput.x;¤							nSpacesInLine = m_hline.nSpaceChars;¤							nRealWidth = m_hline.nWidthLine;¤							break;¤						case TAG_TABULATION:¤							//ENG: Tabulation¤							//RUS: Табуляция¤							nNum = 1;¤							if (!sProperties.IsEmpty())¤							{¤								sProperties = sProperties.Mid(1);¤								nNum = GetLengthUnit(sProperties, nNum);¤							} //if¤							Tag_Tabulation(&ptOutput, nNum);¤							break;¤						case TAG_BITMAP:¤							//-----------------------------¤							//Draws the bitmap ¤							//-----------------------------¤							//ENG: Default Parameters¤							//RUS: Параметры по умолчанию¤							si.nIdRes = 0;¤							si.nIdDll = 0;¤							si.nHandle = 0;¤							si.nWidth = 100;¤							si.bPercentWidth = TRUE;¤							si.nHeight = 100;¤							si.bPercentHeight = TRUE;¤							si.crMask = RGB(255, 0, 255);¤							si.bUseMask = FALSE;¤							si.nStyles = 0;¤							si.nHotStyles = 0;¤							si.strSrcFile.Empty();¤							si.strPathDll.Empty();¤							¤							//ENG: Searching image parameters¤							//RUS: Поиск параметров изображения¤							AnalyseImageParam(sProperties, si);¤							¤							//ENG: If a image's source was specified¤							//RUS: Если указан источник изображения¤							if (si.nIdRes || si.nIdDll || si.nHandle || !si.strSrcFile.IsEmpty())¤							{¤								//ENG: Sets a autodelete flag of the image object¤								//RUS: Установлен флаг автоматического удаления объекта изображения¤								bAutoDelete = TRUE;¤								¤								//ENG: Gets a handle of the image¤								//RUS: Получить дескриптор изображения¤								if (si.nIdRes)¤									hBitmap = GetBitmapFromResources(si.nIdRes);¤								else if (!si.strSrcFile.IsEmpty())¤									hBitmap = GetBitmapFromFile(si.strSrcFile);¤								else if (si.nIdDll)¤									hBitmap = GetBitmapFromDll(si.nIdDll, si.strPathDll);¤								else if (si.nHandle)¤								{¤									hBitmap = (HBITMAP)si.nHandle;¤									//ENG: If an image handle specified, disables autodelete¤									//RUS: Если указан дескриптор изображения, то запрещаем удаление¤									bAutoDelete = FALSE;¤								} //if¤								¤								//ENG: If a handle of an image was retrieved¤								//RUS: Если дескриптор изображения получен¤								if (NULL != hBitmap)¤								{¤									//ENG: Image with shadow or not?¤									//RUS: Изображение с тенью или нет¤									bShadow = IsImageWithShadow(si);¤									¤									//ENG: Retrieves an original size of an image¤									//RUS: Получаем оригинальный размер изображения¤									m_drawmanager.GetSizeOfBitmap(hBitmap, &sz);¤									¤									//ENG: Retrieves an output size¤									//RUS: Получаем размеры для рисования¤									if (si.bPercentWidth) si.nWidth = ::MulDiv(sz.cx, si.nWidth, 100);¤									if (si.bPercentHeight) si.nHeight = ::MulDiv(sz.cy, si.nHeight, 100);¤									¤									//ENG: If a shadow was enabled then set a real size¤									//RUS: Если тень доступна, то устанавливаем реальный размер¤									if (si.nWidth && si.nHeight && bShadow)¤									{¤										sz.cx = si.nWidth + m_szOffsetShadow.cx;¤										sz.cy = si.nHeight + m_szOffsetShadow.cy;¤									} //if¤									¤									int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;¤									if (m_nMaxWidth && ((nMaxSize - sz.cx) < 0) && nTextWrapWidth) ¤									{¤										//ENG: Not all text was printed (cause text wrap) ¤										//RUS: Не вся строка еще вывелась (в случае переноса текста)¤										m_hline.bWrappedLine = TRUE;¤										Tag_NewLine(&ptOutput, 1, &szTextArea);¤										nBeginLineX = ptOutput.x;¤										nSpacesInLine = m_hline.nSpaceChars;¤										nRealWidth = m_hline.nWidthLine;¤									} //if¤									nRealWidth -= sz.cx;¤¤									//ENG: Store a last horizontal alignment¤									//RUS: Запоминаем последнее горизонтальное выравнивание¤									if (MODE_FIRSTPASS == m_nNumPass) ¤										m_hline.nHorzAlign = m_defStyle.nHorzAlign;¤									¤									//ENG: Retrieves a vertical coordinates of drawing area¤									//RUS: Получаем вертикальную координату области рисования¤									y = VerticalAlignImage(ptOutput.y, si.nHeight);¤									¤									//ENG: If an image is exist and not prepare mode¤									//RUS: Если изображение доступно и не установлен режим подготовки¤									if (si.nWidth && si.nHeight && (MODE_DRAW == m_nNumPass))¤									{¤										//ENG: Add an output area to hyperlink list if needed¤										//RUS: Если необходимо добавляем область вывода в список гиперссылок¤										StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);¤										¤										//ENG: If a mouse over an image then applies a hot styles¤										//RUS: Если мышь над изображением, то применяем соотвествующие стили¤										if (m_defStyle.nTypeLink != LINK_NONE)¤										{¤											if (m_nCurIndexLink == m_nHoverIndexLink)¤												si.nStyles = si.nHotStyles;¤										} //if¤										¤										if (!m_bIsEnable)¤											si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;¤										¤										//ENG: Drawing an image¤										//RUS: Рисование изображения¤										m_drawmanager.DrawBitmap(m_hDC, ptOutput.x, y, si.nWidth, si.nHeight, hBitmap, ¤											si.bUseMask, si.crMask, si.nStyles, ¤											bShadow, ¤											m_szOffsetShadow.cx, m_szOffsetShadow.cy, ¤											m_szDepthShadow.cx, m_szDepthShadow.cy, ¤											clrShadow);¤									} //if¤									¤									//ENG: Moves to a right of the outputed image¤									//RUS: Перемещаемся справа от выведенного изображения¤									ptOutput.x += sz.cx; //si.nWidth;¤									¤									//ENG: If needed delete a handle of an image¤									//RUS: Если необходимо удаляем дескриптор изображения¤									if (bAutoDelete)¤										::DeleteObject(hBitmap);¤								} //if¤							} //if¤							break;¤						case TAG_ICON:¤							//-----------------------------¤							//Draws the icon¤							//-----------------------------¤							//ENG: Default Parameters¤							//RUS: Параметры по умолчанию¤							si.nIdRes = 0;¤							si.nIdDll = 0;¤							si.nHandle = 0;¤							si.nWidth = 100;¤							si.bPercentWidth = TRUE;¤							si.nHeight = 100;¤							si.bPercentHeight = TRUE;¤							si.nStyles = 0;¤							si.nHotStyles = 0;¤							si.strSrcFile.Empty();¤							si.strPathDll.Empty();¤							¤							//ENG: Searching image parameters¤							//RUS: Поиск параметров изображения¤							AnalyseImageParam(sProperties, si);¤							¤							//ENG: If a image's source was specified¤							//RUS: Если указан источник изображения¤							if (si.nIdRes || si.nIdDll || si.nHandle || !si.strSrcFile.IsEmpty())¤							{¤								//ENG: Sets a autodelete flag of the image object¤								//RUS: Установлен флаг автоматического удаления объекта изображения¤								bAutoDelete = TRUE;¤								¤								//RUS: Получаем требуемый размер иконки¤								sz.cx = si.nWidth;¤								sz.cy = si.nHeight;¤								if (si.bPercentWidth) sz.cx = ::MulDiv(::GetSystemMetrics(SM_CXICON), si.nWidth, 100);¤								if (si.bPercentHeight) sz.cy = ::MulDiv(::GetSystemMetrics(SM_CYICON), si.nHeight, 100);¤								¤								//ENG: Gets a handle of the image¤								//RUS: Получить дескриптор изображения¤								if (si.nIdRes)¤									hIcon = GetIconFromResources(si.nIdRes, sz.cx, sz.cy);¤								else if (!si.strSrcFile.IsEmpty())¤									hIcon = GetIconFromFile(si.strSrcFile, sz.cx, sz.cy);¤								else if (si.nIdDll)¤									hIcon = GetIconFromDll(si.nIdDll, sz.cx, sz.cy, si.strPathDll);¤								else if (si.nHandle)¤								{¤									hIcon = (HICON)si.nHandle;¤									¤									//ENG: If an image handle specified, disables autodelete¤									//RUS: Если указан дескриптор изображения, то запрещаем удаление¤									bAutoDelete = FALSE;¤								} //if¤								¤								//ENG: If a handle of an image was retrieved¤								//RUS: Если дескриптор изображения получен¤								if (NULL != hIcon)¤								{¤									//ENG: Image with shadow or not?¤									//RUS: Изображение с тенью или нет¤									BOOL bShadow = IsImageWithShadow(si);¤									¤									//ENG: Retrieves an original size of an image¤									//RUS: Получаем оригинальный размер изображения¤									m_drawmanager.GetSizeOfIcon(hIcon, &sz);¤									si.nWidth = sz.cx;¤									si.nHeight = sz.cy;¤									¤									//ENG: Retrieves an output size¤									//RUS: Получаем размеры для рисования¤									//									if (si.bPercentWidth) si.nWidth = ::MulDiv(sz.cx, si.nWidth, 100);¤									//									if (si.bPercentHeight) si.nHeight = ::MulDiv(sz.cy, si.nHeight, 100);¤									¤									//ENG: If a shadow was enabled then set a real size¤									//RUS: Если тень доступна, то устанавливаем реальный размер¤									if (si.nWidth && si.nHeight && bShadow)¤									{¤										sz.cx = si.nWidth + m_szOffsetShadow.cx;¤										sz.cy = si.nHeight + m_szOffsetShadow.cy;¤									} //if¤¤									int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;¤									if (m_nMaxWidth && ((nMaxSize - sz.cx) < 0) && nTextWrapWidth) ¤									{¤										//ENG: Not all text was printed (cause text wrap) ¤										//RUS: Не вся строка еще вывелась (в случае переноса текста)¤										m_hline.bWrappedLine = TRUE;¤										Tag_NewLine(&ptOutput, 1, &szTextArea);¤										nBeginLineX = ptOutput.x;¤										nSpacesInLine = m_hline.nSpaceChars;¤										nRealWidth = m_hline.nWidthLine;¤									} //if¤									nRealWidth -= sz.cx;¤									¤									//ENG: Store a last horizontal alignment¤									//RUS: Запоминаем последнее горизонтальное выравнивание¤									if (MODE_FIRSTPASS == m_nNumPass) ¤										m_hline.nHorzAlign = m_defStyle.nHorzAlign;¤									¤									//ENG: Retrieves a vertical coordinates of drawing area¤									//RUS: Получаем вертикальную координату области рисования¤									y = VerticalAlignImage(ptOutput.y, si.nHeight);¤									¤									//ENG: If an image is exist and not prepare mode¤									//RUS: Если изображение доступно и не установлен режим подготовки¤									if (si.nWidth && si.nHeight && (MODE_DRAW == m_nNumPass))¤									{¤										//ENG: Add an output area to hyperlink list if needed¤										//RUS: Если необходимо добавляем область вывода в список гиперссылок¤										StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);¤										¤										//ENG: If a mouse over an image then applies a hot styles¤										//RUS: Если мышь над изображением, то применяем соотвествующие стили¤										if (m_defStyle.nTypeLink != LINK_NONE)¤										{¤											if (m_nCurIndexLink == m_nHoverIndexLink)¤												si.nStyles = si.nHotStyles;¤										} //if¤										¤										if (!m_bIsEnable)¤											si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;¤										¤										//ENG: Drawing an image¤										//RUS: Рисование изображения¤										m_drawmanager.DrawIcon(m_hDC, ptOutput.x, y, si.nWidth, si.nHeight, hIcon, si.nStyles, ¤											bShadow, ¤											m_szOffsetShadow.cx, m_szOffsetShadow.cy, ¤											m_szDepthShadow.cx, m_szDepthShadow.cy, ¤											clrShadow);¤									} //if¤									//ENG: Moves to a right of the outputed image¤									//RUS: Перемещаемся справа от выведенного изображения¤									ptOutput.x += sz.cx; //si.nWidth;¤									¤									//ENG: If needed delete a handle of an image¤									//RUS: Если необходимо удаляем дескриптор изображения¤									if (bAutoDelete) ¤										::DestroyIcon(hIcon);¤								} //if¤							} //if¤							break;¤						case TAG_IMAGELIST:¤							//-----------------------------¤							//Draws the icon from image list¤							//-----------------------------¤							//ENG: Default Parameters¤							//RUS: Параметры по умолчанию¤							si.nIndexImageList = 0;¤							si.nIdRes = 0;¤							si.nIdDll = 0;¤							si.nHandle = 0;¤							si.nWidth = 100;¤							si.bPercentWidth = TRUE;¤							si.nHeight = 100;¤							si.bPercentHeight = TRUE;¤							si.nSpeed = 0;¤							si.bUseMask = FALSE;¤							si.crMask = RGB(255, 0, 255);¤							si.cx = 0;//GetSystemMetrics(SM_CXICON);¤							si.cy = 0;//GetSystemMetrics(SM_CYICON);¤							si.nStyles = 0;¤							si.nHotStyles = 0;¤							si.strSrcFile.Empty();¤							si.strPathDll.Empty();¤							¤							//ENG: Searching image parameters¤							//RUS: Поиск параметров изображения¤							AnalyseImageParam(sProperties, si);¤							¤							//ENG: Image with shadow or not?¤							//RUS: Изображение с тенью или нет¤							bShadow = IsImageWithShadow(si);¤							¤							if (si.nIdRes || si.nIdDll || si.nHandle || !si.strSrcFile.IsEmpty())¤							{¤								//ENG: Sets a autodelete flag of the image object¤								//RUS: Установлен флаг автоматического удаления объекта изображения¤								bAutoDelete = TRUE;¤								¤								//ENG: Gets a handle of the image¤								//RUS: Получить дескриптор изображения¤								if (si.nIdRes)¤									hBitmap = GetBitmapFromResources(si.nIdRes);¤								else if (!si.strSrcFile.IsEmpty())¤									hBitmap = GetBitmapFromFile(si.strSrcFile);¤								else if (si.nIdDll)¤									hBitmap = GetBitmapFromDll(si.nIdDll, si.strPathDll);¤								else if (si.nHandle)¤								{¤									hBitmap = (HBITMAP)si.nHandle;¤									//ENG: If an image handle specified, disables autodelete¤									//RUS: Если указан дескриптор изображения, то запрещаем удаление¤									bAutoDelete = FALSE;¤								} //if¤								¤								//ENG: If a handle of an image was retrieved¤								//RUS: Если дескриптор изображения получен¤								if (NULL != hBitmap)¤								{¤									//ENG: Retrieves an original size of an image¤									//RUS: Получаем оригинальный размер изображения¤									m_drawmanager.GetSizeOfBitmap(hBitmap, &sz);¤¤									//ENG: Creates a no specified sizes¤									//RUS: Создаем незаданные размеры¤									if (!si.cx && !si.cy)¤										si.cx = si.cy = std::min(sz.cx, sz.cy);¤									else if (!si.cx)¤										si.cx = si.cy;¤									else if (!si.cy)¤										si.cy = si.cx;¤									¤									//ENG: Retrieves an output size¤									//RUS: Получаем размеры для рисования¤									if (si.bPercentWidth) si.nWidth = ::MulDiv(si.cx, si.nWidth, 100);¤									if (si.bPercentHeight) si.nHeight = ::MulDiv(si.cy, si.nHeight, 100);¤									¤									//ENG: If a shadow was enabled then set a real size¤									//RUS: Если тень доступна, то устанавливаем реальный размер¤									szReal.cx = si.nWidth;¤									szReal.cy = si.nHeight;¤									if (si.nWidth && si.nHeight && bShadow)¤									{¤										szReal.cx += m_szOffsetShadow.cx;¤										szReal.cy += m_szOffsetShadow.cy;¤									} //if¤									¤									//ENG: Gets a max columns and rows of the images on the bitmap¤									//RUS: Получаем максимальное число колонок и строк изображений на битмапке¤									nMaxCol = sz.cx / si.cx;¤									nMaxRow = sz.cy / si.cy;¤									¤									if (si.nSpeed)¤									{¤										if (MODE_FIRSTPASS == m_nNumPass)¤										{¤											sa.nIndex = si.nIndexImageList;¤											sa.nMaxImages = nMaxCol * nMaxRow;¤											sa.nSpeed = si.nSpeed;¤											sa.nTimerCount = 0;¤											m_arrAni.push_back(sa);¤										}¤										else if (MODE_DRAW == m_nNumPass)¤										{¤											m_nCurIndexAni ++;¤											sa = m_arrAni [m_nCurIndexAni];¤											si.nIndexImageList = sa.nIndex;¤										} //if¤									} //if¤									¤									//ENG: If a specified index of image is a legitimate value¤									//RUS: Если указанный индекс изображения допустим¤									if ((si.nIndexImageList < (int)(nMaxCol * nMaxRow)) && nMaxCol && nMaxRow)¤									{¤										int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;¤										if (m_nMaxWidth && ((nMaxSize - szReal.cx) < 0) && nTextWrapWidth) ¤										{¤											//ENG: Not all text was printed (cause text wrap) ¤											//RUS: Не вся строка еще вывелась (в случае переноса текста)¤											m_hline.bWrappedLine = TRUE;¤											Tag_NewLine(&ptOutput, 1, &szTextArea);¤											nBeginLineX = ptOutput.x;¤											nSpacesInLine = m_hline.nSpaceChars;¤											nRealWidth = m_hline.nWidthLine;¤										} //if¤										nRealWidth -= szReal.cx;¤										¤										//ENG: Store a last horizontal alignment¤										//RUS: Запоминаем последнее горизонтальное выравнивание¤										if (MODE_FIRSTPASS == m_nNumPass) ¤											m_hline.nHorzAlign = m_defStyle.nHorzAlign;¤										¤										//ENG: Retrieves a vertical coordinates of drawing area¤										//RUS: Получаем вертикальную координату области рисования¤										y = VerticalAlignImage(ptOutput.y, szReal.cy);¤										¤										//ENG: If an image is exist and not prepare mode¤										//RUS: Если изображение доступно и не установлен режим подготовки¤										if (si.nWidth && si.nHeight && (MODE_DRAW == m_nNumPass))¤										{¤											//ENG: Add an output area to hyperlink list if needed¤											//RUS: Если необходимо добавляем область вывода в список гиперссылок¤											StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + szReal.cx, y + szReal.cy);¤											¤											//ENG: If a mouse over an image then applies a hot styles¤											//RUS: Если мышь над изображением, то применяем соотвествующие стили¤											if (m_defStyle.nTypeLink != LINK_NONE)¤											{¤												if (m_nCurIndexLink == m_nHoverIndexLink)¤													si.nStyles = si.nHotStyles;¤											} //if¤											¤											if (!m_bIsEnable)¤												si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;¤											¤											//ENG: Drawing an image¤											//RUS: Рисование изображения¤											m_drawmanager.DrawImageList(m_hDC, ptOutput.x, y, si.nWidth, si.nHeight, hBitmap,¤												si.nIndexImageList, si.cx, si.cy,¤												si.bUseMask, si.crMask, si.nStyles, ¤												bShadow, ¤												m_szOffsetShadow.cx, m_szOffsetShadow.cy, ¤												m_szDepthShadow.cx, m_szDepthShadow.cy, ¤												clrShadow);¤										} //if¤										¤										//ENG: Moves to a right of the outputed image¤										//RUS: Перемещаемся справа от выведенного изображения¤										ptOutput.x += szReal.cx;¤									} //if¤									¤									//ENG: If needed delete a handle of an image¤									//RUS: Если необходимо удаляем дескриптор изображения¤									if (bAutoDelete)¤										::DeleteObject(hBitmap);¤								} //if¤							}¤							else if (NULL != m_hImageList)¤							{¤								// Ensure that the common control DLL is loaded. ¤								InitCommonControls(); ¤¤								if ((int)si.nIndexImageList < ImageList_GetImageCount(m_hImageList))¤								{¤									hIcon = ImageList_ExtractIcon(NULL, m_hImageList, si.nIndexImageList);¤									if (NULL != hIcon)¤									{¤										sz.cx = si.nWidth;¤										sz.cy = si.nHeight;¤										if (si.bPercentWidth) sz.cx = ::MulDiv(m_szImageList.cx, si.nWidth, 100);¤										if (si.bPercentHeight) sz.cy = ::MulDiv(m_szImageList.cy, si.nHeight, 100);¤										¤										szReal.cx = sz.cx;¤										szReal.cy = sz.cy;¤										if (sz.cx && sz.cy && bShadow)¤										{¤											szReal.cx += m_szOffsetShadow.cx;¤											szReal.cy += m_szOffsetShadow.cy;¤										} //if¤										¤										int nMaxSize = nTextWrapWidth - ptOutput.x + m_rcOutput.left;¤										if (m_nMaxWidth && ((nMaxSize - szReal.cx) < 0) && nTextWrapWidth) ¤										{¤											//ENG: Not all text was printed (cause text wrap) ¤											//RUS: Не вся строка еще вывелась (в случае переноса текста)¤											m_hline.bWrappedLine = TRUE;¤											Tag_NewLine(&ptOutput, 1, &szTextArea);¤											nBeginLineX = ptOutput.x;¤											nSpacesInLine = m_hline.nSpaceChars;¤											nRealWidth = m_hline.nWidthLine;¤										} //if¤										nRealWidth -= sz.cx;¤¤										if (MODE_FIRSTPASS == m_nNumPass) ¤											m_hline.nHorzAlign = m_defStyle.nHorzAlign; //Store a last horizontal alignment¤										y = VerticalAlignImage(ptOutput.y, szReal.cy);¤										if (sz.cx && sz.cy && (MODE_DRAW == m_nNumPass))¤										{¤											StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + szReal.cx, y + szReal.cy);¤											¤											if (m_defStyle.nTypeLink != LINK_NONE)¤											{¤												if (m_nCurIndexLink == m_nHoverIndexLink)¤													si.nStyles = si.nHotStyles;¤											} //if¤											¤											if (!m_bIsEnable)¤												si.nStyles = (si.nStyles & 0xFF00) | IMAGE_EFFECT_MONOCHROME;¤											¤											m_drawmanager.DrawIcon(m_hDC, ptOutput.x, y, ¤												sz.cx, sz.cy, hIcon, si.nStyles, ¤												bShadow, ¤												m_szOffsetShadow.cx, m_szOffsetShadow.cy, ¤												m_szDepthShadow.cx, m_szDepthShadow.cy, ¤												clrShadow);¤											::DestroyIcon(hIcon);¤										} //if¤										ptOutput.x += szReal.cx;¤									} //if¤								} //if¤							} //if¤							break;¤						case TAG_STRING:¤							//-----------------------------¤							//Draws the string¤							//-----------------------------¤							nIdRes = 0;¤							nIdDll = 0;¤							sText.Empty();¤							while (nIndex < sProperties.GetLength())¤							{¤								//ENG: Searching a parameters of a tag¤								//RUS: Поиск параметров тэга¤								sValue = GetNextProperty(sProperties, nIndex, sParameter);¤								//ENG: If a parameter was found¤								//RUS: Если параметр найден¤								if (!sParameter.IsEmpty())¤								{¤									if (sParameter == _T("idres"))¤										nIdRes = GetLengthUnit(sValue, nIdRes);¤									else if (sParameter == _T("iddll"))¤										nIdRes = GetLengthUnit(sValue, nIdDll);¤									else if (sParameter == _T("srcdll"))¤										sText = GetStyleString(sValue, sText);¤								} //if¤							} //while¤							if (nIdRes || nIdDll)¤							{¤								if (nIdRes)¤									sText = GetStringFromResource(nIdRes);¤								else if (nIdDll)¤									sText = GetStringFromDll(nIdDll, sText);¤								¤								if (!sText.IsEmpty())¤								{¤									::GetTextExtentPoint32(m_hDC, sText, sText.GetLength(), &sz);¤									if (MODE_FIRSTPASS == m_nNumPass) m_hline.nHorzAlign = m_defStyle.nHorzAlign; //Store a last horizontal alignment¤									y = VerticalAlignText(ptOutput.y, sz.cy);¤									if (MODE_DRAW == m_nNumPass)¤									{¤										StoreHyperlinkArea(ptOutput.x, y, ptOutput.x + sz.cx, y + sz.cy);¤										::TextOut(m_hDC, ptOutput.x, y, sText, sText.GetLength());¤									} //if¤									ptOutput.x += sz.cx;¤								} //if¤							} //if¤							break;¤						} //switch¤					} //if¤				} //if¤		} //if¤	} //for¤	if (nBeginLineX != ptOutput.x)¤	{¤		m_hline.bWrappedLine = FALSE;¤		Tag_NewLine(&ptOutput, 1, &szTextArea);¤	}¤¤	//ENG: Reset an additional interval for space chars¤	//RUS: Сброс дополнительного интервала между словами¤	::SetTextJustification(m_hDC, 0, 0);¤¤	szTextArea.cy = ptOutput.y - lpRect->top;¤¤	//Adds the percent's length to the line's length¤	for (i = nFirstLine; i < m_nCurLine; i++)¤	{¤		m_hline = m_arrHtmlLine [i];¤		if (0 != m_hline.nAddPercentWidth)¤		{¤			m_hline.nWidthLine += ::MulDiv(m_hline.nAddPercentWidth, szTextArea.cx, 100);¤			szTextArea.cx = std::max((long)szTextArea.cx, (long)m_hline.nWidthLine);¤		} //if¤	} //for¤//¤//	if (NULL != lpSize)¤//	{¤//		szTextArea.cx = m_szOutput.cx;¤//		szTextArea.cy = m_szOutput.cy;¤//	} //if¤	return szTextArea;¤} //End DrawHtmlString¤¤void CPPHtmlDrawer::StoreHyperlinkArea(int left, int top, int right, int bottom)¤{¤	if (m_defStyle.nTypeLink != LINK_NONE)¤	{¤		STRUCT_HYPERLINK link;¤		link.rcArea.left = left;¤		link.rcArea.top = top;¤		link.rcArea.right = right;¤		link.rcArea.bottom = bottom;¤		link.sHyperlink = m_defStyle.sHyperlink;¤		link.nTypeLink = m_defStyle.nTypeLink;¤		link.nIndexLink = m_nCurIndexLink;¤		m_arrLinks.push_back(link);¤	} //if¤} //StoreHyperlinkArea¤¤void CPPHtmlDrawer::SelectNewHtmlStyle(LPCTSTR lpszNameStyle, STRUCT_CHANGESTYLE & cs)¤{¤	//Unpack a new styles¤	UnpackTextStyle(GetTextStyle(lpszNameStyle), cs);¤}¤¤BOOL CPPHtmlDrawer::StoreRestoreStyle(BOOL bRestore)¤{¤	BOOL bOk = FALSE;¤	if (bRestore)¤	{¤		//Restore styles¤		if (m_arrStack.size() > 0)¤		{¤			STRUCT_CHANGESTYLE cs = m_arrStack.back();¤			if (cs.strTag == m_defStyle.strTag)¤			{¤				m_defStyle = cs;¤				m_arrStack.pop_back();¤				bOk = TRUE;¤			} //if¤		} //if¤		m_defStyle.strTag.Empty();¤	}¤	else ¤	{¤		m_arrStack.push_back(m_defStyle);¤		bOk = TRUE;¤	} //if¤¤	return bOk;¤} //End StoreRestoreStyle¤¤void CPPHtmlDrawer::UpdateContext()¤{¤	::SelectObject(m_hDC, m_hOldFont);¤	::DeleteObject(m_hFont);¤	m_lfDefault.lfHeight = m_defStyle.nSizeFont;¤	m_lfDefault.lfWeight = m_defStyle.nWeightFont;¤	m_lfDefault.lfItalic = m_defStyle.bItalicFont;¤	m_lfDefault.lfStrikeOut = m_defStyle.bStrikeOutFont;¤	m_lfDefault.lfUnderline = m_defStyle.bUnderlineFont;¤	_tcscpy (m_lfDefault.lfFaceName, m_defStyle.sFaceFont);¤	m_hFont = ::CreateFontIndirect(&m_lfDefault);¤	m_hOldFont = (HFONT)::SelectObject(m_hDC, m_hFont);¤	::GetTextMetrics(m_hDC, &m_tm);¤	¤	::SetBkMode(m_hDC, m_defStyle.nBkMode);¤	::SetTextColor(m_hDC, m_defStyle.crText);¤	::SetBkColor(m_hDC, m_defStyle.crBkgnd);¤} //End UpdateContext¤¤int CPPHtmlDrawer::VerticalAlignText(int y, int nHeight)¤{¤	//Vertical align¤	if (MODE_FIRSTPASS == m_nNumPass)¤	{¤		//If calculate then don't output text¤		m_hline.nDescentLine = std::max((long)m_hline.nDescentLine, (long)nHeight - m_tm.tmAscent);¤		m_hline.nHeightLine = std::max((long)m_hline.nHeightLine, m_tm.tmAscent);¤	}¤	else if (MODE_DRAW == m_nNumPass)¤	{¤		switch (m_defStyle.nVertAlign)¤		{¤		case ALIGN_VCENTER:¤			y += (m_hline.nHeightLine - m_tm.tmHeight) / 2;¤			break;¤		case ALIGN_BASELINE:¤			y += m_hline.nHeightLine - m_hline.nDescentLine - m_tm.tmAscent;¤			break;¤		case ALIGN_BOTTOM:¤			y += m_hline.nHeightLine - m_tm.tmAscent;¤			break;¤		} //switch¤	} //if¤	return y;¤} //End VerticalAlignText¤¤int CPPHtmlDrawer::VerticalAlignImage(int y, int nHeight)¤{¤	//Vertical align¤	if (MODE_FIRSTPASS == m_nNumPass)¤	{¤		//If calculate then don't output text¤		m_hline.nHeightLine = std::max(m_hline.nHeightLine, nHeight);¤	}¤	else if (MODE_DRAW == m_nNumPass)¤	{¤		switch (m_defStyle.nVertAlign)¤		{¤		case ALIGN_VCENTER:¤			y += (m_hline.nHeightLine - nHeight) / 2;¤			break;¤		case ALIGN_BASELINE:¤			y += m_hline.nHeightLine - m_hline.nDescentLine - nHeight;¤			break;¤		case ALIGN_BOTTOM:¤			y += m_hline.nHeightLine - nHeight;¤			break;¤		} //switch¤	} //if¤	return y;¤} //End VerticalAlignImage¤¤void CPPHtmlDrawer::Tag_NewLine(LPPOINT lpPoint, int nNum, LPSIZE lpSize)¤{¤	//New line¤	if (nNum <= 0)¤		nNum = 1;¤¤	if (MODE_FIRSTPASS == m_nNumPass)¤	{¤		if (!m_hline.nHeightLine)¤			m_hline.nHeightLine = m_tm.tmHeight;¤		lpSize->cx = std::max(lpSize->cx, lpPoint->x - m_rcOutput.left);¤		m_hline.nWidthLine = lpPoint->x - m_rcOutput.left; //Adds the real length of the lines¤		m_hline.nHeightLine += m_hline.nDescentLine; //Adds the real height of the lines¤		m_arrHtmlLine [m_nCurLine] = m_hline;¤	} //if¤	¤	m_nCurLine ++;¤¤	lpPoint->y += m_hline.nHeightLine * nNum;¤	lpPoint->x = InitNewLine(m_rcOutput.left);	¤} //End Tag_NewLine¤¤int CPPHtmlDrawer::InitNewLine(int x)¤{¤	if (MODE_FIRSTPASS == m_nNumPass)¤	{¤		//ENG: Creates a new line with default parameters¤		//RUS: Создание новой линии с параметрами по-умолчанию¤		m_hline.nAddPercentWidth = 0;¤		m_hline.nDescentLine = 0;¤		m_hline.nHeightLine = 0;¤		m_hline.nWidthLine = 0;¤		m_hline.nHorzAlign = m_defStyle.nHorzAlign;¤		m_hline.nSpaceChars = 0;¤		m_arrHtmlLine.push_back(m_hline);¤	}¤	else if (MODE_DRAW == m_nNumPass)¤	{¤		//ENG: Gets the data of the first line and converts the percent value to the real width¤		//RUS: Получаем данные первой строки и преобразуем процентную ширину в реальную¤		m_hline = m_arrHtmlLine [m_nCurLine];¤		int nRealWidth = m_rcOutput.right - m_rcOutput.left;¤		¤		if (m_hline.nAddPercentWidth)¤			m_hline.nWidthLine += ::MulDiv(nRealWidth, m_hline.nAddPercentWidth, 100);¤¤		if ((ALIGN_JUSTIFY == m_hline.nHorzAlign) && m_hline.bWrappedLine)¤			::SetTextJustification(m_hDC, nRealWidth - m_hline.nWidthLine, m_hline.nSpaceChars);¤		else¤			::SetTextJustification(m_hDC, 0, 0);¤		¤		//ENG: Horizontal coordinate of the begin output¤		//RUS: Координата начала вывода с учетом выравнивания¤		switch (m_hline.nHorzAlign)¤		{¤		case ALIGN_CENTER:¤			x = m_rcOutput.left + (nRealWidth - m_hline.nWidthLine) / 2;¤			break;¤		case ALIGN_RIGHT:¤			x = m_rcOutput.left + nRealWidth - m_hline.nWidthLine;¤			break;¤		} //switch¤	} //if¤	return x;¤} //End of InitNewLine¤¤void CPPHtmlDrawer::Tag_Tabulation(LPPOINT lpPoint, int nNum)¤{¤	//Tabulation¤	if (!nNum)¤		nNum = 1;¤	int nWidth = (lpPoint->x - m_rcOutput.left) % m_nTabSize;¤	if (nWidth)¤	{¤		//aligns with tab¤		lpPoint->x += m_nTabSize - nWidth;¤		nNum --;¤	} //if¤	lpPoint->x += (nNum * m_nTabSize);¤} //End Tag_Tabulation¤¤/////////////////////////////////////////////////////////////////////////////////////////¤¤void CPPHtmlDrawer::Draw(HDC hDC, LPCTSTR lpszHtml, LPPOINT lpPoint)¤{¤	//ENG: Preparing an output text¤	//RUS: Подготовка текста к выводу¤	SIZE size;¤	PrepareOutput(hDC, lpszHtml, &size);¤¤	//ENG: If output was disabled¤	//RUS: Если вывод запрещен¤	if (!size.cx || !size.cy)¤		return;¤	¤	//ENG: Calculates an output area¤	//RUS: Подсчет области вывода¤	RECT rect;¤	rect.left = lpPoint->x;¤	rect.top = lpPoint->y;¤	rect.right = rect.left + size.cx;¤	rect.bottom = rect.top + size.cy;¤	¤	//ENG: Output a prepared text¤	//RUS: Вывод подготовленного текста¤	DrawPreparedOutput(hDC, &rect);¤} //End Draw¤¤void CPPHtmlDrawer::PrepareOutput(HDC hDC, LPCTSTR lpszHtml, LPSIZE lpSize)¤{¤	//ENG: Copy initial parameters¤	//RUS: Копирование начальных параметров¤	m_hDC = hDC;¤¤	//ENG: Reset text justification¤	::SetTextJustification(m_hDC, 0, 0);¤¤	RECT rect;¤	rect.left = rect.right = rect.top = rect.bottom = 0;¤//	if (m_bIsTextWrapEnabled)¤		rect.right = m_nMaxWidth;¤	m_csHtmlText = lpszHtml;¤	ReplaceSpecChars();¤	lpSize->cx = lpSize->cy = 0;¤	¤	//ENG: If prepared text wasn't empty then return¤	//RUS: Если подготовленный текст не пустой, то выход¤	if (!m_csHtmlText.IsEmpty())¤	{¤		//ENG: Sets a prepare mode¤		//RUS: Устанавливаем режим подготовки¤		m_nNumPass = MODE_FIRSTPASS;¤¤		m_arrTables.clear();¤¤		//ENG: Prepares to real output¤		//RUS: Подготовка к реальному выводу¤		DrawHtml(lpSize, &rect);¤¤		if (!lpSize->cx && !lpSize->cy)¤			m_csHtmlText.Empty();¤¤		//Cuts a tooltip if his real width more than m_nMaxWidth¤		if (m_nMaxWidth/*m_bIsTextWrapEnabled*/ && (lpSize->cx > m_nMaxWidth))¤			lpSize->cx = m_nMaxWidth;¤		¤		lpSize->cx ++;¤		lpSize->cy ++;¤	} //if¤} //End PrepareOutput¤¤////////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer::DrawPreparedOutput()¤//		Draw a string prepared by PrepareOutput method.¤//------------------------------------------------------------------¤// Parameters:¤//		hDC				- Device Context to drawing ¤//		lpRect			- Pointer to RECT structure contains a bounding rectangle of¤//						  drawing area.¤////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::DrawPreparedOutput(HDC hDC, LPCRECT lpRect)¤{¤	//ENG: If prepared text was empty then return¤	//RUS: Если подготовленный текст пустой, то выход¤	if (m_csHtmlText.IsEmpty())¤		return;¤¤	//ENG: Copy initial parameters¤	//RUS: Копирование начальных параметров¤	m_hDC = hDC;¤	SIZE size = {0, 0};¤¤	//ENG: Sets a output mode¤	//RUS: Устанавливаем режим вывода¤	m_nNumPass = MODE_DRAW;¤¤	RECT rect = *lpRect;¤//	if (((rect.right - rect.left) > m_nMaxWidth) && m_bIsTextWrapEnabled)¤//		rect.right = rect.left + m_nMaxWidth;¤¤	//ENG: Real output the prepared string¤	//RUS: Вывод подготовленной строки¤	DrawHtml(&size, &rect);¤} //End of DrawPreparedOutput¤¤// The following appeared in Paul DiLascia's Jan 1998 MSJ articles.¤// It loads a "hand" cursor from the winhlp32.exe module¤void CPPHtmlDrawer::SetDefaultCursor()¤{¤	if (m_hLinkCursor == NULL)                // No cursor handle - load our own¤    {¤#ifdef IDC_HAND¤		//This code was added from Zorglab's comments to hyperlink control from Chris Maunder¤		m_hLinkCursor = ::LoadCursor(NULL, IDC_HAND); // Load Windows' hand cursor¤		if (m_hLinkCursor != NULL)                    // if not available, load it from winhlp32.exe¤			return;¤#endif //IDC_HAND¤		// Get the windows directory¤        CPPString strWndDir;¤        GetWindowsDirectory(strWndDir.GetBuffer(MAX_PATH), MAX_PATH);¤        strWndDir.ReleaseBuffer();¤¤        strWndDir += _T("\\winhlp32.exe");¤        // This retrieves cursor #106 from winhlp32.exe, which is a hand pointer¤        HMODULE hModule = LoadLibrary(strWndDir);¤        if (hModule) ¤		{¤            HCURSOR hHandCursor = ::LoadCursor(hModule, MAKEINTRESOURCE(106));¤            if (hHandCursor)¤                m_hLinkCursor = CopyCursor(hHandCursor);¤        } //if¤        FreeLibrary(hModule);¤    } //if¤} //End SetDefaultCursor¤¤void CPPHtmlDrawer::SetHyperlinkCursor(HCURSOR hCursor /* = NULL */)¤{¤	if ((m_hLinkCursor == hCursor) && (NULL != m_hLinkCursor))¤		return;¤¤	if (NULL != m_hLinkCursor)¤	{¤		::DestroyCursor(m_hLinkCursor);¤		m_hLinkCursor = NULL;¤	} //if¤	¤¤    if (NULL == hCursor)¤		SetDefaultCursor();¤	else¤		m_hLinkCursor = hCursor;¤} //End SetHyperlinkCursor¤¤HCURSOR CPPHtmlDrawer::GetHyperlinkCursor() const¤{¤    return m_hLinkCursor;¤} //End GetHyperlinkCursor¤¤/////////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer::SetCallbackHyperlink¤// This function sets or removes the notification messages from the control before display.¤//¤// Parameters:¤//	hWnd [in] -    If non-NULL the control will be send the notification ¤//				   to specified window¤//				   Else the notification will not send¤///////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam /* = 0 */)¤{¤//	TRACE(_T("CPPHtmlDrawer::SetCallbackHyperlink()\n"));¤¤	m_csCallbackLink.hWnd = hWnd;¤	if (NULL == hWnd)¤	{¤		m_csCallbackLink.nMessage = 0;¤		m_csCallbackLink.lParam = 0;¤	}¤	else¤	{¤		m_csCallbackLink.nMessage = nMessage;¤		m_csCallbackLink.lParam = lParam;¤	} //if¤} //End SetCallbackHyperlink¤¤void CPPHtmlDrawer::SetCallbackRepaint(HWND hWnd, UINT nMessage, LPARAM lParam /* = 0 */)¤{¤//	TRACE(_T("CPPHtmlDrawer::SetCallbackRepaint()\n"));¤¤	m_csCallbackRepaint.hWnd = hWnd;¤	if (NULL == hWnd)¤	{¤		m_csCallbackRepaint.nMessage = 0;¤		m_csCallbackRepaint.lParam = 0;¤	}¤	else¤	{¤		m_csCallbackRepaint.nMessage = nMessage;¤		m_csCallbackRepaint.lParam = lParam;¤	} //if¤} //End SetCallbackRepaint¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetImageList (public member function)¤//    sets the image list to tooltip¤//¤//  Parameters :¤//		nIdBitmap	[in] - Resource IDs of the bitmap to be associated with the image list¤//		cx			[in] - Dimensions of each image, in pixels.¤//		cy			[in] - Dimensions of each image, in pixels.¤//		nCount		[in] - Number of images that the image list initially contains.¤//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the ¤//						   specified bitmap is changed to black, and the corresponding ¤//						   bit in the mask is set to one.¤//  Returns :¤//		None¤//¤/////////////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)¤{¤	// Load bitmap¤	HBITMAP hBitmap = GetBitmapFromResources(nIdBitmap);¤	SetImageList(hBitmap, cx, cy, nCount, crMask);¤} //End SetImageList¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::SetImageList (public member function)¤//    sets the image list to tooltip¤//¤//  Parameters :¤//		hBitmap		[in] - Handle of the bitmap to be associated with the image list¤//		cx			[in] - Dimensions of each image, in pixels.¤//		cy			[in] - Dimensions of each image, in pixels.¤//		nCount		[in] - Number of images that the image list initially contains.¤//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the ¤//						   specified bitmap is changed to black, and the corresponding ¤//						   bit in the mask is set to one.¤//  Returns :¤//		None¤//¤/////////////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)¤{¤	//ENG: Removes previously image list¤	//RUS: Удаляем предыдущий список изображений¤	if (NULL != m_hImageList)¤		::DeleteObject(m_hImageList);¤¤	//ENG: If don't need to create a new image list¤	//RUS: Если не нужно создавать новый список изображений¤	if (NULL == hBitmap)¤		return;¤¤	// Ensure that the common control DLL is loaded. ¤	InitCommonControls(); ¤	¤	m_hImageList = ImageList_Create(cx, cy, ILC_COLOR32 | ILC_MASK, nCount, 1);¤	ImageList_AddMasked(m_hImageList, hBitmap, crMask);¤	m_szImageList.cx = cx;¤	m_szImageList.cy = cy;¤} //End SetImageList¤¤/////////////////////////////////////////////////////////////////////////////¤//  CPPToolTip::GetImageList (public member function)¤//    gets the image list from tooltip¤//¤//  Parameters :¤//		sz		   [out] - Dimensions of each image, in pixels.¤//  Returns :¤//		A pointer to a CImageList object¤//¤/////////////////////////////////////////////////////////////////////////////¤//CImageList * CPPHtmlDrawer::GetImageList(CSize & sz)¤//{¤//	sz = m_szImageList;¤//	return &m_ImageList;¤//} //End GetImageList¤¤void CPPHtmlDrawer::EnableEscapeSequences(BOOL bEnable /* = TRUE */)¤{¤	m_bEnableEscapeSequences = bEnable;¤}¤¤void CPPHtmlDrawer::LoadResourceDll(LPCTSTR lpszPathDll, DWORD dwFlags /* = 0 */)¤{¤	HINSTANCE hInst = NULL;¤	if (NULL != lpszPathDll)¤		hInst = ::LoadLibraryEx(lpszPathDll, NULL, dwFlags);¤	¤	SetResourceDll(hInst);¤¤	if (NULL != hInst)¤		m_bFreeInstDll = TRUE;¤} //End LoadResourceDll¤¤void CPPHtmlDrawer::SetResourceDll(HINSTANCE hInstDll /* = NULL */)¤{¤	if (NULL != m_hInstDll)¤	{¤		if (!m_bFreeInstDll)¤			return;¤		::FreeLibrary(m_hInstDll);¤		m_hInstDll = NULL;¤	} //if¤¤	m_bFreeInstDll = FALSE;¤¤	if (NULL != hInstDll)¤		m_hInstDll = hInstDll;¤} //End SetResourceDll¤¤¤CPPDrawManager * CPPHtmlDrawer::GetDrawManager()¤{¤	return &m_drawmanager;¤} //End GetDrawManager¤¤BOOL CPPHtmlDrawer::IsImageWithShadow(_STRUCT_IMAGE & si)¤{¤	DWORD dwStyles = si.nStyles | si.nHotStyles;¤	if ((dwStyles & IMAGE_EFFECT_MONO_SHADOW) || ¤		(dwStyles & IMAGE_EFFECT_GRADIENT_SHADOW))¤		return TRUE;¤	¤	return FALSE;¤}¤¤///////////////////////////////////////////////////////////////////////////¤// Map of the styles¤void CPPHtmlDrawer::SetDefaultCssStyles()¤{¤	CPPString str = _T("");¤	str += _T("body {font-size: 10pt; color:black; font-family:Verdana}\r\n");¤	str += _T("p {font-size: 10pt; color:black; font-family:Verdana; font-weight:bold}\r\n");¤	str += _T("h1 {font-size: 14pt; color:black; font-family:Verdana; font-weight:bold}\r\n");¤	str += _T("h2 {font-size: 13pt; color:#ff9900; font-family:Verdana; font-weight:bold}\r\n");¤	str += _T("h3 {font-size: 12pt; color:#ff9900; font-family:Arial; font-weight:bold}\r\n");¤	str += _T("h4 {font-size: 10pt; color:black; font-family:Verdana; font-weight:bold}\r\n");¤	str += _T("h5 {font-size: 9pt; color:#ff9900; font-family:Verdana; font-weight:bold}\r\n");¤	str += _T("h6 {font-size: 65%; color:#626262; font-family:Verdana; font-weight:normal}\r\n");¤	str += _T("pre {font-size: 9pt; font-family:\"Courier\"; background-color:#fbedbb}\r\n");¤	str += _T("code {color:#990000; font-family:Arial}\r\n");¤	str += _T("a:link {text-decoration:none; color:blue}\r\n");¤	str += _T("a:hover {text-decoration:underline; color:blue}\r\n");¤	str += _T("sub {font-size:65%; vertical-align:bottom}\r\n");¤	str += _T("sup {font-size:65%; vertical-align:top}\r\n");¤	str += _T("big {font-size:125%}\r\n");¤	str += _T("small {font-size:75%}\r\n");¤	str += _T(".cpp-comment {color:green; font-style:italic}\r\n");¤//	str += _T("td {text-align:center; color:#ff0000; vertical-align:middle}\r\n");¤//	str += _T("table {padding:2; border-width:1; color:red}\r\n");¤¤	SetCssStyles(str);¤} //End SetDefaultCssStyle¤¤void CPPHtmlDrawer::SetCssStyles(DWORD dwIdCssString, LPCTSTR lpszPathDll /* = NULL */)¤{¤	CPPString str;¤	if (NULL == lpszPathDll)¤		str = GetStringFromResource(dwIdCssString);¤	else¤		str = GetStringFromDll(dwIdCssString, lpszPathDll);¤	SetCssStyles(str);¤} //End SetCssStyles¤¤void CPPHtmlDrawer::SetCssStyles(LPCTSTR lpszCssString /* = NULL */)¤{¤	m_mapStyles.clear(); //removes previously styles¤¤	if (NULL == lpszCssString)¤	{¤		SetDefaultCssStyles();¤	}¤	else¤	{¤		CPPString str = (CPPString)lpszCssString;¤		m_strCssStyles = str;¤		¤		CPPString strName;¤		CPPString strProperty;¤		¤		int nBegin;¤		TCHAR chSymbol;¤		int nIndex = 0;¤		¤		while (nIndex < str.GetLength())¤		{¤			//Passes a space in begin string¤			if (GetIndexNextAlphaNum(str, nIndex))¤			{¤				nBegin = nIndex;¤				//Searching end of the style name¤				chSymbol = GetIndexNextChars(str, nIndex, _T(" {"));¤				if ((nIndex > nBegin) && (0 != chSymbol))¤				{¤					strName = str.Mid(nBegin, nIndex - nBegin);¤					if (!strName.IsEmpty())¤					{¤						if (chSymbol != _T(' '))¤							nIndex --;¤						chSymbol = GetIndexNextChars(str, nIndex, _T("{"));¤						if (0 != chSymbol)¤						{¤							nBegin = nIndex + 1;¤							chSymbol = GetIndexNextChars(str, nIndex, _T("}"));¤							if ((nIndex > nBegin) && (0 != chSymbol))¤							{¤								strProperty = str.Mid(nBegin, nIndex - nBegin);¤								SetTextStyle(strName, strProperty);¤							} //if¤						} //if¤					} //if¤				} //if¤			} //if¤		} //while¤	} //if¤} //End SetCssStyles¤¤LPCTSTR CPPHtmlDrawer::GetCssStyles()¤{¤	return (LPCTSTR)m_strCssStyles;¤} //End GetCssStyles¤¤LPCTSTR CPPHtmlDrawer::GetTextStyle(LPCTSTR lpszStyleName)¤{¤	CPPString name = (CPPString)lpszStyleName;¤	name.MakeLower();¤	iter_mapStyles iterMap = m_mapStyles.find(name);¤	¤	if (iterMap != m_mapStyles.end())¤		return (LPCTSTR)iterMap->second;¤¤	//Not found¤	return NULL;¤} //End GetTextStyle¤¤void CPPHtmlDrawer::SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue)¤{¤	CPPString name = (CPPString)lpszStyleName;¤	name.MakeLower();¤	iter_mapStyles iterMap = m_mapStyles.find(name);¤	¤	if (iterMap != m_mapStyles.end())¤	{¤		//Modifies ¤		iterMap->second = (CPPString)lpszStyleValue;¤	}¤	else¤	{¤		//Add new¤		m_mapStyles.insert(std::make_pair(name, (CPPString)lpszStyleValue));¤	} //if¤} //End SetTextStyle¤¤void CPPHtmlDrawer::RemoveTextStyle(LPCTSTR lpszStyleName)¤{¤	CPPString name = (CPPString)lpszStyleName;¤	name.MakeLower();¤	iter_mapStyles iterMap = m_mapStyles.find(name);¤	¤	if (iterMap == m_mapStyles.end())¤		return; //item was not found¤	¤	m_mapStyles.erase(iterMap);¤} //End RemoveTextStyle¤¤void CPPHtmlDrawer::AddToTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszAddStyle)¤{¤} //End AddToTextStyle¤¤void CPPHtmlDrawer::UnpackTextStyle(CPPString strStyle, _STRUCT_CHANGESTYLE & cs)¤{¤	//Gets a string¤	strStyle.MakeLower();¤	if (strStyle.IsEmpty())¤		return;¤¤	CPPString strName;¤	CPPString strParameter;¤¤	int nBegin;¤	TCHAR chSymbol;¤	int nIndex = 0;¤	CPPString str;¤¤	while (nIndex < strStyle.GetLength())¤	{¤		//Passes a space in begin string¤		if (GetIndexNextAlphaNum(strStyle, nIndex))¤		{¤			nBegin = nIndex;¤			//Searching end of the style name¤			chSymbol = GetIndexNextChars(strStyle, nIndex, _T(" :"));¤			if (0 != chSymbol)¤			{¤				//Gets a property's name¤				strName = strStyle.Mid(nBegin, nIndex - nBegin);¤¤				//Gets a property's value¤				strParameter = GetParameterString(strStyle, nIndex, _T(':'));¤¤				//Analyzing name¤				if (strName == _T("font-size"))¤				{¤					cs.nSizeFont = GetLengthUnit(strParameter, cs.nSizeFont, TRUE);¤				}¤				else if (strName == _T("font-family"))¤				{¤					if (!strParameter.IsEmpty())¤						cs.sFaceFont = strParameter;¤				}¤				else if (strName == _T("font-style"))¤				{¤					cs.bItalicFont = GetStyleFontStyle(strParameter, cs.bItalicFont);¤				}¤				else if (strName == _T("font-weight"))¤				{¤					cs.nWeightFont = GetStyleFontWeight(strParameter, cs.nWeightFont);¤				}¤				else if (strName == _T("text-align"))¤				{¤					cs.nHorzAlign = GetStyleHorzAlign(strParameter, cs.nHorzAlign);¤				}¤				else if (strName == _T("text-transform"))¤				{¤					cs.nTextTransform = GetStyleTextTransform(strParameter, cs.nTextTransform);¤				}¤				else if (strName == _T("color"))¤				{¤					if (m_bIsEnable)¤						cs.crText = GetStyleColor(strParameter, cs.crText);¤					else¤						cs.crText = GetColorByName("");¤				}¤				else if (strName == _T("background-color"))¤				{¤					if (((strParameter == _T("transparent")) && strParameter.IsEmpty()) || !m_bIsEnable)¤					{¤						cs.nBkMode = TRANSPARENT;¤					}¤					else¤					{¤						cs.nBkMode = OPAQUE;¤						cs.crBkgnd = GetStyleColor(strParameter, cs.crBkgnd);¤					} //if¤				}¤				else if (strName == _T("text-decoration"))¤				{¤					StyleTextDecoration(strParameter, cs);¤				}¤				else if (strName == _T("vertical-align"))¤				{¤					cs.nVertAlign = GetStyleVertAlign(strParameter, cs.nVertAlign);¤				}¤				else if (strName == _T("border-color"))¤				{¤					if (m_bIsEnable)¤						cs.crBorderLight = GetStyleColor(strParameter, cs.crBorderLight);¤					else¤						cs.crBorderLight = GetColorByName("");¤					cs.crBorderDark = cs.crBorderLight;¤				}¤				else if ((strName == _T("border-width")) || (strName == _T("size")))¤				{¤					cs.nBorderWidth = StyleBorderWidth(strParameter, cs.nBorderWidth);¤					if (!cs.nBorderWidth)¤						cs.nBorderStyle = CPPDrawManager::PEN_NULL;¤					else if (CPPDrawManager::PEN_NULL == cs.nBorderStyle)¤						cs.nBorderStyle = CPPDrawManager::PEN_SOLID;¤				}¤				else if (strName == _T("border-style"))¤				{¤					cs.nBorderStyle = StyleBorder(strParameter, cs.nBorderStyle);¤					if ((CPPDrawManager::PEN_NULL != cs.nBorderStyle) && !cs.nBorderWidth)¤						cs.nBorderWidth = 1;¤				}¤				else if (strName == _T("margin"))¤				{¤					cs.nMargin = GetLengthUnit(strParameter, cs.nMargin);¤				}¤				else if (strName == _T("padding"))¤				{¤					cs.nPadding = GetLengthUnit(strParameter, cs.nPadding);¤				} //if¤			} //if¤		} //if¤	} //while¤} //End UnpackTextStyle¤¤BOOL CPPHtmlDrawer::GetStyleFontStyle(CPPString & str, BOOL bDefault)¤{¤	if ((str == _T("normal")) || str.IsEmpty())¤	{¤		bDefault = FALSE;¤	}¤	else if ((str == _T("italic")) || (str == _T("oblique"))) ¤	{¤		bDefault = TRUE;¤	} //if¤¤	return bDefault;¤} //End GetStyleFontStyle¤¤int CPPHtmlDrawer::GetStyleFontWeight(CPPString & str, int nDefault)¤{¤	if ((str == _T("normal")) || str.IsEmpty())¤	{¤		nDefault = FW_NORMAL;¤	}¤	else if (str == _T("bold"))¤	{¤		nDefault = FW_BOLD;¤	}¤	else if (str == _T("bolder"))¤	{¤		nDefault = 900;¤	}¤	else if (str == _T("lighter"))¤	{¤		nDefault = 100;¤	}¤	else¤	{¤		nDefault = _ttoi(str);¤	} //if¤¤	return nDefault;¤} //End GetStyleFontWeight¤¤int CPPHtmlDrawer::GetStyleHorzAlign(CPPString & str, int nDefault)¤{¤	if ((str == _T("left")) || str.IsEmpty())¤	{¤		nDefault = ALIGN_LEFT;¤	}¤	else if (str == _T("center"))¤	{¤		nDefault = ALIGN_CENTER;¤	}¤	else if (str == _T("right"))¤	{¤		nDefault = ALIGN_RIGHT;¤	}¤¤	return nDefault;¤} //End GetStyleHorzAlign¤¤int CPPHtmlDrawer::GetStyleVertAlign(CPPString & str, int nDefault)¤{¤	if ((str == _T("baseline")) || str.IsEmpty())¤	{¤		nDefault = ALIGN_BASELINE;¤	}¤	else if ((str == _T("middle")) || (str == _T("vcenter")))¤	{¤		nDefault = ALIGN_VCENTER;¤	}¤	else if (str == _T("top"))¤	{¤		nDefault = ALIGN_TOP;¤	}¤	else if (str == _T("bottom"))¤	{¤		nDefault = ALIGN_BOTTOM;¤	}¤	¤	return nDefault;¤} //End GetStyleVertAlign¤¤int CPPHtmlDrawer::GetStyleTextTransform(CPPString & str, int nDefault)¤{¤	if ((str == _T("none")) || str.IsEmpty())¤	{¤		nDefault = TEXT_TRANSFORM_NONE;¤	}¤	else if (str == _T("uppercase"))¤	{¤		nDefault = TEXT_TRANSFORM_UPPERCASE;¤	}¤	else if (str == _T("lowercase"))¤	{¤		nDefault = TEXT_TRANSFORM_LOWERCASE;¤	}¤	else if (str == _T("capitalize"))¤	{¤		nDefault = TEXT_TRANSFORM_CAPITALIZE;¤	}¤	¤	return nDefault;¤}¤¤COLORREF CPPHtmlDrawer::GetStyleColor(CPPString & str, COLORREF crDefault)¤{¤//	if (!m_bIsEnable)¤//		return GetColorByName("");¤	¤	if (!str.IsEmpty())¤	{¤		if (str.GetAt(0) == _T('#'))¤		{¤			if (str.GetLength() == 7)¤			{¤				CPPString strHex = _T("0x");¤				strHex += str.Mid(5, 2);¤				strHex += str.Mid(3, 2);¤				strHex += str.Mid(1, 2);¤				crDefault = (COLORREF)_tcstoul(strHex, 0, 0);¤			} //if¤		}¤		else if ((str.GetAt(0) >= '0') && (str.GetAt(0) <= '9'))¤			crDefault = (COLORREF)_tcstoul(str, 0, 0);¤		else¤			crDefault = GetColorByName(str, crDefault);¤	} //if ¤¤	return crDefault;¤} //End GetStyleColor¤¤int CPPHtmlDrawer::GetLengthUnit(CPPString & str, int nDefault, BOOL bFont /* = FALSE */)¤{¤	if (str.IsEmpty())¤		return nDefault;¤	¤	if (IsPercentableValue(str))¤	{¤		//Percent value¤		int percent = _ttoi(str.Left(str.GetLength() - 1));¤		return ::MulDiv(nDefault, percent, 100);¤	} //if¤¤	int nSign = 0;¤	if (str.GetAt(0) == _T('+')) nSign = 1;¤	else if (str.GetAt(0) == _T('-')) nSign = -1;¤	¤	if (0 != nSign) str = str.Right(str.GetLength() - 1);¤	¤	//ENG: This code fragment fixed by Reinhard Steiner(2004/10/20).¤	int nValue = _ttoi(str);¤	CPPString strUnit;¤	if(str.GetLength() >= 2)¤		strUnit = str.Right(2);¤¤	if (strUnit == _T("px"))		nDefault = nValue;¤	else if (strUnit == _T("ex"))¤	{¤		SIZE szText;¤		CPPString strText = _T("x");¤		::GetTextExtentPoint32(m_hDC, strText, strText.GetLength(), &szText);¤		nDefault = nValue * szText.cy;¤	}¤	else if (strUnit == _T("em"))	nDefault = nValue * m_tm.tmHeight;¤	else¤	{¤		//Gets pixel in inch¤		nValue *= ::GetDeviceCaps(m_hDC, LOGPIXELSY);¤		if (strUnit == _T("in"))		nDefault = nValue;¤		else if (strUnit == _T("cm"))	nDefault = (int)((double)nValue / 2.54);¤		else if (strUnit == _T("mm"))	nDefault = (int)((double)nValue / 25.4);¤		else if (strUnit == _T("pt"))	nDefault = nValue / 72;¤		else if (strUnit == _T("pc"))	nDefault = nValue / 6;¤		else¤		{¤			nValue = _tcstoul(str, 0, 0);//_ttoi(str);¤			if ((nValue > 0) && (nValue < 8) && bFont)¤			{¤				int nSize [] = {8, 10, 12, 14, 18, 24, 36};¤				nDefault = nSize [nValue - 1];¤			}¤			else¤			{¤				nDefault = nValue;¤			} //if¤		} //if¤	} //if¤	¤	return nDefault;¤} //End GetLengthUnit¤¤void CPPHtmlDrawer::StyleTextDecoration(CPPString & str, _STRUCT_CHANGESTYLE & cs)¤{¤	if (str.IsEmpty())¤		str = _T("none");¤	¤	int nBegin = 0;¤	int nEnd = 0;¤	CPPString strTemp;¤	while (nBegin < str.GetLength())¤	{¤		if (GetIndexNextAlphaNum(str, nBegin))¤		{¤			nEnd = nBegin;¤			GetIndexNextChars(str, nEnd, _T(" ,"));¤			strTemp = str.Mid(nBegin, nEnd - nBegin);¤			nBegin = nEnd;¤			if (strTemp == _T("none"))¤			{¤				cs.bUnderlineFont = FALSE;¤				cs.bStrikeOutFont = FALSE;¤				cs.bOverlineFont = FALSE;¤			}¤			else if (strTemp == _T("underline"))¤			{¤				cs.bUnderlineFont = TRUE;¤			}¤			else if (strTemp == _T("line-through"))¤			{¤				cs.bStrikeOutFont = TRUE;¤			}¤			else if (strTemp == _T("overline"))¤			{¤				cs.bOverlineFont = TRUE;¤			}  //if¤		} //if¤	} //while¤} //End StyleTextDecoration¤¤int CPPHtmlDrawer::StyleBorderWidth(CPPString & str, int nDefault)¤{¤	if (str ==_T("thin"))		nDefault = ::MulDiv(75, nDefault, 100);¤	else if (str ==_T("thick"))	nDefault = ::MulDiv(125, nDefault, 100);¤	else if (str !=_T("medium"))nDefault = GetLengthUnit(str, nDefault);¤¤	return nDefault;¤} //End StyleBorderWidth¤¤int CPPHtmlDrawer::StyleBorder(CPPString & str, int nDefault)¤{¤	if ((str == _T("none")) || str.IsEmpty()) nDefault = CPPDrawManager::PEN_NULL;¤	else if (str == _T("solid")) nDefault = CPPDrawManager::PEN_SOLID;¤	else if (str == _T("dotted")) nDefault = CPPDrawManager::PEN_DOT;¤	else if (str == _T("dashed")) nDefault = CPPDrawManager::PEN_DASH;¤	else if (str == _T("double")) nDefault = CPPDrawManager::PEN_DOUBLE;¤¤	return nDefault;¤} //End StyleBorder¤¤void CPPHtmlDrawer::SetDefaultStyles(_STRUCT_CHANGESTYLE & cs)¤{¤	m_defStyle.strTag.Empty();		//The name of the last opened tag¤	¤	//Font¤	m_defStyle.nSizeFont = 16;		//The height of the logic font¤	m_defStyle.nWeightFont = FW_NORMAL;	//The weight of the logic font¤	m_defStyle.bItalicFont = FALSE;	//Is italic logic font?¤	m_defStyle.bUnderlineFont = FALSE;//Is underline logic font?¤	m_defStyle.bStrikeOutFont = FALSE;//Is strikeout logic font?¤	m_defStyle.bOverlineFont = FALSE; //Is overline logic font?¤	m_defStyle.sFaceFont = _T("Verdana");  //The face name of the logic font¤	¤	//Color		¤	m_defStyle.crText = RGB (0, 0, 0);	//The foreground color ¤	m_defStyle.crBkgnd = RGB (255, 255, 255);	//The background color (also begin for the gradient)¤	m_defStyle.crBorderLight = RGB (0, 0, 0);	//The border color¤	m_defStyle.crBorderDark = RGB (0, 0, 0);	//The border color¤	m_defStyle.crMidBkgnd = RGB (255, 255, 255);//The middle background color¤	m_defStyle.crEndBkgnd = RGB (255, 255, 255);//The end background color¤	¤	//Fill¤	m_defStyle.nBkMode = TRANSPARENT;		//The background mode for the text (TRANSPARENT, OPAQUE)¤	m_defStyle.nFillBkgnd = -1;	//The fill effect of the background¤	m_defStyle.strNameResBk.Empty();¤	¤	//Align¤	m_defStyle.nHorzAlign = ALIGN_LEFT;	//The horizontal align¤	m_defStyle.nVertAlign = ALIGN_BASELINE;	//The vertical align¤	¤	//Border¤	m_defStyle.nBorderStyle = CPPDrawManager::PEN_NULL;	//The border style¤	m_defStyle.nBorderWidth = 0;	//The width of the border¤	¤	//Text¤	m_defStyle.nTextTransform = TEXT_TRANSFORM_NONE;//Transformation of the text (NONE, UPPERCASE, LOWERCASE, CAPITALIZE)¤	¤	//Margins¤	m_defStyle.nMargin = 2;¤	¤	//Padding¤	m_defStyle.nPadding = 0;¤	¤	//Hyperlink¤	m_defStyle.nTypeLink = LINK_NONE;		//The type of the link (NONE, HREF, MESSAGE)¤	m_defStyle.sHyperlink.Empty(); //The additional parameter for the link¤} //SetDefaultStyles¤¤/////////////////////////////////////////////////////////////////¤// Search body of the next tag¤//---------------------------------------------------------------¤// Parameters:¤//     In: str    - a string with html text¤//         nIndex - an index of the first char to the searching in the string¤//    Out: nIndex - an index of the char in the string after found tag's text¤//         strTag - a string contained the tag's text if was found¤// Return: A string before found tag's text ¤/////////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::SearchNextTag(CPPString & str, CPPString & strTag, int & nIndex)¤{¤	int nBegin;¤	CPPString sText = _T("");¤	strTag.Empty();¤¤	while (nIndex < str.GetLength())¤	{¤		nBegin = nIndex;¤		//Searching a chars of the begin tag¤		nIndex = str.Find(_T("<"), nIndex);¤		if (nIndex < 0)¤			nIndex = str.GetLength(); //A tag wasn't found¤		sText += str.Mid(nBegin, nIndex - nBegin);¤		if (nIndex < str.GetLength())¤		{¤			//May be it is a begin of the tag?¤			if ((nIndex < (str.GetLength() - 1)) && (_T('<') != str.GetAt(nIndex + 1)))¤			{¤				//Yes of cause!!!¤				strTag = GetTagBody(str, nIndex);¤				return sText;¤			}¤			//No, it is a char '<'¤			sText += _T("<");¤			nIndex += 2;¤			break;¤		} //if¤	} //while¤	return sText;¤} //End SearchNextTag¤¤/////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer::GetTagBody¤//	Gets a name of tag with a parameters¤//---------------------------------------------------------------¤// Parameters:¤//	[in]¤//		str		-	a string with html text¤//		nIndex	-   an index of the begin of the tag. ¤//	[out]¤//		nIndex  -	an index of char after the tag¤//---------------------------------------------------------------¤// Return values:¤//	A tag's name .¤/////////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::GetTagBody(CPPString & str, int & nIndex)¤{¤	CPPString sTagName = _T("");¤	//ENG: Search the tag's end ¤	//RUS: Ищем окончание тэга¤	int nEndOfTag = str.Find(_T('>'), nIndex);¤	//ENG: The tag's end was found. Passes a tag's begin char ('<')¤	//RUS: Конец тэга найденю Пропускаем символ начала тэга¤	nIndex++;¤	if (nEndOfTag > nIndex)¤	{¤		//ENG: Gets a full body of tag¤		//RUS: Получаем полную строку тэга¤		sTagName = str.Mid(nIndex, nEndOfTag - nIndex);¤		//ENG: Jump to next char after the tag¤		//RUS: Перемещаемся на следующий за тэгом символ¤		nIndex = nEndOfTag + 1;¤	} //if¤	return sTagName;¤} //End of GetTagBody¤¤/////////////////////////////////////////////////////////////////¤// Split a tag to his name and properties¤//---------------------------------------------------------------¤// Parameters:¤//     In: sTag    - a string with tag's text¤//    Out: sTag	   - a tag's name¤// Return: A property's string ¤/////////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::SplitTag(CPPString & sTag)¤{¤	CPPString sParam(_T(""));¤	int nIndex = 0;¤	TCHAR tch = GetIndexNextChars(sTag, nIndex, _T(" ="));¤	if (tch != _T('\0'))¤	{¤		//ENG: The separator was found. Splits a tag's body to his name and his parameteres ¤		//RUS: Разделитель найден. Разделяем тело тэга на имя и параметры¤		sParam = sTag.Mid(nIndex);¤		sTag = sTag.Left(nIndex);¤		sParam.TrimLeft(_T(' '));¤	} //if¤	return sParam;¤} //End of SplitTag¤¤CPPString CPPHtmlDrawer::GetNextProperty(CPPString & str, int & nIndex, CPPString & sProp)¤{¤	CPPString sValue(_T(""));¤	sProp.Empty();¤	¤	//Passes the spaces before a property¤	if (GetIndexNextAlphaNum(str, nIndex))¤	{¤		//The begin of the property was found¤		int nBegin = nIndex;¤		//Searching end of the property¤		GetIndexNextChars(str, nIndex, _T(" ="));¤		//Gets a property's string¤		sProp = str.Mid(nBegin, nIndex - nBegin);¤		TCHAR chFound = GetIndexNextNoChars(str, nIndex, _T(" "));¤		if (_T('=') == chFound)¤		{¤			chFound = GetIndexNextNoChars(str, nIndex, _T(" ="));¤			if ((_T('\'') == chFound) || (_T('\"') == chFound))¤			{¤				nIndex++;¤			}¤			else¤			{¤				chFound = _T(' ');¤			} //if¤			sValue += chFound;¤			nBegin = nIndex;¤			GetIndexNextChars(str, nIndex, sValue);¤			sValue = str.Mid(nBegin, nIndex - nBegin);¤			nIndex ++;¤		} //if¤	} //if¤	return sValue;¤} //End of GetNextProperty¤¤/////////////////////////////////////////////////////////////////¤// Searching the next property of the tag¤//---------------------------------------------------------------¤// Parameters:¤//     In: str    - a string with html text¤//         nIndex - an index of the first char to the searching in the string¤//    Out: nIndex - an index of the char in the string after found tag's text¤// Return: A property's string ¤/////////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::SearchPropertyOfTag(CPPString & str, int & nIndex)¤{¤	CPPString sText = _T("");¤	¤	//Passes the spaces before a property¤	if (GetIndexNextAlphaNum(str, nIndex))¤	{¤		//The begin of the property was found¤		int nBegin = nIndex;¤		//Searching end of the property¤		TCHAR chFound = GetIndexNextChars(str, nIndex, _T(" ="));¤		//Gets a property's string¤		sText = str.Mid(nBegin, nIndex - nBegin);¤	} //if¤	return sText;¤} //End SearchPropertyOfTag¤¤/////////////////////////////////////////////////////////////////¤// Search a tag¤//---------------------------------------------------------------¤// Parameters:¤//     In: str    - a string with html text¤//         nIndex - an index of the first char to the searching in the string¤//    Out: nIndex - an index of the first char of the tag¤// Return: TRUE if specified tag was found ¤//---------------------------------------------------------------¤// Example: (strTag = "table") or (strTag = "/table")¤/////////////////////////////////////////////////////////////////¤BOOL CPPHtmlDrawer::SearchTag(CPPString & str, int & nIndex, CPPString strTag)¤{¤	strTag = _T("<") + strTag;¤	while (nIndex < str.GetLength())¤	{¤		nIndex = str.Find(strTag, nIndex);¤		if (nIndex < 0)¤			nIndex = str.GetLength();¤		else¤		{¤			if (nIndex > 0)¤			{¤				if (str.GetAt(nIndex - 1) != _T('<'))¤					return TRUE;¤				nIndex += 2;¤			}¤			else return TRUE;¤		} //if¤	}¤	return FALSE;¤} //End SearchTag¤¤/////////////////////////////////////////////////////////////////¤// Search a first alpha_num chars or first arithmetic char¤//---------------------------------------------------------------¤// Parameters:¤//     In: str    - a string with html text¤//         nIndex - an index of the first char to the searching in the string¤//    Out: nIndex - an index of the first found char¤// Return: TRUE if specified char was found ¤/////////////////////////////////////////////////////////////////¤BOOL CPPHtmlDrawer::GetIndexNextAlphaNum(CPPString & str, int & nIndex, BOOL bArithmetic /* = FALSE */)¤{¤	TCHAR ch;¤	for (; nIndex < str.GetLength(); nIndex++)¤	{¤		ch = str.GetAt(nIndex);¤		if ((ch >= _T('0')) && (ch <= _T('9')))¤			return TRUE;¤		if ((ch >= _T('A')) && (ch <= _T('Z')))¤			return TRUE;¤		if ((ch >= _T('a')) && (ch <= _T('z')))¤			return TRUE;¤		if (ch == _T('.'))¤			return TRUE;¤		if (bArithmetic)¤		{¤			if ((_T('+') == ch) || (_T('-') == ch) || ¤				(_T('*') == ch) || (_T('/') == ch))¤				return TRUE;¤		} //if¤	} //for¤	return FALSE;¤} //End GetIndexNextAlphaNum¤¤/////////////////////////////////////////////////////////////////¤// Search a first char of the chars set¤//---------------------------------------------------------------¤// Parameters:¤//     In: str      - a string with html text¤//         nIndex   - an index of the first char to the searching in the string¤//		   strChars - the set of the chars¤//    Out: nIndex   - an index of the first found char¤// Return: A found char or zero if chars was not found  ¤/////////////////////////////////////////////////////////////////¤TCHAR CPPHtmlDrawer::GetIndexNextChars(CPPString & str, int & nIndex, CPPString strChars)¤{¤	int i;¤	for (; nIndex < str.GetLength(); nIndex++)¤	{¤		for (i = 0; i < strChars.GetLength(); i++)¤		{¤			if (str.GetAt(nIndex) == strChars.GetAt(i))¤				return str.GetAt(nIndex);¤		} //for¤	} //for¤	return 0;¤} //End GetIndexNextChars¤¤/////////////////////////////////////////////////////////////////¤// Search a first char isn't specified in chars set¤//---------------------------------------------------------------¤// Parameters:¤//     In: str      - a string with html text¤//         nIndex   - an index of the first char to the searching in the string¤//		   strChars - the set of the chars¤//    Out: nIndex   - an index of the first char isn't from chars set¤// Return: A found char or zero if all chars was specified in the chars set  ¤/////////////////////////////////////////////////////////////////¤TCHAR CPPHtmlDrawer::GetIndexNextNoChars(CPPString & str, int & nIndex, CPPString strChars)¤{¤	int i;¤	BOOL bFound;¤	for (; nIndex < str.GetLength(); nIndex++)¤	{¤		bFound = FALSE;¤		for (i = 0; (i < strChars.GetLength()) && !bFound; i++)¤		{¤			if (str.GetAt(nIndex) == strChars.GetAt(i))¤				bFound = TRUE;¤		} //for¤		if (!bFound)¤			return str.GetAt(nIndex);¤	} //for¤	return 0;¤} //End GetIndexNextNoChars¤¤/////////////////////////////////////////////////////////////////¤// Is exist a property's parameter?¤//---------------------------------------------------------------¤// Parameters:¤//     In: str         - a string with html text¤//         nIndex      - an index of the first char to the searching in the string¤//		   chSeparator - the char is a begin of the parameter¤//    Out: nIndex   - an index of the begin parameter (if it exist) or the begin of the next property¤// Return: TRUE if parameter was found  ¤/////////////////////////////////////////////////////////////////¤BOOL CPPHtmlDrawer::GetBeginParameter(CPPString & str, int & nIndex, TCHAR chSeparator /* = _T(':') */)¤{¤	TCHAR ch;¤	for (; nIndex < str.GetLength(); nIndex++) ¤	{¤		//Gets a current char¤		ch = str.GetAt(nIndex);¤		if (_T(' ') != ch)¤		{¤			//if it is not space char¤			if (chSeparator == ch)¤			{¤				//if begin of the property's parameter was found¤				nIndex ++; //jump to the next char after a begin parameter¤				return TRUE;¤			}¤			else¤			{¤				return FALSE;¤			}//if¤		} //if¤	} //for¤	return FALSE;¤} //End GetBeginParameter¤¤/////////////////////////////////////////////////////////////////¤// Gets a parameter for the currrent property¤//---------------------------------------------------------------¤// Parameters:¤//     In: str         - a string with html text¤//         nIndex      - an index of the first char to the searching in the string¤//		   chSeparator - the char is a begin of the parameter¤//    Out: nIndex   - an index of the first char after the parameter¤// Return: String of the property's parameter (empty if it is not exist)  ¤/////////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::GetParameterString(CPPString & str, int & nIndex, TCHAR chBeginParam /* = _T(':') */, CPPString strSeparators /* = _T(";") */)¤{¤	if (GetBeginParameter(str, nIndex, chBeginParam))¤	{¤		//Parameter for the current property was found¤		TCHAR ch = GetIndexNextNoChars(str, nIndex, strSeparators + _T(" "));¤		if (0 != ch)¤		{¤			int nBegin = nIndex;¤			if (_T('"') == str.GetAt(nIndex))¤			{¤				nIndex++;¤				TCHAR ch = GetIndexNextChars(str, nIndex, _T("\""));¤				if (_T('"') == ch)¤				{¤					nIndex ++;¤					return str.Mid(nBegin + 1, nIndex - nBegin - 2);¤				} //if¤			}¤			else¤			{¤				GetIndexNextChars(str, nIndex, strSeparators);¤				return str.Mid(nBegin, nIndex - nBegin);¤			} //if¤		} //if¤	} //if¤	return _T("");¤} //End GetParameterString¤¤/////////////////////////////////////////////////////////////////¤// Gets a name of the tag¤//---------------------------------------------------------------¤// Parameters:¤//     In: str         - a tag's string¤//         nIndex      - an index of the first char to the searching in the string¤//    Out: nIndex   - an index of the first char after the parameter¤// Return: Name of the tag (empty if it is not exist)  ¤/////////////////////////////////////////////////////////////////¤CPPString CPPHtmlDrawer::GetNameOfTag(CPPString & str, int & nIndex)¤{¤	CPPString strName = _T("");¤	GetIndexNextNoChars(str, nIndex, _T(" "));¤	int nBegin = nIndex;¤	GetIndexNextChars(str, nIndex, _T(" ="));¤	if (nIndex > nBegin)¤		strName = str.Mid(nBegin, nIndex - nBegin);¤	¤	return strName;¤} //End GetNameOfTag¤¤/////////////////////////////////////////////////////¤// Gets dimensions of the table¤//---------------------------------------------------¤//  In: sTable - the string contains a HTML table¤// Return: cx - number of the columns¤//         cy - number of the row¤/////////////////////////////////////////////////////¤SIZE CPPHtmlDrawer::GetTableDimensions(CPPString & sTable)¤{¤	//ENG: A table dimensions by default¤	//RUS: Размеры таблицы по умолчанию¤	SIZE szTable = {0, 0};¤	int nIndex = 0;¤	int nCol = 0;¤	while (nIndex < sTable.GetLength())¤	{¤		//ENG: Search a begin of the row¤		//RUS: Ищем начало строки¤		if (SearchTag(sTable, nIndex, _T("tr")))¤		{¤			//ENG: Increment count of the rows¤			//RUS: Увеличиваем количество строк¤			szTable.cy++;¤¤			//ENG: Count of the columns in current row¤			//RUS: Количество колонок в текущей строке¤			nCol = 0;¤			int nEndRow;¤			int nNewCell;¤			do ¤			{¤				nEndRow = nNewCell = nIndex;¤				//ENG: Search an end of the row or a begin of the cell¤				//RUS: Ищем конец строки или начало ячейки¤				SearchTag(sTable, nEndRow, _T("/tr"));¤				SearchTag(sTable, nNewCell, _T("td"));¤				if (nNewCell < nEndRow)¤				{¤					nIndex = nNewCell;¤¤					//ENG: Passes a tag body and get a properties of the tag¤					//RUS: Пропускаем тэг начала ячейки и получаем строку свойств тэга¤					CPPString sTag;¤					SearchNextTag(sTable, sTag, nNewCell);¤					CPPString sProperties = SplitTag(sTag);¤¤					//ENG: Analyses a properties of the tag¤					//RUS: Анализируем свойства тэга¤					STRUCT_CHANGESTYLE style;¤					SIZE szSpan = AnalyseCellParam(sProperties, style, TRUE);¤¤					//ENG: Increment count of the cells¤					//RUS: Увеличиваем количество ячеек в строке¤					nCol += szSpan.cx;¤¤					//ENG: Jump to end of the cell¤					//RUS: Переходим на конец ячейки¤					SearchEndOfCell(sTable, nIndex);¤				} //if¤			} while (nNewCell < nEndRow);¤			nIndex = nEndRow;¤			if (nCol > szTable.cx)¤				szTable.cx = nCol;¤		} //if¤	} //while¤	return szTable;¤} //End GetTableDimensions¤¤/////////////////////////////////////////////////////¤// CPPHtmlDrawer::SearchEndOfTable¤//	Searching the end of the table¤//---------------------------------------------------¤//  Parameter:    ¤//		str - the string contains a HTML table¤//		nIndex - index of the first char after the <table> tag¤//	Return values:¤//		nIndex - index of the begin char of a </table> tag¤/////////////////////////////////////////////////////¤void CPPHtmlDrawer::SearchEndOfTable(CPPString & str, int & nIndex)¤{¤	int nBeginTable = nIndex + 7;¤	int nEndTable = nIndex + 7;¤	int nTable = 1;¤	do¤	{¤		SearchTag(str, nBeginTable, _T("table"));¤		SearchTag(str, nEndTable, _T("/table"));¤		if (nBeginTable < nEndTable)¤		{¤			nTable++;¤			nBeginTable += 7;¤		}¤		else if (nEndTable < nBeginTable)¤		{¤			nTable --;¤			nEndTable += 8;¤		} //if¤	}¤	while ((nBeginTable != nEndTable) && nTable); //while¤	nIndex = nEndTable - 8;¤} //End SearchEndOfTable¤¤/////////////////////////////////////////////////////¤// CPPHtmlDrawer::SearchEndOfRow¤//	Searching the end of the row¤//---------------------------------------------------¤//  Parameter:    ¤//		str - the string contains a HTML table¤//		nIndex - index of the first char after the <tr> tag¤//	Return values:¤//		nIndex - index of the begin char of a </tr> tag¤/////////////////////////////////////////////////////¤void CPPHtmlDrawer::SearchEndOfRow(CPPString & str, int & nIndex)¤{¤	nIndex += 4;¤	int nBeginRow, nEndRow, nStartTable;¤	int nRow = 1;¤¤	do¤	{¤		nBeginRow = nEndRow = nStartTable = nIndex;¤¤		SearchTag(str, nBeginRow, _T("tr"));¤		SearchTag(str, nEndRow, _T("/tr"));¤		SearchTag(str, nStartTable, _T("table"));¤		¤		if ((nStartTable < nBeginRow) && (nStartTable < nEndRow))¤		{¤			SearchEndOfTable(str, nStartTable);¤			nIndex = nStartTable + 6;¤		}¤		else if (nBeginRow < nEndRow)¤		{¤			nRow++;¤			nIndex = nBeginRow + 4;¤		}¤		else if (nEndRow < nBeginRow)¤		{¤			nRow --;¤			nIndex = nEndRow + 5;¤		} //if¤	}¤	while ((nIndex < str.GetLength()) && nRow); //while¤	nIndex -= 5;¤} //End SearchEndOfRow¤¤/////////////////////////////////////////////////////¤// CPPHtmlDrawer::SearchEndOfCell¤//	Searching the end of the cell¤//---------------------------------------------------¤//  Parameter:    ¤//		str - the string contains a HTML table¤//		nIndex - index of the first char after the <td> tag¤//	Return values:¤//		nIndex - index of the begin char of a </td> tag¤/////////////////////////////////////////////////////¤void CPPHtmlDrawer::SearchEndOfCell(CPPString & str, int & nIndex)¤{¤	nIndex += 4;¤	int nEndCell, nStartTable;¤	do¤	{¤		nEndCell = nStartTable = nIndex;¤¤		SearchTag(str, nEndCell, _T("/td"));¤		SearchTag(str, nStartTable, _T("table"));¤		¤		if (nStartTable < nEndCell)¤		{¤			SearchEndOfTable(str, nStartTable);¤			nEndCell = nIndex = nStartTable + 6;¤		}¤		else¤		{¤			nIndex = nEndCell + 5;¤		} //if¤	}¤	while (nStartTable < nEndCell); //while¤	nIndex -= 5;¤} //End SearchEndOfCell¤¤///////////////////////////////////////////////////////////////////////¤// Analysing the cell parameters¤//---------------------------------------------------------------------¤// Parameters:¤//   In: strTag - str string contains parameters of the <table>, <td> or <tr> tags¤//           cs - the structures contains the current styles¤//		 bTable - ¤//  Out:     cs - the structures contains the new styles¤///////////////////////////////////////////////////////////////////////¤SIZE CPPHtmlDrawer::AnalyseCellParam(CPPString & sProperties, _STRUCT_CHANGESTYLE & cs, BOOL bTable)¤{¤	SIZE szSpan = {1, 1};¤	if (sProperties.IsEmpty())¤		return szSpan;¤	¤	int i = 0;¤	CPPString sParameter;¤	CPPString sValue;¤	¤	while (i < sProperties.GetLength())¤	{¤		//ENG: Searching a parameters of a tag¤		//RUS: Поиск параметров тэга¤		sValue = GetNextProperty(sProperties, i, sParameter);¤¤		//ENG: Processes the specific parameters for <table> tag.¤		//RUS: Обрабатываем специфические для тэга <table> параметры¤		if(bTable)¤		{¤			if (sParameter == _T("cellpadding"))¤			{¤				cs.nMargin = GetLengthUnit(sValue, cs.nMargin);¤			}¤			else if (sParameter == _T("cellspacing"))¤			{¤				cs.nPadding = GetLengthUnit(sValue, cs.nPadding);¤			} ¤			else if (sParameter == _T("background"))¤			{¤				cs.strNameResBk = sValue;¤			} //if¤		} //if¤¤		if (sParameter == _T("rowspan"))¤		{¤			szSpan.cy = GetLengthUnit(sValue, szSpan.cy);¤		}¤		else if (sParameter == _T("colspan"))¤		{¤			szSpan.cx = GetLengthUnit(sValue, szSpan.cx);¤		}¤		else if (sParameter == _T("border"))¤		{¤			cs.nBorderWidth = GetLengthUnit(sValue, cs.nBorderWidth);¤			if (!cs.nBorderWidth)¤				cs.nBorderStyle = CPPDrawManager::PEN_NULL;¤			else if (CPPDrawManager::PEN_NULL == cs.nBorderStyle)¤				cs.nBorderStyle = CPPDrawManager::PEN_SOLID;¤		}¤		else if (sParameter == _T("borderstyle"))¤		{¤			cs.nBorderStyle = StyleBorder(sValue, cs.nBorderStyle);¤			if ((CPPDrawManager::PEN_NULL != cs.nBorderStyle) && !cs.nBorderWidth)¤					cs.nBorderWidth = 1;¤		}¤		else if (sParameter == _T("bordercolor"))¤		{¤			if (m_bIsEnable)¤				cs.crBorderLight = GetStyleColor(sValue, cs.crBorderLight);¤			else¤				cs.crBorderLight = GetColorByName("");¤			cs.crBorderDark = cs.crBorderLight;¤		}¤		else if (sParameter == _T("bordercolorlight"))¤		{¤			if (m_bIsEnable)¤				cs.crBorderLight = GetStyleColor(sValue, cs.crBorderLight);¤			else¤				cs.crBorderLight = GetColorByName("");¤		}¤		else if (sParameter == _T("bordercolordark"))¤		{¤			if (m_bIsEnable)¤				cs.crBorderDark = GetStyleColor(sValue, cs.crBorderDark);¤			else¤				cs.crBorderDark = GetColorByName("");¤		}¤		else if (sParameter == _T("bgcolor"))¤		{¤			if (m_bIsEnable)¤			{¤				cs.crBkgnd = GetStyleColor(sValue, cs.crBkgnd);¤				if (cs.nFillBkgnd < 0)¤					cs.nFillBkgnd = CPPDrawManager::EFFECT_SOLID;¤			} //if¤		}¤		else if (sParameter == _T("bgmidcolor"))¤		{¤			if (m_bIsEnable)¤				cs.crMidBkgnd = GetStyleColor(sValue, cs.crMidBkgnd);¤		}¤		else if (sParameter == _T("bgendcolor"))¤		{¤			if (m_bIsEnable)¤				cs.crEndBkgnd = GetStyleColor(sValue, cs.crEndBkgnd);¤		}¤		else if (sParameter == _T("bgeffect"))¤		{¤			if (m_bIsEnable)¤				cs.nFillBkgnd = GetStyleBkgndEffect(sValue, cs.nFillBkgnd);¤		}¤		else if (sParameter == _T("align"))¤		{¤			cs.nHorzAlign = GetStyleHorzAlign(sValue, cs.nHorzAlign);¤		}¤		else if (sParameter == _T("valign"))¤		{¤			cs.nVertAlign = GetStyleVertAlign(sValue, cs.nVertAlign);¤		}¤		else if (sParameter == _T("width"))¤		{¤			cs.nCellWidth = GetLengthUnit(sValue, cs.nCellWidth);¤		}¤		else if (sParameter == _T("height"))¤		{¤			cs.nCellHeight = GetLengthUnit(sValue, cs.nCellHeight);¤		} //if¤	} //for¤¤	//ENG:¤	//RUS: ¤	if ((CPPDrawManager::PEN_NULL == cs.nBorderStyle) || !cs.nBorderWidth)¤	{¤		cs.nBorderStyle = CPPDrawManager::PEN_NULL;¤		cs.nBorderWidth = 0;¤	}¤	else if (CPPDrawManager::PEN_SOLID != cs.nBorderStyle)¤	{¤		cs.nBorderWidth = 1;¤	}	//if¤¤	//ENG: ¤	//RUS: Для ячеек ширина всегда равна 1¤	if (!bTable && cs.nBorderWidth)¤		cs.nBorderWidth = 1;¤¤	return szSpan;¤} //End AnalyseCellParam¤¤///////////////////////////////////////////////////////////////////////¤// Analysing the image parameters¤//---------------------------------------------------------------------¤// Parameters:¤//   In: sProperties - the sing contains¤//           si - the structures contains the image parameters¤//  Out:     si - the structures contains the image parameters¤///////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::AnalyseImageParam(CPPString & sProperties, _STRUCT_IMAGE & si)¤{¤	if (sProperties.IsEmpty())¤		return;¤	¤	int i = 0;¤	CPPString sParameter;¤	CPPString sValue;¤	¤	while (i < sProperties.GetLength())¤	{¤		//ENG: Searching a parameters of a tag¤		//RUS: Поиск параметров тэга¤		sValue = GetNextProperty(sProperties, i, sParameter);¤¤//		sParameter = SearchPropertyOfTag(sProperties, i);¤//		sValue = GetParameterString(sProperties, i, _T('='), _T(" "));¤			¤		if (sParameter == _T("index"))¤		{¤			si.nIndexImageList = GetLengthUnit(sValue, si.nIndexImageList);¤		}¤		else if (sParameter == _T("idres"))¤		{¤			si.nIdRes = GetLengthUnit(sValue, si.nIdRes);¤		}¤		else if (sParameter == _T("iddll"))¤		{¤			si.nIdDll = GetLengthUnit(sValue, si.nIdDll);¤		}¤		else if (sParameter == _T("handle"))¤		{¤			si.nHandle = GetLengthUnit(sValue, si.nHandle);¤		}¤		else if (sParameter == _T("file"))¤		{¤			si.strSrcFile = GetStyleString(sValue, si.strSrcFile);¤		}¤		else if (sParameter == _T("srcdll"))¤		{¤			si.strPathDll = GetStyleString(sValue, si.strPathDll);¤		}¤		else if (sParameter == _T("mask"))¤		{¤			si.crMask = GetStyleColor(sValue, si.crMask);¤			si.bUseMask = TRUE;¤		}¤		else if (sParameter == _T("style"))¤		{¤			si.nStyles = GetStyleImageShortForm(sValue);¤			si.nHotStyles = si.nStyles;¤		}¤		else if (sParameter == _T("hotstyle"))¤		{¤			si.nHotStyles = GetStyleImageShortForm(sValue);¤		}¤		else if (sParameter == _T("cx"))¤		{¤			si.cx = GetLengthUnit(sValue, si.cx);¤		}¤		else if (sParameter == _T("cy"))¤		{¤			si.cy = GetLengthUnit(sValue, si.cy);¤		}¤		else if (sParameter == _T("width"))¤		{¤			si.bPercentWidth = IsPercentableValue(sValue);¤			si.nWidth = GetLengthUnit(sValue, si.nWidth);¤		}¤		else if (sParameter == _T("height"))¤		{¤			si.bPercentHeight = IsPercentableValue(sValue);¤			si.nHeight = GetLengthUnit(sValue, si.nHeight);¤		}¤		else if (sParameter == _T("speed"))¤		{¤			si.nSpeed = GetLengthUnit(sValue, si.nSpeed);¤		} //if¤	} //for¤} //End AnalyseImageParam¤¤CPPString CPPHtmlDrawer::GetStyleString(CPPString str, CPPString strDefault)¤{¤	if (!str.IsEmpty())¤		strDefault = str;¤	return str;¤}¤¤///////////////////////////////////////////////////////////////////////¤// Analysing the short form of the font style¤//---------------------------------------------------------------------¤// Parameters:¤//   In: str - string contains parameters of the font in the short form¤// Short form styles¤//       [+] - positive style¤//       [-] - inverse style¤//       [b] - bold¤//       [i] - italic¤//       [u] - underlined¤//       [s] - strikeout¤//       [o] - overline¤///////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::GetStyleFontShortForm(CPPString & str)¤{¤	if (!str.IsEmpty())¤	{¤		BOOL bSetValue = TRUE;¤		for (int i = 0; i < str.GetLength(); i++)¤		{¤			switch (str.GetAt(i))¤			{¤			case _T('-'):¤				bSetValue = FALSE;¤				break;¤			case _T('+'):¤				bSetValue = TRUE;¤				break;¤			case _T('b'):¤				m_defStyle.nWeightFont = (bSetValue) ? FW_BOLD : FW_NORMAL;¤				bSetValue = TRUE;¤				break;¤			case _T('i'):¤				m_defStyle.bItalicFont = bSetValue;¤				bSetValue = TRUE;¤				break;¤			case _T('u'):¤				m_defStyle.bUnderlineFont = bSetValue;¤				bSetValue = TRUE;¤				break;¤			case _T('s'):¤				m_defStyle.bStrikeOutFont = bSetValue;¤				bSetValue = TRUE;¤				break;¤			case _T('o'):¤				m_defStyle.bOverlineFont = bSetValue;¤				bSetValue = TRUE;¤				break;¤			} //switch¤		} //for¤	} //if¤} //End GetStyleFontShortForm¤¤//Get font style value¤UINT CPPHtmlDrawer::GetStyleImageShortForm(CPPString & str)¤{¤	UINT uStyle = 0; //Original image¤	¤	if (!str.IsEmpty())¤	{¤		for (int i = 0; i < str.GetLength(); i++)¤		{¤			switch (str.GetAt(i))¤			{¤			case _T('d'):¤				uStyle |= IMAGE_EFFECT_DARKEN;¤				break;¤			case _T('g'):¤				uStyle |= IMAGE_EFFECT_GRAYEN;¤				break;¤			case _T('s'):¤				if (m_szOffsetShadow.cx || m_szOffsetShadow.cy)¤				{¤					if (m_bGradientShadow)¤						uStyle |= IMAGE_EFFECT_GRADIENT_SHADOW;¤					else uStyle |= IMAGE_EFFECT_MONO_SHADOW;¤				} //if¤				break;¤			case _T('l'):¤				uStyle |= IMAGE_EFFECT_LIGHTEN;¤				break;¤			} //switch¤		} //for¤	} //if¤	¤	return uStyle;¤} //End GetStyleImageShortForm¤¤BOOL CPPHtmlDrawer::IsPercentableValue(CPPString & str)¤{¤	if (!str.IsEmpty())¤	{¤		if (str.GetAt(str.GetLength() - 1) == _T('%'))¤			return TRUE;¤	}¤	return FALSE;¤}¤¤int CPPHtmlDrawer::GetStyleBkgndEffect(CPPString & str, int nDefault)¤{¤	if (!str.IsEmpty())¤	{¤		if (str == _T("transparent"))¤			nDefault = -1;¤		else if (str == _T("solid"))¤			nDefault = CPPDrawManager::EFFECT_SOLID;¤		else if (str == _T("hgradient"))¤			nDefault = CPPDrawManager::EFFECT_HGRADIENT;¤		else if (str == _T("vgradient"))¤			nDefault = CPPDrawManager::EFFECT_VGRADIENT;¤		else if (str == _T("hcgradient"))¤			nDefault = CPPDrawManager::EFFECT_HCGRADIENT;¤		else if (str == _T("vcgradient"))¤			nDefault = CPPDrawManager::EFFECT_VCGRADIENT;¤		else if (str == _T("3hgradient"))¤			nDefault = CPPDrawManager::EFFECT_3HGRADIENT;¤		else if (str == _T("3vgradient"))¤			nDefault = CPPDrawManager::EFFECT_3VGRADIENT;¤#ifdef USE_SHADE¤		else if (str == _T("noise"))¤			nDefault = CPPDrawManager::EFFECT_NOISE;¤		else if (str == _T("diagshade"))¤			nDefault = CPPDrawManager::EFFECT_DIAGSHADE;¤		else if (str == _T("hshade"))¤			nDefault = CPPDrawManager::EFFECT_HSHADE;¤		else if (str == _T("vshade"))¤			nDefault = CPPDrawManager::EFFECT_VSHADE;¤		else if (str == _T("hbump"))¤			nDefault = CPPDrawManager::EFFECT_HBUMP;¤		else if (str == _T("vbump"))¤			nDefault = CPPDrawManager::EFFECT_VBUMP;¤		else if (str == _T("softbump"))¤			nDefault = CPPDrawManager::EFFECT_SOFTBUMP;¤		else if (str == _T("hardbump"))¤			nDefault = CPPDrawManager::EFFECT_HARDBUMP;¤		else if (str == _T("metal"))¤			nDefault = CPPDrawManager::EFFECT_METAL;¤#endif¤		else nDefault = GetLengthUnit(str, nDefault);¤	} //if¤¤	return nDefault;¤} //End GetStyleBkgndEffect¤¤int CPPHtmlDrawer::GetTableWidth(CPPString & str, int nClientWidth, int nMinWidth, BOOL bSet /* = FALSE */)¤{¤	if (!str.IsEmpty())¤	{¤		int i = 0;¤		CPPString strProperty;¤		CPPString strParameter;¤		¤		while (i < str.GetLength())¤		{¤			strProperty = SearchPropertyOfTag(str, i);¤			strParameter = GetParameterString(str, i, _T('='), _T(" "));¤			strProperty.MakeLower();¤			¤			if (strProperty == _T("width"))¤			{¤				if (IsPercentableValue(strParameter))¤				{¤					int nWidth = GetLengthUnit(strParameter, 100);¤					if (bSet)¤					{¤						if (nWidth <= 100)¤							nClientWidth = ::MulDiv(nMinWidth, 100, nWidth);¤						else¤							nClientWidth = ::MulDiv(nMinWidth, nWidth, 100);¤					}¤					else¤					{¤						if (nWidth < 100)¤							nClientWidth = ::MulDiv(nClientWidth, nWidth, 100);¤					} //if¤				}¤				else¤				{¤					nClientWidth = GetLengthUnit(strParameter, nMinWidth);¤				} //if¤				break;¤			} //if¤		} //while¤	} //if¤¤	if (nClientWidth < nMinWidth)¤		nClientWidth = nMinWidth;¤¤	return nClientWidth;¤} //End GetTableWidth¤¤void CPPHtmlDrawer::DrawBackgroundImage(HDC hDC, int nDestX, int nDestY, int nWidth, int nHeight, CPPString strNameImage)¤{¤	if (!m_bIsEnable)¤		return;¤	if (strNameImage.IsEmpty())¤		return;¤	if (strNameImage.GetLength() < 6)¤		return;¤¤	HBITMAP hBitmap = NULL;¤¤	int nIndex = 0;¤	if (GetIndexNextAlphaNum(strNameImage, nIndex))¤	{¤		int nBegin = nIndex;¤		//Searching end of the style name¤		TCHAR chSymbol = GetIndexNextChars(strNameImage, nIndex, _T(" :"));¤		if (0 != chSymbol)¤		{¤			//Gets a property's name¤			CPPString strName = strNameImage.Mid(nBegin, nIndex - nBegin);¤			//Gets a property's value¤			CPPString strParameter = GetParameterString(strNameImage, nIndex, _T(':'));¤			¤			if (strName == _T("idres"))¤			{¤				UINT nID = (UINT)GetLengthUnit(strParameter, 0);¤				hBitmap = GetBitmapFromResources(nID);¤			}¤			else if (strName == _T("iddll"))¤			{¤				UINT nID = (UINT)GetLengthUnit(strParameter, 0);¤				hBitmap = GetBitmapFromDll(nID);¤			}¤			else if (strName == _T("file"))¤			{¤				hBitmap = GetBitmapFromFile(strParameter);¤			} //if¤		} //if¤	} //if¤¤	if (NULL == hBitmap)¤		return;¤¤	SIZE sz;¤	m_drawmanager.GetSizeOfBitmap(hBitmap, &sz);¤	HDC hSrcDC = ::CreateCompatibleDC(hDC);¤	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hSrcDC, hBitmap);¤	m_drawmanager.MultipleCopy(hDC, nDestX, nDestY, nWidth, nHeight, hSrcDC, 0, 0, sz.cx, sz.cy);¤	::SelectObject(hSrcDC, hOldBitmap);¤	::DeleteDC(hSrcDC);¤¤	::DeleteObject(hBitmap);¤	hBitmap = NULL;¤} //End of DrawBackgroundImage¤¤////////////////////////////////////////////////////////////////////¤// CPPHtmlDrawer::SetTooltipShadow()¤//		Sets a image's shadow.¤//------------------------------------------------------------------¤// Parameters:¤//		nOffsetX, ¤//		nOffsetY		- The offsets of the tooltip's shadow from the tooltip's window.¤//		nDarkenPercent	- So far as colors under the shadow will be darken (0 - 100)¤//      bGradient		- TRUE to use a gradient shadow.¤//		nDepthX,¤//		nDepthY			- The gradient depths of the tooltip's shadow.¤////////////////////////////////////////////////////////////////////¤void CPPHtmlDrawer::SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent /* = 50 */, ¤								  BOOL bGradient /* = TRUE */, int nDepthX /* = 7 */, int nDepthY /* = 7 */)¤{¤	m_szOffsetShadow.cx = nOffsetX;¤	m_szOffsetShadow.cy = nOffsetY;¤	m_szDepthShadow.cx = nDepthX;¤	m_szDepthShadow.cy = nDepthY;¤	m_nDarkenShadow = std::min(100, (int)nDarkenPercent);¤	m_bGradientShadow = bGradient;¤	BYTE nColor = ::MulDiv(255, 100 - m_nDarkenShadow, 100);¤	m_crShadow = RGB(nColor, nColor, nColor);¤} //End of SetTooltipShadow¤¤CPPString CPPHtmlDrawer::GetWordWrap(CPPString & str, int nMaxSize, int & nRealSize)¤{¤	int nCurIndex = 0;¤	int nLastIndex = 0;¤	SIZE sz = {0, 0};¤	TCHAR tch = _T(' ');¤	CPPString sResult = _T("");¤	while ((sz.cx <= nRealSize) && (0 != tch))¤	{¤		nLastIndex = nCurIndex;¤		nCurIndex ++;¤		tch = GetIndexNextChars(str, nCurIndex, PPHTMLDRAWER_BREAK_CHARS);¤		::GetTextExtentPoint32(m_hDC, str, nCurIndex, &sz);¤	} //while¤¤	if (0 == nLastIndex)¤	{¤		if (nMaxSize == nRealSize)¤		{¤			//RUS: Разрывов в строке не обнаружено, поэтому будем разбивать строку ¤			//     по символам, а не по словам¤			sz.cx = 0;¤			int i = 1;¤			for (; i < str.GetLength(); i++)¤			{¤				::GetTextExtentPoint32(m_hDC, str, i + 1, &sz);¤				if (sz.cx > nRealSize)¤				{¤					sResult = str.Left(i);¤					str = str.Mid(i);¤					::GetTextExtentPoint32(m_hDC, sResult, i, &sz);¤					nRealSize = sz.cx;¤					return sResult;¤				} //if¤			} //for¤			::GetTextExtentPoint32(m_hDC, str, i, &sz);¤			//RUS: Невозможно разбить строку, выводим целиком¤			sResult = str;¤			str.Empty();¤		}¤		else¤		{¤			//RUS: В отставшееся место текущей строки не влазит ни одного слова¤			sz.cx = 0;¤		} //if¤	}¤	else ¤	{¤		sResult = str.Left(nLastIndex + 1);¤		str = str.Mid(nLastIndex + 1);¤		sResult.TrimRight();¤		::GetTextExtentPoint32(m_hDC, sResult, sResult.GetLength(), &sz);¤//		str.TrimRight();¤		str.TrimLeft();¤	} //if¤	nRealSize = sz.cx;¤	return sResult;¤} //End of GetWordWrap¤¤int CPPHtmlDrawer::GetCountOfChars(CPPString str, TCHAR tchar /*= _T(' ')*/)¤{¤	int nCount = 0;¤	//ENG:¤	//RUS:¤	for (int i = 0; i < str.GetLength(); i++)¤	{¤		if (tchar == str.GetAt(i))¤			nCount++;¤	} //if¤	return nCount;¤}¤//#UC END# *4700B81F006D*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B81F006D_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B81F006D_DESTR_BODY*¤	SetResourceDll(NULL);¤¤	if (NULL != m_hLinkCursor)¤	{¤		::DestroyCursor(m_hLinkCursor);¤		m_hLinkCursor = NULL;¤	}¤	¤	if (NULL != m_hImageList)¤		::DeleteObject(m_hImageList);¤	//#UC END# *4700B81F006D_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B81F006D_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B81F006D_CUSTOM_INCLUDES*¤#include "shared/WinGUI/Controls/CPPDrawManager.h"¤#include <vector>¤#include <map>¤¤#ifdef _MFC_VER¤	#define CPPString	CString //MFC program¤#endif¤//#UC END# *4700B81F006D_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B81F006D*"
		    value      	(value Text 
|//#UC START# *4700B81F006D*¤public:¤	CPPHtmlDrawer();¤¤// Attributes¤public:¤¤// Operations¤public:¤	//Drawing methods¤	void  Draw(HDC hDC, LPCTSTR lpszHtml, LPPOINT lpPoint);¤	void  PrepareOutput(HDC hDC, LPCTSTR lpszHtml, LPSIZE lpSize); //Prepares to draw the HTML string¤	void  DrawPreparedOutput(HDC hDC, LPCRECT lpRect);¤¤	void  EnableEscapeSequences(BOOL bEnable = TRUE);¤	void  EnableOutput(BOOL bEnable = TRUE);¤	void  SetDisabledColor(COLORREF color);¤	¤	//Shadow of the image¤	void SetImageShadow(int nOffsetX, int nOffsetY, BYTE nDarkenPercent = 50, BOOL bGradient = TRUE, int nDepthX = 7, int nDepthY = 7);¤¤	CPPString GetResCommandPrompt(UINT nID, UINT nNumParam = 0);¤¤	//Functions for the styles¤	void SetTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszStyleValue);¤	void SetCssStyles(LPCTSTR lpszCssString = NULL); //Sets the CSS styles¤	void SetCssStyles(DWORD dwIdCssString, LPCTSTR lpszPathDll = NULL); //Sets the CSS styles¤	LPCTSTR GetCssStyles(); //Returns the current CSS styles¤¤	void OnLButtonDown(LPPOINT lpClient);¤	BOOL OnSetCursor(LPPOINT lpClient);¤	BOOL OnTimer(); //New timer count¤¤	void SetHyperlinkCursor(HCURSOR hCursor = NULL); //Sets the cursor to be displayed when moving the mouse over a link. Specifying NULL will cause the control to display its default 'hand' cursor.¤	HCURSOR GetHyperlinkCursor() const; //Returns the current link cursor.¤¤	void SetCallbackHyperlink(HWND hWnd, UINT nMessage, LPARAM lParam = 0); //Sets the callback message: "Mouse over the link".¤	void SetCallbackRepaint(HWND hWnd, UINT nMessage, LPARAM lParam = 0); //Sets the callback message: "Please repaint me".¤¤	//Functions for images¤	void SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));¤	void SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask = RGB(255, 0, 255));¤¤	void LoadResourceDll(LPCTSTR lpszPathDll, DWORD dwFlags = 0); //Sets the path to the resource's DLL¤	void SetResourceDll(HINSTANCE hInstDll = NULL); //Sets the handle of the loaded resource's DLL¤¤	void SetMaxWidth(int nWidth = 0) {m_nMaxWidth = nWidth;}; //Sets the maximum width of the output window.¤	int  GetMaxWidth() {return m_nMaxWidth;}; //Gets the maximum width of the output window.¤//	void EnableTextWrap(BOOL bEnable = TRUE){¤//		m_bIsTextWrapEnabled = bEnable;};¤//	BOOL IsTextWrapEnabled() {return m_bIsTextWrapEnabled;};¤¤	void SetTabSize(int nSize) {m_nTabSize = nSize;};¤¤	CPPDrawManager * GetDrawManager();¤¤	static short GetVersionI()		{return 0x13;}¤	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("1.3 beta");}¤	¤// Implementation¤protected:¤	enum{	ALIGN_LEFT = 0,¤			ALIGN_CENTER,¤			ALIGN_RIGHT,¤			ALIGN_JUSTIFY¤		};¤	¤	enum{	ALIGN_TOP = 0,¤			ALIGN_VCENTER,¤			ALIGN_BOTTOM,¤			ALIGN_BASELINE¤		};¤¤	enum{	LINK_NONE = 0,¤			LINK_HREF,¤			LINK_MESSAGE¤		};¤¤	enum{	TEXT_TRANSFORM_NONE = 0,¤			TEXT_TRANSFORM_UPPERCASE,¤			TEXT_TRANSFORM_LOWERCASE,¤			TEXT_TRANSFORM_CAPITALIZE¤		};¤¤	enum{	BORDER_STYLE_NONE = 0,¤			BORDER_STYLE_SOLID,¤			BORDER_STYLE_DOTTED,¤			BORDER_STYLE_DASHED,¤			BORDER_STYLE_DOUBLE,¤		};¤¤	enum {	TAG_NONE = 0,¤			TAG_BOLD,¤			TAG_ITALIC,¤			TAG_UNDERLINE,¤			TAG_STRIKEOUT,¤			TAG_FONT,¤			TAG_HLINE,¤			TAG_NEWLINE,¤			TAG_TABULATION,¤			TAG_LEFT,¤			TAG_CENTER,¤			TAG_RIGHT,¤			TAG_JUSTIFY,¤			TAG_BASELINE,¤			TAG_TOP,¤			TAG_VCENTER,¤			TAG_BOTTOM,¤			TAG_BITMAP,¤			TAG_ICON,¤			TAG_IMAGELIST,¤			TAG_STRING,¤			TAG_NEWSTYLE,¤			TAG_SPAN,¤			TAG_HYPERLINK¤		};¤¤#pragma pack(1)¤	typedef struct _STRUCT_TAGPROP¤	{¤		DWORD dwTagIndex;	// The hot rect of the hyperlink¤		CPPString strTagName;	// The type of the hyperlink¤	} STRUCT_TAGPROP;¤#pragma pack()¤¤#pragma pack(1)¤	typedef struct _STRUCT_ANIMATION¤	{¤		int nIndex;		//The current index of the image¤		int nMaxImages; //The max images in the bitmap¤		int nTimerCount;//The current time position¤		int nSpeed;		//The speed of animation¤	} STRUCT_ANIMATION;¤#pragma pack()¤¤#pragma pack(1)¤	typedef struct _STRUCT_HYPERLINK¤	{¤		RECT rcArea;		// The hot rect of the hyperlink¤		int nTypeLink;		// The type of the hyperlink¤		int nIndexLink;		// The index of the hyperlink¤		CPPString sHyperlink; // The hyperlink¤	} STRUCT_HYPERLINK;¤#pragma pack()¤	¤#pragma pack(1)¤	typedef struct _STRUCT_CHANGESTYLE ¤	{¤		CPPString strTag;		//The name of the last opened tag¤		¤		//Font¤		int  nSizeFont;		//The height of the logic font¤		int	 nWeightFont;	//The weight of the logic font¤		BOOL bItalicFont;	//Is italic logic font?¤		BOOL bUnderlineFont;//Is underline logic font?¤		BOOL bStrikeOutFont;//Is strikeout logic font?¤		BOOL bOverlineFont; //Is overline logic font?¤		CPPString sFaceFont;  //The face name of the logic font¤		¤		//Color		¤		COLORREF crText;	//The foreground color ¤		COLORREF crBkgnd;	//The background color (also begin for the gradient)¤		COLORREF crBorderLight;	//The border color¤		COLORREF crBorderDark;	//The border color¤		COLORREF crMidBkgnd;//The middle background color¤		COLORREF crEndBkgnd;//The end background color¤¤		//Fill¤		int  nBkMode;		//The background mode for the text (TRANSPARENT, OPAQUE)¤		int  nFillBkgnd;	//The fill effect of the background¤		CPPString strNameResBk;¤¤		//Align¤		int  nHorzAlign;	//The horizontal align¤		int  nVertAlign;	//The vertical align¤		¤		//Border¤		int  nBorderStyle;	//The border style¤		int  nBorderWidth;	//The width of the border¤¤		//Cell Sizes¤		int nCellWidth;		//The width of the cell¤		int nCellHeight;	//The height of the cell¤		BOOL bCellWidthPercent; //The width value in the percent¤		BOOL bCellHeightPercent; //The height value in the percent¤¤		//Text¤		int  nTextTransform;//Transformation of the text (NONE, UPPERCASE, LOWERCASE, CAPITALIZE)¤¤		int nMargin;		//Margins¤		¤		int nPadding;		//Padding¤		¤		//Hyperlink¤		int  nTypeLink;		//The type of the link (NONE, HREF, MESSAGE)¤		CPPString sHyperlink; //The additional parameter for the link¤	} STRUCT_CHANGESTYLE; ¤#pragma pack()¤	¤#pragma pack(1)¤	typedef struct _STRUCT_IMAGE¤	{¤		int			nIndexImageList;//image's index of the image list¤		int			nIdRes;			//ID resource from app¤		int			nIdDll;			//ID resource from dll¤		int			nHandle;		//handle of the resource¤		int			cx;				//horizontal size of image¤		int			cy;				//vertical size of image¤		int			nWidth;			//width of image¤		int			nHeight;		//height of image¤		int         nSpeed;			//speed for animation¤		UINT		nStyles;		//styles of image¤		UINT		nHotStyles;		//hot styles of image¤		BOOL        bUseMask;		//¤		BOOL		bPercentWidth;¤		BOOL		bPercentHeight;¤		COLORREF	crMask;			//color of mask¤		CPPString	strSrcFile;		//path on the source file¤		CPPString   strPathDll;		//path on the resource dll¤	} STRUCT_IMAGE;¤#pragma pack()¤	¤#pragma pack(1)¤	typedef struct _STRUCT_CALLBACK¤	{¤		HWND		hWnd;			/* Дескриптор окна, принимающего сообщение */¤		UINT		nMessage;		// Message identifier¤		WPARAM		wParam;¤		LPARAM		lParam;¤	} STRUCT_CALLBACK;¤#pragma pack()¤¤#pragma pack(1)¤	typedef struct _STRUCT_HTMLLINE¤	{¤		int  nWidthLine;¤		int  nHeightLine;¤		int  nDescentLine;¤		int  nAddPercentWidth;¤		int  nHorzAlign;¤		int  nSpaceChars;	//a count of space chars in the line¤		BOOL bWrappedLine;	//TRUE if text was wrapped in the current line¤	} STRUCT_HTMLLINE;¤#pragma pack()¤¤#pragma pack(1)¤	typedef struct _STRUCT_CELL¤	{¤		int   nColSpan;			//-1 = Cell isn't used, >0 - How much columns was spaned¤		int   nRowSpan;			//-1 = Cell isn't used, >0 - How much rows was spaned¤		SIZE  szText;			//Real size of the text's area¤		SIZE  szCell;			//Real size of the cell¤		BOOL  bFixedWidth;		//TRUE if width of this cell was fixed¤//		vecHtmlLine vecLines;¤//		int   nWidth;			//Width of the cell¤//		int   nHeight;			//Height of the cell¤//		BOOL  bWidthPercent;	//if TRUE nWidth member in a percents¤//		BOOL  bHeightPercent;	//if TRUE nHeight member in a percents¤	} STRUCT_CELL;¤#pragma pack()¤¤	//Cells of Table¤	typedef std::vector<STRUCT_CELL> vecRow;	//Alone row¤	typedef std::vector<vecRow> vecTable;		//Vector of the rows is a table¤	typedef std::vector<int> vecSize;			//Width of the columns or height of the rows¤	typedef std::vector<BOOL> vecFlag;			//Flags for fixed widthes of the columns¤¤#pragma pack(1)¤	typedef struct _STRUCT_TABLE¤	{¤		vecTable  cells;	//Info about each cell of the table¤		vecSize   width;	//Dimensions of the width of the columns¤		vecSize	  height;	//Dimensions of the height of the rows¤		vecFlag   fixed_width; //¤	} STRUCT_TABLE;¤#pragma pack()¤¤	typedef std::vector<STRUCT_TABLE> vecTables;¤	vecTables m_arrTables;	//All tables¤	int   m_nCurTable;	  //The current index of the table¤	int   m_nCurTableRow; //The current row of the table¤¤	STRUCT_CALLBACK	m_csCallbackRepaint; //Callback for repaint HTML drawer¤	STRUCT_CALLBACK	m_csCallbackLink; //Callback for hyperlink message¤	STRUCT_CHANGESTYLE m_defStyle;¤	STRUCT_HTMLLINE m_hline;¤¤	CPPDrawManager m_drawmanager;¤	¤	//Values of the system context¤	HIMAGELIST m_hImageList;¤	SIZE m_szImageList;¤¤	HINSTANCE m_hInstDll;¤	BOOL m_bFreeInstDll;¤¤	HCURSOR m_hLinkCursor;¤	HFONT m_hOldFont;¤	int m_nOldBkMode;¤	COLORREF m_crOldText;¤	COLORREF m_crOldBk;¤¤//	BOOL m_bIsTextWrapEnabled;		//Is text wrap enabled¤	BOOL m_bIsEnable; //TRUE for fullcolor output, FALSE for disabled output¤	COLORREF m_crDisabled;¤//	SIZE m_szOutput; // Output size¤	RECT m_rcOutput; //Output rectangle¤//	POINT m_ptOutput; //Output coordinates¤	HDC m_hDC; //Device context to output or to prepare¤	CPPString m_csHtmlText; //String to output¤¤//	COLORREF m_clrShadow;¤¤	int	  m_nNumPass;	//The number or type of the pass¤¤	int   m_nTabSize;	// The max size for the each tabulation¤	int   m_nMaxWidth;	// The max width for wrapping output¤	int   m_nCurLine;   // The current drawing line¤	int   m_nNumCurTable; //The number of the current table¤//	RECT  m_rect; //¤//	int m_nLineHeight; //The height of the current line¤//	int m_nLineDescent;¤	int m_nHoverIndexLink; //The index of the link under the mouse¤	int m_nCurIndexLink;¤	int m_nCurIndexAni; //The index of the animation¤	BOOL m_bLastValueIsPercent;¤	BOOL m_bEnableEscapeSequences; // ¤¤	//Shadow of the image¤	BOOL m_bGradientShadow;¤	SIZE m_szOffsetShadow;¤	SIZE m_szDepthShadow;¤	BYTE m_nDarkenShadow;¤	COLORREF m_crShadow;¤¤	TEXTMETRIC m_tm;¤¤	LOGFONT m_lfDefault; //Default font¤	HFONT m_hFont;¤¤	//Wrapper string¤	CPPString m_strPrefix; //Prefix string ¤	CPPString m_strPostfix; //Postfix string¤	CPPString m_strCssStyles;¤¤	//Vectors¤	typedef std::vector<STRUCT_HTMLLINE> vecHtmlLine;¤	vecHtmlLine m_arrHtmlLine;¤¤	//Vector of the stack¤	typedef std::vector<STRUCT_CHANGESTYLE> arrStack;¤	arrStack m_arrStack;¤¤	//Vector of the hyperlinks¤	typedef std::vector<STRUCT_HYPERLINK> arrLink;¤	arrLink m_arrLinks;¤¤	typedef std::vector<STRUCT_ANIMATION> arrAni;¤	arrAni m_arrAni;¤¤	//Map of the colors by name¤	typedef std::map<CPPString, COLORREF> mapColors;¤	typedef std::map<CPPString, COLORREF>::iterator iterMapColors;¤	mapColors m_mapColors;¤¤	//Map of the styles¤	typedef std::map<CPPString, CPPString> mapStyles;¤	typedef std::map<CPPString, CPPString>::iterator iter_mapStyles;¤	mapStyles m_mapStyles;¤	mapStyles m_mapSpecChars;¤¤	//Map of the colors by name¤	typedef std::map<CPPString, STRUCT_TAGPROP> mapTags;¤	typedef mapTags::iterator iterMapTags;¤	mapTags m_mapTags;¤//	mapTags m_mapTableProp;¤¤protected:¤	void SetListOfTags(); //Fill a map of tags¤	void AddTagToList(LPCTSTR lpszName, DWORD dwTagIndex, LPCTSTR lpszFullName); //Add tag to the list of tags¤	DWORD GetTagFromList(CPPString sTagName, CPPString & strFullName, BOOL & bCloseTag); //Get tag from the list¤¤	void SetListSpecChars();¤	void AddSpecChar(LPCTSTR lpszAlias, TCHAR tch);¤	void AddSpecChar(LPCTSTR lpszAlias, LPCTSTR lpszValue);¤	void ReplaceSpecChars();¤¤	//The resource's methods¤	HICON GetIconFromResources(DWORD dwID, int nWidth = 0, int nHeight = 0) const; //Load an icon from the app resources¤	HICON GetIconFromFile(LPCTSTR lpszPath, int nWidth = 0, int nHeight = 0) const; //Load an icon from the file¤	HICON GetIconFromDll(DWORD dwID, int nWidth = 0, int nHeight = 0, LPCTSTR lpszPathDll = NULL) const; //Load an icon from the dll resources¤	HBITMAP GetBitmapFromResources(DWORD dwID) const; //Load a bitmap from the app resources¤	HBITMAP GetBitmapFromFile(LPCTSTR lpszPath) const; //Load a bitmap from the file¤	HBITMAP GetBitmapFromDll(DWORD dwID, LPCTSTR lpszPathDll = NULL) const; //Load a bitmap from the dll resources¤	CPPString GetStringFromResource(DWORD dwID) const; //Load a string from the app resources¤	CPPString GetStringFromDll(DWORD dwID, LPCTSTR lpszPathDll = NULL) const; //Load a string from the dll resources¤¤	//The drawing methods¤	void DrawHtml(LPSIZE lpSize, LPCRECT lpRect); //Draws the HTML text on device context or gets the size of the output area.¤	SIZE DrawHtmlTable(CPPString & sTable, LPCRECT lpRect); //Draws the HTML table on device context or gets the size of the output area.¤//	SIZE DrawHtmlTableRow(CPPString & sRow, LPCRECT lpRect, vecCol & row); //Draws the HTML row of the table¤	void DrawHtmlTableRow(CPPString & sRow, LPCRECT lpRect, STRUCT_TABLE & st, int nRow);¤	void DrawHtmlTableCell(CPPString & sCell, LPCRECT lpRect, STRUCT_CELL & sc); //Draws the HTML cell of the table¤	SIZE DrawHtmlString(CPPString & sHtml, LPCRECT lpRect); //Draws the HTML string on device context or gets the size of the output area.¤¤//public:¤	//The methods¤	void SetDefaultCssStyles();¤	void SetDefaultCursor();¤	LPLOGFONT GetSystemToolTipFont() const; //Gets the system logfont¤¤	CPPString SearchNextTag(CPPString & str, CPPString & strTag, int & nIndex); //Search next tag¤	BOOL SearchTag(CPPString & str, int & nIndex, CPPString strTag); //Search begin of the specified tag¤¤	CPPString GetTagBody(CPPString & str, int & nIndex); //Gets a name of tag and the parameters of tag¤	CPPString SplitTag(CPPString & sTag); //Split a tag to the tag's name and parameters¤	CPPString GetNextProperty(CPPString & str, int & nIndex, CPPString & sProp); //Gets next property¤¤¤	CPPString SearchPropertyOfTag(CPPString & str, int & nIndex); //Search a name or a property of a tag¤	SIZE  AnalyseCellParam(CPPString & sTag, _STRUCT_CHANGESTYLE & cs, BOOL bTable);¤	void  AnalyseImageParam(CPPString & strTag, _STRUCT_IMAGE & si);¤	BOOL  IsImageWithShadow(_STRUCT_IMAGE & si);¤¤	//Functions for hyperlink¤	int PtInHyperlink(LPPOINT lpPoint);¤	void JumpToHyperlink(int nLink);¤	void StoreHyperlinkArea(int left, int top, int right, int bottom);¤	HINSTANCE GotoURL(LPCTSTR url, int showcmd = SW_SHOW);¤	LONG GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata);¤¤	//Functions for notify¤	void CallbackOnClickHyperlink(LPCTSTR sLink);¤	void CallbackOnRepaint(int nIndexLink);¤¤	//Running tag¤	int  VerticalAlignText(int y, int nHeight);¤	int  VerticalAlignImage(int y, int nHeight);¤	void UpdateContext();¤	BOOL StoreRestoreStyle(BOOL bRestore);¤	void Tag_NewLine(LPPOINT lpPoint, int nNum, LPSIZE lpSize);¤	void Tag_Tabulation(LPPOINT lpPoint, int nNum);¤	int  InitNewLine(int x);¤¤	void SelectNewHtmlStyle(LPCTSTR lpszNameStyle, STRUCT_CHANGESTYLE & cs);¤¤	SIZE  GetTableDimensions(CPPString & sTable); //Gets dimensions of the table¤	void  SearchEndOfTable(CPPString & str, int & nIndex); //Searching end of the table¤	void  SearchEndOfRow(CPPString & str, int & nIndex); //Searching end of the row¤	void  SearchEndOfCell(CPPString & str, int & nIndex); //Searching end of the cell¤¤	//Functions for the map of the styles¤	void SetTableOfColors();¤	void SetColorName(LPCTSTR lpszColorName, COLORREF color);¤	COLORREF GetColorByName(LPCTSTR lpszColorName, COLORREF crDefColor = RGB(0, 0, 0));¤¤	BOOL GetIndexNextAlphaNum(CPPString & str, int & nIndex, BOOL bArithmetic = FALSE);¤	BOOL GetBeginParameter(CPPString & str, int & nIndex, TCHAR chSeparator = _T(':'));¤	TCHAR GetIndexNextChars(CPPString & str, int & nIndex, CPPString strChars);¤	TCHAR GetIndexNextNoChars(CPPString & str, int & nIndex, CPPString strChars);¤	CPPString GetParameterString(CPPString & str, int & nIndex, TCHAR chBeginParam = _T(':'), CPPString strSeparators = _T(";"));¤	CPPString GetNameOfTag(CPPString & str, int & nIndex);¤	CPPString GetWordWrap(CPPString & str, int nMaxSize, int & nRealSize);¤¤	//Functions for the map of the styles¤	LPCTSTR GetTextStyle(LPCTSTR lpszStyleName);¤	void RemoveTextStyle(LPCTSTR lpszStyleName);¤	void AddToTextStyle(LPCTSTR lpszStyleName, LPCTSTR lpszAddStyle);¤	void UnpackTextStyle(CPPString strStyle, _STRUCT_CHANGESTYLE & cs);¤¤	//Functions for analyzing parameters¤	void SetDefaultStyles(_STRUCT_CHANGESTYLE & cs);¤	BOOL GetStyleFontStyle(CPPString & str, BOOL bDefault);¤	int  GetStyleFontWeight(CPPString & str, int nDefault);¤	int  GetStyleHorzAlign(CPPString & str, int nDefault);¤	int  GetStyleVertAlign(CPPString & str, int nDefault);¤	COLORREF GetStyleColor(CPPString & str, COLORREF crDefault);¤	int  GetStyleTextTransform(CPPString & str, int nDefault);¤	CPPString GetStyleString(CPPString str, CPPString strDefault);¤	void GetStyleFontShortForm(CPPString & str);¤	UINT GetStyleImageShortForm(CPPString & str);¤	int GetStyleBkgndEffect(CPPString & str, int nDefault);¤	¤	void StyleTextDecoration(CPPString & str, _STRUCT_CHANGESTYLE & cs);¤	int StyleBorderWidth(CPPString & str, int Default);¤	int StyleBorder(CPPString & str, int nDefault);¤¤	//Get¤	int GetLengthUnit(CPPString & str, int nDefault, BOOL bFont = FALSE);¤	BOOL IsPercentableValue(CPPString & str);¤	int GetTableWidth(CPPString & str, int nClientWidth, int nMinWidth, BOOL bSet = FALSE);¤¤	//Drawing¤	void DrawBackgroundImage(HDC hDC, int nDestX, int nDestY, int nWidth, int nHeight, CPPString strNameImage);¤¤	int GetCountOfChars(CPPString str, TCHAR tchar = _T(' ')); //Gets counts of chars¤//#UC END# *4700B81F006D*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPHtmlDrawer|4700B81F006D
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659777444"))
	    quid       	"4700B81F006D"
	    documentation 	"класс для отрисовки html'я"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator")
	(object Class "CPPDrawManager"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CPPDrawManager.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CPPDrawManager.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8C80280_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4700B8C80280_CUSTOM_INCLUDES*¤#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))¤//#UC END# *4700B8C80280_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8C80280*"
		    value      	(value Text 
|//#UC START# *4700B8C80280*¤CPPDrawManager::CPPDrawManager()¤{¤¤}¤¤void CPPDrawManager::GetSizeOfIcon(HICON hIcon, LPSIZE pSize) const¤{¤	pSize->cx = 0;¤	pSize->cy = 0;¤	if (hIcon != NULL)¤	{¤		ICONINFO ii;¤		// Gets icon dimension¤		::ZeroMemory(&ii, sizeof(ICONINFO));¤		if (::GetIconInfo(hIcon, &ii))¤		{¤			pSize->cx = (DWORD)(ii.xHotspot * 2);¤			pSize->cy = (DWORD)(ii.yHotspot * 2);¤			//release icon mask bitmaps¤			if(ii.hbmMask)¤				::DeleteObject(ii.hbmMask);¤			if(ii.hbmColor)¤				::DeleteObject(ii.hbmColor);¤		} //if¤	} //if¤} //End GetSizeOfIcon¤¤void CPPDrawManager::GetSizeOfBitmap(HBITMAP hBitmap, LPSIZE pSize) const¤{¤	pSize->cx = 0;¤	pSize->cy = 0;¤	if (hBitmap != NULL)¤	{¤		BITMAP	csBitmapSize;¤		// Get bitmap size¤		int nRetValue = ::GetObject(hBitmap, sizeof(csBitmapSize), &csBitmapSize);¤		if (nRetValue)¤		{¤			pSize->cx = (DWORD)csBitmapSize.bmWidth;¤			pSize->cy = (DWORD)csBitmapSize.bmHeight;¤		} //if¤	} //if¤} //End GetSizeOfBitmap¤¤void CPPDrawManager::AlphaBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY, int percent /* = 100 */)¤{¤	_ASSERT ((NULL != hDestDC) || (NULL != hSrcDC));¤¤	if (percent >= 100)¤	{¤		::BitBlt(hDestDC, nDestX, nDestY, dwWidth, dwHeight, hSrcDC, nSrcX, nSrcY, SRCCOPY);¤		return;¤	} //if¤¤	HDC hTempDC = ::CreateCompatibleDC(hDestDC);¤	if (NULL == hTempDC)¤		return;¤	¤	//Creates Source DIB¤	LPBITMAPINFO lpbiSrc;¤	// Fill in the BITMAPINFOHEADER¤	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤	lpbiSrc->bmiHeader.biWidth = dwWidth;¤	lpbiSrc->bmiHeader.biHeight = dwHeight;¤	lpbiSrc->bmiHeader.biPlanes = 1;¤	lpbiSrc->bmiHeader.biBitCount = 32;¤	lpbiSrc->bmiHeader.biCompression = BI_RGB;¤	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;¤	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biClrUsed = 0;¤	lpbiSrc->bmiHeader.biClrImportant = 0;¤	¤	COLORREF* pSrcBits = NULL;¤	HBITMAP hSrcDib = CreateDIBSection (¤		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,¤		NULL, NULL);¤	¤	if ((NULL != hSrcDib) && (NULL != pSrcBits))¤	{¤		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hSrcDib);¤		::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hSrcDC, nSrcX, nSrcY, SRCCOPY);¤		::SelectObject (hTempDC, hOldTempBmp);¤		¤		//Creates Destination DIB¤		LPBITMAPINFO lpbiDest;¤		// Fill in the BITMAPINFOHEADER¤		lpbiDest = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤		lpbiDest->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤		lpbiDest->bmiHeader.biWidth = dwWidth;¤		lpbiDest->bmiHeader.biHeight = dwHeight;¤		lpbiDest->bmiHeader.biPlanes = 1;¤		lpbiDest->bmiHeader.biBitCount = 32;¤		lpbiDest->bmiHeader.biCompression = BI_RGB;¤		lpbiDest->bmiHeader.biSizeImage = dwWidth * dwHeight;¤		lpbiDest->bmiHeader.biXPelsPerMeter = 0;¤		lpbiDest->bmiHeader.biYPelsPerMeter = 0;¤		lpbiDest->bmiHeader.biClrUsed = 0;¤		lpbiDest->bmiHeader.biClrImportant = 0;¤		¤		COLORREF* pDestBits = NULL;¤		HBITMAP hDestDib = CreateDIBSection (¤			hDestDC, lpbiDest, DIB_RGB_COLORS, (void **)&pDestBits,¤			NULL, NULL);¤		¤		if ((NULL != hDestDib) && (NULL != pDestBits))¤		{¤			::SelectObject (hTempDC, hDestDib);¤			::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hDestDC, nDestX, nDestY, SRCCOPY);¤			::SelectObject (hTempDC, hOldTempBmp);¤¤			double src_darken = (double)percent / 100.0;¤			double dest_darken = 1.0 - src_darken;¤			¤			for (DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pSrcBits++, pDestBits++)¤			{¤				*pDestBits = PixelAlpha(*pSrcBits, src_darken, *pDestBits, dest_darken);¤			} //for¤			¤			::SelectObject (hTempDC, hDestDib);¤			::BitBlt (hDestDC, nDestX, nDestY, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);¤			::SelectObject (hTempDC, hOldTempBmp);¤¤			delete lpbiDest;¤			::DeleteObject(hDestDib);¤		} //if¤		delete lpbiSrc;¤		::DeleteObject(hSrcDib);¤	} //if¤¤	::DeleteDC(hTempDC);¤} //End AlphaBitBlt¤¤void CPPDrawManager::AlphaChannelBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY)¤{¤	_ASSERT ((NULL != hDestDC) || (NULL != hSrcDC));¤¤	HDC hTempDC = ::CreateCompatibleDC(hDestDC);¤	if (NULL == hTempDC)¤		return;¤	¤	//Creates Source DIB¤	LPBITMAPINFO lpbiSrc;¤	// Fill in the BITMAPINFOHEADER¤	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤	lpbiSrc->bmiHeader.biWidth = dwWidth;¤	lpbiSrc->bmiHeader.biHeight = dwHeight;¤	lpbiSrc->bmiHeader.biPlanes = 1;¤	lpbiSrc->bmiHeader.biBitCount = 32;¤	lpbiSrc->bmiHeader.biCompression = BI_RGB;¤	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;¤	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biClrUsed = 0;¤	lpbiSrc->bmiHeader.biClrImportant = 0;¤	¤	COLORREF* pSrcBits = NULL;¤	HBITMAP hSrcDib = CreateDIBSection (¤		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,¤		NULL, NULL);¤	¤	if ((NULL != hSrcDib) && (NULL != pSrcBits))¤	{¤		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hSrcDib);¤		::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hSrcDC, nSrcX, nSrcY, SRCCOPY);¤		::SelectObject (hTempDC, hOldTempBmp);¤		¤		//Creates Destination DIB¤		LPBITMAPINFO lpbiDest;¤		// Fill in the BITMAPINFOHEADER¤		lpbiDest = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤		lpbiDest->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤		lpbiDest->bmiHeader.biWidth = dwWidth;¤		lpbiDest->bmiHeader.biHeight = dwHeight;¤		lpbiDest->bmiHeader.biPlanes = 1;¤		lpbiDest->bmiHeader.biBitCount = 32;¤		lpbiDest->bmiHeader.biCompression = BI_RGB;¤		lpbiDest->bmiHeader.biSizeImage = dwWidth * dwHeight;¤		lpbiDest->bmiHeader.biXPelsPerMeter = 0;¤		lpbiDest->bmiHeader.biYPelsPerMeter = 0;¤		lpbiDest->bmiHeader.biClrUsed = 0;¤		lpbiDest->bmiHeader.biClrImportant = 0;¤		¤		COLORREF* pDestBits = NULL;¤		HBITMAP hDestDib = CreateDIBSection (¤			hDestDC, lpbiDest, DIB_RGB_COLORS, (void **)&pDestBits,¤			NULL, NULL);¤		¤		if ((NULL != hDestDib) && (NULL != pDestBits))¤		{¤			::SelectObject (hTempDC, hDestDib);¤			::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hDestDC, nDestX, nDestY, SRCCOPY);¤			::SelectObject (hTempDC, hOldTempBmp);¤¤			double src_darken;¤			BYTE nAlpha;¤			¤			for (DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pSrcBits++, pDestBits++)¤			{¤				nAlpha = LOBYTE(*pSrcBits >> 24);¤				src_darken = (double)nAlpha / 255.0;¤				*pDestBits = PixelAlpha(*pSrcBits, src_darken, *pDestBits, 1.0 - src_darken);¤			} //for¤			¤			::SelectObject (hTempDC, hDestDib);¤			::BitBlt (hDestDC, nDestX, nDestY, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);¤			::SelectObject (hTempDC, hOldTempBmp);¤¤			delete lpbiDest;¤			::DeleteObject(hDestDib);¤		} //if¤		delete lpbiSrc;¤		::DeleteObject(hSrcDib);¤	} //if¤¤	::DeleteDC(hTempDC);¤} //End of AlphaChannelBitBlt¤¤HBITMAP CPPDrawManager::CreateImageEffect(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, DWORD dwEffect, BOOL bUseMask /* = TRUE */, COLORREF clrMask /* = RGB(255, 0, 255) */, COLORREF clrMono /* = RGB(255, 255, 255) */)¤{¤	HBITMAP hOldSrcBmp = NULL;¤	HBITMAP hOldResBmp = NULL;  ¤	HDC hMainDC = NULL;¤	HDC hSrcDC = NULL;¤	HDC hResDC = NULL;¤	¤	hMainDC = ::GetDC(NULL);¤	hSrcDC = ::CreateCompatibleDC(hMainDC);¤	hResDC = ::CreateCompatibleDC(hMainDC);¤¤	hOldSrcBmp = (HBITMAP)::SelectObject(hSrcDC, hBitmap);¤¤	LPBITMAPINFO lpbi;¤¤	// Fill in the BITMAPINFOHEADER¤	lpbi = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤	lpbi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤	lpbi->bmiHeader.biWidth = dwWidth;¤	lpbi->bmiHeader.biHeight = dwHeight;¤	lpbi->bmiHeader.biPlanes = 1;¤	lpbi->bmiHeader.biBitCount = 32;¤	lpbi->bmiHeader.biCompression = BI_RGB;¤	lpbi->bmiHeader.biSizeImage = dwWidth * dwHeight;¤	lpbi->bmiHeader.biXPelsPerMeter = 0;¤	lpbi->bmiHeader.biYPelsPerMeter = 0;¤	lpbi->bmiHeader.biClrUsed = 0;¤	lpbi->bmiHeader.biClrImportant = 0;¤¤	COLORREF* pBits = NULL;¤	HBITMAP hDibBmp = CreateDIBSection (¤		hSrcDC, lpbi, DIB_RGB_COLORS, (void **)&pBits,¤		NULL, NULL);¤¤	if (hDibBmp == NULL || pBits == NULL)¤	{¤		delete lpbi;¤		_ASSERT (FALSE);¤		return NULL;¤	} //if¤¤	hOldResBmp = (HBITMAP)::SelectObject (hResDC, hDibBmp);¤	::BitBlt (hResDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, SRCCOPY);¤¤	clrMask = CLR_TO_RGBQUAD(clrMask);¤	clrMono = CLR_TO_RGBQUAD(clrMono);¤¤	DWORD dwAlpha;¤	for (DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, *pBits++)¤	{¤		COLORREF color = (COLORREF)*pBits;¤		//ENG: Extract an original alpha value¤		dwAlpha = color & 0xFF000000;¤		if (dwAlpha != 0) ¤			m_bIsAlpha = TRUE;¤		if (bUseMask && (color == clrMask))¤		{¤			//This is transparent area¤			color = RGB(0, 0, 0);¤		}¤		else ¤		{¤			//ENG: Color conversion¤			if (dwEffect & IMAGE_EFFECT_GRAYEN) color = GrayMirrorColor(color);¤			if (dwEffect & IMAGE_EFFECT_DARKEN) color = DarkenColor(color, 0.75);¤			if (dwEffect & IMAGE_EFFECT_LIGHTEN) color = LightenColor(color, 0.25);¤			if (dwEffect & IMAGE_EFFECT_MONOCHROME) color = clrMono;¤		} //if¤		if (dwEffect & IMAGE_EFFECT_INVERT) color = InvertColor(color);¤		//ENG: Merges a color with an original alpha value¤		*pBits = (color | dwAlpha);¤	} //for¤¤	::SelectObject(hSrcDC, hOldSrcBmp);¤	::SelectObject(hResDC, hOldResBmp);¤	::DeleteDC(hSrcDC);¤	::DeleteDC(hResDC);¤	::ReleaseDC(NULL, hMainDC);¤	¤	delete lpbi;¤¤	return hDibBmp;¤} //End CreateImageEffect¤¤//----------------------------------------------------------¤// CPPDrawManager::GrayMirrorColor()¤//	Graying color in RGBQUAD format¤//----------------------------------------------------------¤// Parameter:¤//	clrColor	- RGBQUAD value from DIB¤// Return value:¤//	A grayed color in the RGBQUAD format¤//----------------------------------------------------------¤COLORREF CPPDrawManager::GrayMirrorColor(COLORREF clrColor)¤{¤	BYTE nGrayColor = (BYTE)((GetBValue(clrColor) * 0.299) + (GetGValue(clrColor) * 0.587) + (GetRValue(clrColor) * 0.114));¤	¤	return RGB(nGrayColor, nGrayColor, nGrayColor);¤} //End of GrayMirrorColor¤¤COLORREF CPPDrawManager::GrayColor(COLORREF clrColor)¤{¤	BYTE nGrayColor = (BYTE)((GetRValue(clrColor) * 0.299) + (GetGValue(clrColor) * 0.587) + (GetBValue(clrColor) * 0.114));¤	¤	return RGB(nGrayColor, nGrayColor, nGrayColor);¤} //End GrayColor¤¤COLORREF CPPDrawManager::InvertColor(COLORREF clrColor)¤{¤	return RGB(255 - GetRValue(clrColor), 255 - GetGValue(clrColor), 255 - GetBValue(clrColor));¤} //End InvertColor¤¤COLORREF CPPDrawManager::DarkenColor(COLORREF clrColor, double darken)¤{¤	if (darken >= 0.0 && darken < 1.0)¤	{¤		BYTE color_r, color_g, color_b;¤		color_r = (BYTE)(GetRValue(clrColor) * darken);¤		color_g = (BYTE)(GetGValue(clrColor) * darken);¤		color_b = (BYTE)(GetBValue(clrColor) * darken);¤		clrColor = RGB(color_r, color_g, color_b);¤	} //if¤	¤	return clrColor;¤} //End DarkenColor¤¤COLORREF CPPDrawManager::LightenColor(COLORREF clrColor, double lighten)¤{¤	if (lighten > 0.0 && lighten <= 1.0)¤	{¤		BYTE color_r, color_g, color_b;¤		¤		lighten += 1.0;¤		color_r = (BYTE)std::min((DWORD)GetRValue(clrColor) * lighten, 255.0);¤		color_g = (BYTE)std::min((DWORD)GetGValue(clrColor) * lighten, 255.0);¤		color_b = (BYTE)std::min((DWORD)GetBValue(clrColor) * lighten, 255.0);¤		clrColor = RGB(color_r, color_g, color_b);¤/*		¤		lighten *= 255¤		color_r = (BYTE)max(0, min(255, (int)((color_r - 128) * 2.0 + 128 + lighten)));¤		color_g = (BYTE)max(0, min(255, (int)((color_g - 128) * 2.0 + 128 + lighten)));¤		color_b = (BYTE)max(0, min(255, (int)((color_b - 128) * 2.0 + 128 + lighten)));¤		clrColor = RGB(color_r, color_g, color_b);¤*/¤	} //if¤	¤	return clrColor;¤} //End LightenColor¤¤COLORREF CPPDrawManager::PixelAlpha(COLORREF clrSrc, double src_darken, COLORREF clrDest, double dest_darken)¤{¤	return RGB (GetRValue (clrSrc) * src_darken + GetRValue (clrDest) * dest_darken, ¤				GetGValue (clrSrc) * src_darken + GetGValue (clrDest) * dest_darken, ¤				GetBValue (clrSrc) * src_darken + GetBValue (clrDest) * dest_darken);¤	¤} //End PixelAlpha¤¤HICON CPPDrawManager::StretchIcon(HICON hIcon, DWORD dwWidth, DWORD dwHeight)¤{¤	HICON hStretchedIcon = NULL;¤	HDC   hMainDC = NULL;¤	HDC   hSrcDC = NULL;¤	HDC   hDestDC = NULL;¤	BITMAP bmp;¤	HBITMAP hOldSrcBitmap = NULL;¤	HBITMAP hOldDestBitmap = NULL;¤	ICONINFO csOriginal, csStretched;¤	¤	if (!::GetIconInfo(hIcon, &csOriginal))¤		return FALSE;¤	¤	hMainDC = ::GetDC(NULL);¤	hSrcDC = ::CreateCompatibleDC(hMainDC);¤	hDestDC = ::CreateCompatibleDC(hMainDC);¤	¤	if ((NULL == hMainDC) || (NULL == hSrcDC) || (NULL == hDestDC))¤		return NULL;¤	¤	if (::GetObject(csOriginal.hbmColor, sizeof(BITMAP), &bmp))¤	{¤		DWORD	dwWidthOrg = csOriginal.xHotspot * 2;¤		DWORD	dwHeightOrg = csOriginal.yHotspot * 2;¤		¤		csStretched.hbmColor = ::CreateBitmap(dwWidth, dwHeight, bmp.bmPlanes, bmp.bmBitsPixel, NULL);¤		if (NULL != csStretched.hbmColor)¤		{¤			hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, csOriginal.hbmColor);¤			hOldDestBitmap = (HBITMAP)::SelectObject(hDestDC, csStretched.hbmColor);¤			::StretchBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, dwWidthOrg, dwHeightOrg, SRCCOPY);¤			if (::GetObject(csOriginal.hbmMask, sizeof(BITMAP), &bmp))¤			{¤				csStretched.hbmMask = ::CreateBitmap(dwWidth, dwHeight, bmp.bmPlanes, bmp.bmBitsPixel, NULL);¤				if (NULL != csStretched.hbmMask)¤				{¤					::SelectObject(hSrcDC, csOriginal.hbmMask);¤					::SelectObject(hDestDC, csStretched.hbmMask);¤					::StretchBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, dwWidthOrg, dwHeightOrg, SRCCOPY);¤				} //if¤			} //if¤			::SelectObject(hSrcDC, hOldSrcBitmap);¤			::SelectObject(hDestDC, hOldDestBitmap);¤			csStretched.fIcon = TRUE;¤			hStretchedIcon = ::CreateIconIndirect(&csStretched);¤		} //if¤		::DeleteObject(csStretched.hbmColor);¤		::DeleteObject(csStretched.hbmMask);¤	} //if¤	¤	::DeleteObject(csOriginal.hbmColor);¤	::DeleteObject(csOriginal.hbmMask);¤	::DeleteDC(hSrcDC);¤	::DeleteDC(hDestDC);¤	::ReleaseDC(NULL, hMainDC);¤	¤	return hStretchedIcon;¤} //End StretchIcon¤¤void CPPDrawManager::FillGradient (HDC hDC, LPCRECT lpRect, ¤								COLORREF colorStart, COLORREF colorFinish, ¤								BOOL bHorz/* = TRUE*/)¤{¤    // this will make 2^6 = 64 fountain steps¤    int nShift = 6;¤    int nSteps = 1 << nShift;¤¤	RECT r2;¤	r2.top = lpRect->top;¤	r2.left = lpRect->left;¤	r2.right = lpRect->right;¤	r2.bottom = lpRect->bottom;¤¤	int nHeight = lpRect->bottom - lpRect->top;¤	int nWidth = lpRect->right - lpRect->left;¤¤	for (int i = 0; i < nSteps; i++)¤    {¤        // do a little alpha blending¤        BYTE bR = (BYTE) ((GetRValue(colorStart) * (nSteps - i) +¤                   GetRValue(colorFinish) * i) >> nShift);¤        BYTE bG = (BYTE) ((GetGValue(colorStart) * (nSteps - i) +¤                   GetGValue(colorFinish) * i) >> nShift);¤        BYTE bB = (BYTE) ((GetBValue(colorStart) * (nSteps - i) +¤                   GetBValue(colorFinish) * i) >> nShift);¤¤		HBRUSH hBrush = ::CreateSolidBrush(RGB(bR, bG, bB));¤		¤        // then paint with the resulting color¤¤        if (!bHorz)¤        {¤            r2.top = lpRect->top + ((i * nHeight) >> nShift);¤            r2.bottom = lpRect->top + (((i + 1) * nHeight) >> nShift);¤            if ((r2.bottom - r2.top) > 0)¤                ::FillRect(hDC, &r2, hBrush);¤        }¤        else¤        {¤            r2.left = lpRect->left + ((i * nWidth) >> nShift);¤            r2.right = lpRect->left + (((i + 1) * nWidth) >> nShift);¤            if ((r2.right - r2.left) > 0)¤                ::FillRect(hDC, &r2, hBrush);¤        } //if¤		¤		if (NULL != hBrush)¤		{¤			::DeleteObject(hBrush);¤			hBrush = NULL;¤		} //if¤    } //for¤} //End FillGradient¤¤#ifdef USE_SHADE¤void CPPDrawManager::SetShade(LPCRECT lpRect, UINT shadeID /* = 0 */, BYTE granularity /* = 8 */, ¤						  BYTE coloring /* = 0 */, COLORREF hicr /* = 0 */, COLORREF midcr /* = 0 */, COLORREF locr /* = 0 */)¤{¤	long	sXSize,sYSize,bytes,j,i,k,h;¤	BYTE	*iDst ,*posDst;¤	¤	sYSize = lpRect->bottom - lpRect->top; ¤	sXSize = lpRect->right - lpRect->left; ¤¤	m_dNormal.Create(sXSize,sYSize,8);					//create the default bitmap¤¤	long r,g,b;											//build the shaded palette¤	for(i = 0; i < 129; i++)¤	{¤		r=((128-i)*GetRValue(locr)+i*GetRValue(midcr))/128;¤		g=((128-i)*GetGValue(locr)+i*GetGValue(midcr))/128;¤		b=((128-i)*GetBValue(locr)+i*GetBValue(midcr))/128;¤		m_dNormal.SetPaletteIndex((BYTE)i,(BYTE)r,(BYTE)g,(BYTE)b);¤	} //for¤	for(i=1;i<129;i++){¤		r=((128-i)*GetRValue(midcr)+i*GetRValue(hicr))/128;¤		g=((128-i)*GetGValue(midcr)+i*GetGValue(hicr))/128;¤		b=((128-i)*GetBValue(midcr)+i*GetBValue(hicr))/128;¤		m_dNormal.SetPaletteIndex((BYTE)(i+127),(BYTE)r,(BYTE)g,(BYTE)b);¤	} //for¤¤	m_dNormal.BlendPalette(hicr,coloring);	//color the palette¤¤	bytes = m_dNormal.GetLineWidth();¤	iDst = m_dNormal.GetBits();¤	posDst =iDst;¤	long a,x,y,d,xs,idxmax,idxmin;¤¤	int grainx2 = RAND_MAX/(max(1,2*granularity));¤	idxmax=255-granularity;¤	idxmin=granularity;¤¤	switch (shadeID)¤	{¤//----------------------------------------------------¤	case EFFECT_METAL:¤		m_dNormal.Clear();¤		// create the strokes¤		k=40;	//stroke granularity¤		for(a=0;a<200;a++){¤			x=rand()/(RAND_MAX/sXSize); //stroke postion¤			y=rand()/(RAND_MAX/sYSize);	//stroke position¤			xs=rand()/(RAND_MAX/min(sXSize,sYSize))/2; //stroke lenght¤			d=rand()/(RAND_MAX/k);	//stroke color¤			for(i=0;i<xs;i++){¤				if (((x-i)>0)&&((y+i)<sYSize))¤					m_dNormal.SetPixelIndex(x-i,y+i,(BYTE)d);¤				if (((x+i)<sXSize)&&((y-i)>0))¤					m_dNormal.SetPixelIndex(sXSize-x+i,y-i,(BYTE)d);¤			} //for¤		} //for¤		//blend strokes with SHS_DIAGONAL¤		posDst =iDst;¤		a=(idxmax-idxmin-k)/2;¤		for(i = 0; i < sYSize; i++) {¤			for(j = 0; j < sXSize; j++) {¤				d=posDst[j]+((a*i)/sYSize+(a*(sXSize-j))/sXSize);¤				posDst[j]=(BYTE)d;¤				posDst[j]+=rand()/grainx2;¤			} //for¤			posDst+=bytes;¤		} //for¤¤		break;¤//----------------------------------------------------¤	case EFFECT_HARDBUMP:	// ¤		//set horizontal bump¤		for(i = 0; i < sYSize; i++) {¤			k=(255*i/sYSize)-127;¤			k=(k*(k*k)/128)/128;¤			k=(k*(128-granularity*2))/128+128;¤			for(j = 0; j < sXSize; j++) {¤				posDst[j]=(BYTE)k;¤				posDst[j]+=rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤		//set vertical bump¤		d=min(16,sXSize/6);	//max edge=16¤		a=sYSize*sYSize/4;¤		posDst =iDst;¤		for(i = 0; i < sYSize; i++) {¤			y=i-sYSize/2;¤			for(j = 0; j < sXSize; j++) {¤				x=j-sXSize/2;¤				xs=sXSize/2-d+(y*y*d)/a;¤				if (x>xs) posDst[j]=(BYTE)idxmin+(BYTE)(((sXSize-j)*128)/d);¤				if ((x+xs)<0) posDst[j]=(BYTE)idxmax-(BYTE)((j*128)/d);¤				posDst[j]+=rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_SOFTBUMP: //¤		for(i = 0; i < sYSize; i++) {¤			h=(255*i/sYSize)-127;¤			for(j = 0; j < sXSize; j++) {¤				k=(255*(sXSize-j)/sXSize)-127;¤				k=(h*(h*h)/128)/128+(k*(k*k)/128)/128;¤				k=k*(128-granularity)/128+128;¤				if (k<idxmin) k=idxmin;¤				if (k>idxmax) k=idxmax;¤				posDst[j]=(BYTE)k;¤				posDst[j]+=rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_VBUMP: // ¤		for(j = 0; j < sXSize; j++) {¤			k=(255*(sXSize-j)/sXSize)-127;¤			k=(k*(k*k)/128)/128;¤			k=(k*(128-granularity))/128+128;¤			for(i = 0; i < sYSize; i++) {¤				posDst[j+i*bytes]=(BYTE)k;¤				posDst[j+i*bytes]+=rand()/grainx2-granularity;¤			} //for¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_HBUMP: //¤		for(i = 0; i < sYSize; i++) {¤			k=(255*i/sYSize)-127;¤			k=(k*(k*k)/128)/128;¤			k=(k*(128-granularity))/128+128;¤			for(j = 0; j < sXSize; j++) {¤				posDst[j]=(BYTE)k;¤				posDst[j]+=rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_DIAGSHADE:	//¤		a=(idxmax-idxmin)/2;¤		for(i = 0; i < sYSize; i++) {¤			for(j = 0; j < sXSize; j++) {¤				posDst[j]=(BYTE)(idxmin+a*i/sYSize+a*(sXSize-j)/sXSize);¤				posDst[j]+=rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_HSHADE:	//¤		a=idxmax-idxmin;¤		for(i = 0; i < sYSize; i++) {¤			k=a*i/sYSize+idxmin;¤			for(j = 0; j < sXSize; j++) {¤				posDst[j]=(BYTE)k;¤				posDst[j]+=rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_VSHADE:	//:¤		a=idxmax-idxmin;¤		for(j = 0; j < sXSize; j++) {¤			k=a*(sXSize-j)/sXSize+idxmin;¤			for(i = 0; i < sYSize; i++) {¤				posDst[j+i*bytes]=(BYTE)k;¤				posDst[j+i*bytes]+=rand()/grainx2-granularity;¤			} //for¤		} //for¤		break;¤//----------------------------------------------------¤	case EFFECT_NOISE:¤		for(i = 0; i < sYSize; i++) {¤			for(j = 0; j < sXSize; j++) {¤				posDst[j]=128+rand()/grainx2-granularity;¤			} //for¤			posDst+=bytes;¤		} //for¤	} //switch¤//----------------------------------------------------¤} //End SetShade¤#endif¤¤void CPPDrawManager::FillEffect(HDC hDC, DWORD dwEffect, LPCRECT lpRect, COLORREF clrBegin, COLORREF clrMid /* = 0 */, COLORREF clrEnd /* = 0 */,  BYTE granularity /* = 0 */, BYTE coloring /* = 0 */)¤{¤	HBRUSH hBrush = NULL;¤¤	RECT rect;¤	rect.left = lpRect->left;¤	rect.top = lpRect->top;¤	rect.right = lpRect->right;¤	rect.bottom = lpRect->bottom;¤¤	int nHeight = rect.bottom - rect.top;¤	int nWidth = rect.right - rect.left;¤	¤	switch (dwEffect)¤	{¤	default:¤		hBrush = ::CreateSolidBrush(clrBegin);¤		::FillRect(hDC, lpRect, hBrush);¤		break;¤	case EFFECT_HGRADIENT:¤		FillGradient(hDC, lpRect, clrBegin, clrEnd, TRUE);¤		break;¤	case EFFECT_VGRADIENT:¤		FillGradient(hDC, lpRect, clrBegin, clrEnd, FALSE);¤		break;¤	case EFFECT_HCGRADIENT:¤		rect.right = rect.left + nWidth / 2;¤		FillGradient(hDC, &rect, clrBegin, clrEnd, TRUE);¤		rect.left = rect.right;¤		rect.right = lpRect->right;¤		FillGradient(hDC, &rect, clrEnd, clrBegin, TRUE);¤		break;¤	case EFFECT_3HGRADIENT:¤		rect.right = rect.left + nWidth / 2;¤		FillGradient(hDC, &rect, clrBegin, clrMid, TRUE);¤		rect.left = rect.right;¤		rect.right = lpRect->right;¤		FillGradient(hDC, &rect, clrMid, clrEnd, TRUE);¤		break;¤	case EFFECT_VCGRADIENT:¤		rect.bottom = rect.top + nHeight / 2;¤		FillGradient(hDC, &rect, clrBegin, clrEnd, FALSE);¤		rect.top = rect.bottom;¤		rect.bottom = lpRect->bottom;¤		FillGradient(hDC, &rect, clrEnd, clrBegin, FALSE);¤		break;¤	case EFFECT_3VGRADIENT:¤		rect.bottom = rect.top + nHeight / 2;¤		FillGradient(hDC, &rect, clrBegin, clrMid, FALSE);¤		rect.top = rect.bottom;¤		rect.bottom = lpRect->bottom;¤		FillGradient(hDC, &rect, clrMid, clrEnd, FALSE);¤		break;¤#ifdef USE_SHADE¤	case EFFECT_NOISE:¤	case EFFECT_DIAGSHADE:¤	case EFFECT_HSHADE:¤	case EFFECT_VSHADE:¤	case EFFECT_HBUMP:¤	case EFFECT_VBUMP:¤	case EFFECT_SOFTBUMP:¤	case EFFECT_HARDBUMP:¤	case EFFECT_METAL:¤		rect.left = 0;¤		rect.top = 0;¤		rect.right = nWidth;¤		rect.bottom = nHeight;¤		SetShade(&rect, dwEffect, granularity, coloring, clrBegin, clrMid, clrEnd);¤		m_dNormal.Draw(hDC, lpRect->left, lpRect->top);¤		break; ¤#endif¤	} //switch¤¤	if (NULL != hBrush)¤	{¤		::DeleteObject(hBrush);¤		hBrush = NULL;¤	} //if¤} //End FillEffect¤¤void CPPDrawManager::MultipleCopy(HDC hDestDC, int nDestX, int nDestY, DWORD dwDestWidth, DWORD dwDestHeight, ¤										HDC hSrcDC, int nSrcX, int nSrcY, DWORD dwSrcWidth, DWORD dwSrcHeight)¤{¤	// Horizontal copying¤	int right, bottom;¤	int nDestRight = (int)(nDestX + dwDestWidth);¤	int nDestBottom = (int)(nDestY + dwDestHeight);¤	for (int x = nDestX; x < nDestRight; x+= dwSrcWidth)¤	{¤		right = std::min (x + (int)dwSrcWidth, nDestRight);¤		// Vertical copying¤		for (int y = nDestY; y < nDestBottom; y+= dwSrcHeight)¤		{¤			bottom = std::min (y + (int)dwSrcHeight, nDestBottom);¤			::BitBlt(hDestDC, x, y, right - x, bottom - y, hSrcDC, nSrcX, nSrcY, SRCCOPY);¤		} //for¤	} //for¤} //End MultipleCopy¤¤void CPPDrawManager::DrawBitmap(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,¤					BOOL bUseMask, COLORREF crMask, ¤					DWORD dwEffect /* = IMAGE_EFFECT_NONE */, ¤					BOOL bShadow /* = FALSE */, ¤					DWORD dwCxShadow /* = PPDRAWMANAGER_SHADOW_XOFFSET */, ¤					DWORD dwCyShadow /* = PPDRAWMANAGER_SHADOW_YOFFSET */,¤					DWORD dwCxDepth /* = PPDRAWMANAGER_SHADOW_XDEPTH */, ¤					DWORD dwCyDepth /* = PPDRAWMANAGER_SHADOW_YDEPTH */,¤					COLORREF clrShadow /* = PPDRAWMANAGER_SHADOW_COLOR */)¤{¤	m_bIsAlpha = FALSE;¤	if (NULL == hSrcBitmap)¤		return;¤¤	SIZE sz;¤	GetSizeOfBitmap(hSrcBitmap, &sz);¤¤	HDC hSrcDC = ::CreateCompatibleDC(hDC);¤	HDC hDestDC = ::CreateCompatibleDC(hDC);¤	¤	HBITMAP hBitmapTemp = ::CreateCompatibleBitmap(hDC, dwWidth, dwHeight);¤¤	HBITMAP hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, hSrcBitmap);¤	HBITMAP hOldDestBitmap = (HBITMAP)::SelectObject(hDestDC, hBitmapTemp);¤¤	//Scales a bitmap if need¤	if (((DWORD)sz.cx != dwWidth) || ((DWORD)sz.cy != dwHeight))¤		::StretchBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, sz.cx, sz.cy, SRCCOPY);¤	else¤		::BitBlt(hDestDC, 0, 0, dwWidth, dwHeight, hSrcDC, 0, 0, SRCCOPY);¤¤	::SelectObject(hDestDC, hOldDestBitmap);¤	¤	HBITMAP hMaskBmp = CreateImageEffect(hBitmapTemp, dwWidth, dwHeight, IMAGE_EFFECT_MASK, bUseMask, crMask);¤	HBITMAP hBitmap = CreateImageEffect(hBitmapTemp, dwWidth, dwHeight, dwEffect, bUseMask, crMask, clrShadow);¤	¤	if (bShadow)¤	{¤		if (dwEffect & IMAGE_EFFECT_SHADOW)¤		{¤			POINT ptShadow;¤			ptShadow.x = x + dwCxShadow;¤			ptShadow.y = y + dwCyShadow;¤			HBITMAP hShadowBmp =  CreateImageEffect(hBitmapTemp, dwWidth, dwHeight, IMAGE_EFFECT_MASK, bUseMask, crMask, InvertColor(clrShadow));¤			DrawShadow(hDC, ptShadow.x, ptShadow.y, dwWidth, dwHeight, hShadowBmp, dwEffect & IMAGE_EFFECT_GRADIENT_SHADOW, dwCxDepth, dwCyDepth);¤			::DeleteObject(hShadowBmp);¤		}¤		else¤		{¤			x += dwCxShadow;¤			y += dwCyShadow;¤		} //if¤	} //if¤	¤	if (m_bIsAlpha)¤	{¤		::SelectObject(hSrcDC, hBitmap);¤		AlphaChannelBitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0);¤	}¤	else¤	{¤		//Merge the image mask with background¤		::SelectObject(hSrcDC, hMaskBmp);¤		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCAND);¤		¤		//Draw the image¤		::SelectObject(hSrcDC, hBitmap);¤		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCPAINT);¤	}¤	¤	::SelectObject(hSrcDC, hOldSrcBitmap);¤	¤	::DeleteDC(hDestDC);¤	::DeleteDC(hSrcDC);¤¤	::DeleteObject(hBitmap);¤	::DeleteObject(hMaskBmp);¤	::DeleteObject(hBitmapTemp);¤} //End DrawBitmap¤¤void CPPDrawManager::DrawIcon(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HICON hSrcIcon,¤  							DWORD dwEffect /* = IMAGE_EFFECT_NONE */, ¤							BOOL bShadow /* = FALSE */, ¤							DWORD dwCxShadow /* = PPDRAWMANAGER_SHADOW_XOFFSET */, ¤							DWORD dwCyShadow /* = PPDRAWMANAGER_SHADOW_YOFFSET */,¤							DWORD dwCxDepth /* = PPDRAWMANAGER_SHADOW_XDEPTH */, ¤							DWORD dwCyDepth /* = PPDRAWMANAGER_SHADOW_YDEPTH */,¤							COLORREF clrShadow /* = PPDRAWMANAGER_SHADOW_COLOR */)¤{¤	m_bIsAlpha = FALSE;¤	if (NULL == hSrcIcon)¤		return;¤¤	SIZE sz;¤	GetSizeOfIcon(hSrcIcon, &sz);¤¤	HICON hIcon = NULL;¤¤	if (((DWORD)sz.cx == dwWidth) && ((DWORD)sz.cy == dwHeight))¤		hIcon = ::CopyIcon(hSrcIcon);¤	else hIcon = StretchIcon(hSrcIcon, dwWidth, dwHeight);¤	¤	ICONINFO csOriginal;¤¤	if (!::GetIconInfo(hIcon, &csOriginal))¤		return;¤¤	HDC hSrcDC = ::CreateCompatibleDC(hDC);¤	¤	HBITMAP hBitmap;¤	if (dwEffect & IMAGE_EFFECT_MONOCHROME)¤		hBitmap = CreateImageEffect(csOriginal.hbmMask, dwWidth, dwHeight, dwEffect, TRUE, RGB(255, 255, 255), clrShadow);¤	else¤		hBitmap = CreateImageEffect(csOriginal.hbmColor, dwWidth, dwHeight, dwEffect, TRUE, RGB(0, 0, 0), clrShadow);¤	HBITMAP hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, hBitmap);¤¤	if (bShadow)¤	{¤		if (dwEffect & IMAGE_EFFECT_SHADOW)¤		{¤			POINT ptShadow;¤			ptShadow.x = x + dwCxShadow;¤			ptShadow.y = y + dwCyShadow;¤			HBITMAP hShadowBmp =  CreateImageEffect(csOriginal.hbmMask, dwWidth, dwHeight, IMAGE_EFFECT_MASK, TRUE, RGB(255, 255, 255), InvertColor(clrShadow));¤			DrawShadow(hDC, ptShadow.x, ptShadow.y, dwWidth, dwHeight, hShadowBmp, dwEffect & IMAGE_EFFECT_GRADIENT_SHADOW, dwCxDepth, dwCyDepth);¤			::DeleteObject(hShadowBmp);¤		}¤		else¤		{¤			x += dwCxShadow;¤			y += dwCyShadow;¤		} //if¤	} //if¤	¤	if (m_bIsAlpha)¤	{¤//		::SelectObject(hSrcDC, hBitmap);¤		AlphaChannelBitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0);¤	}¤	else¤	{¤		//-------------------------------------------------------------------¤		// !!! ATTENTION !!!¤		// I don't know why a icon uses text's color¤		// Therefore I change a text's color to BLACK and after draw I restore¤		// original color¤		//-------------------------------------------------------------------¤		COLORREF crOldColor = ::SetTextColor(hDC, RGB(0, 0, 0));¤		//Merge the image mask with background¤		::SelectObject(hSrcDC, csOriginal.hbmMask);¤		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCAND);¤		//Draw the image¤		::SelectObject(hSrcDC, hBitmap);¤		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCPAINT);¤		::SetTextColor(hDC, crOldColor);¤	} //if¤¤	::SelectObject(hSrcDC, hOldSrcBitmap);¤	::DeleteDC(hSrcDC);¤	::DeleteObject(hBitmap);¤	::DestroyIcon(hIcon);¤¤	::DeleteObject(csOriginal.hbmColor);¤	::DeleteObject(csOriginal.hbmMask);¤} //End DrawIcon¤¤void CPPDrawManager::DrawShadow(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, BOOL bGradient /* = FALSE */, DWORD dwDepthX /* = PPDRAWMANAGER_SHADOW_YOFFSET */, DWORD dwDepthY /* = PPDRAWMANAGER_SHADOW_XOFFSET */)¤{¤	HDC hSrcDC = ::CreateCompatibleDC(hDestDC);¤	if (NULL == hSrcDC)¤		return;¤¤	HDC hTempDC = ::CreateCompatibleDC(hDestDC);¤	if (NULL == hTempDC)¤	{¤		::DeleteDC(hSrcDC);¤		return;¤	} // if¤	¤	//Creates Source DIB¤	LPBITMAPINFO lpbiSrc;¤	// Fill in the BITMAPINFOHEADER¤	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤	lpbiSrc->bmiHeader.biWidth = dwWidth;¤	lpbiSrc->bmiHeader.biHeight = dwHeight;¤	lpbiSrc->bmiHeader.biPlanes = 1;¤	lpbiSrc->bmiHeader.biBitCount = 32;¤	lpbiSrc->bmiHeader.biCompression = BI_RGB;¤	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;¤	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biClrUsed = 0;¤	lpbiSrc->bmiHeader.biClrImportant = 0;¤	¤	COLORREF* pSrcBits = NULL;¤	HBITMAP hSrcDib = CreateDIBSection (¤		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,¤		NULL, NULL);¤	¤	if ((NULL != hSrcDib) && (NULL != pSrcBits))¤	{¤		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);¤		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hMask);¤		if (bGradient)¤		{¤			if (!(dwDepthX & 0x1)) dwDepthX++;¤			if (!(dwDepthY & 0x1)) dwDepthY++;¤			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, WHITENESS);¤			::StretchBlt (hSrcDC, dwDepthX / 2, dwDepthY / 2, dwWidth - dwDepthX, dwHeight - dwDepthY, hTempDC, 0, 0, dwWidth, dwHeight, SRCCOPY);¤		}¤		else¤		{¤			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);¤		} //if¤		::SelectObject (hTempDC, hOldTempBmp);¤		::SelectObject (hSrcDC, hOldSrcBmp);¤		¤		//Creates Destination DIB¤		LPBITMAPINFO lpbiDest;¤		// Fill in the BITMAPINFOHEADER¤		lpbiDest = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤		lpbiDest->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤		lpbiDest->bmiHeader.biWidth = dwWidth;¤		lpbiDest->bmiHeader.biHeight = dwHeight;¤		lpbiDest->bmiHeader.biPlanes = 1;¤		lpbiDest->bmiHeader.biBitCount = 32;¤		lpbiDest->bmiHeader.biCompression = BI_RGB;¤		lpbiDest->bmiHeader.biSizeImage = dwWidth * dwHeight;¤		lpbiDest->bmiHeader.biXPelsPerMeter = 0;¤		lpbiDest->bmiHeader.biYPelsPerMeter = 0;¤		lpbiDest->bmiHeader.biClrUsed = 0;¤		lpbiDest->bmiHeader.biClrImportant = 0;¤		¤		COLORREF* pDestBits = NULL;¤		HBITMAP hDestDib = CreateDIBSection (¤			hDestDC, lpbiDest, DIB_RGB_COLORS, (void **)&pDestBits,¤			NULL, NULL);¤		¤		if ((NULL != hDestDib) && (NULL != pDestBits))¤		{¤			::SelectObject (hTempDC, hDestDib);¤			::BitBlt (hTempDC, 0, 0, dwWidth, dwHeight, hDestDC, nDestX, nDestY, SRCCOPY);¤			::SelectObject (hTempDC, hOldTempBmp);¤			¤			if (bGradient)¤			{¤				double * depth = new double [dwWidth * dwHeight];¤				SmoothMaskImage(dwWidth, dwHeight, pSrcBits, dwDepthX, dwDepthY, depth);¤				for(DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pDestBits++)¤					*pDestBits = DarkenColor(*pDestBits, *(depth + pixel));¤				delete [] depth;¤			}¤			else¤			{¤				for(DWORD pixel = 0; pixel < dwWidth * dwHeight; pixel++, pSrcBits++, pDestBits++)¤					*pDestBits = DarkenColor(*pDestBits, (double)GetRValue(*pSrcBits) / 255.0);¤			} //if¤				¤			¤			::SelectObject (hTempDC, hDestDib);¤			::BitBlt (hDestDC, nDestX, nDestY, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);¤			::SelectObject (hTempDC, hOldTempBmp);¤¤			delete lpbiDest;¤			::DeleteObject(hDestDib);¤		} //if¤		delete lpbiSrc;¤		::DeleteObject(hSrcDib);¤	} //if¤	::DeleteDC(hTempDC);¤	::DeleteDC(hSrcDC);¤} //End DrawIcon¤¤void CPPDrawManager::DrawImageList(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,¤					int nIndex, int cx, int cy,¤					BOOL bUseMask, COLORREF crMask, ¤					DWORD dwEffect /*= IMAGE_EFFECT_NONE*/, ¤					BOOL bShadow /*= FALSE*/, ¤					DWORD dwCxShadow /*= PPDRAWMANAGER_SHADOW_XOFFSET*/, ¤					DWORD dwCyShadow /*= PPDRAWMANAGER_SHADOW_YOFFSET*/,¤					DWORD dwCxDepth /*= PPDRAWMANAGER_SHADOW_XDEPTH*/, ¤					DWORD dwCyDepth /*= PPDRAWMANAGER_SHADOW_YDEPTH*/,¤					COLORREF clrShadow /*= PPDRAWMANAGER_SHADOW_COLOR*/)¤{¤	if ((NULL == hSrcBitmap) || !cx || !cy)¤		return;¤¤	SIZE sz;¤	GetSizeOfBitmap(hSrcBitmap, &sz);¤¤	//ENG: Gets a max columns and rows of the images on the bitmap¤	//RUS: Получаем максимальное число колонок и строк изображений на битмапке¤	int nMaxCol = sz.cx / cx;¤	int nMaxRow = sz.cy / cy;¤	int nMaxImages = nMaxCol * nMaxRow;¤¤	if ((nIndex < nMaxImages) && nMaxCol && nMaxRow)¤	{¤		//ENG: Gets an specified image from the bitmap¤		//RUS: Получаем указанное изображение из битмапа¤		HDC hSrcDC = ::CreateCompatibleDC(hDC);¤		HDC hDestDC = ::CreateCompatibleDC(hDC);¤		HBITMAP hIconBmp = ::CreateCompatibleBitmap(hDC, cx, cy);¤		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject(hSrcDC, hSrcBitmap);¤		HBITMAP hOldDestBmp = (HBITMAP)::SelectObject(hDestDC, hIconBmp);¤		::BitBlt(hDestDC, 0, 0, cx, cy, hSrcDC, (nIndex % nMaxCol) * cx, (nIndex / nMaxCol) * cy, SRCCOPY);¤		::SelectObject(hSrcDC, hOldSrcBmp);¤		::SelectObject(hDestDC, hOldDestBmp);¤		::DeleteDC(hSrcDC);¤		::DeleteDC(hDestDC);¤		DrawBitmap( hDC, x, y, dwWidth, dwHeight, hIconBmp, ¤					bUseMask, crMask, dwEffect, ¤					bShadow, dwCxShadow, dwCyShadow, ¤					dwCxDepth, dwCyDepth, clrShadow);¤		::DeleteObject(hIconBmp);¤	} //if¤} //End of DrawImageList¤¤void CPPDrawManager::MaskToDepth(HDC hDC, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, double * pDepth, BOOL bGradient /* = FALSE */, DWORD dwDepthX /* = PPDRAWMANAGER_CXSHADOW */, DWORD dwDepthY /* = PPDRAWMANAGER_CYSHADOW */)¤{¤	HDC hSrcDC = ::CreateCompatibleDC(hDC);¤	if (NULL == hSrcDC)¤	{¤		::DeleteDC(hSrcDC);¤		hSrcDC = NULL;¤		return;¤	} //if¤¤	HDC hTempDC = ::CreateCompatibleDC(hDC);¤	if (NULL == hTempDC)¤	{¤		::DeleteDC(hTempDC);¤		hTempDC = NULL;¤		return;¤	} //if¤	¤	//Creates Source DIB¤	LPBITMAPINFO lpbiSrc;¤	// Fill in the BITMAPINFOHEADER¤	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤	lpbiSrc->bmiHeader.biWidth = dwWidth;¤	lpbiSrc->bmiHeader.biHeight = dwHeight;¤	lpbiSrc->bmiHeader.biPlanes = 1;¤	lpbiSrc->bmiHeader.biBitCount = 32;¤	lpbiSrc->bmiHeader.biCompression = BI_RGB;¤	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;¤	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biClrUsed = 0;¤	lpbiSrc->bmiHeader.biClrImportant = 0;¤	¤	COLORREF* pSrcBits = NULL;¤	HBITMAP hSrcDib = CreateDIBSection (¤		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,¤		NULL, NULL);¤	¤	if ((NULL != hSrcDib) && (NULL != pSrcBits))¤	{¤		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);¤		HBITMAP hOldTempBmp = (HBITMAP)::SelectObject (hTempDC, hMask);¤		if (bGradient)¤		{¤			if (!(dwDepthX & 0x1)) dwDepthX++;¤			if (!(dwDepthY & 0x1)) dwDepthY++;¤			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, WHITENESS);¤			::StretchBlt (hSrcDC, dwDepthX / 2, dwDepthY / 2, dwWidth - dwDepthX, dwHeight - dwDepthY, hTempDC, 0, 0, dwWidth, dwHeight, SRCCOPY);¤		}¤		else¤		{¤			::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hTempDC, 0, 0, SRCCOPY);¤		} //if¤		::SelectObject (hTempDC, hOldTempBmp);¤		::SelectObject (hSrcDC, hOldSrcBmp);¤		¤		if (bGradient)¤		{¤			SmoothMaskImage(dwWidth, dwHeight, pSrcBits, dwDepthX, dwDepthY, pDepth);¤		}¤		else¤		{¤			for (DWORD pixel = 0; pixel < (dwHeight * dwWidth); pixel++, pSrcBits++, pDepth++)¤			{¤				*pDepth = GetRValue(*pSrcBits) / 255;¤			} //for¤		} //if¤		delete lpbiSrc;¤		::DeleteObject(hSrcDib);¤	} //if¤	::DeleteDC(hTempDC);¤	::DeleteDC(hSrcDC);¤} //End MaskToDepth¤¤void CPPDrawManager::DarkenByDepth(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, double * pDepth)¤{¤	HDC hSrcDC = ::CreateCompatibleDC(hDC);¤	if (NULL == hSrcDC)¤	{¤		::DeleteDC(hSrcDC);¤		hSrcDC = NULL;¤		return;¤	} //if¤	¤	//Creates Source DIB¤	LPBITMAPINFO lpbiSrc;¤	// Fill in the BITMAPINFOHEADER¤	lpbiSrc = (LPBITMAPINFO) new BYTE[sizeof(BITMAPINFOHEADER)];¤	lpbiSrc->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);¤	lpbiSrc->bmiHeader.biWidth = dwWidth;¤	lpbiSrc->bmiHeader.biHeight = dwHeight;¤	lpbiSrc->bmiHeader.biPlanes = 1;¤	lpbiSrc->bmiHeader.biBitCount = 32;¤	lpbiSrc->bmiHeader.biCompression = BI_RGB;¤	lpbiSrc->bmiHeader.biSizeImage = dwWidth * dwHeight;¤	lpbiSrc->bmiHeader.biXPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biYPelsPerMeter = 0;¤	lpbiSrc->bmiHeader.biClrUsed = 0;¤	lpbiSrc->bmiHeader.biClrImportant = 0;¤	¤	COLORREF* pSrcBits = NULL;¤	HBITMAP hSrcDib = CreateDIBSection (¤		hSrcDC, lpbiSrc, DIB_RGB_COLORS, (void **)&pSrcBits,¤		NULL, NULL);¤	¤	if ((NULL != hSrcDib) && (NULL != pSrcBits))¤	{¤		HBITMAP hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);¤		::BitBlt(hSrcDC, 0, 0, dwWidth, dwHeight, hDC, x, y, SRCCOPY);¤		::SelectObject (hSrcDC, hOldSrcBmp);¤		¤		for (DWORD pixel = 0; pixel < (dwHeight * dwWidth); pixel++, pSrcBits++, pDepth++)¤		{¤			*pSrcBits = DarkenColor(*pSrcBits, *pDepth);¤		} //for¤¤		hOldSrcBmp = (HBITMAP)::SelectObject (hSrcDC, hSrcDib);¤		::BitBlt(hDC, x, y, dwWidth, dwHeight, hSrcDC, 0, 0, SRCCOPY);¤		::SelectObject (hSrcDC, hOldSrcBmp);¤¤		delete lpbiSrc;¤		::DeleteObject(hSrcDib);¤	} //if¤	::DeleteDC(hSrcDC);¤} //DarkenByDepth¤¤void CPPDrawManager::SmoothMaskImage(const int ImageWidth, ¤									 const int ImageHeight,¤									 const COLORREF* const pInitImg,¤									 const int KerWidth,¤									 const int KerHeight,¤									 double* const pResImg_R /*= NULL*/)¤{¤	double* const pfBuff1 = new double[(ImageWidth  + KerWidth  - 1) * ¤		(ImageHeight + KerHeight - 1)];¤	double* const pfBuff2 = new double[(ImageWidth  + KerWidth  - 1) * ¤		(ImageHeight + KerHeight - 1)];¤	¤	// expanding initial image with a padding procdure¤	double* p = pfBuff1;¤	const COLORREF * pInitImg_It = pInitImg;¤	if(NULL != pResImg_R)¤	{¤		for(int _i = - KerHeight/2; _i < ImageHeight +  KerHeight/2; _i++)¤		{¤			for(int _j = -KerWidth/2; _j < ImageWidth + KerWidth/2;  _j++, p++)¤			{¤				if ((_i >= 0) && (_i < ImageHeight) && (_j >= 0) && (_j < ImageWidth))¤				{¤					*p = GetRValue(*pInitImg_It++);¤					//					pInitImg_It++;¤				}¤				else¤					*p = 255;¤			} //for¤		} //for¤		¤		//---¤		GetPartialSums(pfBuff1,¤			(ImageHeight + KerHeight - 1),¤			(ImageWidth  + KerWidth  - 1),¤			KerHeight,¤			KerWidth,¤			pfBuff2,¤			pResImg_R);¤		¤		for(int i = 0; i < ImageHeight*ImageWidth; i++)¤			*(pResImg_R + i) /= KerHeight*KerWidth*255;¤	} //if¤	¤	¤	delete []pfBuff1;¤	delete []pfBuff2;¤} //End SmoothMaskImage¤¤void CPPDrawManager::GetPartialSums(const double* const pM,¤									unsigned int nMRows,¤									unsigned int nMCols,¤									unsigned int nPartRows,¤									unsigned int nPartCols,¤									double* const pBuff,¤									double* const pRes)¤{¤	const double* it1;¤	const double* it2;¤	const double* it3;¤	¤	double* pRowsPartSums;¤	const unsigned int nRowsPartSumsMRows = nMRows;¤	const unsigned int nRowsPartSumsMCols = nMCols - nPartCols + 1;	¤	¤	const unsigned int nResMRows = nMRows - nPartRows + 1;¤	const unsigned int nResMCols = nMCols - nPartCols + 1;¤	¤	¤	unsigned int i,j;¤	double s;¤	¤	// частичные суммы строк¤	it1          = pM;¤	pRowsPartSums = pBuff;¤	¤	for(i = 0; i < nMRows; i++)¤	{¤		//-------------¤		it2 = it1;¤		s = 0;¤		for(j = 0;j < nPartCols;j++)s+=*it2++;¤		//-------------¤		it3 = it1;¤		*pRowsPartSums++ = s;¤		for(/*j = nPartCols*/; j < nMCols; j++)¤		{¤			s+=*it2 - *it3;¤			*pRowsPartSums++ = s;¤			it2++;¤			it3++;¤		} //for¤		//--¤		it1 += nMCols;¤	} //for¤	// формирование резуьтата¤	const double* it4;¤	const double* it5;¤	const double* it6;¤	¤	double* pResIt;¤	¤	it4    = pBuff;¤	pResIt = pRes;¤	¤	for(j = 0; j < nRowsPartSumsMCols; j++)¤	{¤		pResIt = pRes + j;¤		//-------------¤		it5 = it4;¤		s = 0;¤		for(i = 0; i < nPartRows; i++)¤		{¤			s += *it5;¤			it5 += nRowsPartSumsMCols; ¤		} //for¤		//-------------¤		it6 = it4;¤		*pResIt = s;¤		pResIt += nRowsPartSumsMCols;¤		¤		for(; i < nRowsPartSumsMRows; i++)¤		{¤			s += *it5 - *it6;//cout<<s<<endl;¤			*pResIt = s;¤			pResIt += nResMCols;¤			it5 += nRowsPartSumsMCols;¤			it6 += nRowsPartSumsMCols;¤		} //for¤		//--¤		it4 ++;¤	} //for¤} //End GetPartialSums¤¤void CPPDrawManager::DrawRectangle(HDC hDC, LPRECT lpRect, COLORREF crLight, COLORREF crDark, int nStyle /* = PEN_SOLID */, int nSize /* = 1 */)¤{¤	DrawRectangle(hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, crLight, crDark, nStyle, nSize);¤}¤¤void CPPDrawManager::DrawRectangle(HDC hDC, int left, int top, int right, int bottom, ¤								   COLORREF crLight, COLORREF crDark, int nStyle /* = PEN_SOLID */, ¤								   int nSize /* = 1 */)¤{¤	if ((PEN_NULL == nStyle) || (nSize < 1))¤		return;¤¤	int nSysPenStyle = PS_SOLID;¤	int nDoubleLineOffset = nSize * 2;¤	switch (nStyle)¤	{¤	case PEN_DASH: nSysPenStyle = PS_DASH; break;¤	case PEN_DOT: nSysPenStyle = PS_DOT; break;¤	case PEN_DASHDOT: nSysPenStyle = PS_DASHDOT; break;¤	case PEN_DASHDOTDOT: nSysPenStyle = PS_DASHDOTDOT; break;¤	case PEN_DOUBLE:¤	case PEN_SOLID:¤	default:¤		nSysPenStyle = PS_SOLID; ¤		break;¤	} //switch¤¤	//Insideframe¤	left += nSize / 2;¤	top += nSize / 2;¤	right -= nSize / 2;¤	bottom -= nSize / 2;¤¤	//Creates a light pen¤	HPEN hPen = ::CreatePen(nSysPenStyle, nSize, crLight);¤	HPEN hOldPen = (HPEN)::SelectObject(hDC, hPen);¤¤	//Draw light border¤	::MoveToEx(hDC, left, bottom, NULL);¤	::LineTo(hDC, left, top);¤	::LineTo(hDC, right, top);¤	if (PEN_DOUBLE == nStyle)¤	{¤		::MoveToEx(hDC, left + nDoubleLineOffset, bottom - nDoubleLineOffset, NULL);¤		::LineTo(hDC, left + nDoubleLineOffset, top + nDoubleLineOffset);¤		::LineTo(hDC, right - nDoubleLineOffset, top + nDoubleLineOffset);¤	} //if¤¤	//Creates a dark pen if needed¤	if (crLight != crDark)¤	{¤		SelectObject(hDC, hOldPen);¤		::DeleteObject(hPen);¤		hPen = ::CreatePen(nSysPenStyle, nSize, crDark);¤		hOldPen = (HPEN)::SelectObject(hDC, hPen);¤	} //if¤¤	//Draw dark border¤	::MoveToEx(hDC, right, top, NULL);¤	::LineTo(hDC, right, bottom);¤	::LineTo(hDC, left, bottom);¤	if (PEN_DOUBLE == nStyle)¤	{¤		::MoveToEx(hDC, right - nDoubleLineOffset, top + nDoubleLineOffset, NULL);¤		::LineTo(hDC, right - nDoubleLineOffset, bottom - nDoubleLineOffset);¤		::LineTo(hDC, left + nDoubleLineOffset, bottom - nDoubleLineOffset);¤	} //if¤¤	SelectObject(hDC, hOldPen);¤	::DeleteObject(hPen);¤} //End DrawRectangle¤¤void CPPDrawManager::DrawLine(HDC hDC, ¤							  int xStart, int yStart, int xEnd, int yEnd, ¤							  COLORREF color, int nStyle /* = PEN_SOLID */, ¤							  int nSize /* = 1 */) const¤{¤	if ((PEN_NULL == nStyle) || (nSize < 1))¤		return;¤	¤	int nSysPenStyle;¤	int nDoubleLineOffset = nSize * 2;¤	switch (nStyle)¤	{¤	case PEN_DASH: nSysPenStyle = PS_DASH; break;¤	case PEN_DOT: nSysPenStyle = PS_DOT; break;¤	case PEN_DASHDOT: nSysPenStyle = PS_DASHDOT; break;¤	case PEN_DASHDOTDOT: nSysPenStyle = PS_DASHDOTDOT; break;¤	case PEN_DOUBLE:¤	case PEN_SOLID:¤	default:¤		nSysPenStyle = PS_SOLID; ¤		break;¤	} //switch¤¤	HPEN hPen = ::CreatePen(nSysPenStyle, nSize, color);¤	HPEN hOldPen = (HPEN)::SelectObject(hDC, hPen);¤¤	::MoveToEx(hDC, xStart, yStart, NULL);¤	::LineTo(hDC, xEnd, yEnd);¤	¤	if (PEN_DOUBLE == nStyle)¤	{¤		if (xStart != xEnd)¤		{¤			yStart += nDoubleLineOffset;¤			yEnd += nDoubleLineOffset;¤		} //if¤		¤		if (yStart != yEnd)¤		{¤			xStart += nDoubleLineOffset;¤			xEnd += nDoubleLineOffset;¤		} //if¤		::MoveToEx(hDC, xStart, yStart, NULL);¤		::LineTo(hDC, xEnd, yEnd);¤	} //if¤	SelectObject(hDC, hOldPen);¤	::DeleteObject(hPen);¤} //End DrawLine¤//#UC END# *4700B8C80280*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8C80280_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B8C80280_DESTR_BODY*¤	//#UC END# *4700B8C80280_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8C80280_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B8C80280_CUSTOM_INCLUDES*¤#include "shared/WinGUI/Controls/CCeXDib.h"¤¤#define PPDRAWMANAGER_SHADOW_XOFFSET	4	// ¤#define PPDRAWMANAGER_SHADOW_YOFFSET	4	//¤#define PPDRAWMANAGER_SHADOW_XDEPTH		7	// ¤#define PPDRAWMANAGER_SHADOW_YDEPTH		7	//¤#define PPDRAWMANAGER_SHADOW_COLOR		RGB(128, 128, 128)¤¤//Image Effects¤#define IMAGE_EFFECT_NONE				0x0000 //No effect¤#define IMAGE_EFFECT_GRAYEN				0x0001 //An image will grayen¤#define IMAGE_EFFECT_DARKEN				0x0002 //An image will darken¤#define IMAGE_EFFECT_LIGHTEN			0x0004 //An image will lighten¤#define IMAGE_EFFECT_MONOCHROME			0x0008 //An Image will monochrome¤#define IMAGE_EFFECT_MONO_SHADOW		0x0100¤#define IMAGE_EFFECT_GRADIENT_SHADOW	0x0200¤#define IMAGE_EFFECT_INVERT				0x8000¤¤#define IMAGE_EFFECT_MASK				(IMAGE_EFFECT_MONOCHROME | IMAGE_EFFECT_INVERT)¤#define IMAGE_EFFECT_SHADOW				(IMAGE_EFFECT_MONO_SHADOW | IMAGE_EFFECT_GRADIENT_SHADOW)¤¤//#UC END# *4700B8C80280_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8C80280*"
		    value      	(value Text 
|//#UC START# *4700B8C80280*¤public:¤	CPPDrawManager();¤¤	enum {	EFFECT_SOLID = 0,¤			EFFECT_HGRADIENT,¤			EFFECT_VGRADIENT,¤			EFFECT_HCGRADIENT,¤			EFFECT_VCGRADIENT,¤			EFFECT_3HGRADIENT,¤			EFFECT_3VGRADIENT,¤			EFFECT_NOISE,¤			EFFECT_DIAGSHADE,¤			EFFECT_HSHADE,¤			EFFECT_VSHADE,¤			EFFECT_HBUMP,¤			EFFECT_VBUMP,¤			EFFECT_SOFTBUMP,¤			EFFECT_HARDBUMP,¤			EFFECT_METAL,¤			MAX_EFFECTS¤		};¤¤	enum	{ ¤			PEN_NULL = 0,¤			PEN_SOLID,¤			PEN_DASH,¤			PEN_DOT,¤			PEN_DASHDOT,¤			PEN_DASHDOTDOT,¤			PEN_DOUBLE,¤¤			MAX_PEN_STYLES¤			};¤¤public:¤	void  DrawLine(HDC hDC, int xStart, int yStart, int xEnd, int yEnd, COLORREF color, int nStyle = PEN_SOLID, int nSize = 1) const;¤	void  DrawRectangle(HDC hDC, LPRECT lpRect, COLORREF crLight, COLORREF crDark, int nStyle = PEN_SOLID, int nSize = 1);¤	void  DrawRectangle(HDC hDC, int left, int top, int right, int bottom, COLORREF crLight, COLORREF crDark, int nStyle = PEN_SOLID, int nSize = 1);¤	void  GetSizeOfIcon(HICON hIcon, LPSIZE pSize) const;¤	void  GetSizeOfBitmap(HBITMAP hBitmap, LPSIZE pSize) const;¤	¤	void  AlphaBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY, int percent = 100);¤	void  AlphaChannelBitBlt(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HDC hSrcDC, int nSrcX, int nSrcY);¤	void  DrawShadow(HDC hDestDC, int nDestX, int nDestY, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, BOOL bGradient = FALSE, DWORD dwDepthX = PPDRAWMANAGER_SHADOW_XOFFSET, DWORD dwDepthY = PPDRAWMANAGER_SHADOW_YOFFSET);¤	void  MaskToDepth(HDC hDC, DWORD dwWidth, DWORD dwHeight, HBITMAP hMask, double * pDepth, BOOL bGradient = FALSE, DWORD dwDepthX = PPDRAWMANAGER_SHADOW_XOFFSET, DWORD dwDepthY = PPDRAWMANAGER_SHADOW_YOFFSET);¤	void  DarkenByDepth(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, double * pDepth);¤¤	void  SmoothMaskImage(const int ImageWidth, ¤				    const int ImageHeight,¤                    const COLORREF* const pInitImg,¤			        const int KerWidth,¤			        const int KerHeight,¤					double* const pResImg_R = NULL);¤¤	void GetPartialSums(const double* const pM,¤					unsigned int nMRows,¤					unsigned int nMCols,¤					unsigned int nPartRows,¤					unsigned int nPartCols,¤					double* const pBuff,¤					double* const pRes);¤	¤	void  DrawBitmap(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,¤					BOOL bUseMask, COLORREF crMask, ¤					DWORD dwEffect = IMAGE_EFFECT_NONE, ¤					BOOL bShadow = FALSE, ¤					DWORD dwCxShadow = PPDRAWMANAGER_SHADOW_XOFFSET, ¤					DWORD dwCyShadow = PPDRAWMANAGER_SHADOW_YOFFSET,¤					DWORD dwCxDepth = PPDRAWMANAGER_SHADOW_XDEPTH, ¤					DWORD dwCyDepth = PPDRAWMANAGER_SHADOW_YDEPTH,¤					COLORREF clrShadow = PPDRAWMANAGER_SHADOW_COLOR);¤¤	void  DrawIcon( HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HICON hSrcIcon, ¤					DWORD dwEffect = IMAGE_EFFECT_NONE, ¤					BOOL bShadow = FALSE, ¤					DWORD dwCxShadow = PPDRAWMANAGER_SHADOW_XOFFSET, ¤					DWORD dwCyShadow = PPDRAWMANAGER_SHADOW_YOFFSET,¤					DWORD dwCxDepth = PPDRAWMANAGER_SHADOW_XDEPTH, ¤					DWORD dwCyDepth = PPDRAWMANAGER_SHADOW_YDEPTH,¤					COLORREF clrShadow = PPDRAWMANAGER_SHADOW_COLOR);¤¤	void  DrawImageList(HDC hDC, int x, int y, DWORD dwWidth, DWORD dwHeight, HBITMAP hSrcBitmap,¤					int nIndex, int cx, int cy,¤					BOOL bUseMask, COLORREF crMask, ¤					DWORD dwEffect = IMAGE_EFFECT_NONE, ¤					BOOL bShadow = FALSE, ¤					DWORD dwCxShadow = PPDRAWMANAGER_SHADOW_XOFFSET, ¤					DWORD dwCyShadow = PPDRAWMANAGER_SHADOW_YOFFSET,¤					DWORD dwCxDepth = PPDRAWMANAGER_SHADOW_XDEPTH, ¤					DWORD dwCyDepth = PPDRAWMANAGER_SHADOW_YDEPTH,¤					COLORREF clrShadow = PPDRAWMANAGER_SHADOW_COLOR);¤¤	HBITMAP CreateImageEffect(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, DWORD dwEffect, BOOL bUseMask = TRUE, COLORREF clrMask = RGB(255, 0, 255), COLORREF clrMono = RGB(255, 255, 255));¤¤	COLORREF GrayMirrorColor(COLORREF clrColor);¤	COLORREF GrayColor(COLORREF clrColor);¤	COLORREF DarkenColor(COLORREF clrColor, double darken);¤	COLORREF LightenColor(COLORREF clrColor, double lighten);¤	COLORREF InvertColor(COLORREF clrColor);¤	COLORREF PixelAlpha (COLORREF clrSrc, double src_darken, COLORREF clrDest, double dest_darken);¤	¤	HICON StretchIcon(HICON hIcon, DWORD dwWidth, DWORD dwHeight);¤¤	void FillEffect(HDC hDC, DWORD dwEffect, LPCRECT lpRect, COLORREF clrBegin, COLORREF clrMid = 0, COLORREF clrEnd = 0,  BYTE granularity = 0, BYTE coloring = 0);¤	void FillGradient(HDC hDC, LPCRECT lpRect, COLORREF colorStart, COLORREF colorFinish, BOOL bHorz = TRUE);¤	void MultipleCopy(HDC hDestDC, int nDestX, int nDestY, DWORD dwDestWidth, DWORD dwDestHeight, HDC hSrcDC, int nSrcX, int nSrcY, DWORD dwSrcWidth, DWORD dwSrcHeight);¤#ifdef USE_SHADE¤	void SetShade(LPCRECT lpRect, UINT shadeID = 0, BYTE granularity = 8, BYTE coloring = 0, COLORREF hicr = 0, COLORREF midcr = 0, COLORREF locr = 0);¤	CCeXDib m_dNormal/*,m_dh,m_dv*/;¤#endif¤¤	static short GetVersionI()		{return 0x13;}¤//	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("1.3");}¤¤protected:¤	BOOL m_bIsAlpha;¤//#UC END# *4700B8C80280*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CPPDrawManager|4700B8C80280
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659777955"))
	    quid       	"4700B8C80280"
	    documentation 	"класс для работы с графикой"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator")
	(object Class "CCeXDib"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/CCeXDib.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CCeXDib.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8F90119_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4700B8F90119_CUSTOM_INCLUDES*¤#include <windows.h>¤#include <tchar.h>¤//#UC END# *4700B8F90119_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8F90119*"
		    value      	(value Text 
|//#UC START# *4700B8F90119*¤CCeXDib::CCeXDib()¤{¤	m_hDib = NULL;¤	m_dwLineWidth = 0;¤	m_wColors = 0;¤¤	m_hMemDC = NULL;¤	m_hBitmap = NULL;¤	m_lpBits = NULL;¤¤	FreeResources();¤}¤¤void CCeXDib::FreeResources()¤{¤	if (m_hMemDC)	¤		::DeleteDC(m_hMemDC);¤	if (m_hBitmap)	¤		::DeleteObject(m_hBitmap);¤	if (m_hDib)		¤		delete m_hDib;¤¤	m_hDib = NULL;¤	m_hMemDC = NULL;¤	m_hBitmap = NULL;¤	m_lpBits = NULL;¤	memset(&m_bi, 0, sizeof(m_bi));¤} // End of FreeResources¤¤HDIB CCeXDib::Create(DWORD dwWidth, DWORD dwHeight, WORD wBitCount)¤{¤    LPBITMAPINFOHEADER  lpbi = NULL;	// Pointer to BITMAPINFOHEADER¤    DWORD               dwLen = 0;		// Size of memory block¤¤	FreeResources();¤¤	// Following <switch> is taken from¤	// CDIBSectionLite class by Chris Maunder¤    switch (wBitCount) ¤    {¤	    case 1:  m_wColors = 2;   break;¤#ifdef _WIN32_WCE¤        case 2:  m_wColors = 4;   break;   // winCE only       ¤#endif¤        case 4:  m_wColors = 16;  break;¤        case 8:  m_wColors = 256; break;¤        case 16:¤        case 24:¤        case 32: m_wColors = 0;   break;   // 16,24 or 32 bpp have no color table¤¤        default:¤           m_wColors = 0;¤    } // switch¤/*¤    // Make sure bits per pixel is valid¤    if (wBitCount <= 1)			wBitCount = 1;¤    else if (wBitCount <= 4)	wBitCount = 4;¤    else if (wBitCount <= 8)	wBitCount = 8;¤    else				        wBitCount = 24;¤¤    switch (wBitCount)¤	{¤        case 1:¤            m_wColors = 2;¤			break;¤        case 4:¤            m_wColors = 16;¤			break;¤        case 8:¤            m_wColors = 256;¤			break;¤        default:¤            m_wColors = 0;¤			break;¤    } // switch¤*/¤    m_dwLineWidth = WIDTHBYTES(wBitCount * dwWidth);¤¤    // Initialize BITMAPINFOHEADER¤    m_bi.biSize = sizeof(BITMAPINFOHEADER);¤    m_bi.biWidth = dwWidth;         // fill in width from parameter¤    m_bi.biHeight = dwHeight;       // fill in height from parameter¤    m_bi.biPlanes = 1;              // must be 1¤    m_bi.biBitCount = wBitCount;    // from parameter¤    m_bi.biCompression = BI_RGB;    ¤    m_bi.biSizeImage = m_dwLineWidth * dwHeight;¤    m_bi.biXPelsPerMeter = 0;¤    m_bi.biYPelsPerMeter = 0;¤    m_bi.biClrUsed = 0;¤    m_bi.biClrImportant = 0;¤¤    // Calculate size of memory block required to store the DIB.  This¤    // block should be big enough to hold the BITMAPINFOHEADER, the color¤    // table, and the bits.¤    dwLen = GetSize();¤¤	m_hDib = new HDIB[dwLen]; // Allocate memory block to store our bitmap¤    if (m_hDib == NULL) return NULL;¤¤    // Use our bitmap info structure to fill in first part of¤    // our DIB with the BITMAPINFOHEADER¤	lpbi = (LPBITMAPINFOHEADER)(m_hDib);¤    *lpbi = m_bi;¤¤    return m_hDib; // Return handle to the DIB¤} // End of Create¤¤DWORD CCeXDib::GetSize()¤{¤	return m_bi.biSize + m_bi.biSizeImage + GetPaletteSize();¤} // End of GetSize¤¤DWORD CCeXDib::GetPaletteSize()¤{¤	return (m_wColors * sizeof(RGBQUAD));¤} // End of GetPaletteSize¤¤LPBYTE CCeXDib::GetBits()¤{¤	if (m_hDib)	¤		return ((LPBYTE)m_hDib + *(LPDWORD)m_hDib + GetPaletteSize()); ¤¤	return NULL;¤} // End of GetBits¤¤DWORD CCeXDib::GetWidth()¤{¤	return m_bi.biWidth;¤} // End of GetWidth¤¤DWORD CCeXDib::GetHeight()¤{¤	return m_bi.biHeight;¤} // End of GetHeight¤¤DWORD CCeXDib::GetLineWidth()¤{¤	return m_dwLineWidth;¤} // End of GetLineWidth¤¤void CCeXDib::BlendPalette(COLORREF crColor, DWORD dwPerc)¤{¤	if (m_hDib == NULL || m_wColors == 0) ¤		return;¤¤	LPBYTE iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);¤¤	long i,r,g,b;¤¤	RGBQUAD* pPal = (RGBQUAD*)iDst;¤¤	r = GetRValue(crColor);¤	g = GetGValue(crColor);¤	b = GetBValue(crColor);¤¤	if (dwPerc > 100) ¤		dwPerc = 100;¤¤	for (i = 0; i < m_wColors; i++)¤	{¤		pPal[i].rgbBlue = (BYTE)((pPal[i].rgbBlue * (100 - dwPerc) + b * dwPerc) / 100);¤		pPal[i].rgbGreen = (BYTE)((pPal[i].rgbGreen * (100 - dwPerc) + g * dwPerc) / 100);¤		pPal[i].rgbRed = (BYTE)((pPal[i].rgbRed * (100 - dwPerc) + r * dwPerc) / 100);¤	} // for¤} // End of BlendPalette¤¤void CCeXDib::Clear(BYTE byVal)¤{¤	if (m_hDib) ¤		memset(GetBits(), byVal, m_bi.biSizeImage);¤} // End of Clear¤¤void CCeXDib::SetPixelIndex(DWORD dwX, DWORD dwY, BYTE byI)¤{¤	if ((m_hDib == NULL) || (m_wColors == 0) ||¤		((long)dwX < 0) || ((long)dwY < 0) || (dwX >= (DWORD)m_bi.biWidth) || (dwY >= (DWORD)m_bi.biHeight)) return;¤¤	LPBYTE iDst = GetBits();¤	iDst[(m_bi.biHeight - dwY - 1) * m_dwLineWidth + dwX] = byI;¤} // End of SetPixelIndex¤¤void CCeXDib::Clone(CCeXDib* src)¤{¤	Create(src->GetWidth(), src->GetHeight(), src->GetBitCount());¤	if (m_hDib) ¤		memcpy(m_hDib, src->m_hDib, GetSize());¤} // End of Clone¤¤WORD CCeXDib::GetBitCount()¤{¤	return m_bi.biBitCount;¤} // End of GetBitCount¤¤void CCeXDib::SetPaletteIndex(BYTE byIdx, BYTE byR, BYTE byG, BYTE byB)¤{¤	if (m_hDib && m_wColors)¤	{¤		LPBYTE iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);¤		if ((byIdx >= 0) && (byIdx < m_wColors))¤		{	¤			long ldx = byIdx * sizeof(RGBQUAD);¤			iDst[ldx++] = (BYTE)byB;¤			iDst[ldx++] = (BYTE)byG;¤			iDst[ldx++] = (BYTE)byR;¤			iDst[ldx] = (BYTE)0;¤		} // if¤	} // if¤} // End of SetPaletteIndex¤¤void CCeXDib::Draw(HDC hDC, DWORD dwX, DWORD dwY)¤{¤	HBITMAP	hBitmap = NULL;¤	HBITMAP	hOldBitmap = NULL;¤	HDC		hMemDC = NULL;¤¤	if (m_hBitmap == NULL)¤	{¤		m_hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)m_hDib, DIB_RGB_COLORS, &m_lpBits, NULL, 0);¤		if (m_hBitmap == NULL)	return;¤		if (m_lpBits == NULL)¤		{¤			::DeleteObject(m_hBitmap);¤			m_hBitmap = NULL;¤			return;¤		} // if¤	} // if¤¤    memcpy(m_lpBits, GetBits(), m_bi.biSizeImage);¤¤	if (m_hMemDC == NULL)¤	{¤		m_hMemDC = CreateCompatibleDC(hDC);¤		if (m_hMemDC == NULL)	return;¤	} // if¤¤	hOldBitmap = (HBITMAP)SelectObject(m_hMemDC, m_hBitmap);¤¤	BitBlt(hDC, dwX, dwY, m_bi.biWidth, m_bi.biHeight, m_hMemDC, 0, 0, SRCCOPY);¤¤	SelectObject(m_hMemDC, hOldBitmap);¤} // End of Draw¤¤void CCeXDib::Copy(HDC hDC, DWORD dwX, DWORD dwY)¤{¤	if (m_hBitmap == NULL)¤	{¤		m_hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)m_hDib, DIB_RGB_COLORS, &m_lpBits, NULL, 0);¤		if (m_hBitmap == NULL)¤			return;¤		if (m_lpBits == NULL)¤		{¤			::DeleteObject(m_hBitmap);¤			m_hBitmap = NULL;¤			return;¤		} // if¤	} // if¤	¤	HDC hMemDC = ::CreateCompatibleDC(hDC);¤	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hMemDC, m_hBitmap);¤	::BitBlt(hMemDC, 0, 0, m_bi.biWidth, m_bi.biHeight, hDC, dwX, dwY, SRCCOPY);¤	::SelectObject(hMemDC, hOldBitmap);¤} // End of Copy¤¤void CCeXDib::SetGrayPalette()¤{¤	RGBQUAD		pal[256];¤	RGBQUAD*	ppal;¤	LPBYTE		iDst;¤	int			ni;¤¤	if (m_hDib == NULL || m_wColors == 0) return;¤¤	ppal = (RGBQUAD*)&pal[0];¤	iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);¤	for (ni = 0; ni < m_wColors; ni++)¤	{¤		pal[ni] = RGB2RGBQUAD(RGB(ni,ni,ni));¤	} // for¤¤	pal[0] = RGB2RGBQUAD(RGB(0,0,0));¤	pal[m_wColors-1] = RGB2RGBQUAD(RGB(255,255,255));¤¤	memcpy(iDst, ppal, GetPaletteSize());¤} // End of SetGrayPalette¤¤RGBQUAD CCeXDib::RGB2RGBQUAD(COLORREF cr)¤{¤	RGBQUAD c;¤	c.rgbRed = GetRValue(cr);	/* get R, G, and B out of DWORD */¤	c.rgbGreen = GetGValue(cr);¤	c.rgbBlue = GetBValue(cr);¤	c.rgbReserved=0;¤	return c;¤} // End of RGB2RGBQUAD¤¤WORD CCeXDib::GetNumColors()¤{¤	return m_wColors;¤} // End of GetNumColors¤¤BOOL CCeXDib::WriteBMP(LPCTSTR bmpFileName)¤{¤	BITMAPFILEHEADER	hdr;¤	HANDLE	hFile;¤	DWORD	nByteWrite;¤¤	if (*bmpFileName == _T('\0') || m_hDib == 0) return 0;¤¤	hFile=CreateFile(			// open if exist ini file¤		bmpFileName,			// pointer to name of the file ¤		GENERIC_WRITE,			// access mode ¤		0,						// share mode ¤		NULL,					// pointer to security descriptor ¤		CREATE_ALWAYS,			// how to create ¤		FILE_ATTRIBUTE_NORMAL,	// file attributes ¤		NULL				 	// handle to file with attributes to copy  ¤		);¤	if (hFile == INVALID_HANDLE_VALUE) return FALSE;¤¤    // Fill in the fields of the file header¤	hdr.bfType = BFT_BITMAP;¤	hdr.bfSize = GetSize() + sizeof(BITMAPFILEHEADER);¤	hdr.bfReserved1 = hdr.bfReserved2 = 0;¤	hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER)+¤					m_bi.biSize + GetPaletteSize();¤¤    // Write the file header¤	WriteFile(						// write ini (sync mode <-> no overlapped)¤		hFile,						// handle of file to write ¤		(LPSTR) &hdr,				// address of buffer that contains data  ¤		sizeof(BITMAPFILEHEADER),	// number of bytes to write ¤		&nByteWrite,				// address of number of bytes written ¤		NULL	 					// address of structure for data ¤		);¤¤    // Write the DIB header and the bits¤	WriteFile(						// write ini (sync mode <-> no overlapped)¤		hFile,						// handle of file to write ¤		(LPSTR) m_hDib,				// address of buffer that contains data  ¤		GetSize(),					// number of bytes to write ¤		&nByteWrite,				// address of number of bytes written ¤		NULL	 					// address of structure for data ¤		);¤¤	CloseHandle(hFile);				// free file handle¤¤	return TRUE;¤} // End of WriteBMP¤//#UC END# *4700B8F90119*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4700B8F90119_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4700B8F90119_DESTR_BODY*¤	FreeResources();¤	//#UC END# *4700B8F90119_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8F90119_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4700B8F90119_CUSTOM_INCLUDES*¤#ifndef	HDIB¤#define HDIB	HANDLE¤#endif¤¤#ifndef WIDTHBYTES¤#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)¤#endif¤¤#ifndef BFT_BITMAP¤#define BFT_BITMAP 0x4d42   // 'BM'¤#endif¤//#UC END# *4700B8F90119_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4700B8F90119*"
		    value      	(value Text 
|//#UC START# *4700B8F90119*¤public:¤	CCeXDib();¤¤	HDIB Create(DWORD dwWidth, DWORD dwHeight, WORD wBitCount);¤	void Clone(CCeXDib* src);¤	void Draw(HDC hDC, DWORD dwX, DWORD dwY);¤	void Copy(HDC hDC, DWORD dwX, DWORD dwY);¤	LPBYTE GetBits();¤	void Clear(BYTE byVal = 0);¤¤	void SetGrayPalette();¤	void SetPaletteIndex(BYTE byIdx, BYTE byR, BYTE byG, BYTE byB);¤	void SetPixelIndex(DWORD dwX, DWORD dwY, BYTE byI);¤	void BlendPalette(COLORREF crColor, DWORD dwPerc);¤¤	WORD GetBitCount();¤	DWORD GetLineWidth();¤	DWORD GetWidth();¤	DWORD GetHeight();¤	WORD GetNumColors();¤¤	BOOL WriteBMP(LPCTSTR bmpFileName);¤¤private:¤	void FreeResources();¤¤	DWORD GetPaletteSize();¤	DWORD GetSize();¤¤	RGBQUAD RGB2RGBQUAD(COLORREF cr);¤¤	HDIB				m_hDib;¤    BITMAPINFOHEADER    m_bi;¤	DWORD				m_dwLineWidth;¤	WORD				m_wColors;¤¤	HBITMAP				m_hBitmap;	// Handle to bitmap¤	HDC					m_hMemDC;	// Handle to memory DC¤	LPVOID				m_lpBits;	// Pointer to actual bitmap bits¤//#UC END# *4700B8F90119*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need ref count"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need unsorted less"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no base class"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/CCeXDib|4700B8F90119
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659778454"))
	    quid       	"4700B8F90119"
	    documentation 	"класс для поддержки расширенных графиеских эффектов"
	    stereotype 	"SimpleClass"
	    language   	"MDA Generator")
	(object Class "CommonControls"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (rc)"
		    value      	"w:/shared/WinGUI/Controls/CommonControls.rc")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (rc)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/CommonControls.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"rc:*4AD426890274*"
		    value      	(value Text 
|//#UC START# *4AD426890274*¤// Microsoft Visual C++ generated resource script.¤//¤#include "winuser.h"¤¤#define APSTUDIO_READONLY_SYMBOLS¤/////////////////////////////////////////////////////////////////////////////¤//¤// Generated from the TEXTINCLUDE 2 resource.¤//¤ ¤/////////////////////////////////////////////////////////////////////////////¤#undef APSTUDIO_READONLY_SYMBOLS¤¤/////////////////////////////////////////////////////////////////////////////¤// Russian resources¤¤#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)¤#ifdef APSTUDIO_INVOKED¤/////////////////////////////////////////////////////////////////////////////¤//¤// TEXTINCLUDE¤//¤¤1 TEXTINCLUDE ¤BEGIN¤    "resource.h\0"¤END¤¤2 TEXTINCLUDE ¤BEGIN¤    "\0"¤END¤¤3 TEXTINCLUDE ¤BEGIN¤    "\r\n"¤    "\0"¤END¤¤#endif    // APSTUDIO_INVOKED¤¤¤/////////////////////////////////////////////////////////////////////////////¤//¤// Dialog¤//¤¤IDD_PROGRESS_INDICATOR DIALOGEX 0, 0, 288, 63¤STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION¤CAPTION "Progress:"¤FONT 8, "MS Shell Dlg", 400, 0, 0x1¤BEGIN¤    PUSHBUTTON      "Cancel",IDCANCEL,115,42,50,14¤    CONTROL         "",IDC_PROGRESS_INDICATOR,"msctls_progress32",WS_BORDER,7,7,274,14¤    LTEXT           "Generation in process...",IDC_PROGRESS_LABEL,7,24,78,8¤END¤¤¤/////////////////////////////////////////////////////////////////////////////¤//¤// DESIGNINFO¤//¤¤#ifdef APSTUDIO_INVOKED¤GUIDELINES DESIGNINFO ¤BEGIN¤    IDD_PROGRESS_INDICATOR, DIALOG¤    BEGIN¤        LEFTMARGIN, 7¤        RIGHTMARGIN, 281¤        TOPMARGIN, 7¤        BOTTOMMARGIN, 56¤    END¤END¤#endif    // APSTUDIO_INVOKED¤¤#endif    // Russian resources¤/////////////////////////////////////////////////////////////////////////////¤¤//#UC END# *4AD426890274*
		    ))
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"is namespace"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local helper"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need impl-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need inline-file"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"weak"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4AD426890274*"
		    value      	"//#UC START# *4AD426890274*¤#ifdef IDD_PROGRESS_INDICATOR¤#undef IDD_PROGRESS_INDICATOR¤#endif¤¤#define IDD_PROGRESS_INDICATOR          101¤¤#ifdef IDC_PROGRESS_INDICATOR¤#undef IDC_PROGRESS_INDICATOR¤#endif¤¤#define IDC_PROGRESS_INDICATOR          102¤¤#ifdef IDC_PROGRESS_LABEL¤#undef IDC_PROGRESS_LABEL¤#endif¤¤#define IDC_PROGRESS_LABEL              -1¤//#UC END# *4AD426890274*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659778955"))
	    quid       	"4AD426890274"
	    documentation 	"ресурсы"
	    stereotype 	"Resource"
	    language   	"MDA Generator")
	(object Class "ProgressIndicator"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (cpp)"
		    value      	"w:/shared/WinGUI/Controls/ProgressIndicator.cpp")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (cpp)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SELF GENERATED FILE (h)"
		    value      	"w:/shared/WinGUI/Controls/ProgressIndicator.h")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (h)"
		    value      	"file")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need assign op"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Need copy ctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"Refcount"
		    value      	"none")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"base wnd class"
		    value      	"CWnd")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"debug log"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"finished"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"local supervisor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need UC"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need dctor"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"need objcounter"
		    value      	"true")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"no hands"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"non virtual base"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"resizeable"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator User Properties"
		    name       	"singleton"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_DESTR_BODY*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_DESTR_BODY*	¤	//#UC END# *4AD426A003AF_DESTR_BODY*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_MESSAGE_MAP*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_MESSAGE_MAP*¤	ON_BN_CLICKED(IDCANCEL, on_cancel)¤	ON_BN_CLICKED(IDOK, on_ok)¤	ON_MESSAGE(WM_UPDATE_LABEL_TEXT, update_label_impl)¤	ON_MESSAGE(WM_PROGRESS_STEPIT, step_impl)¤	//#UC END# *4AD426A003AF_MESSAGE_MAP*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_DO_DATA_EXCHANGE*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_DO_DATA_EXCHANGE*¤	DDX_Control(pDX, IDC_PROGRESS_INDICATOR, m_progress);¤	//#UC END# *4AD426A003AF_DO_DATA_EXCHANGE*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_ON_INIT_DLG*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_ON_INIT_DLG*¤		GUARD(m_mutex);¤		if (m_delegate) {¤			m_progress.SetRange32 (0, m_delegate->get_progress_size ());¤			m_progress.SetStep (m_delegate->get_step_size ());¤			this->SetWindowText ("Progress: 0%");¤		}¤		//#UC END# *4AD426A003AF_ON_INIT_DLG*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF_CUSTOM_INCLUDES*"
		    value      	"//#UC START# *4AD426A003AF_CUSTOM_INCLUDES*¤//#UC END# *4AD426A003AF_CUSTOM_INCLUDES*")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"cpp:*4AD426A003AF*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF*¤/*void ProgressIndicator::PostNcDestroy () {¤	CDialog::PostNcDestroy();¤	if(!m_was_canceled && m_delegate) {¤		try {¤			if (m_delegate) {¤				m_delegate->progress_indicator_closed (*this);¤			}¤			delete this;¤		} catch (...) {¤			delete this;¤			throw;¤		}¤	}¤}*/¤//#UC END# *4AD426A003AF*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4AD426A003AF_CUSTOM_INCLUDES*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF_CUSTOM_INCLUDES*¤#include "shared/WinGUI/Controls/Controls.h"¤//#UC END# *4AD426A003AF_CUSTOM_INCLUDES*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"h:*4AD426A003AF*"
		    value      	(value Text 
|//#UC START# *4AD426A003AF*¤protected:¤	//virtual void PostNcDestroy ();¤//#UC END# *4AD426A003AF*
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/ProgressIndicator|4AD426A003AF
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16659779438"))
	    quid       	"4AD426A003AF"
	    documentation 	
|Прогресс индикатор. Выполнен в виде НЕ модального диалога, при закрытии "убивает сам себя", поэтому объект его создающий не должен заботится об удалении!!!
	    
	    stereotype 	"Dialog"
	    used_nodes 	(list uses_relationship_list
		(object Uses_Relationship
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659790974"))
		    quid       	"4AD702EE00C3"
		    stereotype 	"uses"
		    supplier   	"Logical View::external::boost::lexical_cast::lexical_cast"
		    quidu      	"46FCA22B0280"))
	    operations 	(list Operations
		(object Operation "ctor"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD426BE03A6_BASE_INIT*"
			    value      	(value Text 
|//#UC START# *4AD426BE03A6_BASE_INIT*¤	, m_delegate (delegate)¤	, m_is_showed (false)¤//#UC END# *4AD426BE03A6_BASE_INIT*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD426BE03A6_BODY*"
			    value      	(value Text 
|//#UC START# *4AD426BE03A6_BODY*¤	//#UC END# *4AD426BE03A6_BODY*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659784107"))
		    quid       	"4AD426BE03A6"
		    documentation 	"конструктор"
		    stereotype 	"ctor"
		    parameters 	(list Parameters
			(object Parameter "inout delegate"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD43CA40312")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659784411"))
			    quid       	"4AD5DFE30054"
			    type       	"ProgressIndicatorDelegate"
			    quidu      	"4AD43CA40312"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "step"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD427C5028C*"
			    value      	(value Text 
|//#UC START# *4AD427C5028C*¤	GUARD(m_mutex);¤	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤		this->PostMessage (WM_PROGRESS_STEPIT, 0, 0);¤	}¤	//#UC END# *4AD427C5028C*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659784813"))
		    quid       	"4AD427C5028C"
		    documentation 	"шаг прогресса"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "step"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD427E002AC*"
			    value      	(value Text 
|//#UC START# *4AD427E002AC*¤	GUARD(m_mutex);¤	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤		this->update_label_text (message);¤		this->PostMessage (WM_PROGRESS_STEPIT, 0, 0);¤	}¤	//#UC END# *4AD427E002AC*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659785159"))
		    quid       	"4AD427E002AC"
		    documentation 	"инициирует шаг, передает сообщение описывающее шаг"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "message"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659785466"))
			    quid       	"4AD427EC0158"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "on_cancel"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD5DED5035E*"
			    value      	(value Text 
|//#UC START# *4AD5DED5035E*¤	GUARD(m_mutex);¤		¤	try {¤		if (m_delegate) {¤			m_delegate->progress_indicator_canceled (*this);¤		}¤	} catch (...) {¤		CDialog::OnCancel ();¤		m_was_canceled = true;¤		m_is_showed = false;¤¤		throw;¤	}¤	¤	CDialog::OnCancel ();¤	m_was_canceled = true;¤	m_is_showed = false;¤	//#UC END# *4AD5DED5035E*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659785868"))
		    quid       	"4AD5DED5035E"
		    documentation 	
|обрабочтик нажатия кнопки "Cancel"
		    
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0)
		(object Operation "update_label_text"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD5E0F70198*"
			    value      	(value Text 
|//#UC START# *4AD5E0F70198*¤	GUARD(m_mutex);¤	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤		char* msg = new char[text.size () + 1];¤		strcpy (msg, text.c_str ());¤		this->PostMessage (WM_UPDATE_LABEL_TEXT, 0, (LPARAM)msg);¤	}¤	//#UC END# *4AD5E0F70198*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659786210"))
		    quid       	"4AD5E0F70198"
		    documentation 	"обновляет текст в IDC_PROGRESS_LABEL на text"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "text"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659787332"))
			    quid       	"4AD5E11100BC"
			    type       	"a-string"
			    quidu      	"452257A0036F"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "step_impl"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"45CC2F60000F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6C2080148*"
			    value      	(value Text 
|//#UC START# *4AD6C2080148*¤	GUARD(m_mutex);¤	if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤		m_progress.StepIt ();¤		unsigned int pos = static_cast<unsigned int> (m_progress.GetPos ());¤		int lower = 0;¤		int upper = 0;¤		m_progress.GetRange (lower, upper);¤		if (pos >= static_cast<unsigned int> (upper)) {¤			m_progress.SetPos (upper);¤			¤			if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤				this->PostMessage (WM_COMMAND, MAKEWPARAM (IDOK, 0), 0);¤			}¤¤			if (m_delegate) {¤				m_delegate->progress_indicator_finished (*this);¤			}¤		} else {¤			std::string text ("Progress: ");¤			text += boost::lexical_cast<std::string> (unsigned int (ceil(float(pos*100)/float(upper))));¤			text += "%";¤			this->SetWindowText (text.c_str ());¤		}¤	}¤¤	return S_OK;¤	//#UC END# *4AD6C2080148*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659787761"))
		    quid       	"4AD6C2080148"
		    documentation 	"реализация шага прогресс индикатора, если прогресс достиг конца - диалог с индикатор закрывается, перед этим посылается сообщение progress_indicator_finished ()"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "w_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F3F0109")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659788069"))
			    quid       	"4AD6DAD6020E"
			    type       	"WPARAM"
			    quidu      	"45CC2F3F0109")
			(object Parameter "l_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F6701F4")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659788435"))
			    quid       	"4AD6DAD6023F"
			    type       	"LPARAM"
			    quidu      	"45CC2F6701F4"))
		    result     	"LRESULT"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0
		    quidu      	"45CC2F60000F")
		(object Operation "close"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6CFC00148*"
			    value      	(value Text 
|//#UC START# *4AD6CFC00148*¤	GUARD(m_mutex);¤	if(!m_was_canceled && m_delegate) {¤		try {¤			if (m_delegate) {¤				m_delegate->progress_indicator_closed (*this);¤			}¤			if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤				this->PostMessage (WM_COMMAND, MAKEWPARAM (IDOK, 0), 0);¤			}¤		} catch (...) {¤			if (m_is_showed == true && ::IsWindow (this->GetSafeHwnd ()) == TRUE) {¤				this->PostMessage (WM_COMMAND, MAKEWPARAM (IDOK, 0), 0);¤			}¤			throw;¤		}¤	}¤	//#UC END# *4AD6CFC00148*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659788838"))
		    quid       	"4AD6CFC00148"
		    documentation 	"закрыть диалог"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "update_label_impl"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"45CC2F60000F")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6DAE3001C*"
			    value      	(value Text 
|//#UC START# *4AD6DAE3001C*¤	char* str = (char*)l_param;¤	std::string text (str);¤	delete [] str;¤¤	GUARD(m_mutex);¤	CWnd* label = this->GetDlgItem (IDC_PROGRESS_LABEL);¤	if (label) {¤		label->SetWindowText (text.c_str ());¤	}¤¤	return S_OK;¤	//#UC END# *4AD6DAE3001C*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659789178"))
		    quid       	"4AD6DAE3001C"
		    documentation 	"обработчик сообщения WM_UPDATE_LABEL_TEXT"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "w_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F3F0109")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659789485"))
			    quid       	"4AD6DB1A021F"
			    type       	"WPARAM"
			    quidu      	"45CC2F3F0109")
			(object Parameter "l_param"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"45CC2F6701F4")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659789843"))
			    quid       	"4AD6DB1A0252"
			    type       	"LPARAM"
			    quidu      	"45CC2F6701F4"))
		    result     	"LRESULT"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0
		    quidu      	"45CC2F60000F")
		(object Operation "show"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6F7840166*"
			    value      	(value Text 
|//#UC START# *4AD6F7840166*¤	bool need_show = false;¤	{¤		GUARD(m_mutex);¤		if (m_is_showed == false) {¤			need_show = true;¤			m_is_showed = true;¤		}¤	}¤	if (need_show) {¤		try {¤			this->DoModal ();¤			{¤				GUARD(m_mutex);¤				m_is_showed = false;¤			}¤			delete this;¤		} catch (...) {¤			{¤				GUARD(m_mutex);¤				m_is_showed = false;¤			}¤			delete this;¤			throw;¤		}		¤	}¤	//#UC END# *4AD6F7840166*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659790260"))
		    quid       	"4AD6F7840166"
		    documentation 	"показать диалог"
		    stereotype 	"oneway,chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "on_ok"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD702720358*"
			    value      	(value Text 
|//#UC START# *4AD702720358*¤	GUARD(m_mutex);¤	CDialog::OnOK ();¤	//#UC END# *4AD702720358*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659790602"))
		    quid       	"4AD702720358"
		    documentation 	"закрывает диалог"
		    stereotype 	"chg"
		    concurrency 	"Sequential"
		    opExportControl 	"Private"
		    uid        	0))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "was_canceled"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"3DBFFE100240")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659782193"))
		    quid       	"4AD6C1390067"
		    documentation 	
|событие о том, что была нажата кнопка "Cancel"
		    
		    type       	"boolean"
		    quidu      	"3DBFFE100240"
		    initv      	"false"
		    Containment 	"By Value")
		(object ClassAttribute "mutex"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"finished"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is mutable"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"smart pointer"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450E6C340232")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659782569"))
		    quid       	"4AD6F7DF00C8"
		    documentation 	"мьютекс дял синхронизации"
		    type       	"mutex"
		    quidu      	"450E6C340232"
		    Containment 	"By Value")
		(object ClassAttribute "is_showed"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"3DBFFE100240")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659782918"))
		    quid       	"4AD6F7F70141"
		    documentation 	"флаг, что дилог показан на экране"
		    type       	"boolean"
		    quidu      	"3DBFFE100240"
		    Containment 	"By Value"))
	    language   	"MDA Generator"
	    nestedClasses 	(list nestedClasses
		(object Class "Messages"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659779863"))
		    quid       	"4AD6DB87005B"
		    documentation 	"сообщения"
		    stereotype 	"Constants"
		    class_attributes 	(list class_attribute_list
			(object ClassAttribute "WM_UPDATE_LABEL_TEXT"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFDE101CA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659781117"))
			    quid       	"4AD6DB9601EB"
			    documentation 	"сообщение об обновлении текста лэйбла"
			    type       	"unsigned long"
			    quidu      	"3DBFFDE101CA"
			    initv      	"WM_USER + 1000"
			    exportControl 	"Public"
			    Containment 	"By Value")
			(object ClassAttribute "WM_PROGRESS_STEPIT"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"3DBFFDE101CA")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659781585"))
			    quid       	"4AD6DC760061"
			    documentation 	"сообщение о шаге"
			    type       	"unsigned long"
			    quidu      	"3DBFFDE101CA"
			    initv      	"WM_USER + 1001"
			    exportControl 	"Public"
			    Containment 	"By Value")))))
	(object Class "ProgressIndicatorDelegate"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"AbstarctOperation"
		    value      	"regular")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsNative"
		    value      	"false")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"WikiPageID (wiki)"
		    value      	(value Text 
|Shared (java and c++),key:SHR,guid:44FEAD4A0272/Home/Модель проекта "shared"/WinGUI/Controls/ProgressIndicatorDelegate|4AD43CA40312
		    ))
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"SourceType (wiki)"
		    value      	"wiki")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ElementCreationOrder"
		    value      	"16663702216"))
	    quid       	"4AD43CA40312"
	    documentation 	"делегат для индикатора"
	    stereotype 	"Facet"
	    operations 	(list Operations
		(object Operation "progress_indicator_canceled"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E310354_4AD423B900A4*"
			    value      	(value Text 
|//#UC START# *4AD43E310354_4AD423B900A4*¤	GUARD (m_mutex);¤	m_indicator = 0;	¤	//#UC END# *4AD43E310354_4AD423B900A4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659792720"))
		    quid       	"4AD43E310354"
		    documentation 	
|обработчик нажатия кнопки "CANCEL" при этом событие progress_indicator_closed не вызывается!
		    
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "indicator"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD426A003AF")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659793023"))
			    quid       	"4AD43E6F00A5"
			    type       	"ProgressIndicator"
			    quidu      	"4AD426A003AF"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "progress_indicator_finished"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6C07103E7_4AD423B900A4*"
			    value      	(value Text 
|//#UC START# *4AD6C07103E7_4AD423B900A4*¤	GUARD (m_mutex);¤	m_indicator = 0;¤	//#UC END# *4AD6C07103E7_4AD423B900A4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659793436"))
		    quid       	"4AD6C07103E7"
		    documentation 	"собатие  о том, что прогресс бар дошел до конца"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "indicator"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD426A003AF")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659793734"))
			    quid       	"4AD6C0A2027A"
			    type       	"ProgressIndicator"
			    quidu      	"4AD426A003AF"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0)
		(object Operation "progress_indicator_closed"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"abstract")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD6C0F50143_4AD423B900A4*"
			    value      	(value Text 
|//#UC START# *4AD6C0F50143_4AD423B900A4*¤	GUARD (m_mutex);¤	m_indicator = 0;¤	//#UC END# *4AD6C0F50143_4AD423B900A4*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659794133"))
		    quid       	"4AD6C0F50143"
		    documentation 	"событие о закрытии окна прогресс индикатора"
		    stereotype 	"chg"
		    parameters 	(list Parameters
			(object Parameter "indicator"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"4AD426A003AF")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659794478"))
			    quid       	"4AD6C10B0174"
			    type       	"ProgressIndicator"
			    quidu      	"4AD426A003AF"))
		    concurrency 	"Sequential"
		    opExportControl 	"Public"
		    uid        	0))
	    class_attributes 	(list class_attribute_list
		(object ClassAttribute "progress_size"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_GET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_GET_ACCESSOR*¤	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);¤	//#UC END# *4AD43E140385_GET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_SET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_SET_ACCESSOR*¤	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);¤	//#UC END# *4AD43E140385_SET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"calling conventions"
			    value      	"none")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"finished"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force use const arg"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is default"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is mutable"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"needs field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"pm"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"reads field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"smart pointer"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"writes field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_4AD423B900A4_GET*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_4AD423B900A4_GET*¤	return m_progress_size;¤	//#UC END# *4AD43E140385_4AD423B900A4_GET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E140385_4AD423B900A4_SET*"
			    value      	(value Text 
|//#UC START# *4AD43E140385_4AD423B900A4_SET*¤	m_progress_size = progress_size;¤	//#UC END# *4AD43E140385_4AD423B900A4_SET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A6117003E")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659791949"))
		    quid       	"4AD43E140385"
		    documentation 	"размер прогресс-индикатора"
		    stereotype 	"property"
		    type       	"unsigned integer"
		    quidu      	"450A6117003E"
		    exportControl 	"Public"
		    Containment 	"By Value")
		(object ClassAttribute "step_size"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"final")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ValueInitialized"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_GET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_GET_ACCESSOR*¤	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);¤	//#UC END# *4AD43E170080_GET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_SET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_SET_ACCESSOR*¤	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);¤	//#UC END# *4AD43E170080_SET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"calling conventions"
			    value      	"none")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"finished"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"force use const arg"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is default"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"is mutable"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"needs field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"pm"
			    value      	"true")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"reads field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"smart pointer"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator User Properties"
			    name       	"writes field"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_4AD423B900A4_GET*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_4AD423B900A4_GET*¤	return m_step_size;¤	//#UC END# *4AD43E170080_4AD423B900A4_GET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43E170080_4AD423B900A4_SET*"
			    value      	(value Text 
|//#UC START# *4AD43E170080_4AD423B900A4_SET*¤	m_step_size = step_size;¤	//#UC END# *4AD43E170080_4AD423B900A4_SET*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ResolvedTypeGuid"
			    value      	"450A6117003E")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659792332"))
		    quid       	"4AD43E170080"
		    documentation 	"устанавливает размер шага"
		    stereotype 	"property"
		    type       	"unsigned integer"
		    quidu      	"450A6117003E"
		    exportControl 	"Public"
		    Containment 	"By Value"))
	    language   	"MDA Generator")
	(object Association "$UNNAMED$0"
	    quid       	"46960BF40261"
	    roles      	(list role_list
		(object Role "image_path_to_index"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659769733"))
		    quid       	"46960BF500BB"
		    documentation 	
|мапа: "путь к файлу с изображением" -> индекс в ImageList'е
		    
		    label      	"image_path_to_index"
		    supplier   	"Logical View::shared::WinGUI::Controls::CImageListEx::ImagePathToIndex"
		    quidu      	"46960BC80119"
		    Containment 	"By Value"
		    exportControl 	"Private"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$1"
		    quid       	"46960BF500CB"
		    supplier   	"Logical View::shared::WinGUI::Controls::CImageListEx"
		    quidu      	"46960B1401F4"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$2"
	    quid       	"46960C3002DE"
	    roles      	(list role_list
		(object Role "$UNNAMED$3"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659767959"))
		    quid       	"46960C31009C"
		    supplier   	"Logical View::Primitives::unsigned integer"
		    quidu      	"450A6117003E"
		    keys       	(list class_attribute_list
			(object ClassAttribute "key"
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ValueInitialized"
				    value      	"true")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"AbstarctOperation"
				    value      	"regular")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"IsNative"
				    value      	"false")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ResolvedTypeGuid"
				    value      	"452257A0036F")
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"ElementCreationOrder"
				    value      	"16659768290"))
			    quid       	"46960C3A034B"
			    type       	"a-string"
			    exportControl 	"Public"
			    Containment 	"By Value"))
		    Containment 	"By Value"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$4"
		    quid       	"46960C31009E"
		    supplier   	"Logical View::shared::WinGUI::Controls::CImageListEx::ImagePathToIndex"
		    quidu      	"46960BC80119"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$5"
	    quid       	"4AD427080065"
	    roles      	(list role_list
		(object Role "progress"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659783294"))
		    quid       	"4AD427120271"
		    documentation 	"контролл для отображения процесса"
		    label      	"progress"
		    supplier   	"Logical View::external::MFCTypes::Controls::CProgressCtrl"
		    quidu      	"4AD426EA0372"
		    Containment 	"By Value"
		    exportControl 	"Private"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$6"
		    quid       	"4AD427120274"
		    supplier   	"Logical View::shared::WinGUI::Controls::ProgressIndicator"
		    quidu      	"4AD426A003AF"
		    is_aggregate 	TRUE)))
	(object Association "$UNNAMED$7"
	    quid       	"4AD43CD2023C"
	    roles      	(list role_list
		(object Role "delegate"
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"AbstarctOperation"
			    value      	"regular")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"IsNative"
			    value      	"false")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43CD20389_GET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43CD20389_GET_ACCESSOR*¤	GUARD(m_mutex);¤	return m_delegate;¤	//#UC END# *4AD43CD20389_GET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"cpp:*4AD43CD20389_SET_ACCESSOR*"
			    value      	(value Text 
|//#UC START# *4AD43CD20389_SET_ACCESSOR*¤	GUARD(m_mutex);¤	m_delegate = delegate;¤	//#UC END# *4AD43CD20389_SET_ACCESSOR*
			    ))
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ElementCreationOrder"
			    value      	"16659783732"))
		    quid       	"4AD43CD20389"
		    documentation 	"делегат, реализующий логику связанную с работой индикатора и обеспечивающий его данными"
		    stereotype 	"property"
		    label      	"delegate"
		    supplier   	"Logical View::shared::WinGUI::Controls::ProgressIndicatorDelegate"
		    quidu      	"4AD43CA40312"
		    is_navigable 	TRUE)
		(object Role "$UNNAMED$8"
		    quid       	"4AD43CD2038B"
		    supplier   	"Logical View::shared::WinGUI::Controls::ProgressIndicator"
		    quidu      	"4AD426A003AF"))))
    logical_presentations 	(list unit_reference_list
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsChanged"
		    value      	""))
	    quid       	"46960ABA0119"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	1384
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::external::MFCTypes::Types::CImageList" @1
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"522")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"141")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(522, 141)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@1
			location   	(357, 113)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"• CImageList")
		    stereotype 	(object ItemLabel
			Parent_View 	@1
			location   	(357, 63)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"46960AE00157"
		    width      	348
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CImageListEx" @2
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1002")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1161")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"1810")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"642"))
		    location   	(1002, 1161)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@2
			location   	(116, 902)
			fill_color 	13434879
			nlines     	1
			max_width  	1772
			justify    	0
			label      	"CImageListEx")
		    stereotype 	(object ItemLabel
			Parent_View 	@2
			location   	(116, 852)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1772
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"46960B1401F4"
		    width      	1790
		    height     	642
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::Primitives::unsigned integer" @3
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1770")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"108")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"404")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"116"))
		    location   	(1770, 108)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	TRUE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@3
			location   	(1577, 62)
			fill_color 	13434879
			nlines     	1
			max_width  	386
			justify    	0
			label      	"unsigned integer")
		    icon_style 	"None"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"450A6117003E"
		    width      	404
		    height     	117
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CImageListEx::ImagePathToIndex" @4
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1782")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"552")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"382")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(1782, 552)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	6572835
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@4
			location   	(1600, 524)
			nlines     	1
			max_width  	364
			justify    	0
			label      	"ImagePathToIndex")
		    stereotype 	(object ItemLabel
			Parent_View 	@4
			location   	(1600, 474)
			anchor     	10
			nlines     	1
			max_width  	364
			justify    	0
			label      	"<<Map>>")
		    icon_style 	"Label"
		    line_color 	6572835
		    fill_color 	16777215
		    quidu      	"46960BC80119"
		    width      	382
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object AssociationViewNew "$UNNAMED$0" @5
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"1410,839;1664,642"))
		    location   	(1538, 740)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"46960BF40261"
		    roleview_list 	(list RoleViews
			(object RoleView "image_path_to_index" @6
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1538,740;1664,642"))
			    Parent_View 	@5
			    location   	(644, -61)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    label      	(object SegLabel @7
				Parent_View 	@6
				location   	(1529, 702)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	1
				anchor_loc 	1
				nlines     	1
				max_width  	412
				justify    	0
				label      	"-image_path_to_index"
				pctDist    	0.109719
				height     	37
				orientation 	0)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960BF500BB"
			    client     	@5
			    supplier   	@4
			    vertices   	(list Points
				(1538, 740)
				(1664, 642))
			    line_style 	0)
			(object RoleView "$UNNAMED$1" @8
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1538,740;1410,839"))
			    Parent_View 	@5
			    location   	(644, -61)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960BF500CB"
			    client     	@5
			    supplier   	@2
			    vertices   	(list Points
				(1538, 740)
				(1410, 839))
			    line_style 	0)))
		(object AssociationViewNew "$UNNAMED$2" @9
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"1779,461;1771,166"))
		    location   	(1775, 313)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"46960C3002DE"
		    roleview_list 	(list RoleViews
			(object RoleView "$UNNAMED$3" @10
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1775,313;1771,166"))
			    Parent_View 	@9
			    location   	(884, -959)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960C31009C"
			    client     	@9
			    supplier   	@3
			    vertices   	(list Points
				(1775, 313)
				(1771, 166))
			    line_style 	0)
			(object RoleView "$UNNAMED$4" @11
			    attributes 	(list Attribute_Set
				(object Attribute
				    tool       	"MDA Generator"
				    name       	"LineVertices"
				    value      	"1775,313;1779,461"))
			    Parent_View 	@9
			    location   	(884, -959)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"46960C31009E"
			    client     	@9
			    supplier   	@4
			    vertices   	(list Points
				(1775, 313)
				(1778, 461))
			    line_style 	0
			    label      	(object SegLabel @12
				Parent_View 	@11
				location   	(1779, 420)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	5
				anchor_loc 	1
				nlines     	1
				max_width  	234
				justify    	0
				label      	"key : a-string"
				pctDist    	0.900000
				height     	12
				orientation 	1))))
		(object InheritView "" @13
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"850,839;564,231"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"46960C560119"
		    client     	@2
		    supplier   	@1
		    vertices   	(list Points
			(850, 839)
			(564, 231))
		    line_style 	0)
		(object ClassView "Class" "Logical View::external::cximage::CxImageUnit::CxImage" @14
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1146")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"141")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(1146, 141)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@14
			location   	(981, 113)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"• CxImage")
		    stereotype 	(object ItemLabel
			Parent_View 	@14
			location   	(981, 63)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"4649B9520148"
		    width      	348
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @15
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"1047,839;1132,231"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	(object SegLabel @16
			Parent_View 	@15
			location   	(1152, 440)
			font       	(object Font
			    size       	10
			    face       	"Arial"
			    charSet    	204
			    bold       	FALSE
			    italics    	FALSE
			    underline  	FALSE
			    strike     	FALSE
			    color      	0
			    default_color 	TRUE)
			anchor     	10
			anchor_loc 	1
			nlines     	1
			max_width  	450
			justify    	0
			label      	"<<uses>>"
			pctDist    	0.669625
			height     	48
			orientation 	1)
		    line_color 	3947680
		    quidu      	"469610550167"
		    client     	@2
		    supplier   	@14
		    vertices   	(list Points
			(1047, 839)
			(1132, 231))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ETSLayout" @17
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"2259")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"957")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"318")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(2259, 957)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@17
			location   	(2110, 927)
			fill_color 	13434879
			nlines     	1
			max_width  	298
			justify    	0
			label      	"• ETSLayout")
		    stereotype 	(object ItemLabel
			Parent_View 	@17
			location   	(2110, 877)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	298
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    fill_color 	14145535
		    quidu      	"46A88BDA035B"
		    width      	316
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CPPToolTip" @18
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"294")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1980")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(294, 1980)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@18
			location   	(129, 1950)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"• CPPToolTip")
		    stereotype 	(object ItemLabel
			Parent_View 	@18
			location   	(129, 1900)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B6AC00CB"
		    width      	348
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CPPHtmlDrawer" @19
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"696")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1656")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(696, 1656)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@19
			location   	(511, 1626)
			fill_color 	13434879
			nlines     	1
			max_width  	370
			justify    	0
			label      	"• CPPHtmlDrawer")
		    stereotype 	(object ItemLabel
			Parent_View 	@19
			location   	(511, 1576)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	370
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B81F006D"
		    width      	388
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CPPDrawManager" @20
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1137")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1671")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"388")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1137, 1671)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@20
			location   	(939, 1641)
			fill_color 	13434879
			nlines     	1
			max_width  	396
			justify    	0
			label      	"• CPPDrawManager")
		    stereotype 	(object ItemLabel
			Parent_View 	@20
			location   	(939, 1591)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	396
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B8C80280"
		    width      	414
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CCeXDib" @21
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"1572")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1665")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"184"))
		    location   	(1572, 1665)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@21
			location   	(1407, 1635)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"• CCeXDib")
		    stereotype 	(object ItemLabel
			Parent_View 	@21
			location   	(1407, 1585)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    fill_color 	12842465
		    quidu      	"4700B8F90119"
		    width      	348
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::external::MFCTypes::Controls::CWnd" @22
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewXPosition"
			    value      	"276")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewYPosition"
			    value      	"1641")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewWidth"
			    value      	"348")
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"ItemViewHeight"
			    value      	"180"))
		    location   	(276, 1641)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@22
			location   	(111, 1613)
			fill_color 	13434879
			nlines     	1
			max_width  	330
			justify    	0
			label      	"• CWnd")
		    stereotype 	(object ItemLabel
			Parent_View 	@22
			location   	(111, 1563)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	328
			justify    	0
			label      	"<<SimpleClass>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"4652B53F01F4"
		    width      	348
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object InheritView "" @23
		    attributes 	(list Attribute_Set
			(object Attribute
			    tool       	"MDA Generator"
			    name       	"LineVertices"
			    value      	"288,1887;280,1731"))
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3947680
		    quidu      	"4700C599006D"
		    client     	@18
		    supplier   	@22
		    vertices   	(list Points
			(288, 1887)
			(280, 1731))
		    line_style 	0)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::CommonControls" @24
		    ShowCompartmentStereotypes 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(2397, 183)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@24
			location   	(2218, 153)
			fill_color 	13434879
			nlines     	1
			max_width  	358
			justify    	0
			label      	"CommonControls")
		    stereotype 	(object ItemLabel
			Parent_View 	@24
			location   	(2218, 103)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	358
			justify    	0
			label      	"<<Resource>>")
		    icon_style 	"Label"
		    fill_color 	16769520
		    quidu      	"4AD426890274"
		    width      	376
		    height     	184
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::external::MFCTypes::Controls::CProgressCtrl" @25
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    location   	(2361, 2958)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@25
			location   	(2188, 2930)
			fill_color 	13434879
			nlines     	1
			max_width  	346
			justify    	0
			label      	"• CProgressCtrl")
		    stereotype 	(object ItemLabel
			Parent_View 	@25
			location   	(2188, 2880)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	346
			justify    	0
			label      	"<<GuiControl>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"4AD426EA0372"
		    width      	364
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ProgressIndicatorDelegate" @26
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(2061, 2007)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@26
			location   	(1425, 1848)
			fill_color 	13434879
			nlines     	1
			max_width  	1272
			justify    	0
			label      	"• ProgressIndicatorDelegate")
		    stereotype 	(object ItemLabel
			Parent_View 	@26
			location   	(1425, 1798)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1272
			justify    	0
			label      	"<<Facet>>")
		    icon_style 	"Label"
		    fill_color 	16766935
		    quidu      	"4AD43CA40312"
		    width      	1290
		    height     	442
		    annotation 	8
		    autoResize 	TRUE)
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ProgressIndicator" @27
		    ShowCompartmentStereotypes 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(858, 2958)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@27
			location   	(83, 2599)
			fill_color 	13434879
			nlines     	1
			max_width  	1550
			justify    	0
			label      	"• ProgressIndicator")
		    stereotype 	(object ItemLabel
			Parent_View 	@27
			location   	(83, 2549)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1550
			justify    	0
			label      	"<<Dialog>>")
		    icon_style 	"Label"
		    line_color 	7885055
		    fill_color 	15448575
		    quidu      	"4AD426A003AF"
		    width      	1568
		    height     	842
		    annotation 	8
		    autoResize 	TRUE)
		(object AssociationViewNew "$UNNAMED$5" @28
		    location   	(1910, 2958)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3342489
		    quidu      	"4AD427080065"
		    roleview_list 	(list RoleViews
			(object RoleView "progress" @29
			    Parent_View 	@28
			    location   	(857, 675)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    label      	(object SegLabel @30
				Parent_View 	@29
				location   	(1891, 3011)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	1
				anchor_loc 	1
				nlines     	1
				max_width  	190
				justify    	0
				label      	"-progress"
				pctDist    	-0.073446
				height     	53
				orientation 	1)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"4AD427120271"
			    client     	@28
			    supplier   	@25
			    vertices   	(list Points
				(1910, 2958)
				(2178, 2958))
			    line_style 	0)
			(object RoleView "$UNNAMED$6" @31
			    Parent_View 	@28
			    location   	(857, 675)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"4AD427120274"
			    client     	@28
			    supplier   	@27
			    vertices   	(list Points
				(1910, 2958)
				(1642, 2958))
			    line_style 	0)))
		(object AssociationViewNew "$UNNAMED$7" @32
		    location   	(1583, 2382)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	TRUE
		    line_color 	3342489
		    quidu      	"4AD43CD2023C"
		    roleview_list 	(list RoleViews
			(object RoleView "delegate" @33
			    Parent_View 	@32
			    location   	(944, 15)
			    font       	(object Font
				size       	10
				face       	"Arial"
				charSet    	204
				bold       	FALSE
				italics    	FALSE
				underline  	FALSE
				strike     	FALSE
				color      	0
				default_color 	TRUE)
			    label      	(object SegLabel @34
				Parent_View 	@33
				location   	(1127, 2475)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	1
				anchor_loc 	1
				nlines     	1
				max_width  	184
				justify    	0
				label      	"+delegate"
				pctDist    	-1.675349
				height     	210
				orientation 	0)
			    stereotype 	(object SegLabel @35
				Parent_View 	@33
				location   	(1152, 2397)
				font       	(object Font
				    size       	10
				    face       	"Arial"
				    charSet    	204
				    bold       	FALSE
				    italics    	FALSE
				    underline  	FALSE
				    strike     	FALSE
				    color      	0
				    default_color 	TRUE)
				anchor     	10
				anchor_loc 	1
				nlines     	1
				max_width  	450
				justify    	0
				label      	"<<property>>"
				pctDist    	-1.400509
				height     	276
				orientation 	0)
			    line_color 	3342489
			    quidu      	"4AD43CD20389"
			    client     	@32
			    supplier   	@26
			    vertices   	(list Points
				(1583, 2382)
				(1777, 2228))
			    line_style 	0)
			(object RoleView "$UNNAMED$8" @36
			    Parent_View 	@32
			    location   	(944, 15)
			    stereotype 	TRUE
			    line_color 	3342489
			    quidu      	"4AD43CD2038B"
			    client     	@32
			    supplier   	@27
			    vertices   	(list Points
				(1583, 2382)
				(1387, 2536))
			    line_style 	0)))
		(object ClassView "Class" "Logical View::external::boost::lexical_cast::lexical_cast" @37
		    ShowCompartmentStereotypes 	TRUE
		    SuppressAttribute 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    location   	(2370, 3321)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	658120
			default_color 	FALSE)
		    label      	(object ItemLabel
			Parent_View 	@37
			location   	(2209, 3293)
			fill_color 	13434879
			nlines     	1
			max_width  	322
			justify    	0
			label      	"• lexical_cast")
		    stereotype 	(object ItemLabel
			Parent_View 	@37
			location   	(2209, 3243)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	322
			justify    	0
			label      	"<<UtilityPack>>")
		    icon_style 	"Label"
		    line_color 	14803425
		    fill_color 	14803425
		    quidu      	"46FCA22B0280"
		    width      	340
		    height     	180
		    annotation 	8
		    autoResize 	TRUE)
		(object UsesView "" @38
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    stereotype 	(object SegLabel @39
			Parent_View 	@38
			location   	(1949, 3095)
			font       	(object Font
			    size       	10
			    face       	"Arial"
			    charSet    	204
			    bold       	FALSE
			    italics    	FALSE
			    underline  	FALSE
			    strike     	FALSE
			    color      	0
			    default_color 	TRUE)
			anchor     	10
			anchor_loc 	1
			nlines     	1
			max_width  	450
			justify    	0
			label      	"<<uses>>"
			pctDist    	0.500000
			height     	120
			orientation 	0)
		    line_color 	3342489
		    quidu      	"4AD702EE00C3"
		    client     	@27
		    supplier   	@37
		    vertices   	(list Points
			(1642, 3144)
			(2199, 3278))
		    line_style 	0)))
	(object ClassDiagram "Main"
	    attributes 	(list Attribute_Set
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"ClassUID"
		    value      	"4AD426A003AF")
		(object Attribute
		    tool       	"MDA Generator"
		    name       	"IsChanged"
		    value      	""))
	    quid       	"4AD6DB820348"
	    title      	"Main"
	    zoom       	100
	    max_height 	28350
	    max_width  	21600
	    origin_x   	0
	    origin_y   	0
	    items      	(list diagram_item_list
		(object ClassView "Class" "Logical View::shared::WinGUI::Controls::ProgressIndicator::Messages" @40
		    ShowCompartmentStereotypes 	TRUE
		    SuppressOperation 	TRUE
		    IncludeAttribute 	TRUE
		    IncludeOperation 	TRUE
		    ShowOperationSignature 	TRUE
		    location   	(780, 456)
		    font       	(object Font
			size       	10
			face       	"Arial"
			charSet    	204
			bold       	FALSE
			italics    	FALSE
			underline  	FALSE
			strike     	FALSE
			color      	0
			default_color 	TRUE)
		    label      	(object ItemLabel
			Parent_View 	@40
			location   	(147, 374)
			fill_color 	13434879
			nlines     	1
			max_width  	1266
			justify    	0
			label      	"Messages")
		    stereotype 	(object ItemLabel
			Parent_View 	@40
			location   	(147, 324)
			fill_color 	13434879
			anchor     	10
			nlines     	1
			max_width  	1266
			justify    	0
			label      	"<<Constants>>")
		    icon_style 	"Label"
		    fill_color 	16119285
		    quidu      	"4AD6DB87005B"
		    width      	1284
		    height     	288
		    annotation 	8
		    autoResize 	TRUE)))))
