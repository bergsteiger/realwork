//////////////////////////////////////////////////////////////////////////////////
// Impl
//////////////////////////////////////////////////////////////////////////////////

: Impl::Category
? Пакет реализации
? Содержит реализацию интерфесных пакетов. Может зависить от других пактов реализации своей компоненты. Определдяет неймспейс.
< *::Category, ValueType::Class, Interface::Class, TestInterface::Class, UMLPrimitive::Class
< TestInterface::Class, Iterator::Class, Const Iterator::Class
< GuiControl::Class, Dialog::Class, PropertySheet::Class, PropertyPage::Class, ComInterface::Class
< Actor::Class, UserNeeds::Class, Feature::Class, UseCase::Class
< CServletPlugin::Class, CListenerPlugin::Class, CMacroPlugin::Class, CComponentPlugin::Class, CJobPlugin::Class, CTriggerPlugin::Class, CVelocityContextPlugin::Class, VM::Class, CXWorkPlugin::Class, CActionPlugin::Class, XPackage::Class, CExtractorPlugin::Class, CSpringPlugin::Class, CLifecyclePlugin::Class
< EvdTag::Class
< EvdStruct::Class
< EvdAtom::Class
< Event::Class
< Resource::Class
$ C 195,245,195
$ l 10,195,10
$ f 10,195,10
p is namespace:b=true ? определяет является ли пакет реализации неймспейсом
p need UC:b=false ? явно включает генерацию дополнительных секций Юзер-Кода
D
L code_impl
Y t3_impl.gif

%f _wiki_up_print
	[{%S{is namespace}=false}* *не* является неймспейсом 
	]

//////////////////////////////////////////////////////////////////////////////////////////////////
+ wiki
= Unit::Category;wiki

//////////////////////////////////////////////////////////////////////////////////
+ h
P
v #-i
O [{"%f_need_impl_header(%S)"="true"}%SN.h]
C /impl/%SN
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
	%f_output_constraint(%S)\
	[{"%f_need_impl_header(%S)"="true"}{<%CX>}\
# t0_h_header
	%f_std_inc(%S)
	[{"<{}{"%CM"="Set::Class"}{C}>"!="0"}\#include \<set\>
	][{"<{}{"%CM"="Map::Class"|"%CM"="MultiMap::Class"}{C}>"!="0"}\#include \<map\>
	][{"<{}{"%CM"="Vector::Class"}{C}>"!="0"}\#include \<vector\>
	][{"<{}{"%CM"="HashMap::Class"}{C}>"!="0"}\#include \<hash_map\>
	][{"<{}{"%CM"="Queue::Class"}{C}>"!="0"}\#include \<queue\>
	]<{\n}[\#include %f_dump_include_path(%DL,%D)
	]>
	[{%S{need UC}=true}%U[{_CUSTOM_INCLUDE}
	]
	]
	%SP[{%S{is namespace}=true}namespace %SN {
	]
	<%CX[{"%CO"=""}
	
	]>[{%S{is namespace}=true}} //namespace %SN
	]%Sp[
	\#include %f_dump_include_path(%f_with_gen_id(i.h,%SL),%S)]
# t0_h_footer
	]

//////////////////////////////////////////////////////////////////////////////////
+ cpp
O [{"%f_need_impl_cpp(%S)"="true"}%SN.cpp]
C /impl/%SN
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
	%f_output_constraint(%S)\
	[{"%f_need_impl_cpp(%S)"="true"}{<%CX>}\
# t0_header
	%f_std_inc(%S)
	[\#include %f_dump_include_path(%f_with_gen_id(h,%SL),%S)
	][<{}{"%f_with_gen_id(h,%CO)"=""}
	%C<{}{"%CS"="uses"&"%CC"="Dependency"}[\#include %f_dump_include_path(%f_with_gen_id(h,%C%TW),%C%T)
	]>>][{%S{need UC}=true}%U[{_CUSTOM_INCLUDE}
	]
	]
	
	%SP[{%S{is namespace}=true}namespace %SN {
	]
	<%CX>
	
	[{%S{is namespace}=true}} //namespace %SN
	]%Sp
# t0_footer
	]

//////////////////////////////////////////////////////////////////////////////////
+ i.h
C /impl/%SN
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
P
O [{%f_need_inline_file(%S)=true}%SN.i.h]
	%f_output_constraint(%S)\
	[{%f_need_inline_file(%S)=true}{<%CX>}\
# t0_header
	%f_set_var(SELF,S)<{}{%CM=UtilityPack::Class::uses::ClassDependency}{}[\#include %f_dump_include_path(%f_with_gen_id(h,%C%TL),%C%T)
	]>[<{}{"%f_with_gen_id(h,%CO)"=""}
	%C<{}{"%CS"="uses"&"%CC"="Dependency"}[\#include %f_dump_include_path(%f_with_gen_id(h,%C%TW),%C%T)
	]>>][{%S{need UC}=true}%U[{_CUSTOM_INCLUDES}
	]
	]
	%SP[{"%S{is namespace}"="true"}namespace %SN {
	][{%S{need UC}=true}
	%U[
	]
	]<%CX>
	[{"%S{is namespace}"="true"}
	} // namespace %SN]
	%Sp
# t0_footer
	]

//////////////////////////////////////////////////////////////////////////////////
+ fctr.h
C /impl/%SN
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
P
	<%CX>

//////////////////////////////////////////////////////////////////////////////////
+ java
C [{%S{is namespace}=true}/%SN]
/C /%SN
P
	<%CX>
//////////////////////////////////////////////////////////////////////////////////
+ fctr.java
= java

//////////////////////////////////////////////////////////////////////////////////
+ fctr.cpp
= fctr.h

//////////////////////////////////////////////////////////////////////////////////
+ pas

+ idl
C /impl/%SN
O [{%S%f_need_idl()=true}%SN.idl]
S [{"%S{is namespace}"="true"}#module %SN {]
s [{"%S{is namespace}"="true"}#};]
	%f_output_constraint(%S)\
	[{%S%f_need_idl()=true}\
# t0_header
	%S%f_idl_subsystem(%S)
# t0_footer
	]

+ idl_ami
S [{"%S{is namespace}"="true"}#module %SN {]
s [{"%S{is namespace}"="true"}#};]
C /%SN
O [{"%f_need_ami(%S)"="true"&%S%f_need_idl()=true}%SN_ami.idl]
	%f_output_constraint(%S)\
	[{"%f_need_ami(%S)"="true"&%S%f_need_idl()=true}
# t0_header
	%S%f_idl_subsystem(%S)
# t0_footer
	]
	
%f _idl_subsystem
	[{"%XU"="idl"}
	
	\#ifndef __<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	\#define __<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	[%f_idl_pre_include(%S)
	
	][{%SN!=RootSrv}\#include "shared/CoreSrv/RootSrv/RootSrv.idl"
	][{"%f_need_ami(%S)"="true"}{<\n\#include %f_dump_include_path(%IL,%I)>}\#include %f_dump_include_path(%f_with_gen_id(idl_ami,%SL),%S)
	]
	[\#pragma prefix "%f_idl_prefix(%S)"
	
	]%SP[{%S{is namespace}=true}
	#module %SN {]<{\n}{%C<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=0&%C<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=1}{%C}[
	[{"%f_print_in_ami_file(%C)"="false"}{\n#\t%CF // AMI forwarded}%CX]]>
	[{%S{is namespace}=true}#};
	]%Sp
	][{"%XU"="idl_ami"}
	
	\#ifndef __AMI_<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	\#define __AMI_<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	
	[%f_idl_pre_include(%S)
	]
	[<\n\#include %f_dump_include_path(%f_with_gen_id(idl,%IL),%I)>
	]
	[\#pragma prefix "%f_idl_prefix(%S)"
	
	]%SP[{%S{is namespace}=true}
	#module %SN {]<{\n}{"%f_print_in_ami_file(%C)"="true"&%C<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=0&%C<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=1}
	%f_with_gen_id(idl,%CX)>
	[{%S{is namespace}=true}#};
	]%Sp
	]
	
	\#endif
//////////////////////////////////////////////////////////////////////////////////////////////////
// support functions

f _need_comp_func
	[{<{}{%f_used_as_compare_func(%s)=true}{%sC}>!=0}{false}true]

f _st_need_impl
	[{%SM=Struct::Class}{false}%f_el_need_impl(%S)]

f _el_need_impl
	[{%f_need_less_func(%S)=true|%f_need_comp_func(%S)=true|%S%f_struct_need_impl()=true}{false}true]

f _need_impl_cpp
	[{<{}{%f_st_need_impl(%C)=true|%Ca!=inline&%t_has_impl(%C)=true}{%CC}>!=0}{false}true]

f _need_impl_header
	[{"<{}{"%CO"=""}{C}>"="0"}{true}false]

f _realize_more_than_one_facet
	[{<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=0&<{}{%RS=ServerFacet|%RS=ServerInterface}{C}>!=1}{false}true]

f _servant_or_simpleclass
	[{%SS=Servant|%SS=SimpleClass}{false}true]

%f _need_idl
	[{<{}{%f_servant_or_simpleclass(%C)=true&%f_realize_more_than_one_facet(%C)=true}{C}>!=0}{false}true]