//////////////////////////////////////////////////////////////////////////////////
// ServerInterface
//////////////////////////////////////////////////////////////////////////////////

: ServerInterface::Category
? Серверный интерфейсный пакет
? Содержит экспортируемые наружу компоненты типы и интерфейсы. Определяет неймспейс. Может зависить только от других интерфейсных пакетов (своей компоненты или чужой)
> ServerInterface::Class, Constants::Class, Enum::Class, Exception::Class
> Struct::Class, BitMask::Class, Typedef::Class, Union::Class, Valuetype::Class, ServerFacet::Class
> Vector::Class, StateMachine::Class
$ C 215,215,255
$ l 10,10,255
$ f 10,10,255
D
v +#i
p is namespace:b=true ? определяет является ли модуль неймспейсом
p need UC:b=false ? явно включает генерацию дополнительных секций Юзер-Кода
L code_server_interfaces
Y t3_server_interface.gif

%f _wiki_up_print
	[{%S{is namespace}=false}* *не* является неймспейсом 
	]

//////////////////////////////////////////////////////////////////////////////////
%f _need_idl
	true

//////////////////////////////////////////////////////////////////////////////////////////////////
+ wiki
= Unit::Category;wiki

+ idl
C /%SN
O %SN.idl
S [{"%S{is namespace}"="true"}#module %SN {]
s [{"%S{is namespace}"="true"}#};]
	%f_output_constraint(%S)\
# t0_header
	%f_idl_subsystem(%S)
# t0_footer

//////////////////////////////////////////////////////////////////////////////////
+ idl_ami
S [{"%S{is namespace}"="true"}#module %SN {]
s [{"%S{is namespace}"="true"}#};]
C /%SN
O [{"%f_need_ami(%S)"="true"}%SN_ami.idl]
	[{"%f_need_ami(%S)"="true"}
# t0_header
	%f_idl_subsystem(%S)
# t0_footer
	]

//////////////////////////////////////////////////////////////////////////////////
+ h
C /%SN
O [{%f_srv_need_cpp_files(%S)=true}%SN.h]
P
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
	%f_output_constraint(%S)\
	[{%f_srv_need_cpp_files(%S)=true}
# t0_h_header
	%f_std_inc(%S)
	\#include %f_dump_include_path(%f_delsubstr_from_end(%SW,2)C.h,%S)
	%f_includes_by_contents(%S)<[\#include %f_dump_include_path(%DL,%D)]
	>[
	// forward decls for friend interface's servants<{}{"%f_has_factory_methods(%C)"="true"}{%C}%C[
	<{}{%aS=friend&%aC=Dependency}{Sp}%a%P<%f_in_scope_name(%L)
	>>]>]
	%SP[{"%S{is namespace}"="true"}namespace %SN {
	]
	<{}{%CM=Typedef::Class&%C%GN=string}typedef const char* %CN_const;
	
	><{}{%CM=ServerInterface::Class}[%CX
	
	]>[{"%S{is namespace}"="true"}} // namespace %SN
	]%Sp
# t0_h_footer
	]

//////////////////////////////////////////////////////////////////////////////////
+ cpp
P
C /%SN
O [{%f_srv_need_cpp_files(%S)=true&"%f_need_factory_files(%S)"="true"}%SN.cpp]
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
	%f_output_constraint(%S)\
	[{%f_srv_need_cpp_files(%S)=true&"%f_need_factory_files(%S)"="true"}
# t0_header
	%f_std_inc(%S)
	\#include %f_dump_include_path(%f_with_gen_id(h,%SL),%S)
	\#include %f_dump_include_path(%f_with_gen_id(h,%PL),%P)
	
	%SP[{"%S{is namespace}"="true"}namespace %SN {
	]
	<{}{%CM=ServerInterface::Class}%CX
	>[{"%S{is namespace}"="true"}} // namespace %SN
	]%Sp
# t0_footer
	]

+ i.h
C /%SN
P
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]

//////////////////////////////////////////////////////////////////////////////////
+ fctr.h
C /%SN
O [{"%f_need_factory_files(%S)"="true"}%SNFactories.h]
P
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
	%f_output_constraint(%S)\
	[{"%f_need_factory_files(%S)"="true"}\
# t0_h_header
	%f_std_inc(%S)
	\#include \<map\>
	\#include \<string\>
	\#include "ace/Singleton.h"
	[{<{}{%CM=ServerInterface::Class}{C}>!=0}\#include %f_dump_include_path(%f_with_gen_id(h,%SL),%S)
	]\#include "%f_delsubstr_from_end(%f_with_gen_id(h,%SL),2)S.h"
	
	%SP[{"%S{is namespace}"="true"}namespace %SN {
	]<[%CX
	
	]>[{"%S{is namespace}"="true"}} // namespace %SN
	]%Sp
# t0_h_footer
	]

//////////////////////////////////////////////////////////////////////////////////
+ fctr.cpp
P
C /%SN
O [{"%f_need_factory_files(%S)"="true"}%SNFactories.cpp]
S [{"%S{is namespace}"="true"}namespace %SN {\n]
s [{"%S{is namespace}"="true"}} // namespace %SN\n]
	%f_output_constraint(%S)\
	[{"%f_need_factory_files(%S)"="true"}\
# t0_header
	%f_std_inc(%S)
	\#include "%f_with_gen_id(fctr.h,%SL)"
	\#include "%f_with_gen_id(h,%PL)"
	
	%SP[{"%S{is namespace}"="true"}namespace %SN {
	]<%CX>[{"%S{is namespace}"="true"}} // namespace %SN
	]%Sp
# t0_footer
	]

+ java
C [{%S{is namespace}=true}/%SN]
P
	<%CX>

+ fctr.java
= java
/////////////////////////////////////////////////////////////////////////////
// support functions

f _srv_need_cpp_files
	[{<{}{%AS=ServerInterface|%AS=ServerFacet}{C}>!=0}{false}true]

f _idl_subsystem
	[{"%XU"="idl"}
	
	\#ifndef __<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	\#define __<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	[%f_idl_pre_include(%S)
	
	][{%SN!=RootSrv}\#include "shared/CoreSrv/RootSrv/RootSrv.idl"
	][{"%f_need_ami(%S)"="true"}{<\n\#include %f_dump_include_path(%IL,%I)>}\#include %f_dump_include_path(%f_with_gen_id(idl_ami,%SL),%S)
	]
	[\#pragma prefix "%f_idl_prefix(%S)"
	
	]%SP[{%S{is namespace}=true}
	#module %SN {]<{\n}{}{%C}[
	[{"%f_print_in_ami_file(%C)"="false"}{\n#\t%CF // AMI forwarded}%CX]]>
	[{%S{is namespace}=true}#};
	]%Sp
	][{"%XU"="idl_ami"}
	
	\#ifndef __AMI_<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	\#define __AMI_<{_}{"%PM"="Interface::Category"}%f_to_upper(%PN)>_%f_to_upper(%SN)_IDL__
	
	[%f_idl_pre_include(%S)
	]
	[<\n\#include %f_dump_include_path(%f_with_gen_id(idl,%IL),%I)>
	]
	[\#pragma prefix "%f_idl_prefix(%S)"
	
	]%SP[{%S{is namespace}=true}
	#module %SN {]<{\n}{"%f_print_in_ami_file(%C)"="true"}
	%f_with_gen_id(idl,%CX)>
	[{%S{is namespace}=true}#};
	]%Sp
	]
	
	\#endif
