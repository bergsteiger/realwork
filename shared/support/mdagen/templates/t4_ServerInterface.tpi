//////////////////////////////////////////////////////////////////////////////////
// ServerInterface (class)
//////////////////////////////////////////////////////////////////////////////////
: ServerInterface::Class::friend::ClassDependency
? Друг
? Определяет что интерфейс (источник) использует указанный объект (цель) как друг. Т.е. ЦЕЛЬ открывает свои свои скрытые данные и методы ИСТОЧНИКУ.
? ВНИМАНИЕ!!! ИМЕННО ИСТОЧНИК БУДЕТ ДРУГОМ ЦЕЛИ А НЕ НАООБОРОТ!
%f _wiki_child_kind
	friend

: ServerInterface::Class
? Серверный интерфейс
? Определяет интерфейсы в контексте своей компоненты. Для Сервера это серверные интерфейсы, для ДЛЛ - объъектный интерфейс экспортируемый ДЛЛ, для библиотеки - интерфейс клсса, для ГУИ набор операция пользователя.
< *::Category, *::Class
a raf
p Use AMI:b=false ? генерирует CORBA интерфейс с поддержкой AMI
p debug log:b=false ? включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту
p TODO:s ? напоминалка что-то сделать
$ C 215,215,255
$ l 10,10,255
$ f 10,10,255

L code_server_interafce
Y t4_server_interface.gif
%f _wiki_up_print
	[{%S{Use AMI}=true}* интерфейс с поддержкой AMI
	]

%f _wiki_up_add_gen

%t _constraint
c                         {}
r "%f_has_factory_methods(%S)"="false"&"%Sa"!="abstract": {Not abstract %SS must provide at least one factory}
r {"<{}{%GS!=%SS}{C}>"!="0"}:	{%SS can inherit only from other %SS}
r {"<{}{%RS!=ServerFacet}{C}>"!="0"}:	{%SS can realize only ServerFacet}
/r {<{}{%CC=Attribute&%Cl=ref}{C}>!=0}:                      {%SS не может иметь ref связи}
r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS, используемого в качестве серверного типа, не должно совпадать с именем родителя}
r {<{}{%P{Full MDP}=true}{C}>!=0&<{}{%DS=UseCase}{C}>=0}:	{%SS не используется ни одним прецедентом}

%f _has_private_factory
	[{<{}{%CS=factory&%CV!=PublicAccess|%CS=multy factory&%CV!=PublicAccess}{C}>!=0}{false}true]

%f _base_fctr_mng
	: virtual public POA_%f_full_name(%S)FactoryManagerSrv[{%S%f_has_private_factory()=true}, virtual public %SNFactoryManagerLocal]

%f _base_fctr_mng_java
	 extends %SNFactoryManagerSrvPOA[{%S%f_has_private_factory()=true} %SNFactoryManagerLocal] 

%f _publish_self_cpp
	void %SNFactoryManager::publish_self () {
		if (Singleton::instance()-\>m_has_registred_factories) {
			%SNFactoryManagerSrv_var ref = Singleton::instance()-\>_this();
			CoreSrv::bind_path (&LibHome::get().get_orb_facet().get_ns_root(), ref.in(), "%f_full_name(%S)");
		}
	}\n\n

%f _publish_self_java
	\tpublic static void publish_self () {
	\t	if (%SNFactoryManager.instance().hasRegistredFactories) {
	\t		try {
	\t			ru.garant.shared.CoreSrv.cos_naming_op.bindPath (
	\t				<{}{%PM=Library::Category|%PM=ServerLibrary::Category}%f_dump_java_package(%P).%PN.LibHome>.get().get_orb_facet().get_ns_root()
	\t				, <{}{%PM=Library::Category|%PM=ServerLibrary::Category}%f_dump_java_package(%P).%PN.LibHome>.get().get_orb_facet().get_root_poa().servant_to_reference(%SNFactoryManager.instance())
	\t				, "%f_full_name(%S)"
	\t			);
	\t		} catch (Exception e) {
	\t			Logs.LOG_SEX(e);
	\t		}
	\t	}
	\t}\n\n

%f _publish_self_h
	\tstatic void publish_self ();\n\n

//////////////////////////////////////////////////////////////////////////////////////////////////
+ wiki
= Servant::Class;wiki

+ fctr.h
= Interface::Class;fctr.h

+ fctr.cpp
= Interface::Class;fctr.cpp

+ java
O %SNFactory.java
	%f_output_constraint(%S)\
# t0_header
	%f_set_var(INT,S)package %f_dump_java_package(%S);
	
	%f_dump_std_java_imports(%S)
	
/	<{}{"%iC"!="Category"}{%i}%f_java_import(%i)
/	><{}{"%f_set_var(ARG,C)%{INT}<{}{%iU=%{ARG}%TU}{C}>"="0"&%CC=Attribute&%C%TM!=UMLPrimitive::Class&%f_can_dump_attr(%C%T)=true}{%C}%f_java_import(%C%T)
/	>
	[{"%f_has_factory_methods(%S)"="true"}%f_java_core_exceptions(%S)
	][{%f_is_server_type(%S)=true}
	import %f_dump_java_package(%P).%P%P%f_name_prefix()LibHome;
	]
	%t_visibility(%S,"%XU")class %SNFactory {
	[{"%f_has_factory_methods(%S)"="true"}
	[<{}{%aS=friend&%aC=Dependency}{Sp}%a%P<	friend class %f_type(%L); // friend's servants
	>><{}{"%ga"="abstract"}%g<{}{"%aM"="Interface::Class::friend::ClassDependency"}{Sp}%a%P<	friend class %f_type(%L); // friend's servants
	>>>
	][%f_set_var(INT,S)<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
	%CX
	>>][<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}
	%CX
	>>][<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}
	%CX
	>>][<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}
	%CX
	>>][%f_set_var(INT,S)<{}{"%CS"="remover"&"%CV"="PublicAccess"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&"%CV"="PublicAccess"}{%C}
	%CX
	>>][<{}{"%CS"="remover"&"%CV"!="PublicAccess"}{%C}
	%CX
	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&"%CV"!="PublicAccess"}{%C}
	%CX
	>>]%S%f_additional_fctr_def_java()
	]
	} //interface %SNFactory

+ fctr.java
= Interface::Class;fctr.java

+ idl
F [{"%Sa"="abstract"}abstract ]interface %SN;
	<#%FF
	>%f_docs(%S)\
	#[{"%Sa"="abstract"}abstract ]interface %SN[: <{, }%f_type(%G)>] {<{}{%f_is_factory(%C)=false}[
	%CX]>
	#};[{%f_has_factory_methods(%S)=true}
	
	#// factory manager server interface for %SN
	#interface %SNFactoryManagerSrv {
	[%f_set_var(INT,S)<{}{%CS=factory&%CV=PublicAccess}%CX
	
	><{}{%ga=abstract}%g<{}{%CS=factory&%CV=PublicAccess}%CX
	
	>>][<{}{%CS=multi factory&%CV=PublicAccess}%CX
	
	><{}{%ga=abstract}%g<{}{%CS=multi factory&%CV=PublicAccess}%CX
	
	>>][%f_set_var(INT,S)<{}{%CS=remover&%CV=PublicAccess}%CX
	
	><{}{%ga=abstract}%g<{}{%CS=remover&%CV=PublicAccess}%CX
	
	>>]#};]

%f _additional_fctr_def
	private:
		typedef ACE_Singleton\<%SNFactoryManagerSrv_var, ACE_SYNCH_RECURSIVE_MUTEX\> FactoryManagerSrvSingleton;
		static Core::Mutex s_init_mutex;
		static bool s_renew_mode;
	<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"}{%C}	
	%f_srv_fctr_mng_fctr_h(%C)
	>

%f _additional_fctr_def_java
		static boolean sRenewMode = false;
		static class FactoryManagerSrvSingleton {
			private static %SNFactoryManagerSrv INSTANCE = null;
	
			public static %SNFactoryManagerSrv instance () {
				return INSTANCE;
			}
	
			public static void setInstance (%SNFactoryManagerSrv inst) {
				INSTANCE = inst;
			}
	
		}
	<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"}{%C}
	%f_srv_fctr_mng_fctr_java(%C)
	>
+ h
	%f_dump_factory(%S)[{%S%f_has_private_factory()=true}
	
	// additional interface for private factories implementation
	class %SNFactoryManagerLocal {
		friend class %SNFactory;
	private:<{}{"%CS"="factory"&%CV!=PublicAccess}{%C}
		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Cs]") %CN (%C<{, }%CX>) /*throw (Core::Root::NoActiveFactory%C<, %f_type(%E)>)*/ = 0;
	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&%CV!=PublicAccess}{%C}
		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Cs]") %CN (%C<{, }%CX>) /*throw (Core::Root::NoActiveFactory%C<, %f_type(%E)>)*/ = 0;
	>><{}{"%CS"="multi factory"&%CV!=PublicAccess}{%C}
		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Cs]") %CN (%C<%CX, >const char* key) /*throw (Core::Root::UnknownFactoryKey%C<, %f_type(%E)>)*/ = 0;
	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&%CV!=PublicAccess}{%C}
		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface}%Cs]") %CN (%C<%CX, >const char* key) /*throw (Core::Root::UnknownFactoryKey%C<, %f_type(%E)>)*/ = 0;
	>><{}{"%CS"="remover"&%CV!=PublicAccess}{%C}
		virtual void %CN (%t_arg(%{INT},"in")%C<, %CX>) /*throw (RootSrv::ForeignObject%C<, %f_type(%E)>)*/ = 0;
	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&%CV!=PublicAccess}{%C}
		virtual void %CN (%t_arg(%{INT},"in")%C<, %CX>) /*throw (RootSrv::ForeignObject%C<, %f_type(%E)>)*/ = 0;
	>>};]

f _srv_fctr_mng_fctr_h
		// for cached factory %SN[{%Cx=true}
		struct ObjectCreationIdFor%f_to_borland(%SN) {
	<{}{"%CS"!="nokey"}		[{%f_check_if_type(%C%T,"string")=false}{std::string %CN_arg;}%CX_arg;]
	>
			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%CX>)[ : <{, }{"%CS"!="nokey"}%CN_arg (%CN)>] {
			}
	
			bool operator \< (const ObjectCreationIdFor%f_to_borland(%SN)& c) const {
				return [{}{false}<{ ? true : }{"%CS"!="nokey"}%CN_arg \< c.%CN_arg>];
			}
		};
	
		typedef std::map\<ObjectCreationIdFor%f_to_borland(%SN), %f_var(%{INT})\> CachedObjectsFor%f_to_borland(%SN);
		typedef ACE_Singleton \<CachedObjectsFor%f_to_borland(%SN), ACE_SYNCH_RECURSIVE_MUTEX\> CachedObjectsFor%f_to_borland(%SN)Sngl;][{%Cx=false}
		typedef ACE_Singleton \<%f_var(%{INT}), ACE_SYNCH_RECURSIVE_MUTEX\> CachedObjectFor%f_to_borland(%SN);]
	
		static Core::Mutex s_mutex_for_%SN;

f _srv_fctr_mng_fctr_java
		// for cached factory %SN[{%Cx=true}
		static class ObjectCreationIdFor%f_to_borland(%SN) {
	<{}{"%CS"!="nokey"}		[{%f_check_if_type(%C%T,"string")=false}{String %CNArg;}%f_arg_full_decl(%C)Arg;]
	>
			ObjectCreationIdFor%f_to_borland(%SN) (<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>) {
	[<{}{"%CS"!="nokey"}			this.%CNArg = %CN;
	>]		}
		}
	
	%f_comparator_for_cached_object(%S)
	
		static class CachedObjectsFor%f_to_borland(%SN)Sngl {
			private static java.util.Map\<ObjectCreationIdFor%f_to_borland(%SN), %f_type(%{INT})\> CachedObjectsFor%f_to_borland(%SN) = null;
	
			public static synchronized java.util.Map\<ObjectCreationIdFor%f_to_borland(%SN), %f_type(%{INT})\> instance () {
				if (CachedObjectsFor%f_to_borland(%SN) == null) {
					CachedObjectsFor%f_to_borland(%SN) =
						new java.util.TreeMap\<ObjectCreationIdFor%f_to_borland(%SN), %f_type(%{INT})\> (new ObjectCreationIdFor%f_to_borland(%SN)Comparator ());
				}
				return CachedObjectsFor%f_to_borland(%SN);
			}
		}][{%Cx=false}
		static class CachedObjectFor%f_to_borland(%SN) {
			private static %f_type(%{INT}) INSTANCE = null;
			
			public static %t_ret(%{INT}) instance () {
				return INSTANCE;
			}
			
			public static void setInstance (%f_type(%{INT}) inst) {
				INSTANCE = inst;
			}
		}]

+ cpp
	[{%f_has_factory_methods(%S)=true}Core::Mutex %SNFactory::s_init_mutex;
	bool %SNFactory::s_renew_mode = false;
	<{}{"%CS"="factory"&"%f_is_it_cached(%C)"="true"}{%C}Core::Mutex %SNFactory::s_mutex_for_%CN;
	>[
	%f_set_var(INT,S)<{}{"%CS"="factory"}%CX
	
	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"}%CX
	
	>>][<{}{"%CS"="multi factory"}%CX
	
	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"}%CX
	
	>>][
	%f_set_var(INT,S)<{}{"%CS"="remover"}%CX
	
	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"}%CX
	
	>>]]

: ServerInterface::Class::factory::Operation
? Фабрика (одиночная).
? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты.
? Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик. 
? Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта.
? Для ОДИНОЧНОЙ фабрики - активной может быть только ОДНА такая фабрика - кто последний зарегистрировался тот и активен.
T
e
m f
A const|cached|const,cached
v +-
L code_factory
Y t5_factory.gif

%t _constraint
c                              {}
r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}

%f _wiki_child_kind
	mng


+ idl
	%f_docs(%S)\
	#%t_ret(%{INT},"%Ss") %SN (<{, }%CX>)
	#	raises (CoreSrv::NoActiveFactory<, %f_type(%E)>);

+ h
	%f_docs(%S)\
	#static %t_ret(%{INT},"%Ss") %SN (<{, }%CX>)
	#	/*throw (CoreSrv::NoActiveFactory<, %f_type(%E)>)*/;

+ cpp
	%f_docs(%S)\
	%t_ret(%{INT},"%Ss") %{INT}NFactory::%SN (<{, }%CX>) /*throw (CoreSrv::NoActiveFactory<, %f_type(%E)>)*/ {
		if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
			GUARD (s_init_mutex);
			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
				try {
					CORBA::Object_var obj = CoreSrv::resolve_path (&LibHome::get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})");
					*FactoryManagerSrvSingleton::instance() = %{INT}NFactoryManagerSrv::_narrow (obj);
				} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %{INT}N");
			}
			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
				throw CoreSrv::NoActiveFactory ();
			}
		}
	[{%SV!=PublicAccess}
		%{INT}NFactoryManagerLocal* lsrv = 0;
		try {
			PortableServer::Servant srv = LibHome::get().get_orb_facet().get_root_poa().reference_to_servant (*FactoryManagerSrvSingleton::instance());
			lsrv = dynamic_cast\<%{INT}NFactoryManagerLocal*\>(srv);
		} catch (PortableServer::POA::WrongAdapter&) {
		}
		if (!lsrv) {
			throw CoreSrv::NoActiveFactory ();
		}
	]	try {
	[{%Ss!=cached&%Ss!=const,cached}		return [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN (<{, }%CN>);
	][{%Ss=cached|%Ss=const,cached}[{%Cx=true}
			GUARD(s_mutex_for_%SN);
			CachedObjectsFor%f_to_borland(%SN)::iterator f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>find (ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>));
			if (f == CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>end()) {
				f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>insert (
					CachedObjectsFor%f_to_borland(%SN)::value_type(
						ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
						, [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN (<{, }%CN>)
					)
				).first;
			}
			return *f-\>second;
	][{%Cx=false}
			if (CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr() == 0) {
				GUARD(s_mutex_for_%SN);
				if (CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr() == 0) {
					*CachedObjectFor%f_to_borland(%SN)::instance() = [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN (<{, }%CN>);
				}
			}
			return *CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr();
	]]	} catch (CORBA::TRANSIENT& ) {
			if (s_renew_mode) {
				s_renew_mode = false;
				LOG_W (("%{INT}NFactoryManagerSrv is in invalid (inactive) state"));
				throw CoreSrv::NoActiveFactory ();
			}
			GUARD (s_init_mutex);
			LOG_D (("Try to renew %{INT}NFactoryManagerSrv"));
			
			s_renew_mode = true;
			(*FactoryManagerSrvSingleton::instance()) = 0;
			%{INT}N[{%Ss!=cached&%Ss!=const,cached}{&}_var] ret = %SN (<{, }%CN>);
			s_renew_mode = false;
			
			return ret[{%Ss!=cached&%Ss!=const,cached}._retn()];
		}
	}
+ java	
	%f_docs(%S)\
	#%t_visibility(%S,"%XU")static %t_ret(%{INT},"%Ss") %SN (<{, }%f_arg_full_decl(%C)>) throws ru.garant.shared.CoreSrv.NoActiveFactory<, %f_type(%E)> {
	#	if (FactoryManagerSrvSingleton.instance() == null) {
	#		synchronized (FactoryManagerSrvSingleton.class) {
	#			try {
	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
	#					LibHome.get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})"
	#				);
	#				FactoryManagerSrvSingleton.setInstance(%{INT}NFactoryManagerSrvHelper.narrow (obj));
	#			} catch (java.lang.Exception ex) {
	#				Logs.LOG_SEX (ex);
	#			}
	#			if (FactoryManagerSrvSingleton.instance() == null) {
	#				throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
	#			}
	#		}
	#	}
	[{%SV!=PublicAccess}
	#	%f_type(%{INT})FactoryManagerLocal lsrv = null;
	#	try {
	#		org.omg.PortableServer.Servant srv = LibHome::get().get_orb_facet().get_root_poa().reference_to_servant (FactoryManagerSrvSingleton.instance());
	#		lsrv = (%f_type(%{INT})FactoryManagerLocal)srv;
	#	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {
	#		Logs.LOG_SEX (ex);
	#	}
	#	if (lsrv == null) {
	#		throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
	#	}
	][{%Ss!=cached&%Ss!=const,cached}#	return [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.instance()].%SN (<{, }%CN>);
	][{%Ss=cached|%Ss=const,cached}
	#	try {
	[{%Cx=true}\
	#		synchronized (CachedObjectsFor%f_to_borland(%SN)Sngl.class) {
	#			ObjectCreationIdFor%f_to_borland(%SN) key = new ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>);
	#			%t_ret(%{INT},"%Ss") ret = CachedObjectsFor%f_to_borland(%SN)Sngl.instance().get (key);
	#			if (ret == null) {
	#				ret = [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.instance()].%SN (<{, }%CN>);
	#				CachedObjectsFor%f_to_borland(%SN)Sngl.instance().put (key, ret);
	#			}
	#			return ret;
	][{%Cx=false}
	#		synchronized (CachedObjectFor%f_to_borland(%SN).class) {
	#			if (CachedObjectFor%f_to_borland(%SN).instance() == null) {	
	#				CachedObjectFor%f_to_borland(%SN).setInstance([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.instance()].%SN (<{, }%CN>));
	#			}
	#			return CachedObjectFor%f_to_borland(%SN).instance();
	]#		}
	#	} catch (org.omg.CORBA.TRANSIENT ex) {
	#		if (sRenewMode) {
	#			sRenewMode = false;
	#			Logs.LOG_E ("%{INT}NFactoryManagerSrv is in invalid (inactive) state");
	#			throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
	#		}
	#		synchronized (FactoryManagerSrvSingleton.class) {
	#			sRenewMode = true;
	#			FactoryManagerSrvSingleton.setInstance (null);
	#			%t_ret(%{INT},"%Ss") ret = %SN (<{, }%CN>);
	#			sRenewMode = false;
	
	#			return ret;
	#		}
	#	}
	]#}

: ServerInterface::Class::remover::Operation
? Уничтожитель
? Метод обратный фабричному, т.е. метод приводящий к разрушению (временному или постоянному) созданного фабрикой объекта.
T
m f
e
v +-
L code_remover
Y t5_remover.gif

%t _constraint
c                              {}
r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}

%f _wiki_child_kind
	mng

+ idl
	%f_docs(%S)\
	#void %SN (%t_arg(%{INT},"in") obj_<, %CX>)
	#	raises (CoreSrv::ForeignObject<, %f_type(%E)>);

+ h
	%f_docs(%S)\
	#static void %SN (%t_arg(%{INT},"inout") obj_<, %CX>)
	#	/*throw (CoreSrv::ForeignObject<, %f_type(%E)>)*/;
	#static void %SN (%f_type(%{INT})& obj_<, %CX>)
	#	/*throw (CoreSrv::ForeignObject<, %f_type(%E)>)*/;

+ cpp
	%f_docs(%S)\
	void %{INT}NFactory::%SN (%t_arg(%{INT},"inout") obj_<, %CX>) /*throw (CoreSrv::ForeignObject<, %f_type(%E)>)*/ {
		%{INT}NFactory::%SN (*obj_<, %CN>);
		obj_ = 0;
	}
	
	void %{INT}NFactory::%SN (%f_type(%{INT})& obj_<, %CX>) /*throw (CoreSrv::ForeignObject<, %f_type(%E)>)*/ {
		if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
			GUARD (s_init_mutex);
			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
				try {
					CORBA::Object_var obj = CoreSrv::resolve_path (&LibHome::get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})");
					*FactoryManagerSrvSingleton::instance() = %{INT}NFactoryManagerSrv::_narrow (obj);
				} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %{INT}N");
			}
			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
				throw CoreSrv::ForeignObject ();
			}
		}
	[{%SV!=PublicAccess}
		%{INT}NFactoryManagerLocal* lsrv = 0;
		try {
			PortableServer::Servant srv = LibHome::get().get_orb_facet().get_root_poa().reference_to_servant (*FactoryManagerSrvSingleton::instance());
			lsrv = dynamic_cast\<%{INT}NFactoryManagerLocal*\>(srv);
		} catch (PortableServer::POA::WrongAdapter&) {
		}
		if (!lsrv) {
			throw CoreSrv::ForeignObject ();
		}
	]	try {
			bool clean_up_all = true; // we can't use _is_equivalent here, so we need to clean up all if we find nothing by simple pointer checking
			%f_type(%{INT})_var copy;
			
			{
				GUARD (s_init_mutex);
	
	%P<{}{%CS=factory|%CS=multy factory}[{%Cs=cached|%Cs=const,cached}\
				if (clean_up_all[{%C%Cx=false} && *CachedObjectFor%f_to_borland(%CN)::instance() == &obj_]) {
					[{%C%Cx=false}copy = %f_type(%{INT})::_duplicate (&obj_);
					*CachedObjectFor%f_to_borland(%CN)::instance() = 0;
					clean_up_all = false;][{%C%Cx=true}CachedObjectsFor%f_to_borland(%CN)& map = *CachedObjectsFor%f_to_borland(%CN)Sngl::instance();
					for (
						CachedObjectsFor%f_to_borland(%CN)::iterator it = map.begin(); 
						it != map.end();
						it ++
					) {
						if (it-\>second == &obj_) {
							copy = %f_type(%{INT})::_duplicate (&obj_);
							map.erase (it);
							clean_up_all = false;
							break;
						}
					}]
				}
	]>		}
			[{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN (&obj_<, %CN>);
			
			if (clean_up_all) {
				GUARD (s_init_mutex);
	
	%P<{}{%CS=factory|%CS=multy factory}[{%Cs=cached|%Cs=const,cached}\
				[{%C%Cx=false}*CachedObjectFor%f_to_borland(%CN)::instance() = 0;][{%C%Cx=true}CachedObjectsFor%f_to_borland(%CN)Sngl::instance()-\>clear();]
	]>		}
		} catch (CORBA::TRANSIENT& ) {
			if (s_renew_mode) {
				s_renew_mode = false;
				LOG_W (("%{INT}NFactoryManagerSrv is in invalid (inactive) state"));
				throw CoreSrv::ForeignObject ();
			}
			GUARD (s_init_mutex);
			LOG_D (("Try to renew %{INT}NFactoryManagerSrv"));
			
			s_renew_mode = true;
			(*FactoryManagerSrvSingleton::instance()) = 0;
			%SN (obj_<, %CN>);
			s_renew_mode = false;
		}
	}

+ java	
	%f_docs(%S)\
	#%t_visibility(%S,"%XU")static void %SN (%t_arg(%{INT},"in") obj_<, %f_arg_full_decl(%C)>) throws ru.garant.shared.CoreSrv.ForeignObject<, %f_type(%E)> {
	#	if (FactoryManagerSrvSingleton.instance() == null) {
	#		synchronized (FactoryManagerSrvSingleton.class) {
	#			try {
	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
	#					LibHome.get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})"
	#				);
	#				FactoryManagerSrvSingleton.setInstance(%{INT}NFactoryManagerSrvHelper.narrow (obj));
	#			} catch (java.lang.Exception ex) {
	#				Logs.LOG_SEX (ex);
	#			}
	#			if (FactoryManagerSrvSingleton.instance() == null) {
	#				throw new ru.garant.shared.CoreSrv.ForeignObject ();
	#			}
	#		}
	#	}
	[{%SV!=PublicAccess}
	#	%f_type(%{INT})FactoryManagerLocal lsrv = null;
	#	try {
	#		org.omg.PortableServer.Servant srv = LibHome::get().get_orb_facet().get_root_poa().reference_to_servant (FactoryManagerSrvSingleton.instance());
	#		lsrv = (%f_type(%{INT})FactoryManagerLocal)srv;
	#	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {
	#		Logs.LOG_SEX (ex);
	#	}
	#	if (lsrv == null) {
	#		throw new ru.garant.shared.CoreSrv.ForeignObject ();
	#	}]
	#	try {
	#		boolean clean_up_all = true;
	#		%t_ret(%{INT}) copy = null;
	%P<{}{%CS=factory|%CS=multy factory}[{%Cs=cached|%Cs=const,cached}\
	#			synchronized ([{%C%Cx=true}{CachedObjectFor%f_to_borland(%CN)}CachedObjectsFor%f_to_borland(%CN)Sngl].class) {
	#				if (clean_up_all[{%C%Cx=false} && CachedObjectFor%f_to_borland(%CN).instance().equals (obj_)]) {
	#					[{%C%Cx=false}CachedObjectFor%f_to_borland(%CN).setInstance(null);
	#					clean_up_all = false;][{%C%Cx=true}java.util.Iterator it = CachedObjectsFor%f_to_borland(%CN)Sngl.instance().entrySet().iterator ();
	#					while (it.hasNext ()) {
	#						java.util.Map.Entry entry = (java.util.Map.Entry)it.next ();
	#						if (entry.getValue ().equals (obj_)) {
	#							copy = obj_;
	#							CachedObjectsFor%f_to_borland(%CN)Sngl.instance().remove (entry.getKey ());
	#							clean_up_all = false;
	#							break;
	#						}
	#					}]
	#				}
	#			}]>
/	#		try {
	#			[{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.instance()].%SN (obj_<, %CN>);
/	#		} catch (ru.garant.shared.CoreSrv.NoActiveFactory ex) {
/	#			Logs.LOG_SEX (ex);
/	#			throw new ru.garant.shared.CoreSrv.ForeignObject ();
/	#		}
	#		if (clean_up_all) {
	%P<{}{%CS=factory|%CS=multy factory}[{%Cs=cached|%Cs=const,cached}\
	#				synchronized ([{%C%Cx=true}{CachedObjectFor%f_to_borland(%CN)}CachedObjectsFor%f_to_borland(%CN)Sngl].class) {
	#					[{%C%Cx=false}CachedObjectFor%f_to_borland(%CN).setInstance(null);][{%C%Cx=true}CachedObjectsFor%f_to_borland(%CN)Sngl.instance().clear();]
	#				}
	]>#		}
	#	} catch (org.omg.CORBA.TRANSIENT ex) {
	#		if (sRenewMode) {
	#			sRenewMode = false;
	#			Logs.LOG_W ("WARNING: %{INT}NFactoryManagerSrv is in invalid (inactive) state");
	#			throw  new ru.garant.shared.CoreSrv.ForeignObject ();
	#		}
	#		synchronized (FactoryManagerSrvSingleton.class) {
	#			Logs.LOG_D ("DEBUG: Try to renew %{INT}NFactoryManagerSrv");
	#			sRenewMode = true;
	#			FactoryManagerSrvSingleton.setInstance (null);
	#			%SN (obj_<, %CN>);
	#			sRenewMode = false;
	#		}
	#	}
	#}

: ServerInterface::Class::multi factory::Operation
? Фабрика (множественная).
? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты.
? Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик. 
? Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта.
? Для МНОЖЕСТВЕННОЙ фабрики - активными являются ВСЕ зарегистрированные фабрики, выбор конкретной осущестьвляеться по ключу - дополнительному параметру.
T
e
m f
A const|cached|const,cached
v +-
L code_factory
Y t5_factory.gif

%t _constraint
c                              {}
r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}

%f _wiki_child_kind
	mng


+ idl
	%f_docs(%S)\
	#%t_ret(%{INT},"%Ss") %SN (<%CX, >string in key)
	#	raises (GCM::UnknownFactoryKey<, %f_type(%E)>);


: ServerInterface::Class::Attribute
? Атрибут интерфейса
? для данного атрибута будут сгенерированы методы получения и установки его значения.
p debug log:b=false ? включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту
e a
a a
v +
l l
m t
A const
L code_property
Y t5_property.gif

%f _wiki_child_kind
	property

+ idl
	%f_docs(%S)\
/	[{"%Ex"="false"&"%ex"="false"}#%f_attr(%S) %SN;
/	][{"%Ex"="true"|"%ex"="true"}\
	[{"%SS"!="writeonly"}#%f_iget_attr(%S) get_%SN ()[
	#	raises (<{, }%f_type(%E)>)];
	][{"%SS"!="readonly"}#void set_%SN (%f_iset_attr(%S) %SN)[
	#	raises (<{, }%f_type(%e)>)];
	]
/	]

: ServerInterface::Class::readonly::Attribute
? Атрибут только для чтения
? для данного атрибута будет сгенерирован только метод получения его значения. Если тип атрибута интерфейс - то он будет возвращаться как константный.
= ServerInterface::Class::Attribute
e g

: ServerInterface::Class::writeonly::Attribute
? Атрибут только для записи
? для данного атрибута будут сгенерирован только метод установки его значения.
= ServerInterface::Class::Attribute
e s

: ServerInterface::Class::Attribute::Attribute
= Interface::Class::Attribute::Attribute

: ServerInterface::Class::Operation
T
e
a a
v +
m t
A const|cached|const,cached
? Метод интерфейса
? Согласно спецификации CORBA и мапингу в C++ все удаленные методы не константные. 
p debug log:b=false ? включает генерацию вывода в лог обращений к реализации данной операции
L code_method
Y t5_method.gif

%t _constraint
c                              {}
r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}

%f _wiki_child_kind
	method

+ idl
P
	%f_docs(%S)\
	#[{"%SS"="oneway"}{%f_ret(%S)}oneway void] %SN (<{, }%CX>)[
	#	raises (<{, }%f_type(%E)>)];

: ServerInterface::Class::oneway::Operation
? Асинхронная операция
? Вызов операции будет выполнен асинхронна. Т.е вызавающая сторона получит управление сразу, не дожидаясь ответа. Асинхронная опреация не может иметь возвращаемых результатов и ли возбуждать исключения.
? По умолчанию все методы константные. Для того что бы разрешить методу изменять свой объект, необходимо присвуоить ему стереотип <<oneway,chg>>
? Если используется константный интерфейс, то на нем могут быть вызванны только константные методы.
= ServerInterface::Class::Operation

%t _constraint
c             {}
r	{<{}{%CS=out|%CS=inout&%t_class_type(%C%T)=false}{C}>!=0|%TN!=void}: {%SM can't contain inout/out parameters or return result}

: ServerInterface::Class::Operation::Parameter
+ idl
P
	%f_arg_full_decl(%S)
+ h
= idl
+ cpp
= idl
+ fctr.h
= idl
+ fctr.cpp
= idl

: ServerInterface::Class::oneway::Operation::Parameter
= ServerInterface::Class::Operation::Parameter

: ServerInterface::Class::factory::Operation::Parameter
= ServerInterface::Class::Operation::Parameter

: ServerInterface::Class::remover::Operation::Parameter
= ServerInterface::Class::Operation::Parameter


: ServerInterface::Class::multi factory::Operation::Parameter
= ServerInterface::Class::Operation::Parameter
	
