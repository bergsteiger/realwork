//////////////////////////////////////////////////////////////////////////////////
// functors
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
// Generator
//////////////////////////////////////////////////////////////////////////////////

: Generator::Class
? Генератор
? Определяет функтор (нуль-функтор) с без параметров и заданным типом результата
p const functor:b=true ? указывает что метод функтора будет сгенерирован как константный
p force usage:b=false ? явно определяет, что элемент будет кем-то использован (нужно для проверки)
$ S
$ C 240,205,240
$ l 120,40,120
$ f 120,40,120

v +#-
a r
< *::Class, *::Category

%f _wiki_up_print
	[{%S{const functor}=false}* метод функтора не константный
	]

%f _wiki_up_add_gen

L code_functor
Y t4_functor.gif

%t _constraint
c                              {}
r {%S{force usage}=false&%ax=false}: {%SS ни кем не используется}

+ wiki
G %PU

+ h
F struct %SN;
	[<#%FF
	>]%f_docs(%S)\
	#struct %SN {
	#	%t_functor_ret(%S) operator () %t_functor_functor(%S);
	%f_h_dump_def_init_ctor(%S)[{<{}{"%CS"=""}{C}>!=0}
	#	%SN (<{, }{"%CS"=""}%t_arg(%C%T,"in") %CN_>);
	]<{}{"%CS"=""&%CV=PublicAccess}
	%f_docs(%C)\
	#	%f_attr(%C) [{}{%f_to_omg(%C%TN)}%CN];
	>[
	private:
	<{}{"%CS"=""&%CV=PrivateAccess}%f_docs(%C)\
	#	%f_attr(%C) [{}{%f_to_omg(%C%TN)}%CN];
	>]#};

+ cpp
P
	[%f_functor_impl_body(%S)]

+ i.h
P
	[%f_functor_impl_body(%S)]

f _functor_impl_body
	%t_functor_ret(%S) %f_function_scope(%S)operator () %t_functor_functor(%S) {
		%U[{_IMPL!cpp!}
		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
		]
	}[
	
	%f_common_functors_impl_body(%S)]

//////////////////////////////////////////////////////////////////////////////////
: Generator::Class::result::Attribute
? Результат генератора
v +
l la

//////////////////////////////////////////////////////////////////////////////////
: Generator::Class::Attribute
? Атрибут данных
v -+
l alr
A const
Y t5_attr.gif
//////////////////////////////////////////////////////////////////////////////////
: Generator::Class::uses::ClassDependency
? Использование
? Определяет что сервант (источник) использует указанный объект (цель) каким-либо образом (в том числе создает его через фабрики, есль цель-сервант).
? НА основе данной связи будет сгенерированы пути включения файлов используемого объекта (для цели-серванта так же будет сгенерирована специальная фабрика возвращающая не интерфейс а сервант).
//////////////////////////////////////////////////////////////////////////////////
// UnaryFunctor
//////////////////////////////////////////////////////////////////////////////////

: UnaryFunctor::Class
? Унарный функтор
? Определяет функтор с одним параметром и заданным типом результата (по умолчанию пустым)
= Generator::Class

//////////////////////////////////////////////////////////////////////////////////
: UnaryFunctor::Class::result::Attribute
? Результат функтора
v +
l l

//////////////////////////////////////////////////////////////////////////////////
: UnaryFunctor::Class::param::Attribute
? Параметер функтора (может иметь "стеротип цели" chg указывающий на то что праметр может изменяться внутри функтора)
v +
l lr
A chg

//////////////////////////////////////////////////////////////////////////////////
: UnaryFunctor::Class::Attribute
= Generator::Class::Attribute

//////////////////////////////////////////////////////////////////////////////////
: UnaryFunctor::Class::uses::ClassDependency
= Generator::Class::uses::ClassDependency
//////////////////////////////////////////////////////////////////////////////////
// Predicate
//////////////////////////////////////////////////////////////////////////////////

: Predicate::Class
? Унарный предикат 
? Специальный класс унарных функторов. Определяет функтор с одним параметром и булевым типом результата
= Generator::Class

//////////////////////////////////////////////////////////////////////////////////
: Predicate::Class::param::Attribute
? Параметер предиката
v +
l l

//////////////////////////////////////////////////////////////////////////////////
: Predicate::Class::Attribute
= Generator::Class::Attribute

//////////////////////////////////////////////////////////////////////////////////
: Predicate::Class::uses::ClassDependency
= Generator::Class::uses::ClassDependency
//////////////////////////////////////////////////////////////////////////////////
// BinaryFunctor
//////////////////////////////////////////////////////////////////////////////////

: BinaryFunctor::Class
? Бинарный функтор
? Определяет функтор с двумя параметрами и заданным типом результата (по умолчанию пустым)
= Generator::Class

//////////////////////////////////////////////////////////////////////////////////
: BinaryFunctor::Class::result::Attribute
? Результат функтора
v +
l l

//////////////////////////////////////////////////////////////////////////////////
: BinaryFunctor::Class::first param::Attribute
? Первый параметер функтора (может иметь "стеротип цели" chg указывающий на то что праметр может изменяться внутри функтора)
v +
l l
A chg

//////////////////////////////////////////////////////////////////////////////////
: BinaryFunctor::Class::second param::Attribute
? Второй параметер функтора (может иметь "стеротип цели" chg указывающий на то что праметр может изменяться внутри функтора)
v +
l l
A chg

//////////////////////////////////////////////////////////////////////////////////
: BinaryFunctor::Class::Attribute
= Generator::Class::Attribute

//////////////////////////////////////////////////////////////////////////////////
: BinaryFunctor::Class::uses::ClassDependency
= Generator::Class::uses::ClassDependency
//////////////////////////////////////////////////////////////////////////////////
// BinaryPredicate
//////////////////////////////////////////////////////////////////////////////////

: BinaryPredicate::Class
? Бинарный предикат
? Специальный класс бинарных функторов. Определяет функтор с двумя параметрами и булевым типом результата
= Generator::Class

//////////////////////////////////////////////////////////////////////////////////
: BinaryPredicate::Class::first param::Attribute
? Первый параметер предиката
v +
l l

//////////////////////////////////////////////////////////////////////////////////
: BinaryPredicate::Class::second param::Attribute
? Второй параметер предиката
v +
l l

//////////////////////////////////////////////////////////////////////////////////
: BinaryPredicate::Class::Attribute
= Generator::Class::Attribute

//////////////////////////////////////////////////////////////////////////////////
: BinaryPredicate::Class::uses::ClassDependency
= Generator::Class::uses::ClassDependency
//////////////////////////////////////////////////////////////////////////////////
// support functions
//////////////////////////////////////////////////////////////////////////////////

f _common_functors_impl_body
	%f_impl_dump_def_init_ctor(%S)[{<{}{"%CS"=""}{C}>!=0}
	%f_function_scope(%S)%SN (<{, }{"%CS"=""}%t_arg(%C%T,"in") %CN_>) : <{, }{"%CS"=""}%CN([{%t_refcounted(%C%T)=true&%Cl=ref}{%CN_}%f_type(%C%T)::_duplicate(%CN_)])> {
		%U[{_INIT_CTOR!cpp!}
		]
	}
	]

t _functor_ret
c                                              {}
r "%SS"="Predicate"|"%SS"="BinaryPredicate":  {bool}
r ""="":                                       {<{}{%CS=result}%f_ret(%C)>}

t _functor_functor
c                                                 {}
r "%SS"="Generator":                              {()[{%S{const functor}=true} const]}
r "%SS"="UnaryFunctor"|"%SS"="Predicate":         {(<{}{%CS=param}%f_set_var(PARAM,C)%f_functor_arg(%C%T,"[{%Cs!=chg}{inout}in]")> param_)[{%S{const functor}=true} const]}
r "%SS"="BinaryFunctor"|"%SS"="BinaryPredicate":  {(<{}{%CS=first param}%t_arg(%C%T,"[{%Cs!=chg}{inout}in]")> first_param_, <{}{%CS=second param}%t_arg(%C%T,"[{%Cs!=chg}{inout}in]")> second_param_)[{%S{const functor}=true} const]}

f _functor_arg
	[{"%{PARAM}l"!="ref"}{[{"%t_refcounted(%S)"="true"}{%t_arg(%S,%1)}%t_functor_arg(%S,%1)]}%t_arg(%S,%1)]

t _functor_arg
c                                         {in}                                              {inout}              {out}
r "%t_refcounted(%S)"="true":             {[{%f_is_server_type(%S)=false}const ]%f_tn(%S)_var&} {%f_tn(%S)_var&}         {%f_tn(%S)_var*&}